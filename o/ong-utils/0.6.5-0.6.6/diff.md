# Comparing `tmp/ong_utils-0.6.5-py3-none-any.whl.zip` & `tmp/ong_utils-0.6.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 41462 bytes, number of entries: 23
--rw-r--r--  2.0 unx     2071 b- defN 24-Mar-16 07:31 ong_utils/__init__.py
--rw-r--r--  2.0 unx    12373 b- defN 24-Mar-16 07:23 ong_utils/config.py
--rw-r--r--  2.0 unx     2052 b- defN 24-Mar-16 07:23 ong_utils/credentials.py
--rw-r--r--  2.0 unx    10126 b- defN 24-Mar-16 07:23 ong_utils/desktop_shortcut.py
--rw-r--r--  2.0 unx     3432 b- defN 24-Mar-16 07:23 ong_utils/excel.py
--rw-r--r--  2.0 unx      719 b- defN 24-Mar-16 07:23 ong_utils/import_utils.py
--rw-r--r--  2.0 unx     5805 b- defN 24-Mar-16 07:23 ong_utils/internal_storage.py
--rw-r--r--  2.0 unx     1068 b- defN 24-Mar-16 07:23 ong_utils/jwt_tokens.py
--rw-r--r--  2.0 unx      986 b- defN 23-Dec-31 07:57 ong_utils/parse_html.py
--rw-r--r--  2.0 unx     9505 b- defN 24-Mar-16 07:23 ong_utils/selenium_chrome.py
--rw-r--r--  2.0 unx     9688 b- defN 24-Mar-16 07:23 ong_utils/sensitivity_labels.py
--rw-r--r--  2.0 unx     9911 b- defN 24-Feb-01 06:29 ong_utils/timers.py
--rw-r--r--  2.0 unx    11865 b- defN 24-Mar-16 07:23 ong_utils/ui.py
--rw-r--r--  2.0 unx     2561 b- defN 24-Mar-16 07:23 ong_utils/ui_logging_utils.py
--rw-r--r--  2.0 unx     2758 b- defN 24-Mar-16 07:23 ong_utils/urllib3_utils.py
--rw-r--r--  2.0 unx     2499 b- defN 24-Mar-16 07:23 ong_utils/utils.py
--rw-r--r--  2.0 unx     1202 b- defN 23-Dec-27 07:20 ong_utils/web.py
--rw-r--r--  2.0 unx       51 b- defN 24-Mar-16 07:23 ong_utils/office/__init__.py
--rw-r--r--  2.0 unx     4893 b- defN 24-Mar-16 07:23 ong_utils/office/office_base.py
--rw-r--r--  2.0 unx    28966 b- defN 24-Mar-16 07:31 ong_utils-0.6.5.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Mar-16 07:31 ong_utils-0.6.5.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 24-Mar-16 07:31 ong_utils-0.6.5.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1841 b- defN 24-Mar-16 07:31 ong_utils-0.6.5.dist-info/RECORD
-23 files, 124474 bytes uncompressed, 38516 bytes compressed:  69.1%
+Zip file size: 42461 bytes, number of entries: 23
+-rw-rw-rw-  2.0 fat     2118 b- defN 24-Apr-02 20:07 ong_utils/__init__.py
+-rw-rw-rw-  2.0 fat    12647 b- defN 24-Mar-10 08:19 ong_utils/config.py
+-rw-rw-rw-  2.0 fat     2119 b- defN 24-Mar-10 08:19 ong_utils/credentials.py
+-rw-rw-rw-  2.0 fat    10372 b- defN 24-Mar-10 08:19 ong_utils/desktop_shortcut.py
+-rw-rw-rw-  2.0 fat     3510 b- defN 24-Mar-10 08:19 ong_utils/excel.py
+-rw-rw-rw-  2.0 fat      741 b- defN 24-Mar-10 08:19 ong_utils/import_utils.py
+-rw-rw-rw-  2.0 fat     5981 b- defN 24-Mar-10 08:19 ong_utils/internal_storage.py
+-rw-rw-rw-  2.0 fat     1100 b- defN 24-Mar-10 08:19 ong_utils/jwt_tokens.py
+-rw-rw-rw-  2.0 fat     1013 b- defN 23-Dec-28 23:23 ong_utils/parse_html.py
+-rw-rw-rw-  2.0 fat     9712 b- defN 24-Mar-10 08:19 ong_utils/selenium_chrome.py
+-rw-rw-rw-  2.0 fat     9908 b- defN 24-Mar-12 04:49 ong_utils/sensitivity_labels.py
+-rw-rw-rw-  2.0 fat    10164 b- defN 23-Dec-22 10:21 ong_utils/timers.py
+-rw-rw-rw-  2.0 fat    15305 b- defN 24-Apr-02 20:17 ong_utils/ui.py
+-rw-rw-rw-  2.0 fat     2637 b- defN 24-Mar-10 08:19 ong_utils/ui_logging_utils.py
+-rw-rw-rw-  2.0 fat     2828 b- defN 24-Apr-02 20:07 ong_utils/urllib3_utils.py
+-rw-rw-rw-  2.0 fat     2603 b- defN 24-Mar-10 08:19 ong_utils/utils.py
+-rw-rw-rw-  2.0 fat     1230 b- defN 23-Dec-28 23:23 ong_utils/web.py
+-rw-rw-rw-  2.0 fat       53 b- defN 24-Mar-10 08:19 ong_utils/office/__init__.py
+-rw-rw-rw-  2.0 fat     5050 b- defN 24-Mar-10 08:19 ong_utils/office/office_base.py
+-rw-rw-rw-  2.0 fat    30506 b- defN 24-Apr-02 20:29 ong_utils-0.6.6.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-02 20:29 ong_utils-0.6.6.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       10 b- defN 24-Apr-02 20:29 ong_utils-0.6.6.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1843 b- defN 24-Apr-02 20:29 ong_utils-0.6.6.dist-info/RECORD
+23 files, 131542 bytes uncompressed, 39515 bytes compressed:  70.0%
```

## zipnote {}

```diff
@@ -51,20 +51,20 @@
 
 Filename: ong_utils/office/__init__.py
 Comment: 
 
 Filename: ong_utils/office/office_base.py
 Comment: 
 
-Filename: ong_utils-0.6.5.dist-info/METADATA
+Filename: ong_utils-0.6.6.dist-info/METADATA
 Comment: 
 
-Filename: ong_utils-0.6.5.dist-info/WHEEL
+Filename: ong_utils-0.6.6.dist-info/WHEEL
 Comment: 
 
-Filename: ong_utils-0.6.5.dist-info/top_level.txt
+Filename: ong_utils-0.6.6.dist-info/top_level.txt
 Comment: 
 
-Filename: ong_utils-0.6.5.dist-info/RECORD
+Filename: ong_utils-0.6.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## ong_utils/__init__.py

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-"""
-Common imports for projects
--   create_pool_manager: to create a pool manager for urllib3 that check https certificates
--   LOCAL_TZ: a timezone object with the local timezone
--   OngConfig: a config object
--   is_debugging: true if in debug code
--   get_cookies: for getting a dictionary of cookies from a urllib3 response object
--   cookies2header: transforms cookies to a dict that can be used as header parameter in urllib3 requests
-
-Reads config files from f"~/.config/ongpi/{project_name}.{extension}"
-where extension can be yaml, yml, json or js
-Path can be overridden either with ONG_CONFIG_PATH environ variable
-"""
-from ong_utils.import_utils import AdditionalRequirementException, raise_extra_install
-
-from ong_utils.config import OngConfig
-from ong_utils.internal_storage import InternalStorage
-from ong_utils.parse_html import find_js_variable
-from ong_utils.timers import OngTimer
-from ong_utils.urllib3_utils import create_pool_manager, cookies2header, get_cookies
-from ong_utils.utils import (LOCAL_TZ, is_debugging, to_list, is_mac, is_linux, is_windows, get_current_user,
-                             get_current_domain)
-from ong_utils.web import find_available_port
-from ong_utils.ui import simple_dialog, user_domain_password_dialog, fix_windows_gui_scale
-from ong_utils.ui_logging_utils import print2widget, logger2widget
-
-
-import_excepts = (ModuleNotFoundError, NameError, AdditionalRequirementException)
-try:
-    from ong_utils.excel import df_to_excel
-    from ong_utils.sensitivity_labels import SensitivityLabel
-except import_excepts:
-    df_to_excel = raise_extra_install("xlsx")
-try:
-    from ong_utils.jwt_tokens import decode_jwt_token, decode_jwt_token_expiry
-except import_excepts:
-    decode_jwt_token = decode_jwt_token_expiry = raise_extra_install("jwt")
-    pass
-try:
-    from ong_utils.selenium_chrome import Chrome
-except import_excepts:
-    Chrome = raise_extra_install("selenium")
-try:
-    from ong_utils.credentials import verify_credentials
-except import_excepts:
-    verify_credentials = raise_extra_install("credentials")
-
+"""
+Common imports for projects
+-   create_pool_manager: to create a pool manager for urllib3 that check https certificates
+-   LOCAL_TZ: a timezone object with the local timezone
+-   OngConfig: a config object
+-   is_debugging: true if in debug code
+-   get_cookies: for getting a dictionary of cookies from a urllib3 response object
+-   cookies2header: transforms cookies to a dict that can be used as header parameter in urllib3 requests
+
+Reads config files from f"~/.config/ongpi/{project_name}.{extension}"
+where extension can be yaml, yml, json or js
+Path can be overridden either with ONG_CONFIG_PATH environ variable
+"""
+from ong_utils.import_utils import AdditionalRequirementException, raise_extra_install
+
+from ong_utils.config import OngConfig
+from ong_utils.internal_storage import InternalStorage
+from ong_utils.parse_html import find_js_variable
+from ong_utils.timers import OngTimer
+from ong_utils.urllib3_utils import create_pool_manager, cookies2header, get_cookies
+from ong_utils.utils import (LOCAL_TZ, is_debugging, to_list, is_mac, is_linux, is_windows, get_current_user,
+                             get_current_domain)
+from ong_utils.web import find_available_port
+from ong_utils.ui import simple_dialog, user_domain_password_dialog, fix_windows_gui_scale
+from ong_utils.ui_logging_utils import print2widget, logger2widget
+
+
+import_excepts = (ModuleNotFoundError, NameError, AdditionalRequirementException)
+try:
+    from ong_utils.excel import df_to_excel
+    from ong_utils.sensitivity_labels import SensitivityLabel
+except import_excepts:
+    df_to_excel = raise_extra_install("xlsx")
+try:
+    from ong_utils.jwt_tokens import decode_jwt_token, decode_jwt_token_expiry
+except import_excepts:
+    decode_jwt_token = decode_jwt_token_expiry = raise_extra_install("jwt")
+    pass
+try:
+    from ong_utils.selenium_chrome import Chrome
+except import_excepts:
+    Chrome = raise_extra_install("selenium")
+try:
+    from ong_utils.credentials import verify_credentials
+except import_excepts:
+    verify_credentials = raise_extra_install("credentials")
+
```

## ong_utils/config.py

 * *Ordering differences only*

```diff
@@ -1,274 +1,274 @@
-import getpass
-import logging
-import logging.config
-import os
-import warnings
-
-import keyring
-import ujson
-import yaml
-
-_missing = object()  # In order to use None as default value for function args, this value must be used
-
-
-class OngConfig:
-    extensions_cfg = {
-        '.yaml': (yaml.safe_load, yaml.dump),
-        '.yml': (yaml.safe_load, yaml.dump),
-        '.json': (ujson.load, ujson.dump),
-        '.js': (ujson.load, ujson.dump),
-    }
-
-    # Static configurations to be shared among different files
-    __app_cfg_global = dict()
-    __log_cfg_global = dict()
-    __test_cfg_global = dict()
-
-    __logger = dict()
-
-    # Setters and getters for accessing to the app, log and test config
-    @property
-    def __app_cfg(self) -> dict:
-        return self.__app_cfg_global[self.project_name]
-
-    @__app_cfg.setter
-    def __app_cfg(self, value: dict):
-        self.__app_cfg_global[self.project_name] = value
-
-    @property
-    def __test_cfg(self) -> dict:
-        return self.__test_cfg_global[self.project_name]
-
-    @__test_cfg.setter
-    def __test_cfg(self, value: dict):
-        self.__test_cfg_global[self.project_name] = value
-
-    @property
-    def __log_cfg(self) -> dict:
-        return self.__log_cfg_global[self.project_name]
-
-    @__log_cfg.setter
-    def __log_cfg(self, value: dict):
-        self.__log_cfg_global[self.project_name] = value
-
-    def __init__(self, project_name: str, cfg_filename: str = None,
-                 default_app_cfg: dict = None, default_log_cfg: dict = None,
-                 default_test_cfg: dict = None, write_default_file: bool = False):
-        """
-        Reads configurations from f"~/.config/ongpi/{project_name}.{extension}"
-        :param project_name: the name of the project. Configuration for the project will be read from this key
-            in the yaml/json file
-        :param cfg_filename: an optional filename for the configuration (including extension). If not informed, the
-            filename will be project_name + . + extension, from the known extensions (yaml, yml, json ,js)
-        :param default_app_cfg: a dict with a default application configuration
-        :param default_log_cfg: a dict with a default logging configuration (logDict format)
-        :param default_test_cfg: a dict with a default test configuration
-        :param write_default_file: if False (default), raises Exception if default file is not found. If True
-         and default_app_cfg is not None, writes a default file in case it does not exit and continues with default
-         values
-        """
-        self.project_name = project_name
-        self.test_project_name = f"{self.project_name}_test"
-        self.config_path = os.path.expanduser(os.environ.get("ONG_CONFIG_PATH",
-                                                             os.path.join("~", ".config", "ongpi")))
-        self.__app_cfg = default_app_cfg or dict()
-        self.__test_cfg = default_test_cfg or dict()
-        self.__log_cfg = default_log_cfg or _default_logger_config(app_name=self.project_name)
-        self.config_filename = None
-        for ext, (loader, _) in self.extensions_cfg.items():
-            if cfg_filename:
-                if cfg_filename.endswith(ext):
-                    config_filename = self._get_cfg_filename(filename=cfg_filename)
-                else:
-                    continue
-            else:
-                config_filename = self._get_cfg_filename(ext=ext)
-            if os.path.isfile(config_filename):
-                self.config_filename = config_filename
-                if self.read_config_file():
-                    break
-                else:
-                    raise ValueError(f"Key {self.project_name} was not found in config file {self.config_filename}")
-            else:
-                continue
-
-        if self.config_filename is None:
-            self.config_filename = self._get_cfg_filename(list(self.extensions_cfg.keys())[0], filename=cfg_filename)
-            self.save()
-            # In case there is a default app config and file must not be overwritten, it does not raise an
-            # exception and continues normally creating a file with default values
-            if default_app_cfg is not None and write_default_file:
-                return
-            else:
-                raise FileNotFoundError(f"Configuration file {self.config_filename} not found. "
-                                        f"A new one based on default values has been created")
-
-    def read_config_file(self) -> bool:
-        """Reads config file stored in self.config_filename.
-        Returns True if file contains required config for self.project_name, False otherwise"""
-        cfg = self.load()
-        if self.project_name in cfg:
-            self.__app_cfg.update(cfg[self.project_name])
-            self.__test_cfg.update(cfg.get(self.test_project_name) or dict())
-            if self.project_name not in self.__logger:       # Update logger config just in case is not already initialized
-                self.__log_cfg.update(cfg.get("log") or dict())
-                self._fix_logger_config()
-                logging.config.dictConfig(self.__log_cfg)
-                self.__logger[self.project_name] = logging.getLogger(self.project_name)
-            return True
-        else:
-            return False
-
-    def _get_cfg_filename(self, ext: str = None, filename: str = None):
-        if not filename:
-            filename = self.project_name + ext
-        return os.path.join(self.config_path, filename)
-
-    def load(self) -> dict | None:
-        """Loads contents of self.config_filename. Returns None if file does not exist,
-        a dictionary otherwise"""
-        ext = os.path.splitext(self.config_filename)[-1]
-        loader, writer = self.extensions_cfg[ext]
-        if os.path.isfile(self.config_filename):
-            with open(self.config_filename, "r") as f_cfg:
-                cfg = loader(f_cfg)
-                return cfg
-        return None
-
-    def create_default_config(self):
-        """Creates a config file with the contents of the current configuration"""
-        warnings.warn("The use of create_default_config() is deprecated, use save() instead", DeprecationWarning)
-        self.save()
-
-    def save(self):
-        """Saves current config to the config file self.config_filename"""
-        cfg = {self.project_name: self.__app_cfg,
-               self.test_project_name: self.__test_cfg, "log": dict()}
-        _, ext = os.path.splitext(self.config_filename)
-        loader, writer = self.extensions_cfg[ext]
-        os.makedirs(os.path.dirname(self.config_filename), exist_ok=True)
-        if os.path.isfile(self.config_filename):
-            cfg = self.load()
-            cfg[self.project_name] = self.__app_cfg
-            cfg[self.test_project_name] = self.__test_cfg
-        with open(self.config_filename, "w") as f_cfg:
-            writer(cfg, f_cfg)
-
-    def _fix_logger_config(self):
-        """Replaces log_filename with the current project name, creates directories  for file logs if they don't
-        exist and renames logger to self.project_name"""
-        log_filename = self.__log_cfg['handlers']['logfile']['filename']
-        log_filename = os.path.expanduser(log_filename)
-        self.__log_cfg['handlers']['logfile']['filename'] = log_filename
-        os.makedirs(os.path.dirname(log_filename), exist_ok=True)
-
-    @property
-    def logger(self):
-        return self.__logger.get(self.project_name, None)
-
-    def config(self, item: str, default_value=_missing):
-        """Checks for a parameter in the configuration, and raises exception if not found.
-        If not found but a non-None default_value is used, then default value is returned and no Exception raised"""
-        if item in self.__app_cfg:
-            return self.__app_cfg[item]
-        elif default_value is not _missing:
-            return default_value
-        else:
-            raise ValueError(f"Item {item} not defined in section {self.project_name} of file {self.config_filename}")
-
-    def config_test(self, item: str, default_value=_missing):
-        """Checks for a parameter in the configuration in the test section, and raises exception if not found.
-        If not found but a non-None default_value is used, then default value is returned and no Exception raised"""
-        if item in self.__test_cfg:
-            return self.__test_cfg[item]
-        elif default_value is not _missing:
-            return default_value
-        else:
-            raise ValueError(f"Item {item} not defined in section {self.test_project_name} "
-                             f"of file {self.config_filename}")
-
-    def get_password(self, service_cfg_key: str, username_cfg_key: str):
-        """
-        Returns a password stored in the keyring for the provided service and username config keys
-        :param service_cfg_key: the key of the config item storing the service name, to be retrieved by calling self.config.
-        if not found in config, defaults to service_cfg_key
-        :param username_cfg_key: the key of the config item storing the username, to be retrieved by calling self.config)
-        :return: the password (None if not set)
-        """
-        return keyring.get_password(self.config(service_cfg_key, service_cfg_key),
-                                    self.config(username_cfg_key, username_cfg_key))
-
-    def set_password(self, service_cfg_key: str, username_cfg_key: str) -> None:
-        """
-        Prompts user for a password to be stored in the keyring for the provided service and username config keys
-        :param service_cfg_key: the key of the config item storing the service name (retrieved by calling self.config)
-        :param username_cfg_key: the key of the config item storing the username (retrieved by calling self.config)
-        :return: None
-        """
-        password = getpass.getpass()
-        return keyring.set_password(self.config(service_cfg_key, service_cfg_key),
-                                    self.config(username_cfg_key, username_cfg_key), password)
-
-    def add_app_config(self, item: str, value):
-        """Adds a new value to app_config and stores it. Raises value error if item already existed"""
-        if item not in self.__app_cfg:
-            self.__app_cfg[item] = value
-            self.save()
-        else:
-            raise ValueError(f"Item {item} already existed in app config. Edit it manually")
-
-    def update_app_config(self, item: str, value):
-        """Updates a value into app_config and stores it. Raises value error if item did not exist"""
-        if item in self.__app_cfg:
-            self.__app_cfg[item] = value
-            self.save()
-        else:
-            raise ValueError(f"Item {item} already did not existed in app config.")
-
-    def close_handlers(self, remove_handlers: bool = True):
-        """Forces close of handlers, and also remove them if remove_handlers=True (default)"""
-        handlers = self.logger.handlers[:]
-        for handler in handlers:
-            handler.close()
-            if remove_handlers:
-                self.logger.removeHandler(handler)
-
-
-def _default_logger_config(app_name: str):
-    log_cfg = {
-        'version': 1,
-        'disable_existing_loggers': False,
-        'formatters': {
-            'default_formatter': {
-                'format': '%(asctime)s %(levelname)s %(name)s %(message)s'
-            },
-            'detailed_formatter': {
-                'format': '%(asctime)s - %(filename)s:%(lineno)d - %(levelname)s: %(message)s',
-                'datefmt': '%Y-%m-%d %I:%M:%S'
-            },
-        },
-        'handlers': {
-            'console': {
-                'class': 'logging.StreamHandler',
-                'formatter': 'default_formatter',
-                'level': 'INFO'
-            },
-            'logfile': {
-                'level': 'DEBUG',
-                'class': 'logging.handlers.RotatingFileHandler',
-                'filename': f'~/.log/{app_name}.log',  # Filename be formatted later replacing app_name placeholder
-                'maxBytes': 10 * 1024 * 1024,
-                'backupCount': 5,
-                'formatter': 'detailed_formatter'
-            },
-        },
-        'loggers': {
-            app_name: {
-                'handlers': ['console', 'logfile'],
-                'level': 'DEBUG',
-                'propagate': True,
-            },
-        }
-    }
-
-    return log_cfg
+import getpass
+import logging
+import logging.config
+import os
+import warnings
+
+import keyring
+import ujson
+import yaml
+
+_missing = object()  # In order to use None as default value for function args, this value must be used
+
+
+class OngConfig:
+    extensions_cfg = {
+        '.yaml': (yaml.safe_load, yaml.dump),
+        '.yml': (yaml.safe_load, yaml.dump),
+        '.json': (ujson.load, ujson.dump),
+        '.js': (ujson.load, ujson.dump),
+    }
+
+    # Static configurations to be shared among different files
+    __app_cfg_global = dict()
+    __log_cfg_global = dict()
+    __test_cfg_global = dict()
+
+    __logger = dict()
+
+    # Setters and getters for accessing to the app, log and test config
+    @property
+    def __app_cfg(self) -> dict:
+        return self.__app_cfg_global[self.project_name]
+
+    @__app_cfg.setter
+    def __app_cfg(self, value: dict):
+        self.__app_cfg_global[self.project_name] = value
+
+    @property
+    def __test_cfg(self) -> dict:
+        return self.__test_cfg_global[self.project_name]
+
+    @__test_cfg.setter
+    def __test_cfg(self, value: dict):
+        self.__test_cfg_global[self.project_name] = value
+
+    @property
+    def __log_cfg(self) -> dict:
+        return self.__log_cfg_global[self.project_name]
+
+    @__log_cfg.setter
+    def __log_cfg(self, value: dict):
+        self.__log_cfg_global[self.project_name] = value
+
+    def __init__(self, project_name: str, cfg_filename: str = None,
+                 default_app_cfg: dict = None, default_log_cfg: dict = None,
+                 default_test_cfg: dict = None, write_default_file: bool = False):
+        """
+        Reads configurations from f"~/.config/ongpi/{project_name}.{extension}"
+        :param project_name: the name of the project. Configuration for the project will be read from this key
+            in the yaml/json file
+        :param cfg_filename: an optional filename for the configuration (including extension). If not informed, the
+            filename will be project_name + . + extension, from the known extensions (yaml, yml, json ,js)
+        :param default_app_cfg: a dict with a default application configuration
+        :param default_log_cfg: a dict with a default logging configuration (logDict format)
+        :param default_test_cfg: a dict with a default test configuration
+        :param write_default_file: if False (default), raises Exception if default file is not found. If True
+         and default_app_cfg is not None, writes a default file in case it does not exit and continues with default
+         values
+        """
+        self.project_name = project_name
+        self.test_project_name = f"{self.project_name}_test"
+        self.config_path = os.path.expanduser(os.environ.get("ONG_CONFIG_PATH",
+                                                             os.path.join("~", ".config", "ongpi")))
+        self.__app_cfg = default_app_cfg or dict()
+        self.__test_cfg = default_test_cfg or dict()
+        self.__log_cfg = default_log_cfg or _default_logger_config(app_name=self.project_name)
+        self.config_filename = None
+        for ext, (loader, _) in self.extensions_cfg.items():
+            if cfg_filename:
+                if cfg_filename.endswith(ext):
+                    config_filename = self._get_cfg_filename(filename=cfg_filename)
+                else:
+                    continue
+            else:
+                config_filename = self._get_cfg_filename(ext=ext)
+            if os.path.isfile(config_filename):
+                self.config_filename = config_filename
+                if self.read_config_file():
+                    break
+                else:
+                    raise ValueError(f"Key {self.project_name} was not found in config file {self.config_filename}")
+            else:
+                continue
+
+        if self.config_filename is None:
+            self.config_filename = self._get_cfg_filename(list(self.extensions_cfg.keys())[0], filename=cfg_filename)
+            self.save()
+            # In case there is a default app config and file must not be overwritten, it does not raise an
+            # exception and continues normally creating a file with default values
+            if default_app_cfg is not None and write_default_file:
+                return
+            else:
+                raise FileNotFoundError(f"Configuration file {self.config_filename} not found. "
+                                        f"A new one based on default values has been created")
+
+    def read_config_file(self) -> bool:
+        """Reads config file stored in self.config_filename.
+        Returns True if file contains required config for self.project_name, False otherwise"""
+        cfg = self.load()
+        if self.project_name in cfg:
+            self.__app_cfg.update(cfg[self.project_name])
+            self.__test_cfg.update(cfg.get(self.test_project_name) or dict())
+            if self.project_name not in self.__logger:       # Update logger config just in case is not already initialized
+                self.__log_cfg.update(cfg.get("log") or dict())
+                self._fix_logger_config()
+                logging.config.dictConfig(self.__log_cfg)
+                self.__logger[self.project_name] = logging.getLogger(self.project_name)
+            return True
+        else:
+            return False
+
+    def _get_cfg_filename(self, ext: str = None, filename: str = None):
+        if not filename:
+            filename = self.project_name + ext
+        return os.path.join(self.config_path, filename)
+
+    def load(self) -> dict | None:
+        """Loads contents of self.config_filename. Returns None if file does not exist,
+        a dictionary otherwise"""
+        ext = os.path.splitext(self.config_filename)[-1]
+        loader, writer = self.extensions_cfg[ext]
+        if os.path.isfile(self.config_filename):
+            with open(self.config_filename, "r") as f_cfg:
+                cfg = loader(f_cfg)
+                return cfg
+        return None
+
+    def create_default_config(self):
+        """Creates a config file with the contents of the current configuration"""
+        warnings.warn("The use of create_default_config() is deprecated, use save() instead", DeprecationWarning)
+        self.save()
+
+    def save(self):
+        """Saves current config to the config file self.config_filename"""
+        cfg = {self.project_name: self.__app_cfg,
+               self.test_project_name: self.__test_cfg, "log": dict()}
+        _, ext = os.path.splitext(self.config_filename)
+        loader, writer = self.extensions_cfg[ext]
+        os.makedirs(os.path.dirname(self.config_filename), exist_ok=True)
+        if os.path.isfile(self.config_filename):
+            cfg = self.load()
+            cfg[self.project_name] = self.__app_cfg
+            cfg[self.test_project_name] = self.__test_cfg
+        with open(self.config_filename, "w") as f_cfg:
+            writer(cfg, f_cfg)
+
+    def _fix_logger_config(self):
+        """Replaces log_filename with the current project name, creates directories  for file logs if they don't
+        exist and renames logger to self.project_name"""
+        log_filename = self.__log_cfg['handlers']['logfile']['filename']
+        log_filename = os.path.expanduser(log_filename)
+        self.__log_cfg['handlers']['logfile']['filename'] = log_filename
+        os.makedirs(os.path.dirname(log_filename), exist_ok=True)
+
+    @property
+    def logger(self):
+        return self.__logger.get(self.project_name, None)
+
+    def config(self, item: str, default_value=_missing):
+        """Checks for a parameter in the configuration, and raises exception if not found.
+        If not found but a non-None default_value is used, then default value is returned and no Exception raised"""
+        if item in self.__app_cfg:
+            return self.__app_cfg[item]
+        elif default_value is not _missing:
+            return default_value
+        else:
+            raise ValueError(f"Item {item} not defined in section {self.project_name} of file {self.config_filename}")
+
+    def config_test(self, item: str, default_value=_missing):
+        """Checks for a parameter in the configuration in the test section, and raises exception if not found.
+        If not found but a non-None default_value is used, then default value is returned and no Exception raised"""
+        if item in self.__test_cfg:
+            return self.__test_cfg[item]
+        elif default_value is not _missing:
+            return default_value
+        else:
+            raise ValueError(f"Item {item} not defined in section {self.test_project_name} "
+                             f"of file {self.config_filename}")
+
+    def get_password(self, service_cfg_key: str, username_cfg_key: str):
+        """
+        Returns a password stored in the keyring for the provided service and username config keys
+        :param service_cfg_key: the key of the config item storing the service name, to be retrieved by calling self.config.
+        if not found in config, defaults to service_cfg_key
+        :param username_cfg_key: the key of the config item storing the username, to be retrieved by calling self.config)
+        :return: the password (None if not set)
+        """
+        return keyring.get_password(self.config(service_cfg_key, service_cfg_key),
+                                    self.config(username_cfg_key, username_cfg_key))
+
+    def set_password(self, service_cfg_key: str, username_cfg_key: str) -> None:
+        """
+        Prompts user for a password to be stored in the keyring for the provided service and username config keys
+        :param service_cfg_key: the key of the config item storing the service name (retrieved by calling self.config)
+        :param username_cfg_key: the key of the config item storing the username (retrieved by calling self.config)
+        :return: None
+        """
+        password = getpass.getpass()
+        return keyring.set_password(self.config(service_cfg_key, service_cfg_key),
+                                    self.config(username_cfg_key, username_cfg_key), password)
+
+    def add_app_config(self, item: str, value):
+        """Adds a new value to app_config and stores it. Raises value error if item already existed"""
+        if item not in self.__app_cfg:
+            self.__app_cfg[item] = value
+            self.save()
+        else:
+            raise ValueError(f"Item {item} already existed in app config. Edit it manually")
+
+    def update_app_config(self, item: str, value):
+        """Updates a value into app_config and stores it. Raises value error if item did not exist"""
+        if item in self.__app_cfg:
+            self.__app_cfg[item] = value
+            self.save()
+        else:
+            raise ValueError(f"Item {item} already did not existed in app config.")
+
+    def close_handlers(self, remove_handlers: bool = True):
+        """Forces close of handlers, and also remove them if remove_handlers=True (default)"""
+        handlers = self.logger.handlers[:]
+        for handler in handlers:
+            handler.close()
+            if remove_handlers:
+                self.logger.removeHandler(handler)
+
+
+def _default_logger_config(app_name: str):
+    log_cfg = {
+        'version': 1,
+        'disable_existing_loggers': False,
+        'formatters': {
+            'default_formatter': {
+                'format': '%(asctime)s %(levelname)s %(name)s %(message)s'
+            },
+            'detailed_formatter': {
+                'format': '%(asctime)s - %(filename)s:%(lineno)d - %(levelname)s: %(message)s',
+                'datefmt': '%Y-%m-%d %I:%M:%S'
+            },
+        },
+        'handlers': {
+            'console': {
+                'class': 'logging.StreamHandler',
+                'formatter': 'default_formatter',
+                'level': 'INFO'
+            },
+            'logfile': {
+                'level': 'DEBUG',
+                'class': 'logging.handlers.RotatingFileHandler',
+                'filename': f'~/.log/{app_name}.log',  # Filename be formatted later replacing app_name placeholder
+                'maxBytes': 10 * 1024 * 1024,
+                'backupCount': 5,
+                'formatter': 'detailed_formatter'
+            },
+        },
+        'loggers': {
+            app_name: {
+                'handlers': ['console', 'logfile'],
+                'level': 'DEBUG',
+                'propagate': True,
+            },
+        }
+    }
+
+    return log_cfg
```

## ong_utils/credentials.py

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-"""
-Function to validate user and password (of current logged in user) in windows, linux and macos
-"""
-from ong_utils.import_utils import raise_extra_exception
-from ong_utils.utils import is_windows
-
-
-def verify_credentials(username: str, domain: str, password: str, **kwargs) -> bool:
-    """Checks if password is correct"""
-    if not password:
-        return False
-    if is_windows():
-        return _verify_credentials_windows(username, domain, password)
-    else:
-        return _verify_credentials_unix(username, password)
-
-
-def _verify_credentials_windows(username: str, domain: str, password: str) -> bool:
-    """Checks if password is correct in windows"""
-    try:
-        import win32security
-        hUser = win32security.LogonUser(
-            username,
-            domain,
-            password,
-            # win32security.LOGON32_LOGON_NETWORK,
-            win32security.LOGON32_LOGON_INTERACTIVE,
-            win32security.LOGON32_PROVIDER_DEFAULT
-        )
-    except ModuleNotFoundError:
-        raise_extra_exception("credentials")
-    except win32security.error as e:
-        return False
-    except Exception as e:
-        return False
-    else:
-        return True
-
-
-def _verify_credentials_unix(username: str, password: str) -> bool:
-    """Checks if password is correct in linux/macos"""
-    try:
-        import pam
-        # Use PAM to authenticate the user
-        pam_auth = pam.pam()
-        return pam_auth.authenticate(username, password, service='login')
-    except ModuleNotFoundError:
-        raise_extra_exception("credentials")
-    except pam.PAMError as e:
-        print(f"Authentication failed: {e}")
-        return False
-    except Exception as e:
-        print(e)
-        return False
-
-
-if __name__ == '__main__':
-    from ong_utils.utils import get_current_user, get_current_domain
-    import getpass
-
-    password = getpass.getpass()
-
-    print(verify_credentials(username=get_current_user(),
-                             domain=get_current_domain(),
-                             password=password))
-
-    pass
+"""
+Function to validate user and password (of current logged in user) in windows, linux and macos
+"""
+from ong_utils.import_utils import raise_extra_exception
+from ong_utils.utils import is_windows
+
+
+def verify_credentials(username: str, domain: str, password: str, **kwargs) -> bool:
+    """Checks if password is correct"""
+    if not password:
+        return False
+    if is_windows():
+        return _verify_credentials_windows(username, domain, password)
+    else:
+        return _verify_credentials_unix(username, password)
+
+
+def _verify_credentials_windows(username: str, domain: str, password: str) -> bool:
+    """Checks if password is correct in windows"""
+    try:
+        import win32security
+        hUser = win32security.LogonUser(
+            username,
+            domain,
+            password,
+            # win32security.LOGON32_LOGON_NETWORK,
+            win32security.LOGON32_LOGON_INTERACTIVE,
+            win32security.LOGON32_PROVIDER_DEFAULT
+        )
+    except ModuleNotFoundError:
+        raise_extra_exception("credentials")
+    except win32security.error as e:
+        return False
+    except Exception as e:
+        return False
+    else:
+        return True
+
+
+def _verify_credentials_unix(username: str, password: str) -> bool:
+    """Checks if password is correct in linux/macos"""
+    try:
+        import pam
+        # Use PAM to authenticate the user
+        pam_auth = pam.pam()
+        return pam_auth.authenticate(username, password, service='login')
+    except ModuleNotFoundError:
+        raise_extra_exception("credentials")
+    except pam.PAMError as e:
+        print(f"Authentication failed: {e}")
+        return False
+    except Exception as e:
+        print(e)
+        return False
+
+
+if __name__ == '__main__':
+    from ong_utils.utils import get_current_user, get_current_domain
+    import getpass
+
+    password = getpass.getpass()
+
+    print(verify_credentials(username=get_current_user(),
+                             domain=get_current_domain(),
+                             password=password))
+
+    pass
```

## ong_utils/desktop_shortcut.py

 * *Ordering differences only*

```diff
@@ -1,246 +1,246 @@
-"""
-Creates a desktop link to launch a certain program,
-and modifies its installed files (in dist-info), so it can be uninstalled
-"""
-from __future__ import annotations
-
-import base64
-import hashlib
-import importlib.metadata
-import inspect
-import os
-import sys
-import tempfile
-import zipfile
-from importlib.metadata import distribution
-
-from ong_utils.import_utils import raise_extra_exception
-try:
-    import pyshortcuts.shortcut
-    from pyshortcuts import make_shortcut, platform, shortcut, get_folders
-    from wheel.bdist_wheel import bdist_wheel
-except ModuleNotFoundError:
-    raise_extra_exception("shortcuts")
-
-
-def is_pip() -> bool:
-    """Returns True if running under pip"""
-    if "pip" in os.environ.get("_", ""):
-        return True
-    else:
-        return False
-
-
-def get_name_script(entry_points) -> list:
-    """
-    Takes a distribution object and returns a list of tuples for each entry point with the script name and the
-    module to be executed
-    Example: for "script1 = package.file:function" [("script1", "package.file")]
-    :param entry_points: the list of entry points (result of  self.distribution.entry_points)
-    :return:
-    """
-    retval = []
-
-    def script_to_shortcut(script):
-        script = script.split(":")[0]
-        # check that script is not the one currently executing
-        stack = inspect.stack()
-        script_os = script.replace(".", os.sep)
-        if not any(script_os in s.filename for s in stack):
-            return f"_ -m {script}"
-        else:
-            return None
-
-    if isinstance(entry_points, dict):
-        for console_script in entry_points.get("console_scripts", []):
-            name, script = map(str.strip, console_script.split("="))
-            script = script_to_shortcut(script)
-            if script:
-                retval.append((name, script))
-    else:
-        for ep in entry_points:
-            script = script_to_shortcut(ep.value)
-            if script:
-                retval.append((ep.name, script))
-    return retval
-
-
-class PipCreateShortcut(bdist_wheel):
-    """
-    Creates shortcuts for each entry_point when installing the package from git using pip
-    """
-
-    def run(self):
-        bdist_wheel.run(self)
-        if not is_pip():
-            # If not running under pip, do nothing, as results could be strange
-            return
-        impl_tag, abi_tag, plat_tag = self.get_tag()
-        archive_basename = f"{self.wheel_dist_name}-{impl_tag}-{abi_tag}-{plat_tag}"
-        wheel_path = os.path.join(self.dist_dir, archive_basename + ".whl")
-        ####
-        # Create a new wheel, by unzipping the original files but the RECORD file, that will be modified with the new
-        # shortcut files, in order to be uninstalled later
-        ####
-        tmpfd, tmpname = tempfile.mkstemp(dir=os.path.dirname(wheel_path))
-        os.close(tmpfd)
-        # create a temp copy of the archive without filename
-        with zipfile.ZipFile(wheel_path, 'r') as zin:
-            with zipfile.ZipFile(tmpname, 'w') as zout:
-                zout.comment = zin.comment  # preserve the comment
-                for item in zin.infolist():
-                    if not item.filename.endswith("RECORD"):
-                        zout.writestr(item, zin.read(item.filename))
-                    else:
-                        # Write custom record file here
-                        data = zin.read(item.filename)
-                        data += self.append_scut_record().encode()
-                        zout.writestr(item, data)
-        # replace with the temp archive
-        os.remove(wheel_path)
-        os.rename(tmpname, wheel_path)
-
-    def append_scut_record(self) -> str:
-        """Creates a shortcut for every entry point"""
-        retval = ""
-        for name, script in get_name_script(self.distribution.entry_points):
-            iconfile = 'shovel.icns' if platform.startswith('darwin') else 'shovel.ico'
-            # Not needed: shortcuts are not overwritten using make_shortcut
-            # scut = shortcut(script=script, name=name, userfolders=get_folders())
-            # if os.path.exists(scut_filename):
-            #     os.remove(scut_filename)
-            scut = make_shortcut(script=script, name=name, icon=None,
-                                 description="",
-                                 startmenu=False)
-            scut_filename = os.path.join(scut.desktop_dir, scut.target)
-            for record in file2record(scut_filename):
-                retval += f"{record}\n"
-        return retval
-
-
-def file2record(filename: str) -> list:
-    """Returns a list of lines to append to RECORD file associated to a given a file"""
-    if os.path.isfile(filename):
-        with open(filename, "rb") as f:
-            contents = f.read()
-        sha256 = base64.urlsafe_b64encode(hashlib.sha256(contents).digest())[:-1].decode("utf-8")
-        txt_append_record_file = f"{filename},sha256={sha256},{len(contents)}"
-        return [txt_append_record_file]
-    elif os.path.isdir(filename):
-        # This is macos case. Let's see if it can delete whole dir. Works like a charm ;)
-        return [f"{filename}, ,"]
-    else:
-        raise FileNotFoundError(f"Not found file: {filename}")
-
-
-class PostInstallCreateShortcut:
-    def __init__(self, library: str = __name__):
-        self.library = library
-        try:
-            self.distribution = distribution(self.library)
-            print(f"Creating shortcuts for {library} installed in {self.distribution._path}")
-        except importlib.metadata.PackageNotFoundError as pnfe:
-            pnfe.args = (f"{library}. Is it installed?",)
-            raise pnfe
-
-        # gets the record file (if exists)
-        records = list(f for f in self.distribution.files if f.name == "RECORD")
-        if records:
-            self.record = records[0].locate()
-            self.installed_files = None
-        else:
-            # Add to installed files of the egg_file
-            egg_dir = self.distribution._path.as_posix()
-            assert (egg_dir.endswith("egg-info"))
-            self.installed_files = os.path.join(egg_dir, "installed_files.txt")
-            self.record = None
-
-    def add_file_record(self, shortcut: pyshortcuts.Shortcut):
-        """Adds information on a shortcut to the RECORD file (if exists), including icon"""
-        append_to_record_file = []
-        output_file = self.record or self.installed_files
-        filename = shortcut.target
-        path = shortcut.desktop_dir
-        # path = shortcut.startmenu_dir # In case it was created in start menu
-        sc_path = os.path.join(path, filename)
-        icon_path = shortcut.icon if not "pyshorcuts" in shortcut.icon else ""
-        for file in (sc_path, icon_path):
-            if not file:
-                continue
-            append2record = file2record(file)
-            if os.path.exists(output_file):
-                with open(output_file, "r") as f:
-                    record_data = f.readlines()
-            else:
-                record_data = ""
-            with open(output_file, "a") as f:
-                # avoid writing multiple times in record file
-                for line in append2record:
-                    if output_file == self.installed_files:
-                        line = line.split(",")[0]
-                    if line not in record_data:
-                        f.write(line + "\n")
-
-    def find_icon(self, script_name) -> str | None:
-        """Finds an icon for the given file. If found in png format, then transformed to ico/icns format.
-        Returns None if not found"""
-
-        iconfile_ext = '.icns' if platform.startswith('darwin') else '.ico'
-        # Try to find icon in "icons" folder
-        icon = script_name + iconfile_ext
-        iconfile = list(f for f in self.distribution.files if f.name.endswith(icon))
-        if not iconfile:
-            # Try to find icon in png format
-            png_file = list(f for f in self.distribution.files if f.name.endswith(script_name + ".png"))
-            if not png_file:
-                iconfile = None
-            else:
-                png_file = png_file[0].locate().as_posix()
-                iconfile = png_file[:-4] + iconfile_ext
-                # Create the ad hoc ico/icns file
-                if sys.platform == "darwin":
-                    import icnsutil
-                    img = icnsutil.IcnsFile()
-                    img.add_media('ic07', file=png_file)
-                    img.write(iconfile)
-                else:
-                    from PIL import Image
-                    img = Image.open(png_file)
-                    img.save(iconfile)
-                pass
-        else:
-            iconfile = iconfile[0].locate().as_posix()
-        return iconfile
-
-    def make_shortcuts(self):
-        for name, script in get_name_script(self.distribution.entry_points):
-            # files = list(f for f in entry_point.dist.files)
-            # TODO: test if this script works in windows
-            # script = os.path.normpath(files[0].locate().as_posix())
-            # splits = eps[0].value.split(':')
-            # module = splits[0]
-            # function = splits[1] if len(splits) > 1 else None
-            # if not function:
-            # else:
-            #     This DOES NOT WORK at least in mac, no matter if using " or '
-            #     script = f'_ -c "from {module} import {function};{function}()"'
-            iconfile = self.find_icon(name)
-            scut = shortcut(script=script, name=name, userfolders=get_folders(), icon=iconfile)
-            scut_filename = os.path.join(scut.desktop_dir, scut.target)
-            # In order to add icons once installed, overwrite the shorcut anyway
-            # if os.path.exists(scut_filename):
-            #     continue  # If shortcut existed, skip
-            retva = make_shortcut(script=script, name=name, icon=iconfile,
-                                  description="",
-                                  startmenu=False)
-
-            self.add_file_record(retva)
-
-
-if __name__ == '__main__':
-    sci = PostInstallCreateShortcut()
-    sci.make_shortcuts()
-
-"""
-flat couch vector, minimalist, in style of SKSKS app icon
-"""
+"""
+Creates a desktop link to launch a certain program,
+and modifies its installed files (in dist-info), so it can be uninstalled
+"""
+from __future__ import annotations
+
+import base64
+import hashlib
+import importlib.metadata
+import inspect
+import os
+import sys
+import tempfile
+import zipfile
+from importlib.metadata import distribution
+
+from ong_utils.import_utils import raise_extra_exception
+try:
+    import pyshortcuts.shortcut
+    from pyshortcuts import make_shortcut, platform, shortcut, get_folders
+    from wheel.bdist_wheel import bdist_wheel
+except ModuleNotFoundError:
+    raise_extra_exception("shortcuts")
+
+
+def is_pip() -> bool:
+    """Returns True if running under pip"""
+    if "pip" in os.environ.get("_", ""):
+        return True
+    else:
+        return False
+
+
+def get_name_script(entry_points) -> list:
+    """
+    Takes a distribution object and returns a list of tuples for each entry point with the script name and the
+    module to be executed
+    Example: for "script1 = package.file:function" [("script1", "package.file")]
+    :param entry_points: the list of entry points (result of  self.distribution.entry_points)
+    :return:
+    """
+    retval = []
+
+    def script_to_shortcut(script):
+        script = script.split(":")[0]
+        # check that script is not the one currently executing
+        stack = inspect.stack()
+        script_os = script.replace(".", os.sep)
+        if not any(script_os in s.filename for s in stack):
+            return f"_ -m {script}"
+        else:
+            return None
+
+    if isinstance(entry_points, dict):
+        for console_script in entry_points.get("console_scripts", []):
+            name, script = map(str.strip, console_script.split("="))
+            script = script_to_shortcut(script)
+            if script:
+                retval.append((name, script))
+    else:
+        for ep in entry_points:
+            script = script_to_shortcut(ep.value)
+            if script:
+                retval.append((ep.name, script))
+    return retval
+
+
+class PipCreateShortcut(bdist_wheel):
+    """
+    Creates shortcuts for each entry_point when installing the package from git using pip
+    """
+
+    def run(self):
+        bdist_wheel.run(self)
+        if not is_pip():
+            # If not running under pip, do nothing, as results could be strange
+            return
+        impl_tag, abi_tag, plat_tag = self.get_tag()
+        archive_basename = f"{self.wheel_dist_name}-{impl_tag}-{abi_tag}-{plat_tag}"
+        wheel_path = os.path.join(self.dist_dir, archive_basename + ".whl")
+        ####
+        # Create a new wheel, by unzipping the original files but the RECORD file, that will be modified with the new
+        # shortcut files, in order to be uninstalled later
+        ####
+        tmpfd, tmpname = tempfile.mkstemp(dir=os.path.dirname(wheel_path))
+        os.close(tmpfd)
+        # create a temp copy of the archive without filename
+        with zipfile.ZipFile(wheel_path, 'r') as zin:
+            with zipfile.ZipFile(tmpname, 'w') as zout:
+                zout.comment = zin.comment  # preserve the comment
+                for item in zin.infolist():
+                    if not item.filename.endswith("RECORD"):
+                        zout.writestr(item, zin.read(item.filename))
+                    else:
+                        # Write custom record file here
+                        data = zin.read(item.filename)
+                        data += self.append_scut_record().encode()
+                        zout.writestr(item, data)
+        # replace with the temp archive
+        os.remove(wheel_path)
+        os.rename(tmpname, wheel_path)
+
+    def append_scut_record(self) -> str:
+        """Creates a shortcut for every entry point"""
+        retval = ""
+        for name, script in get_name_script(self.distribution.entry_points):
+            iconfile = 'shovel.icns' if platform.startswith('darwin') else 'shovel.ico'
+            # Not needed: shortcuts are not overwritten using make_shortcut
+            # scut = shortcut(script=script, name=name, userfolders=get_folders())
+            # if os.path.exists(scut_filename):
+            #     os.remove(scut_filename)
+            scut = make_shortcut(script=script, name=name, icon=None,
+                                 description="",
+                                 startmenu=False)
+            scut_filename = os.path.join(scut.desktop_dir, scut.target)
+            for record in file2record(scut_filename):
+                retval += f"{record}\n"
+        return retval
+
+
+def file2record(filename: str) -> list:
+    """Returns a list of lines to append to RECORD file associated to a given a file"""
+    if os.path.isfile(filename):
+        with open(filename, "rb") as f:
+            contents = f.read()
+        sha256 = base64.urlsafe_b64encode(hashlib.sha256(contents).digest())[:-1].decode("utf-8")
+        txt_append_record_file = f"{filename},sha256={sha256},{len(contents)}"
+        return [txt_append_record_file]
+    elif os.path.isdir(filename):
+        # This is macos case. Let's see if it can delete whole dir. Works like a charm ;)
+        return [f"{filename}, ,"]
+    else:
+        raise FileNotFoundError(f"Not found file: {filename}")
+
+
+class PostInstallCreateShortcut:
+    def __init__(self, library: str = __name__):
+        self.library = library
+        try:
+            self.distribution = distribution(self.library)
+            print(f"Creating shortcuts for {library} installed in {self.distribution._path}")
+        except importlib.metadata.PackageNotFoundError as pnfe:
+            pnfe.args = (f"{library}. Is it installed?",)
+            raise pnfe
+
+        # gets the record file (if exists)
+        records = list(f for f in self.distribution.files if f.name == "RECORD")
+        if records:
+            self.record = records[0].locate()
+            self.installed_files = None
+        else:
+            # Add to installed files of the egg_file
+            egg_dir = self.distribution._path.as_posix()
+            assert (egg_dir.endswith("egg-info"))
+            self.installed_files = os.path.join(egg_dir, "installed_files.txt")
+            self.record = None
+
+    def add_file_record(self, shortcut: pyshortcuts.Shortcut):
+        """Adds information on a shortcut to the RECORD file (if exists), including icon"""
+        append_to_record_file = []
+        output_file = self.record or self.installed_files
+        filename = shortcut.target
+        path = shortcut.desktop_dir
+        # path = shortcut.startmenu_dir # In case it was created in start menu
+        sc_path = os.path.join(path, filename)
+        icon_path = shortcut.icon if not "pyshorcuts" in shortcut.icon else ""
+        for file in (sc_path, icon_path):
+            if not file:
+                continue
+            append2record = file2record(file)
+            if os.path.exists(output_file):
+                with open(output_file, "r") as f:
+                    record_data = f.readlines()
+            else:
+                record_data = ""
+            with open(output_file, "a") as f:
+                # avoid writing multiple times in record file
+                for line in append2record:
+                    if output_file == self.installed_files:
+                        line = line.split(",")[0]
+                    if line not in record_data:
+                        f.write(line + "\n")
+
+    def find_icon(self, script_name) -> str | None:
+        """Finds an icon for the given file. If found in png format, then transformed to ico/icns format.
+        Returns None if not found"""
+
+        iconfile_ext = '.icns' if platform.startswith('darwin') else '.ico'
+        # Try to find icon in "icons" folder
+        icon = script_name + iconfile_ext
+        iconfile = list(f for f in self.distribution.files if f.name.endswith(icon))
+        if not iconfile:
+            # Try to find icon in png format
+            png_file = list(f for f in self.distribution.files if f.name.endswith(script_name + ".png"))
+            if not png_file:
+                iconfile = None
+            else:
+                png_file = png_file[0].locate().as_posix()
+                iconfile = png_file[:-4] + iconfile_ext
+                # Create the ad hoc ico/icns file
+                if sys.platform == "darwin":
+                    import icnsutil
+                    img = icnsutil.IcnsFile()
+                    img.add_media('ic07', file=png_file)
+                    img.write(iconfile)
+                else:
+                    from PIL import Image
+                    img = Image.open(png_file)
+                    img.save(iconfile)
+                pass
+        else:
+            iconfile = iconfile[0].locate().as_posix()
+        return iconfile
+
+    def make_shortcuts(self):
+        for name, script in get_name_script(self.distribution.entry_points):
+            # files = list(f for f in entry_point.dist.files)
+            # TODO: test if this script works in windows
+            # script = os.path.normpath(files[0].locate().as_posix())
+            # splits = eps[0].value.split(':')
+            # module = splits[0]
+            # function = splits[1] if len(splits) > 1 else None
+            # if not function:
+            # else:
+            #     This DOES NOT WORK at least in mac, no matter if using " or '
+            #     script = f'_ -c "from {module} import {function};{function}()"'
+            iconfile = self.find_icon(name)
+            scut = shortcut(script=script, name=name, userfolders=get_folders(), icon=iconfile)
+            scut_filename = os.path.join(scut.desktop_dir, scut.target)
+            # In order to add icons once installed, overwrite the shorcut anyway
+            # if os.path.exists(scut_filename):
+            #     continue  # If shortcut existed, skip
+            retva = make_shortcut(script=script, name=name, icon=iconfile,
+                                  description="",
+                                  startmenu=False)
+
+            self.add_file_record(retva)
+
+
+if __name__ == '__main__':
+    sci = PostInstallCreateShortcut()
+    sci.make_shortcuts()
+
+"""
+flat couch vector, minimalist, in style of SKSKS app icon
+"""
```

## ong_utils/excel.py

 * *Ordering differences only*

```diff
@@ -1,78 +1,78 @@
-"""
-Some helper functions to work with openpyxl: write tables, use autofilters, read_excel when it fails...
-"""
-from ong_utils.import_utils import raise_extra_exception
-try:
-    import pandas as pd
-    from openpyxl import load_workbook
-    from openpyxl.worksheet.table import TableStyleInfo, Table
-except ModuleNotFoundError:
-    raise_extra_exception("xlsx")
-
-
-def df_to_excel(df: pd.DataFrame, writer: pd.ExcelWriter, sheet_name: str, index=False, add_table: bool = True):
-    """
-    Writes a df to an opened Excel, fitting column with and adding Tables or activating autofilter
-    Args:
-        df: DataFrame to write
-        writer: already opened excel writer, with engine = "openpyxl" (otherwise a ValueError will be raised)
-        sheet_name: name of the sheet to write in
-        index: False (default) to not write index to excel
-        add_table: True (default) to add Tables to excel, False to add just autofilter
-
-    Returns:
-        None
-    """
-    if writer.engine != "openpyxl":
-        raise ValueError(f"Error: writer engine ({writer.engine}) must be openpyxl, "
-                         f"e.g.: pd.ExcelWriter('filename.xlsx', engine='openpyxl')")
-    cols = [c.upper() if isinstance(c, str) else c for c in df.columns]
-    if len(set(cols)) < len(cols):  # There are duplicated values
-        new_cols = [f"{c}_{i}" if c.upper() in cols[i + 1:] else c for i, c in enumerate(df.columns)]
-        df.columns = new_cols
-
-    if df.empty:
-        df.loc[0] = None  # Force empty row
-    df.to_excel(writer, sheet_name=sheet_name, index=index, header=True)
-    ws = writer.sheets[sheet_name]
-    columns = ws.columns
-    for column, xls_column in zip(df, columns):
-        column_length = max(df[column].astype(str).map(len).max(), len(str(column)))
-        column_length = max(column_length, len(str(column)))  # Include headers in calculation
-        ws.column_dimensions[xls_column[0].column_letter].width = column_length
-
-    if add_table:
-        # Add a default style with striped rows and banded columns
-        style = TableStyleInfo(name="TableStyleMedium9", showFirstColumn=False,
-                               showLastColumn=False, showRowStripes=True, showColumnStripes=True)
-        # create a table
-        tab = Table(displayName=sheet_name.replace(" ", "_"), ref=ws.dimensions, tableStyleInfo=style)
-        '''
-        Table must be added using ws.add_table() method to avoid duplicate names.
-        Using this method ensures table name is unique through out defined names and all other table name. 
-        '''
-        ws.add_table(tab)
-    else:
-        # Add just autofilter
-        ws.auto_filter.ref = ws.dimensions
-
-
-# Currently unused
-def read_excel_file(filename: str, sheet_name: str) -> pd.DataFrame:
-    """Reads Excel file from a filename. If it fails, uses directly openpyxl to process file"""
-    try:
-        retval = pd.read_excel(filename, sheet_name=sheet_name)
-        return retval
-        # with pd.ExcelFile(filename) as excel:
-        #     retval = pd.read_excel(excel, sheet_name=sheet_name)
-        # return retval
-    except UnicodeError as ue:
-        print(ue)
-        # Use openpyxl directly to read the dataframe
-        wb = load_workbook(filename=filename)
-        sheet = wb.worksheets[sheet_name]
-        data = []
-        for row in sheet.iter_rows(values_only=True):
-            data.append(row)
-        retval = pd.DataFrame(data)
-        return retval
+"""
+Some helper functions to work with openpyxl: write tables, use autofilters, read_excel when it fails...
+"""
+from ong_utils.import_utils import raise_extra_exception
+try:
+    import pandas as pd
+    from openpyxl import load_workbook
+    from openpyxl.worksheet.table import TableStyleInfo, Table
+except ModuleNotFoundError:
+    raise_extra_exception("xlsx")
+
+
+def df_to_excel(df: pd.DataFrame, writer: pd.ExcelWriter, sheet_name: str, index=False, add_table: bool = True):
+    """
+    Writes a df to an opened Excel, fitting column with and adding Tables or activating autofilter
+    Args:
+        df: DataFrame to write
+        writer: already opened excel writer, with engine = "openpyxl" (otherwise a ValueError will be raised)
+        sheet_name: name of the sheet to write in
+        index: False (default) to not write index to excel
+        add_table: True (default) to add Tables to excel, False to add just autofilter
+
+    Returns:
+        None
+    """
+    if writer.engine != "openpyxl":
+        raise ValueError(f"Error: writer engine ({writer.engine}) must be openpyxl, "
+                         f"e.g.: pd.ExcelWriter('filename.xlsx', engine='openpyxl')")
+    cols = [c.upper() if isinstance(c, str) else c for c in df.columns]
+    if len(set(cols)) < len(cols):  # There are duplicated values
+        new_cols = [f"{c}_{i}" if c.upper() in cols[i + 1:] else c for i, c in enumerate(df.columns)]
+        df.columns = new_cols
+
+    if df.empty:
+        df.loc[0] = None  # Force empty row
+    df.to_excel(writer, sheet_name=sheet_name, index=index, header=True)
+    ws = writer.sheets[sheet_name]
+    columns = ws.columns
+    for column, xls_column in zip(df, columns):
+        column_length = max(df[column].astype(str).map(len).max(), len(str(column)))
+        column_length = max(column_length, len(str(column)))  # Include headers in calculation
+        ws.column_dimensions[xls_column[0].column_letter].width = column_length
+
+    if add_table:
+        # Add a default style with striped rows and banded columns
+        style = TableStyleInfo(name="TableStyleMedium9", showFirstColumn=False,
+                               showLastColumn=False, showRowStripes=True, showColumnStripes=True)
+        # create a table
+        tab = Table(displayName=sheet_name.replace(" ", "_"), ref=ws.dimensions, tableStyleInfo=style)
+        '''
+        Table must be added using ws.add_table() method to avoid duplicate names.
+        Using this method ensures table name is unique through out defined names and all other table name. 
+        '''
+        ws.add_table(tab)
+    else:
+        # Add just autofilter
+        ws.auto_filter.ref = ws.dimensions
+
+
+# Currently unused
+def read_excel_file(filename: str, sheet_name: str) -> pd.DataFrame:
+    """Reads Excel file from a filename. If it fails, uses directly openpyxl to process file"""
+    try:
+        retval = pd.read_excel(filename, sheet_name=sheet_name)
+        return retval
+        # with pd.ExcelFile(filename) as excel:
+        #     retval = pd.read_excel(excel, sheet_name=sheet_name)
+        # return retval
+    except UnicodeError as ue:
+        print(ue)
+        # Use openpyxl directly to read the dataframe
+        wb = load_workbook(filename=filename)
+        sheet = wb.worksheets[sheet_name]
+        data = []
+        for row in sheet.iter_rows(values_only=True):
+            data.append(row)
+        retval = pd.DataFrame(data)
+        return retval
```

## ong_utils/import_utils.py

 * *Ordering differences only*

```diff
@@ -1,22 +1,22 @@
-"""
-Exception and a function to deal with lack of imports
-"""
-
-
-class AdditionalRequirementException(Exception):
-    """Class for exceptions for lack or extras install (missing dependencies)"""
-    pass
-
-
-def raise_extra_exception(extras: str):
-    """Raises exception for the user to install some extras"""
-    raise AdditionalRequirementException(
-        f"Missing dependencies. Please install extra requirements with 'pip install ong_utils[{extras}]'")
-
-
-def raise_extra_install(extras: str):
-    """Function to raise exception for the user to install some extras. Used to replace original function
-    when dependencies are not met"""
-    def f(*args, **kwargs):
-        raise_extra_exception(extras)
-    return f
+"""
+Exception and a function to deal with lack of imports
+"""
+
+
+class AdditionalRequirementException(Exception):
+    """Class for exceptions for lack or extras install (missing dependencies)"""
+    pass
+
+
+def raise_extra_exception(extras: str):
+    """Raises exception for the user to install some extras"""
+    raise AdditionalRequirementException(
+        f"Missing dependencies. Please install extra requirements with 'pip install ong_utils[{extras}]'")
+
+
+def raise_extra_install(extras: str):
+    """Function to raise exception for the user to install some extras. Used to replace original function
+    when dependencies are not met"""
+    def f(*args, **kwargs):
+        raise_extra_exception(extras)
+    return f
```

## ong_utils/internal_storage.py

 * *Ordering differences only*

```diff
@@ -1,176 +1,176 @@
-"""
-Class to permanently store data using keyring
-"""
-import base64
-import json
-import zlib
-from textwrap import wrap
-
-import keyring
-import keyring.errors
-
-
-def compress_string(input_string: str) -> str:
-    """Compresses a string into another string utf-8 encoded"""
-    # Convert the string to bytes
-    input_bytes = input_string.encode('utf-8')
-
-    # Compress the bytes using zlib
-    compressed_bytes = zlib.compress(input_bytes)
-
-    # Encode the compressed bytes in base64 to get a UTF-8 encoded string
-    compressed_string = base64.b64encode(compressed_bytes).decode('utf-8')
-
-    return compressed_string
-
-
-def decompress_string(compressed_string: str) -> str:
-    """Decompresses a utf-8 encoded string into another string utf-8 encoded"""
-
-    # Decode the UTF-8 encoded string into bytes
-    compressed_bytes = base64.b64decode(compressed_string.encode('utf-8'))
-
-    # Decompress the bytes using zlib
-    decompressed_bytes = zlib.decompress(compressed_bytes)
-
-    # Decode the decompressed bytes back to a string
-    decompressed_string = decompressed_bytes.decode('utf-8')
-
-    return decompressed_string
-
-
-class InternalStorageBase:
-    def __init__(self, app_name: str):
-        self.__app_name = app_name
-
-    @property
-    def app_name(self) -> str:
-        return self.__app_name
-
-    def serialize(self, value) -> str:
-        """Serializes and compresses an object into a string."""
-        return compress_string(json.dumps(value))
-
-    def deserialize(self, value: str):
-        """Deserializes and decompresses a string into is original value"""
-        if value is None:
-            return None
-        return json.loads(decompress_string(value))
-
-    def store_value_raw(self, key: str, value):
-        keyring.set_password(self.app_name, key, value)
-        assert value == InternalStorageBase(self.app_name).get_value_raw(key)
-
-    def get_value_raw(self, key: str):
-        return keyring.get_password(self.app_name, key)
-
-    def remove_stored_value(self, key: str):
-        try:
-            keyring.delete_password(self.app_name, key)
-        except keyring.errors.PasswordDeleteError:
-            pass
-
-
-class InternalStorageV0(InternalStorageBase):
-
-    @property
-    def version(self):
-        return 0
-
-    def make_header(self, chunks: int = 0) -> dict:
-        return dict(version=self.version, class_name=self.__class__.__name__, chunks=chunks)
-
-    def serialize(self, value) -> str:
-        """Serializes and compresses an object into a string."""
-        return compress_string(json.dumps(value))
-
-    def deserialize(self, value: str):
-        """Deserializes and decompresses a string into is original value"""
-        if value is None:
-            return None
-        try:
-            retval = json.loads(decompress_string(value))
-            return retval
-        except:
-            return None
-
-    def store_value(self, key: str, value):
-        """Stores something in keyring"""
-        store_value = self.serialize(value)
-        self.store_value_raw(key, store_value)
-
-    def get_value(self, key: str):
-        stored_value = self.get_value_raw(key)
-        if stored_value is None:
-            return
-        original = self.deserialize(value=stored_value)
-        return original
-
-
-class InternalStorageV1(InternalStorageV0):
-    chunk_size = 1000
-    chunk_header_key = "chunks"
-
-    @property
-    def version(self):
-        return 1
-
-    def chunk(self, store_value: str) -> list:
-        """Splits a string into parts of a maximum size"""
-        return wrap(store_value, self.chunk_size)
-
-    def store_value_raw(self, key: str, value):
-        chunks = self.chunk(value)
-        header = self.make_header(chunks=len(chunks))
-        super().store_value_raw(key, self.serialize(header))
-        for chunk_key, chunk_value in zip(self.iter_chunk_keys(key), chunks):
-            super().store_value_raw(chunk_key, chunk_value)
-
-    def chunk_name(self, key: str, idx_chunk: int) -> str:
-        return f"{key}_{idx_chunk}"
-
-    def iter_chunk_keys(self, key: str) -> str:
-        """Return a list of chunk keys associated to the header found"""
-        header = self.deserialize(super().get_value_raw(key))
-        if self.header_valid(header):
-            for idx_chunk in range(header['chunks']):
-                yield self.chunk_name(key, idx_chunk)
-
-    def get_value_raw(self, key: str):
-        header = self.deserialize(super().get_value_raw(key))
-        if not self.header_valid(header):
-            return super().get_value_raw(key)
-        raw_values = list()
-        for chunk_key in self.iter_chunk_keys(key):
-            raw_value = super().get_value_raw(chunk_key)
-            if raw_value is None:
-                return None
-            raw_values.append(raw_value)
-        return "".join(raw_values)
-
-    def remove_stored_value(self, key: str):
-        """Removes values stored under key (header + all chunks)"""
-        for chunk_key in self.iter_chunk_keys(key):
-            super().remove_stored_value(chunk_key)
-        return super().remove_stored_value(key)
-
-    def header_valid(self, header) -> bool:
-        """True if a header is valid (is a dict, with the needed keys and the expected values"""
-        if isinstance(header, dict):
-            if header.keys() == self.make_header().keys():
-                if (header['version'] == self.version and
-                        header['class_name'] == self.__class__.__name__):
-                    return True
-        return False
-
-
-InternalStorage = InternalStorageV1
-
-if __name__ == '__main__':
-    storage = InternalStorage("Ejemplo")
-
-    for data in ("hola", 1245, dict(uno=1, dos=2), [dict(hola=1, adios=2), 3, ['holi']],
-                 "a" * 2000):
-        serial = storage.serialize(data)
-        data2 = storage.deserialize(serial)
-        print(data, data2)
+"""
+Class to permanently store data using keyring
+"""
+import base64
+import json
+import zlib
+from textwrap import wrap
+
+import keyring
+import keyring.errors
+
+
+def compress_string(input_string: str) -> str:
+    """Compresses a string into another string utf-8 encoded"""
+    # Convert the string to bytes
+    input_bytes = input_string.encode('utf-8')
+
+    # Compress the bytes using zlib
+    compressed_bytes = zlib.compress(input_bytes)
+
+    # Encode the compressed bytes in base64 to get a UTF-8 encoded string
+    compressed_string = base64.b64encode(compressed_bytes).decode('utf-8')
+
+    return compressed_string
+
+
+def decompress_string(compressed_string: str) -> str:
+    """Decompresses a utf-8 encoded string into another string utf-8 encoded"""
+
+    # Decode the UTF-8 encoded string into bytes
+    compressed_bytes = base64.b64decode(compressed_string.encode('utf-8'))
+
+    # Decompress the bytes using zlib
+    decompressed_bytes = zlib.decompress(compressed_bytes)
+
+    # Decode the decompressed bytes back to a string
+    decompressed_string = decompressed_bytes.decode('utf-8')
+
+    return decompressed_string
+
+
+class InternalStorageBase:
+    def __init__(self, app_name: str):
+        self.__app_name = app_name
+
+    @property
+    def app_name(self) -> str:
+        return self.__app_name
+
+    def serialize(self, value) -> str:
+        """Serializes and compresses an object into a string."""
+        return compress_string(json.dumps(value))
+
+    def deserialize(self, value: str):
+        """Deserializes and decompresses a string into is original value"""
+        if value is None:
+            return None
+        return json.loads(decompress_string(value))
+
+    def store_value_raw(self, key: str, value):
+        keyring.set_password(self.app_name, key, value)
+        assert value == InternalStorageBase(self.app_name).get_value_raw(key)
+
+    def get_value_raw(self, key: str):
+        return keyring.get_password(self.app_name, key)
+
+    def remove_stored_value(self, key: str):
+        try:
+            keyring.delete_password(self.app_name, key)
+        except keyring.errors.PasswordDeleteError:
+            pass
+
+
+class InternalStorageV0(InternalStorageBase):
+
+    @property
+    def version(self):
+        return 0
+
+    def make_header(self, chunks: int = 0) -> dict:
+        return dict(version=self.version, class_name=self.__class__.__name__, chunks=chunks)
+
+    def serialize(self, value) -> str:
+        """Serializes and compresses an object into a string."""
+        return compress_string(json.dumps(value))
+
+    def deserialize(self, value: str):
+        """Deserializes and decompresses a string into is original value"""
+        if value is None:
+            return None
+        try:
+            retval = json.loads(decompress_string(value))
+            return retval
+        except:
+            return None
+
+    def store_value(self, key: str, value):
+        """Stores something in keyring"""
+        store_value = self.serialize(value)
+        self.store_value_raw(key, store_value)
+
+    def get_value(self, key: str):
+        stored_value = self.get_value_raw(key)
+        if stored_value is None:
+            return
+        original = self.deserialize(value=stored_value)
+        return original
+
+
+class InternalStorageV1(InternalStorageV0):
+    chunk_size = 1000
+    chunk_header_key = "chunks"
+
+    @property
+    def version(self):
+        return 1
+
+    def chunk(self, store_value: str) -> list:
+        """Splits a string into parts of a maximum size"""
+        return wrap(store_value, self.chunk_size)
+
+    def store_value_raw(self, key: str, value):
+        chunks = self.chunk(value)
+        header = self.make_header(chunks=len(chunks))
+        super().store_value_raw(key, self.serialize(header))
+        for chunk_key, chunk_value in zip(self.iter_chunk_keys(key), chunks):
+            super().store_value_raw(chunk_key, chunk_value)
+
+    def chunk_name(self, key: str, idx_chunk: int) -> str:
+        return f"{key}_{idx_chunk}"
+
+    def iter_chunk_keys(self, key: str) -> str:
+        """Return a list of chunk keys associated to the header found"""
+        header = self.deserialize(super().get_value_raw(key))
+        if self.header_valid(header):
+            for idx_chunk in range(header['chunks']):
+                yield self.chunk_name(key, idx_chunk)
+
+    def get_value_raw(self, key: str):
+        header = self.deserialize(super().get_value_raw(key))
+        if not self.header_valid(header):
+            return super().get_value_raw(key)
+        raw_values = list()
+        for chunk_key in self.iter_chunk_keys(key):
+            raw_value = super().get_value_raw(chunk_key)
+            if raw_value is None:
+                return None
+            raw_values.append(raw_value)
+        return "".join(raw_values)
+
+    def remove_stored_value(self, key: str):
+        """Removes values stored under key (header + all chunks)"""
+        for chunk_key in self.iter_chunk_keys(key):
+            super().remove_stored_value(chunk_key)
+        return super().remove_stored_value(key)
+
+    def header_valid(self, header) -> bool:
+        """True if a header is valid (is a dict, with the needed keys and the expected values"""
+        if isinstance(header, dict):
+            if header.keys() == self.make_header().keys():
+                if (header['version'] == self.version and
+                        header['class_name'] == self.__class__.__name__):
+                    return True
+        return False
+
+
+InternalStorage = InternalStorageV1
+
+if __name__ == '__main__':
+    storage = InternalStorage("Ejemplo")
+
+    for data in ("hola", 1245, dict(uno=1, dos=2), [dict(hola=1, adios=2), 3, ['holi']],
+                 "a" * 2000):
+        serial = storage.serialize(data)
+        data2 = storage.deserialize(serial)
+        print(data, data2)
```

## ong_utils/jwt_tokens.py

 * *Ordering differences only*

```diff
@@ -1,32 +1,32 @@
-from datetime import datetime
-from ong_utils.import_utils import raise_extra_exception
-try:
-    import jwt
-except ModuleNotFoundError:
-    raise_extra_exception("jwt")
-
-
-def decode_jwt_token(access_token: str) -> dict:
-    """Decodes access token and returns it as a dict"""
-    # Code for jwt 2.x
-    if jwt.__version__ >= "2.0.0":
-        # Example of checking token expiry time to expire in the next 10 minutes
-        alg = jwt.get_unverified_header(access_token)['alg']
-        decoded_token = jwt.decode(access_token, algorithms=[alg], options={"verify_signature": False})
-    else:
-        # code for jwt 1.x
-        decoded_token = jwt.decode(access_token, verify=False)
-
-    return decoded_token
-
-
-def decode_jwt_token_expiry(jwt_token: str) -> datetime:
-    """Gets jwt token expiration from token"""
-    decoded_token = decode_jwt_token(jwt_token)
-    expiry = decoded_token['exp']
-    if isinstance(expiry, int):
-        token_expiry = datetime.fromtimestamp(expiry)
-    else:
-        token_expiry = datetime.fromisoformat(expiry)
-    return token_expiry
-
+from datetime import datetime
+from ong_utils.import_utils import raise_extra_exception
+try:
+    import jwt
+except ModuleNotFoundError:
+    raise_extra_exception("jwt")
+
+
+def decode_jwt_token(access_token: str) -> dict:
+    """Decodes access token and returns it as a dict"""
+    # Code for jwt 2.x
+    if jwt.__version__ >= "2.0.0":
+        # Example of checking token expiry time to expire in the next 10 minutes
+        alg = jwt.get_unverified_header(access_token)['alg']
+        decoded_token = jwt.decode(access_token, algorithms=[alg], options={"verify_signature": False})
+    else:
+        # code for jwt 1.x
+        decoded_token = jwt.decode(access_token, verify=False)
+
+    return decoded_token
+
+
+def decode_jwt_token_expiry(jwt_token: str) -> datetime:
+    """Gets jwt token expiration from token"""
+    decoded_token = decode_jwt_token(jwt_token)
+    expiry = decoded_token['exp']
+    if isinstance(expiry, int):
+        token_expiry = datetime.fromtimestamp(expiry)
+    else:
+        token_expiry = datetime.fromisoformat(expiry)
+    return token_expiry
+
```

## ong_utils/parse_html.py

 * *Ordering differences only*

```diff
@@ -1,27 +1,27 @@
-"""
-Functions to find simple elements in websites, without the need for BeautifulSoup
-"""
-from __future__ import annotations
-
-import re
-
-
-def find_js_variable(page_source: str, variable_name: str, sep="=") -> str | None:
-    """
-    Extracts value for a js variable or dictionary
-    Examples:
-    find_js_variable(source, 'var_name') returns some_value if content has var_name="some_value"
-    find_js_variable(source, "var_name", ":") returns some_value if content has
-    "var_name":"some_value"
-    :param page_source: text of the page, such as response.content from requests
-    :param variable_name: name of the variable to look for
-    :param sep: separator between key and value, can be either "=" (default) or ":"
-    :return: The first found value or None if no value was found
-    """
-    pattern = fr'[\"|\']?{variable_name}[\"|\']?\s?{sep}\s?[\"|\'](?P<value>.*?)[\"|\']'
-    found = re.findall(pattern, page_source)
-    if found:
-        return found[0]
-    return None
-
-
+"""
+Functions to find simple elements in websites, without the need for BeautifulSoup
+"""
+from __future__ import annotations
+
+import re
+
+
+def find_js_variable(page_source: str, variable_name: str, sep="=") -> str | None:
+    """
+    Extracts value for a js variable or dictionary
+    Examples:
+    find_js_variable(source, 'var_name') returns some_value if content has var_name="some_value"
+    find_js_variable(source, "var_name", ":") returns some_value if content has
+    "var_name":"some_value"
+    :param page_source: text of the page, such as response.content from requests
+    :param variable_name: name of the variable to look for
+    :param sep: separator between key and value, can be either "=" (default) or ":"
+    :return: The first found value or None if no value was found
+    """
+    pattern = fr'[\"|\']?{variable_name}[\"|\']?\s?{sep}\s?[\"|\'](?P<value>.*?)[\"|\']'
+    found = re.findall(pattern, page_source)
+    if found:
+        return found[0]
+    return None
+
+
```

## ong_utils/selenium_chrome.py

 * *Ordering differences only*

```diff
@@ -1,207 +1,207 @@
-"""
-Controls Chrome web browser
-Needs to download webdriver for Chrome from https://sites.google.com/chromium.org/driver/
-"""
-from __future__ import annotations
-
-import logging
-
-from ong_utils.import_utils import raise_extra_exception
-from ong_utils.utils import is_mac
-try:
-    import selenium.common.exceptions
-    from selenium import webdriver as selenium_webdriver
-    from seleniumwire import webdriver
-    from selenium.common.exceptions import TimeoutException
-    from selenium.webdriver.support.ui import WebDriverWait
-    import seleniumwire.undetected_chromedriver as uc
-except ModuleNotFoundError:
-    raise_extra_exception("selenium")
-
-
-class Chrome:
-
-    def __init__(self, driver_path: str = None, profile_path: str = None, undetected: bool = False,
-                 logger: logging.Logger = None, block_pages: str | list = None, use_selenium: bool = False):
-        """
-        Initializes a selenium Chrome web driver using seleniumwire
-        :param driver_path: path for Chrome web driver executable (defaults to current path)
-        :param profile_path: path for Chrome profile (navigate to chrome://settings). If None,
-        :param undetected: True to use undetected chrome driver under seleniumwire
-        :param logger: optional logger for informing about building driver
-        :param block_pages: a page (or list of pages) to intercept block
-        :param use_selenium: True to use standard selenium driver, False (default) to use seleniumwire
-        """
-        self.logger = logger
-        self.undetected = undetected
-        self.use_selenium = use_selenium
-        if self.use_selenium and self.undetected:
-            raise ValueError("You cannot use use_selenium=True and undetected=True at the same time")
-        self.driver_path = driver_path
-        self.profile_path = profile_path
-        self.__driver = None
-        if isinstance(block_pages, str):
-            self.__block_pages = [block_pages]
-        elif isinstance(block_pages, (list, tuple)):
-            self.__block_pages = block_pages
-        else:
-            self.__block_pages = list()
-
-    def interceptor(self, request):
-        """Blocks access to self.__block_pages"""
-        if not self.__block_pages:
-            return
-        elif any(request.url.startswith(blocked) for blocked in self.__block_pages):
-            request.abort()
-
-    def get_driver(self, headless: bool = False, reuse_last: bool = False, seleniumwire_options: dict = None):
-        """
-        Starts chrome and returns driver instance
-        :param headless: True to run in headless mode. Defaults to False
-        :param reuse_last: True to return last opened driver (if any), False (default) to create a new one
-        :param seleniumwire_options: optional dict to pass to seleniumwire
-        :return: a chrome driver
-        """
-        seleniumwire_options = seleniumwire_options or dict()
-        if reuse_last and self.__driver is not None:
-            return self.__driver
-        self.quit_driver()     # Close previous driver instances
-        if self.undetected:
-            options = uc.ChromeOptions()
-        else:
-            options = webdriver.ChromeOptions()
-        # Avoid annoying messages on chrome startup
-        options.add_argument("--disable-notifications")
-        options.add_argument("google-base-url=about:blank")
-        if self.driver_path:
-            options.binary_location = self.driver_path
-        if self.profile_path:
-            options.add_argument(f"user-data-dir={self.profile_path}")
-        if headless:
-            options.add_argument("--headless=new")  # for Chrome >= 109
-        if self.logger:
-            self.logger.debug(f"Initializing driver with options: {options}")
-        try:
-            if self.undetected:
-                self.__driver = uc.Chrome(options=options, seleniumwire_options=seleniumwire_options)
-            elif not self.use_selenium:
-                self.__driver = webdriver.Chrome(options=options, seleniumwire_options=seleniumwire_options)
-            else:
-                self.__driver = selenium_webdriver.Chrome(options=options)
-        except selenium.common.exceptions.SessionNotCreatedException as snce:
-            if is_mac():   # is macos
-                cmd = "sudo killall Google\ Chrome"
-                print(f"Could not create session. Try executing '{cmd}'")
-            raise
-        except selenium.common.exceptions.NoSuchDriverException as nsde:
-            error_msg = "Chrome not found. Download driver from 'https://chromedriver.chromium.org/downloads'"
-            if self.logger:
-                self.logger.error(error_msg)
-            else:
-                print(error_msg)
-            raise
-        if self.__block_pages:
-            self.__driver.request_interceptor = self.interceptor
-        return self.__driver
-
-    def __iterate__driver(self, url: str, timeout: int, timeout_headless: int):
-        """Opens an url twice, first headless and later interactive. If url is empty does not open it and reuses
-        current driver"""
-        for to, headless in (timeout_headless, True), (timeout, False):
-            if to:
-                if self.logger:
-                    self.logger.debug(f"Opening {headless=} {url=}")
-                if url:
-                    self.get_driver(headless=headless).get(url)
-                yield to
-
-    def wait_for_cookie(self, url: str, cookie_name: str | list, timeout: int, timeout_headless: int = 0):
-        """
-        Opens and url and waits for a certain cookie. Returns driver if cookie found or None otherwise
-        Attempts twice: first headless (if timeout_headless is greater than 0) and then interactive
-        :param url: url to open
-        :param cookie_name: cookie name (or list of cookies) for waiting for. If it is a list, stops when one of
-        them is detected
-        :param timeout_headless: seconds to wait for cookie in headless mode
-        :param timeout: seconds to wait for cookie
-        :return: driver instance or None if could not get cookie
-        """
-        if isinstance(cookie_name, str):
-            cookie_name = [cookie_name]
-        for to in self.__iterate__driver(url, timeout_headless=timeout_headless, timeout=timeout):
-            try:
-                WebDriverWait(self.__driver, timeout=to).until(lambda d: any(d.get_cookie(c) for c in cookie_name))
-                if self.logger:
-                    self.logger.info(f"Cookie {cookie_name} found in {url}")
-                return self.__driver
-            except TimeoutException:
-                pass
-        return None
-
-    def wait_for_auth_token(self, url: str | None, request_url: str, timeout: int, timeout_headless: int = 0) \
-            -> str | None:
-        """
-        Opens and url and waits for a request to a certain url, returning auth header token (returns XXX in a header
-        Authorization: Bearer XXX) and None if not found
-        Attempts twice: first headless (if timeout_headless is greater than 0) and then interactive
-        :param url: url to open. If None, current driver is used (so no headless option is available)
-        :param request_url: request url waiting for
-        :param timeout_headless: seconds to wait for cookie in headless mode
-        :param timeout: seconds to wait for cookie
-        :return: authorization token or None
-        """
-        req = self.wait_for_request(url, request_url, timeout, timeout_headless)
-        if req is not None:
-            token = req.headers['Authorization'].split(" ")[-1]
-            return token
-        return None
-
-    def wait_for_request(self, url: str | None, request_url: str, timeout: int, timeout_headless: int = 0):
-        """
-        Opens and url and waits for a request to a certain url. Returns request if found or None otherwise
-        Attempts twice: first headless (if timeout_headless is greater than 0) and then interactive
-        :param url: url to open. If None, current driver is used (so no headless option is available)
-        :param request_url: request url waiting for
-        :param timeout_headless: seconds to wait for cookie in headless mode
-        :param timeout: seconds to wait for cookie
-        :return: driver instance or None if program could not get cookie
-        """
-        for to in self.__iterate__driver(url, timeout_headless=timeout_headless, timeout=timeout):
-            try:
-                req = self.__driver.wait_for_request(request_url, timeout=to)
-                if self.logger:
-                    self.logger.info(f"Request to {request_url} found in {url}")
-                return req
-            except TimeoutException:
-                pass
-        return None
-
-    def quit_driver(self):
-        """Quits driver instance"""
-        if self.__driver is not None:
-            if self.logger:
-                self.logger.debug("Quitting driver")
-            self.__driver.quit()
-            self.__driver = None
-
-    def close_driver(self):
-        """Closes driver instance"""
-        if self.__driver is not None:
-            self.__driver.close()
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, exc_type, exc_value, traceback):
-        self.quit_driver()
-
-
-if __name__ == '__main__':
-    from ong_utils import Chrome
-    with Chrome(block_pages="https://www.marca.com") as chrome:
-        driver = chrome.get_driver()
-        driver.get("https://www.google.com")
-        driver.implicitly_wait(5)
-        driver.get("https://www.marca.com")
-        driver.implicitly_wait(5)
-
+"""
+Controls Chrome web browser
+Needs to download webdriver for Chrome from https://sites.google.com/chromium.org/driver/
+"""
+from __future__ import annotations
+
+import logging
+
+from ong_utils.import_utils import raise_extra_exception
+from ong_utils.utils import is_mac
+try:
+    import selenium.common.exceptions
+    from selenium import webdriver as selenium_webdriver
+    from seleniumwire import webdriver
+    from selenium.common.exceptions import TimeoutException
+    from selenium.webdriver.support.ui import WebDriverWait
+    import seleniumwire.undetected_chromedriver as uc
+except ModuleNotFoundError:
+    raise_extra_exception("selenium")
+
+
+class Chrome:
+
+    def __init__(self, driver_path: str = None, profile_path: str = None, undetected: bool = False,
+                 logger: logging.Logger = None, block_pages: str | list = None, use_selenium: bool = False):
+        """
+        Initializes a selenium Chrome web driver using seleniumwire
+        :param driver_path: path for Chrome web driver executable (defaults to current path)
+        :param profile_path: path for Chrome profile (navigate to chrome://settings). If None,
+        :param undetected: True to use undetected chrome driver under seleniumwire
+        :param logger: optional logger for informing about building driver
+        :param block_pages: a page (or list of pages) to intercept block
+        :param use_selenium: True to use standard selenium driver, False (default) to use seleniumwire
+        """
+        self.logger = logger
+        self.undetected = undetected
+        self.use_selenium = use_selenium
+        if self.use_selenium and self.undetected:
+            raise ValueError("You cannot use use_selenium=True and undetected=True at the same time")
+        self.driver_path = driver_path
+        self.profile_path = profile_path
+        self.__driver = None
+        if isinstance(block_pages, str):
+            self.__block_pages = [block_pages]
+        elif isinstance(block_pages, (list, tuple)):
+            self.__block_pages = block_pages
+        else:
+            self.__block_pages = list()
+
+    def interceptor(self, request):
+        """Blocks access to self.__block_pages"""
+        if not self.__block_pages:
+            return
+        elif any(request.url.startswith(blocked) for blocked in self.__block_pages):
+            request.abort()
+
+    def get_driver(self, headless: bool = False, reuse_last: bool = False, seleniumwire_options: dict = None):
+        """
+        Starts chrome and returns driver instance
+        :param headless: True to run in headless mode. Defaults to False
+        :param reuse_last: True to return last opened driver (if any), False (default) to create a new one
+        :param seleniumwire_options: optional dict to pass to seleniumwire
+        :return: a chrome driver
+        """
+        seleniumwire_options = seleniumwire_options or dict()
+        if reuse_last and self.__driver is not None:
+            return self.__driver
+        self.quit_driver()     # Close previous driver instances
+        if self.undetected:
+            options = uc.ChromeOptions()
+        else:
+            options = webdriver.ChromeOptions()
+        # Avoid annoying messages on chrome startup
+        options.add_argument("--disable-notifications")
+        options.add_argument("google-base-url=about:blank")
+        if self.driver_path:
+            options.binary_location = self.driver_path
+        if self.profile_path:
+            options.add_argument(f"user-data-dir={self.profile_path}")
+        if headless:
+            options.add_argument("--headless=new")  # for Chrome >= 109
+        if self.logger:
+            self.logger.debug(f"Initializing driver with options: {options}")
+        try:
+            if self.undetected:
+                self.__driver = uc.Chrome(options=options, seleniumwire_options=seleniumwire_options)
+            elif not self.use_selenium:
+                self.__driver = webdriver.Chrome(options=options, seleniumwire_options=seleniumwire_options)
+            else:
+                self.__driver = selenium_webdriver.Chrome(options=options)
+        except selenium.common.exceptions.SessionNotCreatedException as snce:
+            if is_mac():   # is macos
+                cmd = "sudo killall Google\ Chrome"
+                print(f"Could not create session. Try executing '{cmd}'")
+            raise
+        except selenium.common.exceptions.NoSuchDriverException as nsde:
+            error_msg = "Chrome not found. Download driver from 'https://chromedriver.chromium.org/downloads'"
+            if self.logger:
+                self.logger.error(error_msg)
+            else:
+                print(error_msg)
+            raise
+        if self.__block_pages:
+            self.__driver.request_interceptor = self.interceptor
+        return self.__driver
+
+    def __iterate__driver(self, url: str, timeout: int, timeout_headless: int):
+        """Opens an url twice, first headless and later interactive. If url is empty does not open it and reuses
+        current driver"""
+        for to, headless in (timeout_headless, True), (timeout, False):
+            if to:
+                if self.logger:
+                    self.logger.debug(f"Opening {headless=} {url=}")
+                if url:
+                    self.get_driver(headless=headless).get(url)
+                yield to
+
+    def wait_for_cookie(self, url: str, cookie_name: str | list, timeout: int, timeout_headless: int = 0):
+        """
+        Opens and url and waits for a certain cookie. Returns driver if cookie found or None otherwise
+        Attempts twice: first headless (if timeout_headless is greater than 0) and then interactive
+        :param url: url to open
+        :param cookie_name: cookie name (or list of cookies) for waiting for. If it is a list, stops when one of
+        them is detected
+        :param timeout_headless: seconds to wait for cookie in headless mode
+        :param timeout: seconds to wait for cookie
+        :return: driver instance or None if could not get cookie
+        """
+        if isinstance(cookie_name, str):
+            cookie_name = [cookie_name]
+        for to in self.__iterate__driver(url, timeout_headless=timeout_headless, timeout=timeout):
+            try:
+                WebDriverWait(self.__driver, timeout=to).until(lambda d: any(d.get_cookie(c) for c in cookie_name))
+                if self.logger:
+                    self.logger.info(f"Cookie {cookie_name} found in {url}")
+                return self.__driver
+            except TimeoutException:
+                pass
+        return None
+
+    def wait_for_auth_token(self, url: str | None, request_url: str, timeout: int, timeout_headless: int = 0) \
+            -> str | None:
+        """
+        Opens and url and waits for a request to a certain url, returning auth header token (returns XXX in a header
+        Authorization: Bearer XXX) and None if not found
+        Attempts twice: first headless (if timeout_headless is greater than 0) and then interactive
+        :param url: url to open. If None, current driver is used (so no headless option is available)
+        :param request_url: request url waiting for
+        :param timeout_headless: seconds to wait for cookie in headless mode
+        :param timeout: seconds to wait for cookie
+        :return: authorization token or None
+        """
+        req = self.wait_for_request(url, request_url, timeout, timeout_headless)
+        if req is not None:
+            token = req.headers['Authorization'].split(" ")[-1]
+            return token
+        return None
+
+    def wait_for_request(self, url: str | None, request_url: str, timeout: int, timeout_headless: int = 0):
+        """
+        Opens and url and waits for a request to a certain url. Returns request if found or None otherwise
+        Attempts twice: first headless (if timeout_headless is greater than 0) and then interactive
+        :param url: url to open. If None, current driver is used (so no headless option is available)
+        :param request_url: request url waiting for
+        :param timeout_headless: seconds to wait for cookie in headless mode
+        :param timeout: seconds to wait for cookie
+        :return: driver instance or None if program could not get cookie
+        """
+        for to in self.__iterate__driver(url, timeout_headless=timeout_headless, timeout=timeout):
+            try:
+                req = self.__driver.wait_for_request(request_url, timeout=to)
+                if self.logger:
+                    self.logger.info(f"Request to {request_url} found in {url}")
+                return req
+            except TimeoutException:
+                pass
+        return None
+
+    def quit_driver(self):
+        """Quits driver instance"""
+        if self.__driver is not None:
+            if self.logger:
+                self.logger.debug("Quitting driver")
+            self.__driver.quit()
+            self.__driver = None
+
+    def close_driver(self):
+        """Closes driver instance"""
+        if self.__driver is not None:
+            self.__driver.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        self.quit_driver()
+
+
+if __name__ == '__main__':
+    from ong_utils import Chrome
+    with Chrome(block_pages="https://www.marca.com") as chrome:
+        driver = chrome.get_driver()
+        driver.get("https://www.google.com")
+        driver.implicitly_wait(5)
+        driver.get("https://www.marca.com")
+        driver.implicitly_wait(5)
+
```

## ong_utils/sensitivity_labels.py

 * *Ordering differences only*

```diff
@@ -1,220 +1,220 @@
-"""
-Reads and writes sensitivity labels using powershell. It works on closed files.
-Adapted from https://github.com/brunomsantiago/mip_python,
-but modified to get custom properties directly from a sample office doc parsing XML (as powershell is
-too slow reading them but acceptable writing) and to use openpyxl to read sensitivity labels unless otherwise
-specified
-Sample use:
-    # If you know the sensitivity label to apply
-    sl = SensitivityLabel("XXXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX")
-    sl.apply(my_filename)
-    # If you don't know it, but what to clone an existing one (must be an Excel/Word/PowerPoint file)
-    SensitivityLabel(reference_file).apply(my_file)
-"""
-import json
-import os.path
-import subprocess
-import time
-import uuid
-import xml.etree.ElementTree as ET
-from zipfile import ZipFile
-
-import pandas as pd
-import openpyxl
-
-
-def parse_xml_protection_properties(xml_string: str, fmtid: str = "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}") -> dict:
-    """Parses a xml_string with custom properties of an openXML doc and returns a dict"""
-    root = ET.fromstring(xml_string)
-    result = {}
-    for child in root:
-        if child.get('fmtid') != fmtid:
-            continue
-        key = child.attrib.get("name")
-        value = child.findtext("{http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes}lpwstr")
-        if key.startswith("MSIP_"):     # Only capture labels related to Microsoft Information Protection
-            key = key.rsplit("_", maxsplit=1)[-1]
-            result[key] = value
-    return result
-
-
-def read_label_regex(filepath, full_result=False, **kwargs) -> str | dict | None:
-    """
-    Reads information protection labels, by parsing openXML docs. Returns the label name if full_result=False (default),
-    a dict with all information properties if full_result=True or None if no properties could be found
-    """
-    with ZipFile(filepath) as zipfile:
-        name = "docProps/custom.xml"
-        if name in zipfile.namelist():
-            with zipfile.open(name) as f:
-                content = f.read().decode()
-                parsed = parse_xml_protection_properties(content)
-                if parsed:
-                    if full_result:
-                        return parsed
-                    else:
-                        return parsed['Name']
-        return None
-
-
-def read_label_powershell(
-        filepath,
-        full_result=False,
-        powershell=r'C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe',
-        stdout_encoding='iso8859-15',
-):
-    """
-    Read sensitivity label from a Microsoft document
-    This function uses a powershell command as subprocess to read the label_id
-    of a microsoft document previously classified with the sensitivity label.
-    This label_id can be used to apply the same sensitivity label to other
-    documents.
-    It relies on the 'Get-AIPFileStatus' powershell tool. To understand it
-    better try running the command directly in powershell or look for the
-    official Microsoft documentation.
-    By default this function only returns the label_id, but if you want to see
-    the full result from 'Get-AIPFileStatus' use full_result=True.
-    """
-    # The command to call in powershell. It includes the powershell tool
-    # 'ConvertTo-Json' to make it easier to process the results in Python,
-    # specially when the file path is too long, which may break lines.
-    command = f"Get-AIPFileStatus -path '{filepath}' | ConvertTo-Json"
-    # Executing it
-    result = subprocess.Popen([powershell, command], stdout=subprocess.PIPE)
-    result_lines = result.stdout.readlines()
-    # Processing the results and saving to a dictionary
-    clean_lines = [
-        line.decode(stdout_encoding).rstrip('\r\n') for line in result_lines
-    ]
-    json_string = '\n'.join(clean_lines)
-    result_dict = json.loads(json_string)
-    # If selected, return the full results dictionary
-    if full_result:
-        return result_dict
-    # If not returns only the label_id of interest to apply to other document
-    # Per Microsoft documentation if a sensitivity label has both a
-    # 'MainLabelId' and a 'SubLabelId', only the 'SubLabelId' should be used
-    # with 'Set-AIPFileLabel' tool to set the label in a new document.
-    label_id = (
-        result_dict['SubLabelId']
-        if result_dict['SubLabelId']
-        else result_dict['MainLabelId']
-    )
-    return label_id
-
-
-def apply_label(
-        filepath,
-        label_id,
-        powershell=r'C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe',
-        stdout_encoding='iso8859-15',
-):
-    """
-    Apply sensitivity label to a Microsoft document
-    This function uses a powershell command as subprocess to apply it.
-    It relies on the 'Set-AIPFileLabel' powershell tool. To understand it
-    better try running the command directly in powershell or look for the
-    official Microsoft documentation.
-    Per Microsoft documentation if a sensitivity label has both a
-    'MainLabelId' and a 'SubLabelId', only the 'SubLabelId' should be used
-    with 'Set-AIPFileLabel' tool to set the label in a new document.
-    The function returns the elapsed time to apply the label.
-    """
-    start = time.time()
-    # The command to call in powershell
-    command = f"(Set-AIPFileLabel -path '{filepath}' -LabelId '{label_id}').Status.ToString()"
-    # Executing it
-    result = subprocess.Popen([powershell, command], stdout=subprocess.PIPE)
-    result_message = (
-        result.stdout.readline().decode(stdout_encoding).rstrip('\r\n')
-    )
-    # If the command is not successful, raises an exception and display the
-    #  message from 'Set-AIPFileLabel' tool
-    if result_message != 'Success':
-        raise Exception(result_message)
-    end = time.time()
-    return end - start
-
-
-def is_guid(text: str) -> bool:
-    """Checks if a text respond to pattern "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", which is an uuid version 4"""
-    try:
-        uuid.UUID(text, version=4)
-        return True
-    except:
-        return False
-
-
-class SensitivityLabel:
-    """
-    Class to add sensitivity labels to office files created programmatically
-    Sample uses:
-        # Apply a given label to a given file (faster)
-        SensitivityLabel("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx").apply(my_file_path)
-        # Copy label from an existing file to a given file
-        SensitivityLabel(existing_file_full_path).apply(my_file_path)
-    """
-
-    powershell = r'C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe'
-    stdout_encoding = 'iso8859-15'
-
-    def __init__(self, label_or_template: str, use_openpyxl: bool = True):
-        """
-        Creates a new SensitivityLabel instance, based on a guid or in an Excel/Word/PowerPoint file to use as a
-        template
-
-        """
-        self.excel_custom_props = None
-        self.use_openpyxl = use_openpyxl
-        if is_guid(label_or_template):
-            self.__label_id = label_or_template
-        elif self.use_openpyxl and label_or_template.upper().endswith(".XLSX"):
-            self.read_excel_custom_props(label_or_template)
-        elif any(label_or_template.upper().endswith(ext) for ext in (".XLSX", ".DOCX", ".PPTX",
-                                                                     ".PPTM", ".XLSXM", ".DOCM")):
-            self.__label_id = read_label_regex(label_or_template)
-            if not self.__label_id:
-                # Not found. Falling back to the original powershell version, which is quite slow
-                self.__label_id = read_label_powershell(label_or_template, powershell=self.powershell,
-                                                        stdout_encoding=self.stdout_encoding)
-        else:
-            raise ValueError(f"Template file {label_or_template} not understood. Use a excel/word/powerpoint file")
-
-    def read_excel_custom_props(self, file: str):
-        """Reads custom props from an Excel file using openpyxl. Raises exception if file has no sensitivity
-        label"""
-        self.excel_custom_props = list()
-        workbook_with_mip_label = openpyxl.load_workbook(file)
-        # Copying custom properties from one workbook to another
-        for prop in workbook_with_mip_label.custom_doc_props.props:
-            if prop.name.startswith("MSIP"):
-                if "SetDate" in prop.name:
-                    # prop.value = pd.Timestamp.now().isoformat(timespec="seconds") + "Z"
-                    prop.value = pd.Timestamp.now(tz="UTC").isoformat(timespec="seconds")
-                # print(f"{prop.name}: {prop.value}")
-                self.excel_custom_props.append(prop)
-        if not self.excel_custom_props:
-            raise ValueError(f"The given file {file} contains no sensitivity label information")
-
-    def apply_excel_custom_props(self, file: str):
-        """Applies custom props to an Excel file using openpyxl"""
-        if self.excel_custom_props:
-            wb = openpyxl.load_workbook(file)
-            for prop in self.excel_custom_props:
-                wb.custom_doc_props.append(prop)
-            wb.save(file)
-
-    @property
-    def label_id(self) -> str:
-        return self.__label_id
-
-    def apply(self, filename: str):
-        """Applies current SensitivityLabel to a file. File must be closed to work properly"""
-        if not os.path.isfile(filename):
-            raise OSError(f"File not found: {filename}")
-        # Use openpyxl if possible
-        if self.use_openpyxl and self.excel_custom_props and filename.upper().endswith("XLSX"):
-            self.apply_excel_custom_props(filename)
-        else:
-            apply_label(filename, self.label_id, powershell=self.powershell,
-                        stdout_encoding=self.stdout_encoding)
+"""
+Reads and writes sensitivity labels using powershell. It works on closed files.
+Adapted from https://github.com/brunomsantiago/mip_python,
+but modified to get custom properties directly from a sample office doc parsing XML (as powershell is
+too slow reading them but acceptable writing) and to use openpyxl to read sensitivity labels unless otherwise
+specified
+Sample use:
+    # If you know the sensitivity label to apply
+    sl = SensitivityLabel("XXXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX")
+    sl.apply(my_filename)
+    # If you don't know it, but what to clone an existing one (must be an Excel/Word/PowerPoint file)
+    SensitivityLabel(reference_file).apply(my_file)
+"""
+import json
+import os.path
+import subprocess
+import time
+import uuid
+import xml.etree.ElementTree as ET
+from zipfile import ZipFile
+
+import pandas as pd
+import openpyxl
+
+
+def parse_xml_protection_properties(xml_string: str, fmtid: str = "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}") -> dict:
+    """Parses a xml_string with custom properties of an openXML doc and returns a dict"""
+    root = ET.fromstring(xml_string)
+    result = {}
+    for child in root:
+        if child.get('fmtid') != fmtid:
+            continue
+        key = child.attrib.get("name")
+        value = child.findtext("{http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes}lpwstr")
+        if key.startswith("MSIP_"):     # Only capture labels related to Microsoft Information Protection
+            key = key.rsplit("_", maxsplit=1)[-1]
+            result[key] = value
+    return result
+
+
+def read_label_regex(filepath, full_result=False, **kwargs) -> str | dict | None:
+    """
+    Reads information protection labels, by parsing openXML docs. Returns the label name if full_result=False (default),
+    a dict with all information properties if full_result=True or None if no properties could be found
+    """
+    with ZipFile(filepath) as zipfile:
+        name = "docProps/custom.xml"
+        if name in zipfile.namelist():
+            with zipfile.open(name) as f:
+                content = f.read().decode()
+                parsed = parse_xml_protection_properties(content)
+                if parsed:
+                    if full_result:
+                        return parsed
+                    else:
+                        return parsed['Name']
+        return None
+
+
+def read_label_powershell(
+        filepath,
+        full_result=False,
+        powershell=r'C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe',
+        stdout_encoding='iso8859-15',
+):
+    """
+    Read sensitivity label from a Microsoft document
+    This function uses a powershell command as subprocess to read the label_id
+    of a microsoft document previously classified with the sensitivity label.
+    This label_id can be used to apply the same sensitivity label to other
+    documents.
+    It relies on the 'Get-AIPFileStatus' powershell tool. To understand it
+    better try running the command directly in powershell or look for the
+    official Microsoft documentation.
+    By default this function only returns the label_id, but if you want to see
+    the full result from 'Get-AIPFileStatus' use full_result=True.
+    """
+    # The command to call in powershell. It includes the powershell tool
+    # 'ConvertTo-Json' to make it easier to process the results in Python,
+    # specially when the file path is too long, which may break lines.
+    command = f"Get-AIPFileStatus -path '{filepath}' | ConvertTo-Json"
+    # Executing it
+    result = subprocess.Popen([powershell, command], stdout=subprocess.PIPE)
+    result_lines = result.stdout.readlines()
+    # Processing the results and saving to a dictionary
+    clean_lines = [
+        line.decode(stdout_encoding).rstrip('\r\n') for line in result_lines
+    ]
+    json_string = '\n'.join(clean_lines)
+    result_dict = json.loads(json_string)
+    # If selected, return the full results dictionary
+    if full_result:
+        return result_dict
+    # If not returns only the label_id of interest to apply to other document
+    # Per Microsoft documentation if a sensitivity label has both a
+    # 'MainLabelId' and a 'SubLabelId', only the 'SubLabelId' should be used
+    # with 'Set-AIPFileLabel' tool to set the label in a new document.
+    label_id = (
+        result_dict['SubLabelId']
+        if result_dict['SubLabelId']
+        else result_dict['MainLabelId']
+    )
+    return label_id
+
+
+def apply_label(
+        filepath,
+        label_id,
+        powershell=r'C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe',
+        stdout_encoding='iso8859-15',
+):
+    """
+    Apply sensitivity label to a Microsoft document
+    This function uses a powershell command as subprocess to apply it.
+    It relies on the 'Set-AIPFileLabel' powershell tool. To understand it
+    better try running the command directly in powershell or look for the
+    official Microsoft documentation.
+    Per Microsoft documentation if a sensitivity label has both a
+    'MainLabelId' and a 'SubLabelId', only the 'SubLabelId' should be used
+    with 'Set-AIPFileLabel' tool to set the label in a new document.
+    The function returns the elapsed time to apply the label.
+    """
+    start = time.time()
+    # The command to call in powershell
+    command = f"(Set-AIPFileLabel -path '{filepath}' -LabelId '{label_id}').Status.ToString()"
+    # Executing it
+    result = subprocess.Popen([powershell, command], stdout=subprocess.PIPE)
+    result_message = (
+        result.stdout.readline().decode(stdout_encoding).rstrip('\r\n')
+    )
+    # If the command is not successful, raises an exception and display the
+    #  message from 'Set-AIPFileLabel' tool
+    if result_message != 'Success':
+        raise Exception(result_message)
+    end = time.time()
+    return end - start
+
+
+def is_guid(text: str) -> bool:
+    """Checks if a text respond to pattern "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", which is an uuid version 4"""
+    try:
+        uuid.UUID(text, version=4)
+        return True
+    except:
+        return False
+
+
+class SensitivityLabel:
+    """
+    Class to add sensitivity labels to office files created programmatically
+    Sample uses:
+        # Apply a given label to a given file (faster)
+        SensitivityLabel("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx").apply(my_file_path)
+        # Copy label from an existing file to a given file
+        SensitivityLabel(existing_file_full_path).apply(my_file_path)
+    """
+
+    powershell = r'C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe'
+    stdout_encoding = 'iso8859-15'
+
+    def __init__(self, label_or_template: str, use_openpyxl: bool = True):
+        """
+        Creates a new SensitivityLabel instance, based on a guid or in an Excel/Word/PowerPoint file to use as a
+        template
+
+        """
+        self.excel_custom_props = None
+        self.use_openpyxl = use_openpyxl
+        if is_guid(label_or_template):
+            self.__label_id = label_or_template
+        elif self.use_openpyxl and label_or_template.upper().endswith(".XLSX"):
+            self.read_excel_custom_props(label_or_template)
+        elif any(label_or_template.upper().endswith(ext) for ext in (".XLSX", ".DOCX", ".PPTX",
+                                                                     ".PPTM", ".XLSXM", ".DOCM")):
+            self.__label_id = read_label_regex(label_or_template)
+            if not self.__label_id:
+                # Not found. Falling back to the original powershell version, which is quite slow
+                self.__label_id = read_label_powershell(label_or_template, powershell=self.powershell,
+                                                        stdout_encoding=self.stdout_encoding)
+        else:
+            raise ValueError(f"Template file {label_or_template} not understood. Use a excel/word/powerpoint file")
+
+    def read_excel_custom_props(self, file: str):
+        """Reads custom props from an Excel file using openpyxl. Raises exception if file has no sensitivity
+        label"""
+        self.excel_custom_props = list()
+        workbook_with_mip_label = openpyxl.load_workbook(file)
+        # Copying custom properties from one workbook to another
+        for prop in workbook_with_mip_label.custom_doc_props.props:
+            if prop.name.startswith("MSIP"):
+                if "SetDate" in prop.name:
+                    # prop.value = pd.Timestamp.now().isoformat(timespec="seconds") + "Z"
+                    prop.value = pd.Timestamp.now(tz="UTC").isoformat(timespec="seconds")
+                # print(f"{prop.name}: {prop.value}")
+                self.excel_custom_props.append(prop)
+        if not self.excel_custom_props:
+            raise ValueError(f"The given file {file} contains no sensitivity label information")
+
+    def apply_excel_custom_props(self, file: str):
+        """Applies custom props to an Excel file using openpyxl"""
+        if self.excel_custom_props:
+            wb = openpyxl.load_workbook(file)
+            for prop in self.excel_custom_props:
+                wb.custom_doc_props.append(prop)
+            wb.save(file)
+
+    @property
+    def label_id(self) -> str:
+        return self.__label_id
+
+    def apply(self, filename: str):
+        """Applies current SensitivityLabel to a file. File must be closed to work properly"""
+        if not os.path.isfile(filename):
+            raise OSError(f"File not found: {filename}")
+        # Use openpyxl if possible
+        if self.use_openpyxl and self.excel_custom_props and filename.upper().endswith("XLSX"):
+            self.apply_excel_custom_props(filename)
+        else:
+            apply_label(filename, self.label_id, powershell=self.powershell,
+                        stdout_encoding=self.stdout_encoding)
```

## ong_utils/timers.py

 * *Ordering differences only*

```diff
@@ -1,253 +1,253 @@
-"""
-Timer object for measuring elapsed time elapsed in some processes
-"""
-import logging
-from datetime import timedelta
-from time import time
-
-
-def format_hours_min_seconds(total_seconds: float, decimal_places=3) -> str:
-    """Format seconds in hh:mm:ss way including decimals"""
-    retval = str(timedelta(seconds=total_seconds))
-    decimal = retval.rfind(".")
-    if decimal > 0:
-        retval = retval[:decimal + decimal_places + 1]
-    return retval
-
-
-class _OngTic:
-    def __init__(self, msg, logger=None, log_level: str = logging.DEBUG, decimal_places=3):
-        """Starts timer with a msg that identifies the timer"""
-        self.start_t = time()
-        self.total_t = 0
-        self.msg = msg
-        self.is_loop = False
-        self.logger = logger
-        self.log_level = log_level
-        self.printed = False
-        self.decimal_places = decimal_places
-        self.__msg = "Elapsed time for"
-
-    def tic(self):
-        """Starts to count time"""
-        self.start_t = time()
-        self.printed = False
-
-    def toc(self, loop=False):
-        """Accumulates time from tic and  if loop=False (default) prints a message"""
-        self.total_t += time() - self.start_t
-        if not loop:
-            self.print()
-        else:
-            self.is_loop = True
-
-    def print(self, extra_msg: str = ""):
-        """Prints a message showing total elapsed time in seconds"""
-        self.printed = True
-        print_msg = f"{self.__msg} {self.msg}{extra_msg}: {self.total_t:.{self.decimal_places}f}s"
-        if self.total_t > 60:
-            # It more than 60 seconds, format time
-            print_msg += "({})".format(format_hours_min_seconds(self.total_t, decimal_places=self.decimal_places))
-        # If there is a logger, print just to the logger and don't use print
-        if self.logger:
-            self.logger.log(self.log_level, print_msg)
-        else:
-            print(print_msg)
-        self.is_loop = False  # To prevent further prints
-
-    def __del__(self):
-        """In case not printed, prints the total elapsed time """
-        if self.is_loop:
-            self.print(" (in total)")
-        else:
-            if not self.printed:
-                self.__msg = "Closing elapsed time for"
-                self.toc()
-
-
-def is_self_enabled(func, *args, **kwargs):
-    """A decorator that executes decorated member function only if self.enabled is True"""
-
-    def wrapper(*args, **kwargs):
-        self = args[0]
-        if self.enabled:
-            func(*args, **kwargs)
-
-    return wrapper
-
-
-class OngTimer:
-    def __init__(self, enabled=True, msg: str = None, logger=None, log_level=logging.DEBUG, decimal_places=3):
-        """
-        Creates a timer, but it does not start it.
-        The class can be used as a context manager, e.g.:
-
-        with OngTimer(msg="This is a test"):
-            do_something()
-
-        or declaring an instance
-
-        timer = OngTimer()
-        timer.tic("This is a test")
-        do_something()
-        timer.toc("This is a test")
-
-        :param enabled: If enabled=False (defaults to True) does nothing
-        :param msg: Needed only for using as a context manager (using the with keyword)
-        :param logger: optional logger to write messages (default value of None disables it)
-        :param log_level: optional log level for logger (defaults to DEBUG)
-        :param decimal_places: optional number of decimals of second to print (defaults to 3)
-        """
-        self.enabled = enabled
-        self.msg = msg
-        if not self.enabled:
-            return
-        self.__tics = dict()
-        self.logger = logger
-        self.log_level = log_level
-        self.decimal_places = decimal_places
-
-    @is_self_enabled
-    def tic(self, msg):
-        """Starts timer for process identified by msg"""
-        if msg not in self.__tics:
-            self.__tics[msg] = _OngTic(msg, logger=self.logger, log_level=self.log_level, decimal_places=self.decimal_places)
-        ticobj = self.__tics.get(msg)
-        ticobj.tic()
-
-    def _get_ticobj(self, msg):
-        if msg not in self.__tics:
-            raise ValueError(f"The tick '{msg}' has not been initialized")
-        return self.__tics[msg]
-
-    @is_self_enabled
-    def toc(self, msg):
-        """Stops accumulating time for process identified by msg and prints message. No more printing will be done"""
-        self._get_ticobj(msg).toc()
-
-    @is_self_enabled
-    def toc_loop(self, msg):
-        """Stops accumulating time for process identified by msg and DOES NOT prints message"""
-        self._get_ticobj(msg).toc(loop=True)
-
-    def print_loop(self, msg):
-        """Prints total elapsed time of all steps of a loop"""
-        self._get_ticobj(msg).print(" (in total)")
-
-    def elapsed(self, msg):
-        """Returns total elapsed time of a timer"""
-        return self._get_ticobj(msg).total_t
-
-    def __enter__(self):
-        """Allows using timer as a context manager. Needs that param msg has been previously defined in constructor"""
-        if self.msg is None:
-            raise ValueError("A msg arg must be passed in OngTimer constructor")
-        self.tic(self.msg)
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        """Allows using timer as a context manager"""
-        self.toc(self.msg)
-
-    def context_manager(self, msg):
-        """Allows an existing instance to be used as a context manager"""
-        self.msg = msg
-        return self
-
-    @property
-    def msgs(self):
-        """Gets list of tics of all opened msg. Useful for iterating over all and printing"""
-        return self.__tics.keys()
-
-
-if __name__ == '__main__':
-    from time import sleep
-    # Example for formatting time for really long times
-    print(format_hours_min_seconds(10))
-    print(format_hours_min_seconds(100))
-    print(format_hours_min_seconds(1000))
-    print(format_hours_min_seconds(10000.323239392331))
-
-    #########################################################################################################
-    # Standard use (defining an instance and using tic, toc and toc_loop methods, changing decimal places)
-    #########################################################################################################
-    tic = OngTimer()  # if used OngTimer(False), all prints would be disabled
-    more_precise_tic = OngTimer(decimal_places=6)     # Use decimals parameter to increase decimals (defaults to 3)
-
-    tic.tic("Starting")
-    more_precise_tic.tic("Starting (6 decimals)")
-    for i in range(10):
-        tic.tic("Without loop")
-        sleep(0.15)
-        tic.toc("Without loop")
-        tic.tic("Loop")
-        sleep(0.1)
-        if i != 5:
-            tic.toc_loop("Loop")  # Will print elapsed time up to iter #5
-        else:
-            tic.toc("Loop")  # Will print in this case
-    sleep(1)
-    tic.print_loop("Loop")  # Forces print In any case it would be printed in destruction of tic instance
-    tic.toc("Starting")  # Will print total time of the whole loop
-    more_precise_tic.toc("Starting (6 decimals)")  # Will print total time with 6 decimals
-
-    ########################################################################################
-    # Using toc/toc_loop with a non previously defined msg will raise a ValueError Exception
-    ########################################################################################
-    try:
-        tic.toc("This msg has not been defined in a previous tick so ValueError Exception will be risen")
-    except ValueError as ve:
-        print(ve)
-
-    #############################################################
-    # Use as a context manager. Won't work accumulating in a loop
-    #############################################################
-    with OngTimer(msg="Testing sleep"):
-        print("hello context manager")
-        sleep(0.27)
-    with OngTimer().context_manager("Testing sleep"):  # Exactly same as above
-        print("hello context manager")
-        sleep(0.27)
-    # Use context manager (but testing that it can be disabled)
-    with OngTimer(msg="Testing sleep disabled", enabled=False):
-        print("hello disabled context manager")
-        sleep(0.22)
-    # use global timer as context manager
-    existing_instance = OngTimer()
-    with existing_instance.context_manager("Example using an existing context manager instance"):
-        sleep(.19)
-
-    # Optionally: write also tick using a logger
-    import logging
-    logging.basicConfig(level=logging.DEBUG)
-    with OngTimer(msg="Using a logger", logger=logging, log_level=logging.DEBUG):
-        sleep(0.2)
-
-    ##############################################################
-    # When a timer is deleted, any tic without toc will be printed
-    ##############################################################
-    forgoten_toc_timer = OngTimer()             # This timer will have tics without corresponding toc
-    standard_timer = OngTimer(decimal_places=6)
-    forgoten_toc_timer_disabled = OngTimer(enabled=False)
-    forgoten_toc_timer.tic("forgotten timer1")
-    forgoten_toc_timer.tic("forgotten timer2")
-    standard_timer.tic("unforgotten timer")
-    forgoten_toc_timer_disabled.tic("forgotten disabled timer")
-    sleep(0.1)
-    standard_timer.toc("unforgotten timer")
-    del forgoten_toc_timer   # Will print elapsed time, as are pending tocs
-    del standard_timer   # Prints nothing (as there is not pending tic)
-    del forgoten_toc_timer_disabled     # Prints nothing (is disabled)
-
-    #####################################################
-    # Use .msgs property to iterate over all named timers
-    #####################################################
-    loop_timer = OngTimer()
-    for _ in range(10):
-        loop_timer.tic("hello1")
-        loop_timer.tic("hello2")
-        sleep(0.1)
-        loop_timer.toc_loop("hello1")
-        loop_timer.toc_loop("hello2")
-    for msg in loop_timer.msgs:
-        loop_timer.print_loop(msg)
+"""
+Timer object for measuring elapsed time elapsed in some processes
+"""
+import logging
+from datetime import timedelta
+from time import time
+
+
+def format_hours_min_seconds(total_seconds: float, decimal_places=3) -> str:
+    """Format seconds in hh:mm:ss way including decimals"""
+    retval = str(timedelta(seconds=total_seconds))
+    decimal = retval.rfind(".")
+    if decimal > 0:
+        retval = retval[:decimal + decimal_places + 1]
+    return retval
+
+
+class _OngTic:
+    def __init__(self, msg, logger=None, log_level: str = logging.DEBUG, decimal_places=3):
+        """Starts timer with a msg that identifies the timer"""
+        self.start_t = time()
+        self.total_t = 0
+        self.msg = msg
+        self.is_loop = False
+        self.logger = logger
+        self.log_level = log_level
+        self.printed = False
+        self.decimal_places = decimal_places
+        self.__msg = "Elapsed time for"
+
+    def tic(self):
+        """Starts to count time"""
+        self.start_t = time()
+        self.printed = False
+
+    def toc(self, loop=False):
+        """Accumulates time from tic and  if loop=False (default) prints a message"""
+        self.total_t += time() - self.start_t
+        if not loop:
+            self.print()
+        else:
+            self.is_loop = True
+
+    def print(self, extra_msg: str = ""):
+        """Prints a message showing total elapsed time in seconds"""
+        self.printed = True
+        print_msg = f"{self.__msg} {self.msg}{extra_msg}: {self.total_t:.{self.decimal_places}f}s"
+        if self.total_t > 60:
+            # It more than 60 seconds, format time
+            print_msg += "({})".format(format_hours_min_seconds(self.total_t, decimal_places=self.decimal_places))
+        # If there is a logger, print just to the logger and don't use print
+        if self.logger:
+            self.logger.log(self.log_level, print_msg)
+        else:
+            print(print_msg)
+        self.is_loop = False  # To prevent further prints
+
+    def __del__(self):
+        """In case not printed, prints the total elapsed time """
+        if self.is_loop:
+            self.print(" (in total)")
+        else:
+            if not self.printed:
+                self.__msg = "Closing elapsed time for"
+                self.toc()
+
+
+def is_self_enabled(func, *args, **kwargs):
+    """A decorator that executes decorated member function only if self.enabled is True"""
+
+    def wrapper(*args, **kwargs):
+        self = args[0]
+        if self.enabled:
+            func(*args, **kwargs)
+
+    return wrapper
+
+
+class OngTimer:
+    def __init__(self, enabled=True, msg: str = None, logger=None, log_level=logging.DEBUG, decimal_places=3):
+        """
+        Creates a timer, but it does not start it.
+        The class can be used as a context manager, e.g.:
+
+        with OngTimer(msg="This is a test"):
+            do_something()
+
+        or declaring an instance
+
+        timer = OngTimer()
+        timer.tic("This is a test")
+        do_something()
+        timer.toc("This is a test")
+
+        :param enabled: If enabled=False (defaults to True) does nothing
+        :param msg: Needed only for using as a context manager (using the with keyword)
+        :param logger: optional logger to write messages (default value of None disables it)
+        :param log_level: optional log level for logger (defaults to DEBUG)
+        :param decimal_places: optional number of decimals of second to print (defaults to 3)
+        """
+        self.enabled = enabled
+        self.msg = msg
+        if not self.enabled:
+            return
+        self.__tics = dict()
+        self.logger = logger
+        self.log_level = log_level
+        self.decimal_places = decimal_places
+
+    @is_self_enabled
+    def tic(self, msg):
+        """Starts timer for process identified by msg"""
+        if msg not in self.__tics:
+            self.__tics[msg] = _OngTic(msg, logger=self.logger, log_level=self.log_level, decimal_places=self.decimal_places)
+        ticobj = self.__tics.get(msg)
+        ticobj.tic()
+
+    def _get_ticobj(self, msg):
+        if msg not in self.__tics:
+            raise ValueError(f"The tick '{msg}' has not been initialized")
+        return self.__tics[msg]
+
+    @is_self_enabled
+    def toc(self, msg):
+        """Stops accumulating time for process identified by msg and prints message. No more printing will be done"""
+        self._get_ticobj(msg).toc()
+
+    @is_self_enabled
+    def toc_loop(self, msg):
+        """Stops accumulating time for process identified by msg and DOES NOT prints message"""
+        self._get_ticobj(msg).toc(loop=True)
+
+    def print_loop(self, msg):
+        """Prints total elapsed time of all steps of a loop"""
+        self._get_ticobj(msg).print(" (in total)")
+
+    def elapsed(self, msg):
+        """Returns total elapsed time of a timer"""
+        return self._get_ticobj(msg).total_t
+
+    def __enter__(self):
+        """Allows using timer as a context manager. Needs that param msg has been previously defined in constructor"""
+        if self.msg is None:
+            raise ValueError("A msg arg must be passed in OngTimer constructor")
+        self.tic(self.msg)
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        """Allows using timer as a context manager"""
+        self.toc(self.msg)
+
+    def context_manager(self, msg):
+        """Allows an existing instance to be used as a context manager"""
+        self.msg = msg
+        return self
+
+    @property
+    def msgs(self):
+        """Gets list of tics of all opened msg. Useful for iterating over all and printing"""
+        return self.__tics.keys()
+
+
+if __name__ == '__main__':
+    from time import sleep
+    # Example for formatting time for really long times
+    print(format_hours_min_seconds(10))
+    print(format_hours_min_seconds(100))
+    print(format_hours_min_seconds(1000))
+    print(format_hours_min_seconds(10000.323239392331))
+
+    #########################################################################################################
+    # Standard use (defining an instance and using tic, toc and toc_loop methods, changing decimal places)
+    #########################################################################################################
+    tic = OngTimer()  # if used OngTimer(False), all prints would be disabled
+    more_precise_tic = OngTimer(decimal_places=6)     # Use decimals parameter to increase decimals (defaults to 3)
+
+    tic.tic("Starting")
+    more_precise_tic.tic("Starting (6 decimals)")
+    for i in range(10):
+        tic.tic("Without loop")
+        sleep(0.15)
+        tic.toc("Without loop")
+        tic.tic("Loop")
+        sleep(0.1)
+        if i != 5:
+            tic.toc_loop("Loop")  # Will print elapsed time up to iter #5
+        else:
+            tic.toc("Loop")  # Will print in this case
+    sleep(1)
+    tic.print_loop("Loop")  # Forces print In any case it would be printed in destruction of tic instance
+    tic.toc("Starting")  # Will print total time of the whole loop
+    more_precise_tic.toc("Starting (6 decimals)")  # Will print total time with 6 decimals
+
+    ########################################################################################
+    # Using toc/toc_loop with a non previously defined msg will raise a ValueError Exception
+    ########################################################################################
+    try:
+        tic.toc("This msg has not been defined in a previous tick so ValueError Exception will be risen")
+    except ValueError as ve:
+        print(ve)
+
+    #############################################################
+    # Use as a context manager. Won't work accumulating in a loop
+    #############################################################
+    with OngTimer(msg="Testing sleep"):
+        print("hello context manager")
+        sleep(0.27)
+    with OngTimer().context_manager("Testing sleep"):  # Exactly same as above
+        print("hello context manager")
+        sleep(0.27)
+    # Use context manager (but testing that it can be disabled)
+    with OngTimer(msg="Testing sleep disabled", enabled=False):
+        print("hello disabled context manager")
+        sleep(0.22)
+    # use global timer as context manager
+    existing_instance = OngTimer()
+    with existing_instance.context_manager("Example using an existing context manager instance"):
+        sleep(.19)
+
+    # Optionally: write also tick using a logger
+    import logging
+    logging.basicConfig(level=logging.DEBUG)
+    with OngTimer(msg="Using a logger", logger=logging, log_level=logging.DEBUG):
+        sleep(0.2)
+
+    ##############################################################
+    # When a timer is deleted, any tic without toc will be printed
+    ##############################################################
+    forgoten_toc_timer = OngTimer()             # This timer will have tics without corresponding toc
+    standard_timer = OngTimer(decimal_places=6)
+    forgoten_toc_timer_disabled = OngTimer(enabled=False)
+    forgoten_toc_timer.tic("forgotten timer1")
+    forgoten_toc_timer.tic("forgotten timer2")
+    standard_timer.tic("unforgotten timer")
+    forgoten_toc_timer_disabled.tic("forgotten disabled timer")
+    sleep(0.1)
+    standard_timer.toc("unforgotten timer")
+    del forgoten_toc_timer   # Will print elapsed time, as are pending tocs
+    del standard_timer   # Prints nothing (as there is not pending tic)
+    del forgoten_toc_timer_disabled     # Prints nothing (is disabled)
+
+    #####################################################
+    # Use .msgs property to iterate over all named timers
+    #####################################################
+    loop_timer = OngTimer()
+    for _ in range(10):
+        loop_timer.tic("hello1")
+        loop_timer.tic("hello2")
+        sleep(0.1)
+        loop_timer.toc_loop("hello1")
+        loop_timer.toc_loop("hello2")
+    for msg in loop_timer.msgs:
+        loop_timer.print_loop(msg)
```

## ong_utils/ui.py

```diff
@@ -1,285 +1,340 @@
-"""
-Simple ui screens
-"""
-from __future__ import annotations
-
-import abc
-import gettext
-import locale
-import os.path
-from dataclasses import dataclass
-from tkinter import filedialog
-from tkinter import ttk, messagebox, END
-from tkinter.simpledialog import Dialog
-from typing import List, Callable
-from functools import partial
-
-from ong_utils import is_windows
-# from ong_utils.credentials import verify_credentials
-from ong_utils.utils import get_current_user, get_current_domain
-
-
-def fix_windows_gui_scale():
-    """Fixes "strange" look of tk in windows due to bad scaling,
-    based on https://stackoverflow.com/a/43046744"""
-    if is_windows():
-        from ctypes import windll
-        windll.shcore.SetProcessDpiAwareness(1)
-
-
-fix_windows_gui_scale()
-
-# Configure localization
-locale.setlocale(locale.LC_ALL, "")  # Use the system's default locale
-lang = locale.getlocale()[0]
-translation = gettext.translation("messages", localedir="locales", languages=[lang], fallback=True)
-translation.install()
-
-# Define _() as the translation function
-_ = translation.gettext
-
-_STATE_ENABLED = "normal"
-_STATE_DISABLED = "disabled"  # 'readonly' could also work
-
-
-class _UiBaseButton:
-    @abc.abstractmethod
-    def button_name(self) -> str | None:
-        return None
-
-    @abc.abstractmethod
-    def button_command(self, entry: ttk.Entry):
-        """What to do when button is pressed. Receives an entry which is the one that has the attached info"""
-        pass
-
-    def make_button(self, master, entry: ttk.Entry) -> ttk.Button:
-        return ttk.Button(master, text=self.button_name(), command=self.button_command(entry=entry))
-
-    @abc.abstractmethod
-    def validate(self, value: str) -> bool:
-        """Validates the button"""
-        return True
-
-
-class UiFolderButton(_UiBaseButton):
-    def button_name(self) -> str | None:
-        return "..."
-
-    def button_command(self, entry: ttk.Entry):
-        folder_selected = filedialog.askdirectory(initialdir=entry.get(), title="Selecciona una carpeta")
-        if folder_selected:
-            entry.delete(0, END)
-            entry.insert(0, folder_selected)
-
-    def validate(self, value: str) -> bool:
-        return os.path.isdir(value)
-
-
-class UiFileButton(_UiBaseButton):
-    def button_name(self) -> str | None:
-        return "..."
-
-    def button_command(self, entry: ttk.Entry):
-        file_selected = filedialog.askopenfilename(initialdir=entry.get(), title="Selecciona un fichero")
-        if file_selected:
-            entry.delete(0, END)
-            entry.insert(0, file_selected)
-
-    def validate(self, value: str) -> bool:
-        return os.path.isfile(value)
-
-
-class UiPasswordButton(_UiBaseButton):
-    view = True
-    show = None
-
-    def button_name(self) -> str | None:
-        return "Ver"
-
-    def button_command(self, entry: ttk.Entry):
-        if self.view:
-            self.show = entry.cget("show")
-            entry.configure(show="")
-        else:
-            entry.configure(show=self.show)
-        self.view = not self.view
-
-    def validate(self, value: str) -> bool:
-        return True
-
-
-@dataclass
-class UiField:
-    name: str  # Name of the field (for internal code)
-    label: str  # Label of the field (that will be shown in the window and translated)
-    default_value: str = ""  # Default value
-    show: str = None  # For passwords use "*"
-    # Validation function, that will receive all field names of the window, so need **kwargs
-    validation_func: Callable[[dict], bool] = None
-    # state of the tk.Entry. True is editable, false will make not editable
-    editable: bool = True
-    # Width parameter of an Entry field, make it longer if needed
-    width: int = 20
-    # Include an additional Button
-    button: _UiBaseButton = None
-
-    @property
-    def state(self):
-        """Turns editable into the string state parameter of the tk.Entry"""
-        return _STATE_ENABLED if self.editable else _STATE_DISABLED
-
-
-class _UiFieldButton(UiField):
-    @abc.abstractmethod
-    def button_command(self, entry: ttk.Entry):
-        print("Executing parent command")
-        pass
-
-    @abc.abstractmethod
-    def button_name(self) -> str:
-        pass
-
-
-class _SimpleDialog(Dialog):
-    def __init__(self, title: str, description: str, field_list: List[UiField], parent=None):
-        self.description = description
-        self.field_list = field_list
-        self.__values = dict()
-        self.ui_fields = dict()
-        self.validated = False
-        Dialog.__init__(self, parent, title)
-
-    def body(self, master):
-        """Creates ui elements for the body, returns the one that will take focus"""
-        description_label = ttk.Label(master, text=self.description)
-        description_label.grid(row=0, column=0, pady=5, padx=10, columnspan=2)
-        focus = description_label
-        for row, field in enumerate(self.field_list):
-            # Label and entry for the username
-            label = ttk.Label(master, text=_(field.label))
-            label.grid(row=row + 1, column=0, pady=5, padx=10, sticky="w")
-            entry = ttk.Entry(master, show=field.show, width=field.width)
-            entry.insert(0, field.default_value)
-            if not field.editable:
-                # entry.configure(state='readonly')
-                entry.configure(state=_STATE_DISABLED)
-            entry.grid(row=row + 1, column=1, pady=5, padx=(10, 10), sticky="w")
-            if field.button:
-                btn = ttk.Button(master, text=field.button.button_name(),
-                                 command=partial(field.button.button_command, entry=entry))
-                btn.grid(row=row + 1, column=1, pady=5, padx=(0, 10), sticky="e")
-            self.ui_fields[field.name] = entry
-            focus = entry
-        return focus
-
-    def validate(self):
-        """Validates form, returning 1 if ok and 0 otherwise. Shows error messages if it does not work"""
-        try:
-            self.update_values()
-            for field in self.field_list:
-                if ((field.validation_func and not field.validation_func(**self.__values)) or
-                        field.button and not field.button.validate(self.__values[field.name])):
-                    messagebox.showerror(_("Error"), _("Invalid field") + ": " + _(field.label))
-                    return 0
-            self.validated = True
-            return 1
-        except Exception as e:
-            print(e)
-            return 0
-
-    def update_values(self):
-        for field in self.field_list:
-            self.__values[field.name] = self.ui_fields.get(field.name).get() if field.name in self.ui_fields else None
-
-    @property
-    def return_values(self) -> dict:
-        """Returns a dict of field names and values, or an empty dict if validation failed"""
-        if self.validated:
-            return self.__values
-        else:
-            return dict()
-
-
-def simple_dialog(title: str, description: str, field_list: List[UiField], parent=None) -> dict:
-    """Shows a dialog with the given title, and description and fields and returns a dict with
-    the values.
-    Example:
-        from ong_utils.credentials import verify_credentials
-        field_list = [UiField(name="domain", label="Domain", default_value="homecomputer"),
-                  UiField(name="username", label="User", default_value="homeuser"),
-                  UiField(name="password", label="Password", default_value="",
-                          show="*",
-                          validation_func=verify_credentials),
-                  UiField(name="server", label="Servidor")]
-        result = dialog(title, description, field_list)
-    """
-    win = _SimpleDialog(title, description, field_list, parent=parent)
-    return win.return_values
-
-
-def user_domain_password_dialog(title: str, description: str, validate_password: Callable[[dict], bool] = None,
-                                parent=None, default_values: dict = None) -> dict:
-    """
-    A dialog windows that asks for username, domain and password, and optionally validates it.
-    :param title: title of the dialog window
-    :param description: a label that will be shown before the entry fields to show help for the user
-    :param validate_password: an optional function that will receive "username", "domain" and "password" named args
-    and returns bool. You can use ong_utils.credentials.verify_credentials to validate against logged-in user
-    :param parent: an optional main window to show modal dialog
-    :param default_values: a dict of optional default values for the form. The keys could be "username", "domain" and
-    "password". If username or domain are not informed, current logged-in username and domain are used
-    :return: a dict with the following keys: username, domain and password if validation was ok
-    or an empty dict if user cancelled
-    """
-    default_values = default_values or dict()
-    field_list = [UiField(name="domain", label="Domain",
-                          default_value=default_values.get("domain", get_current_domain()),
-                          editable=False),
-                  UiField(name="username", label="User",
-                          default_value=default_values.get("username", get_current_user()),
-                          editable=False),
-                  UiField(name="password", label="Password",
-                          default_value=default_values.get("password", ""),
-                          show="*",
-                          validation_func=validate_password)]
-    return simple_dialog(title, description, field_list, parent=parent)
-
-
-if __name__ == '__main__':
-    # from ong_utils import simple_dialog
-    # from ong_utils.ui import UiField, UiFileButton, UiPasswordButton, UiFolderButton
-
-    field_list = [UiField(name="domain",  # Key of the dict in the return dictionary and for validation functions
-                          label="Domain",  # Name to the shown for the user
-                          default_value="fake domain",  # Default value to be used
-                          editable=False  # Not editable
-                          ),
-                  UiField(name="username", label="User", default_value="fake user",
-                          editable=False,
-                          ),
-                  UiField(name="password", label="Password", default_value="",
-                          show="*",  # Hides password by replacing with *
-                          # validation_func=verify_credentials
-                          # The validation function receives values of all fields, so should accept extra **kwargs
-                          button=UiPasswordButton()
-                          ),
-                  UiField(name="server", label="Server",
-                          width=40),
-                  # Will ask for a folder and validate that exists
-                  UiField(name="folder", label="Folder", button=UiFolderButton(), width=80),
-                  # Will ask for a file and validate that exists
-                  UiField(name="file", label="File", button=UiFileButton(), width=90),
-                  ]
-    # Call the function to open the login window with custom options
-    res = simple_dialog(title="Sample form", description="Show descriptive message for the user",
-                        field_list=field_list)
-    print(res)
-
-    res = user_domain_password_dialog("Log in form", "Please enter your credentials",
-                                      validate_password=None,
-                                      default_values=dict(username="fake user", domain="fake domain",
-                                                          password="fake password"))
-    print(res)
-    # print(tkinter.simpledialog.askstring(title="hola", prompt="di algo",
-    #                                      initialvalue="respuesta de ejemplo"))
-    # print(tkinter.messagebox.askyesno(title="Hola", message="Dime si o no"))
+"""
+Simple ui screens
+"""
+from __future__ import annotations
+
+import abc
+import gettext
+import locale
+import os.path
+from dataclasses import dataclass
+from tkinter import filedialog
+from tkinter import ttk, messagebox, END
+from tkinter.simpledialog import Dialog
+from typing import List, Callable
+from functools import partial
+
+from ong_utils import is_windows
+# from ong_utils.credentials import verify_credentials
+from ong_utils.utils import get_current_user, get_current_domain
+
+
+def fix_windows_gui_scale():
+    """Fixes "strange" look of tk in windows due to bad scaling,
+    based on https://stackoverflow.com/a/43046744"""
+    if is_windows():
+        from ctypes import windll
+        windll.shcore.SetProcessDpiAwareness(1)
+
+
+fix_windows_gui_scale()
+
+# Configure localization
+locale.setlocale(locale.LC_ALL, "")  # Use the system's default locale
+lang = locale.getlocale()[0]
+translation = gettext.translation("messages", localedir="locales", languages=[lang], fallback=True)
+translation.install()
+
+# Define _() as the translation function
+_ = translation.gettext
+
+_STATE_ENABLED = "normal"
+_STATE_DISABLED = "disabled"  # 'readonly' could also work
+
+
+class _UiBaseButton:
+    """Base class for buttons added to a simple dialog (for selecting files or folders, showing passwords...)"""
+    @abc.abstractmethod
+    def button_name(self) -> str | None:
+        return None
+
+    @abc.abstractmethod
+    def button_command(self, entry: ttk.Entry):
+        """What to do when button is pressed. Receives an entry which is the one that has the attached info"""
+        pass
+
+    def make_button(self, master, entry: ttk.Entry) -> ttk.Button:
+        return ttk.Button(master, text=self.button_name(), command=self.button_command(entry=entry))
+
+    @abc.abstractmethod
+    def validate(self, value: str) -> bool:
+        """Validates the button"""
+        return True
+
+
+class UiFolderButton(_UiBaseButton):
+    """Defines a button for browsing for a folder and update entry field accordingly. It also validates
+    that the contents of the field is a valid existing folder"""
+    def button_name(self) -> str | None:
+        return "..."
+
+    def button_command(self, entry: ttk.Entry):
+        folder_selected = filedialog.askdirectory(initialdir=entry.get(),
+                                                  title=_("Select folder"))
+        if folder_selected:
+            entry.delete(0, END)
+            entry.insert(0, folder_selected)
+
+    def validate(self, value: str) -> bool:
+        return os.path.isdir(value)
+
+
+class UiFileButton(_UiBaseButton):
+    """Defines a button for browsing for a file and update entry field accordingly. It also validates
+    that the contents of the field is a valid existing file"""
+
+    def button_name(self) -> str | None:
+        return "..."
+
+    def button_command(self, entry: ttk.Entry):
+        file_selected = filedialog.askopenfilename(initialdir=entry.get(),
+                                                   title=_("Select file"))
+        if file_selected:
+            entry.delete(0, END)
+            entry.insert(0, file_selected)
+
+    def validate(self, value: str) -> bool:
+        return os.path.isfile(value)
+
+
+class UiPasswordButton(_UiBaseButton):
+    """Defines a button for showing/hiding passwords. Does not add additional validations"""
+
+    view = True
+    show = None
+
+    def button_name(self) -> str | None:
+        return "Ver"
+
+    def button_command(self, entry: ttk.Entry):
+        if self.view:
+            self.show = entry.cget("show")
+            entry.configure(show="")
+        else:
+            entry.configure(show=self.show)
+        self.view = not self.view
+
+    def validate(self, value: str) -> bool:
+        return True
+
+
+@dataclass
+class UiField:
+    name: str  # Name of the field (for internal code)
+    label: str  # Label of the field (that will be shown in the window and translated)
+    default_value: str = ""  # Default value
+    show: str = None  # For passwords use "*"
+    # Validation function, that will receive all field names of the window, so need **kwargs
+    validation_func: Callable[[dict], bool] = None
+    # state of the tk.Entry. True is editable, false will make not editable
+    editable: bool = True
+    # Width parameter of an Entry field, make it longer if needed
+    width: int = 20
+    # Include an additional Button
+    button: _UiBaseButton = None
+    # True to avoid validation when field is empty (defaults to False)
+    allow_empy: bool = False
+    # Optional list of valid values. If supplied, a ComboBox is used instead of an Entry Field
+    valid_values: List[str] = None
+
+    @property
+    def state(self):
+        """Turns editable into the string state parameter of the tk.Entry"""
+        return _STATE_ENABLED if self.editable else _STATE_DISABLED
+
+
+class _UiFieldButton(UiField):
+    @abc.abstractmethod
+    def button_command(self, entry: ttk.Entry):
+        print("Executing parent command")
+        pass
+
+    @abc.abstractmethod
+    def button_name(self) -> str:
+        pass
+
+
+class _SimpleDialog(Dialog):
+    def __init__(self, title: str, description: str, field_list: List[UiField], parent=None):
+        self.description = description
+        self.field_list = field_list
+        self.__values = dict()
+        self.ui_fields = dict()
+        self.validated = False
+        Dialog.__init__(self, parent, title)
+
+    def body(self, master):
+        """Creates ui elements for the body, returns the one that will take focus"""
+        description_label = ttk.Label(master, text=self.description)
+        description_label.grid(row=0, column=0, pady=5, padx=10, columnspan=2)
+        focus = description_label
+        for row, field in enumerate(self.field_list):
+            # Label and entry for the username
+            label = ttk.Label(master, text=_(field.label))
+            label.grid(row=row + 1, column=0, pady=5, padx=10, sticky="w")
+            if field.valid_values:
+                entry = ttk.Combobox(master, show=field.show, width=field.width,
+                                     values=field.valid_values)
+                if field.default_value in field.valid_values:
+                    entry.set(field.default_value)
+            else:
+                entry = ttk.Entry(master, show=field.show, width=field.width)
+                entry.insert(0, field.default_value)
+            if not field.editable:
+                # entry.configure(state='readonly')
+                entry.configure(state=_STATE_DISABLED)
+            entry.grid(row=row + 1, column=1, pady=5, padx=(10, 10), sticky="w")
+            if field.button:
+                btn = ttk.Button(master, text=field.button.button_name(),
+                                 command=partial(field.button.button_command, entry=entry))
+                btn.grid(row=row + 1, column=1, pady=5, padx=(0, 10), sticky="e")
+            self.ui_fields[field.name] = entry
+            focus = entry
+        return focus
+
+    def validate(self):
+        """Validates form, returning 1 if ok and 0 otherwise. Shows error messages if it does not work"""
+        try:
+            self.update_values()
+            for field in self.field_list:
+                # Do not validate if field is empty and allow_empty = True
+                if field.allow_empy and not self.__values[field.name]:
+                    continue
+                if ((field.validation_func and not field.validation_func(**self.__values)) or
+                        field.button and not field.button.validate(self.__values[field.name])):
+                    messagebox.showerror(_("Error"), _("Invalid field") + ": " + _(field.label))
+                    return 0
+            self.validated = True
+            return 1
+        except Exception as e:
+            print(e)
+            return 0
+
+    def update_values(self):
+        for field in self.field_list:
+            self.__values[field.name] = self.ui_fields.get(field.name).get() if field.name in self.ui_fields else None
+
+    @property
+    def return_values(self) -> dict:
+        """Returns a dict of field names and values, or an empty dict if validation failed"""
+        if self.validated:
+            return self.__values
+        else:
+            return dict()
+
+
+def simple_dialog(title: str, description: str, field_list: List[UiField], parent=None) -> dict:
+    """Shows a dialog with the given title, and description and fields and returns a dict with
+    the values.
+    Example:
+        from ong_utils.credentials import verify_credentials
+        field_list = [UiField(name="domain", label="Domain", default_value="homecomputer"),
+                  UiField(name="username", label="User", default_value="homeuser"),
+                  UiField(name="password", label="Password", default_value="",
+                          show="*",
+                          validation_func=verify_credentials),
+                  UiField(name="server", label="Servidor")]
+        result = dialog(title, description, field_list)
+
+    Use the UiPasswordButton, UiFolderButton or UiFileButton as the button parameter to add a button
+    to show password or to select and validate files or folders, such as here:
+         field_list = [UiField(name="domain",  # Key of the dict in the return dictionary and for validation functions
+                          label="Domain",  # Name to the shown for the user
+                          default_value="fake domain",  # Default value to be used
+                          editable=False  # Not editable
+                          ),
+                  UiField(name="username", label="User", default_value="fake user",
+                          editable=False,
+                          ),
+                  UiField(name="password", label="Password", default_value="",
+                          show="*",  # Hides password by replacing with *
+                          # validation_func=verify_credentials
+                          # The validation function receives values of all fields, so should accept extra **kwargs
+                          button=UiPasswordButton()
+                          ),
+                  UiField(name="server", label="Server",
+                          width=40),
+                  # Will ask for a folder and validate that exists
+                  UiField(name="folder", label="Folder", button=UiFolderButton(), width=80),
+                  # Will ask for a file and validate that exists
+                  UiField(name="file", label="File", button=UiFileButton(), width=90),
+                  ]
+    """
+    win = _SimpleDialog(title, description, field_list, parent=parent)
+    return win.return_values
+
+
+def user_domain_password_dialog(title: str, description: str, validate_password: Callable[[dict], bool] = None,
+                                parent=None, default_values: dict = None) -> dict:
+    """
+    A dialog windows that asks for username, domain and password, and optionally validates it.
+    :param title: title of the dialog window
+    :param description: a label that will be shown before the entry fields to show help for the user
+    :param validate_password: an optional function that will receive "username", "domain" and "password" named args
+    and returns bool. You can use ong_utils.credentials.verify_credentials to validate against logged-in user
+    :param parent: an optional main window to show modal dialog
+    :param default_values: a dict of optional default values for the form. The keys could be "username", "domain" and
+    "password". If username or domain are not informed, current logged-in username and domain are used
+    :return: a dict with the following keys: username, domain and password if validation was ok
+    or an empty dict if user cancelled
+    """
+    default_values = default_values or dict()
+    bullet = "\u2022"  # specifies bullet character
+
+    field_list = [UiField(name="domain", label="Domain",
+                          default_value=default_values.get("domain", get_current_domain()),
+                          editable=False),
+                  UiField(name="username", label="User",
+                          default_value=default_values.get("username", get_current_user()),
+                          editable=False),
+                  UiField(name="password", label="Password",
+                          default_value=default_values.get("password", ""),
+                          show=bullet,
+                          validation_func=validate_password)]
+    return simple_dialog(title, description, field_list, parent=parent)
+
+
+if __name__ == '__main__':
+    # from ong_utils import simple_dialog
+    # from ong_utils.ui import UiField, UiFileButton, UiPasswordButton, UiFolderButton
+
+    field_list = [UiField(name="domain",  # Key of the dict in the return dictionary and for validation functions
+                          label="Domain",  # Name to the shown for the user
+                          default_value="fake domain",  # Default value to be used
+                          editable=False  # Not editable
+                          ),
+                  UiField(name="username", label="User", default_value="fake user",
+                          editable=False,
+                          ),
+                  UiField(name="password", label="Password", default_value="",
+                          show="*",  # Hides password by replacing with *
+                          # validation_func=verify_credentials
+                          # The validation function receives values of all fields, so should accept extra **kwargs
+                          button=UiPasswordButton()
+                          ),
+                  UiField(name="server", label="Server",
+                          width=40),
+                  # Will ask for a folder and validate that exists
+                  UiField(name="folder", label="Folder", button=UiFolderButton(), width=80),
+                  # Will ask for a file and validate that exists
+                  UiField(name="file", label="File", button=UiFileButton(), width=90),
+                  ]
+    # Call the function to open the login window with custom options
+    res = simple_dialog(title="Sample form", description="Show descriptive message for the user",
+                        field_list=field_list)
+    print(res)
+
+    res = user_domain_password_dialog("Log in form", "Please enter your credentials",
+                                      validate_password=None,
+                                      default_values=dict(username="fake user", domain="fake domain",
+                                                          password="fake password"))
+    print(res)
+
+    res = simple_dialog("Un titulo",
+                        "una Descripcion",
+                        field_list=
+                        [
+                            UiField(name="a", label="A", allow_empy=True, button=UiFileButton()),
+                            UiField(name="b", label="B", default_value="Si", valid_values=['Si', 'No'])
+                        ])
+    print(res)
```

## ong_utils/ui_logging_utils.py

 * *Ordering differences only*

```diff
@@ -1,76 +1,76 @@
-"""
-Some utils for visual logging using tkinter:
-    - as handler to redirect prints to a tk Entry widget
-    - a logging handler for logging directly to a tk Entry widget
-
-You can implement child classes that override the LogTextHandler.emit_widget and the PrintHandler.write_widget to
-write to tk Widgets different from a tk.Entry widget. These new classes can be passed as the handler_class parameters
-to print2widget and logger2widget functions to activate them
-"""
-
-import logging
-import sys
-import tkinter as tk
-
-
-class LogTextHandler(logging.Handler):
-    """A logging handler that sends output to a read only tkinter widget"""
-
-    def __init__(self, widget: tk.Text):
-        logging.Handler.__init__(self)
-        self.widget = widget
-
-    def emit_widget(self, msg: str):
-        """Overwrite this method in a child class to write to a different widget"""
-        self.widget.configure(state='normal')
-        self.widget.insert('end', msg + '\n')
-        self.widget.configure(state='disabled')
-        self.widget.update()
-
-    def emit(self, record):
-        log_entry = self.format(record)
-        try:
-            self.emit_widget(log_entry)
-        except tk.TclError as te:
-            sys.stderr.write(str(te))
-            sys.stderr.flush()
-
-
-class PrintHandler(object):
-    """Handler used to redirect prints to a tk Entry widget"""
-
-    def __init__(self, widget):
-        self.widget = widget
-        self.stdout = sys.stdout
-        sys.stdout = self
-
-    def write_widget(self, s: str):
-        """Overwrite this method in a child class to write to a different widget"""
-        self.widget.configure(state='normal')
-        self.widget.insert('end', s)
-        self.widget.configure(state='disabled')
-        self.widget.update()
-
-    def write(self, s):
-        try:
-            self.write_widget(s)
-        except tk.TclError as te:
-            sys.stderr.write(str(te))
-            sys.stderr.flush()
-
-    def flush(self):
-        pass
-
-
-def print2widget(widget: tk.Widget, handler_class=PrintHandler):
-    """Redirects all class to print to the given tkinter widget"""
-    handler_class(widget)
-
-
-def logger2widget(logger: logging.Logger, widget: tk.Widget, level=logging.INFO, handler_class=LogTextHandler):
-    """Adds a new LogTextHandler for the given logger to redirects its logs to the given tkinter Entry widget"""
-    # Do not add logger if it already existed
-    if not any(isinstance(h, handler_class) for h in logger.handlers):
-        lh = handler_class(widget)
-        lh.setLevel(level)
-        logger.addHandler(lh)
+"""
+Some utils for visual logging using tkinter:
+    - as handler to redirect prints to a tk Entry widget
+    - a logging handler for logging directly to a tk Entry widget
+
+You can implement child classes that override the LogTextHandler.emit_widget and the PrintHandler.write_widget to
+write to tk Widgets different from a tk.Entry widget. These new classes can be passed as the handler_class parameters
+to print2widget and logger2widget functions to activate them
+"""
+
+import logging
+import sys
+import tkinter as tk
+
+
+class LogTextHandler(logging.Handler):
+    """A logging handler that sends output to a read only tkinter widget"""
+
+    def __init__(self, widget: tk.Text):
+        logging.Handler.__init__(self)
+        self.widget = widget
+
+    def emit_widget(self, msg: str):
+        """Overwrite this method in a child class to write to a different widget"""
+        self.widget.configure(state='normal')
+        self.widget.insert('end', msg + '\n')
+        self.widget.configure(state='disabled')
+        self.widget.update()
+
+    def emit(self, record):
+        log_entry = self.format(record)
+        try:
+            self.emit_widget(log_entry)
+        except tk.TclError as te:
+            sys.stderr.write(str(te))
+            sys.stderr.flush()
+
+
+class PrintHandler(object):
+    """Handler used to redirect prints to a tk Entry widget"""
+
+    def __init__(self, widget):
+        self.widget = widget
+        self.stdout = sys.stdout
+        sys.stdout = self
+
+    def write_widget(self, s: str):
+        """Overwrite this method in a child class to write to a different widget"""
+        self.widget.configure(state='normal')
+        self.widget.insert('end', s)
+        self.widget.configure(state='disabled')
+        self.widget.update()
+
+    def write(self, s):
+        try:
+            self.write_widget(s)
+        except tk.TclError as te:
+            sys.stderr.write(str(te))
+            sys.stderr.flush()
+
+    def flush(self):
+        pass
+
+
+def print2widget(widget: tk.Widget, handler_class=PrintHandler):
+    """Redirects all class to print to the given tkinter widget"""
+    handler_class(widget)
+
+
+def logger2widget(logger: logging.Logger, widget: tk.Widget, level=logging.INFO, handler_class=LogTextHandler):
+    """Adds a new LogTextHandler for the given logger to redirects its logs to the given tkinter Entry widget"""
+    # Do not add logger if it already existed
+    if not any(isinstance(h, handler_class) for h in logger.handlers):
+        lh = handler_class(widget)
+        lh.setLevel(level)
+        logger.addHandler(lh)
```

## ong_utils/urllib3_utils.py

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-"""
-Utility functions related to urllib3 package
-
-examples:
-from ong_utils import http, cookies2header, get_cookies
-url = "whicheverurl"
-req = http.request("get", url)
-cookies = get_cookies(req)
-headers = {"Accept": "text/html;application/json"}
-headers.update(cookies2header(cookies))
-req.http.request("get", url, headers=headers)       # Using cookies from previous response
-"""
-
-from http.cookiejar import CookieJar
-from urllib.request import Request
-from urllib3.response import HTTPResponse
-
-import certifi
-import urllib3.contrib.pyopenssl
-
-
-def create_pool_manager(status=10, backoff_factor=0.15, **kwargs) -> urllib3.PoolManager:
-    """
-    Creates an urllib3.PoolManager instance, that checks https connections and optionally retries queries
-    :param status: param to urllib3.util.Retry. Means number of times to retry in case of an error status
-    (e.g. after 503 error), by default 10. Use 0 or None to disable retries
-    :param backoff_factor: param to urllib3.util.Retry. Means, more or less, seconds to wait between retries
-    (read urllib3.util.Retry docs for more details), by default 0.15
-    :param kwargs: any other parameter will be passed to urllib3.util.Retry
-    :return: an urllib3.PoolManager instance that can be use with .request or .openurl methods
-    """
-    urllib3.contrib.pyopenssl.inject_into_urllib3()
-    if status is not None and status > 0:
-        retries = urllib3.util.Retry(
-            status=status,      # Retry 10 times on error status (e.g. after 503 error)
-            backoff_factor=backoff_factor,      # Aprox seconds to wait between retries
-            **kwargs
-        )
-    else:
-        retries = None
-    http = urllib3.PoolManager(cert_reqs='CERT_REQUIRED',
-                               ca_certs=certifi.where(),
-                               retries=retries
-                               )
-    return http
-
-    pass
-
-
-def cookies2header(cookies: dict) -> dict:
-    """Converts cookies in dict to header field 'Cookie' for use in urllib3"""
-    return dict(Cookie="; ".join(f"{k}={v}" for k, v in cookies.items()))
-
-
-def get_cookies(resp: HTTPResponse, request: Request = None) -> dict:
-    """Gets cookies from response of an urllib3 function (request, urlopen)"""
-    cj = CookieJar()
-    if request is None:
-        try:
-            url = resp.geturl()
-            request = request or Request(url)
-        except ValueError:
-            # Not a valid url, fix it getting host address from pool (if any)
-            if pool := getattr(resp, "_pool"):
-                request = Request(f"{pool.scheme}://{pool.host}:{pool.port}{resp.geturl()}")
-            else:
-                raise
-    cks = cj.make_cookies(resp, request)
-    cookies = {c.name: c.value for c in cks}
-    return cookies
+"""
+Utility functions related to urllib3 package
+
+examples:
+from ong_utils import http, cookies2header, get_cookies
+url = "whicheverurl"
+req = http.request("get", url)
+cookies = get_cookies(req)
+headers = {"Accept": "text/html;application/json"}
+headers.update(cookies2header(cookies))
+req.http.request("get", url, headers=headers)       # Using cookies from previous response
+"""
+
+from http.cookiejar import CookieJar
+from urllib.request import Request
+from urllib3.response import HTTPResponse
+
+import certifi
+import urllib3.contrib.pyopenssl
+
+
+def create_pool_manager(status=10, backoff_factor=0.15, **kwargs) -> urllib3.PoolManager:
+    """
+    Creates an urllib3.PoolManager instance, that checks https connections and optionally retries queries
+    :param status: param to urllib3.util.Retry. Means number of times to retry in case of an error status
+    (e.g. after 503 error), by default 10. Use 0 or None to disable retries
+    :param backoff_factor: param to urllib3.util.Retry. Means, more or less, seconds to wait between retries
+    (read urllib3.util.Retry docs for more details), by default 0.15
+    :param kwargs: any other parameter will be passed to urllib3.util.Retry
+    :return: an urllib3.PoolManager instance that can be use with .request or .openurl methods
+    """
+    urllib3.contrib.pyopenssl.inject_into_urllib3()
+    if status is not None and status > 0:
+        retries = urllib3.util.Retry(
+            status=status,      # Retry 10 times on error status (e.g. after 503 error)
+            backoff_factor=backoff_factor,      # Aprox seconds to wait between retries
+            **kwargs
+        )
+    else:
+        retries = None
+    http = urllib3.PoolManager(cert_reqs='CERT_REQUIRED',
+                               ca_certs=certifi.where(),
+                               retries=retries
+                               )
+    return http
+
+    pass
+
+
+def cookies2header(cookies: dict) -> dict:
+    """Converts cookies in dict to header field 'Cookie' for use in urllib3"""
+    return dict(Cookie="; ".join(f"{k}={v}" for k, v in cookies.items()))
+
+
+def get_cookies(resp: HTTPResponse, request: Request = None) -> dict:
+    """Gets cookies from response of an urllib3 function (request, urlopen)"""
+    cj = CookieJar()
+    if request is None:
+        try:
+            url = resp.geturl()
+            request = request or Request(url)
+        except ValueError:
+            # Not a valid url, fix it getting host address from pool (if any)
+            if pool := getattr(resp, "_pool"):
+                request = Request(f"{pool.scheme}://{pool.host}:{pool.port}{resp.geturl()}")
+            else:
+                raise
+    cks = cj.make_cookies(resp, request)
+    cookies = {c.name: c.value for c in cks}
+    return cookies
```

## ong_utils/utils.py

 * *Ordering differences only*

```diff
@@ -1,104 +1,104 @@
-"""
-General utils that do not need additional libraries to the ong_utils base libraries:
-    - get local timezone    (uses dateutil)
-    - check if is debugging
-    - conversion of a value to list
-    - checks if is mac, linux or windows
-    - get user and domain
-"""
-import os
-import platform
-import sys
-
-import dateutil.tz
-
-LOCAL_TZ = dateutil.tz.tzlocal()
-
-
-class _BoolVariableFunction:
-    """Create an instance of this class with a boolean value and assign it to a variable.
-    The variable will evaluate to the given boolean, and so will do a functon call to the variable
-    Example: will print "False" in both cases
-        a = _BoolVariableFunction(False)
-        if a:
-            print("True")
-        else:
-            print("False")
-        if a():
-            print("True")
-        else:
-            print("False")
-    """
-
-    def __init__(self, value: bool):
-        self.value = value
-
-    def __bool__(self):
-        """To evaluate as a variable"""
-        return self.value
-
-    def __call__(self, *args, **kwargs):
-        """To evaluate as a function"""
-        return self.value
-
-    def __eq__(self, other):
-        """For comparisons"""
-        return self.value == other
-
-
-# Check for debugging, if so run debug server
-is_debugging = _BoolVariableFunction(True if sys.gettrace() else False)
-
-
-def to_list(value) -> list:
-    """
-    Converts a value to a list
-    :param value: a value that is not a list (or tuple)
-    :return: value converted into a list or tuple
-    """
-    if isinstance(value, (list, tuple)):
-        return value
-    return [value]
-
-
-"""
-Functions to detect under which OS the code is running
-"""
-
-
-class _PlatformVariableFunction(_BoolVariableFunction):
-    def __init__(self, platform_name: str):
-        self.platform_name = platform_name
-        super().__init__(platform.system() == self.platform_name)
-
-
-"""True if running in macos"""
-is_mac = _PlatformVariableFunction("Darwin")
-
-"""True if running Windows"""
-is_windows = _PlatformVariableFunction("Windows")
-
-"""True if running Linux"""
-is_linux = _PlatformVariableFunction("Linux")
-
-"""
-Functions to get current user and domain
-"""
-
-
-def get_current_user() -> str:
-    return os.getenv("USER", os.getenv("USERNAME"))
-
-
-def get_current_domain() -> str:
-    return os.getenv("USERDOMAIN", "")
-
-
-def get_computername() -> str:
-    return platform.node()
-
-
-if __name__ == '__main__':
-    print(f"{get_current_user()=}")
-    print(f"{get_current_domain()=}")
-    print(f"{get_computername()=}")
+"""
+General utils that do not need additional libraries to the ong_utils base libraries:
+    - get local timezone    (uses dateutil)
+    - check if is debugging
+    - conversion of a value to list
+    - checks if is mac, linux or windows
+    - get user and domain
+"""
+import os
+import platform
+import sys
+
+import dateutil.tz
+
+LOCAL_TZ = dateutil.tz.tzlocal()
+
+
+class _BoolVariableFunction:
+    """Create an instance of this class with a boolean value and assign it to a variable.
+    The variable will evaluate to the given boolean, and so will do a functon call to the variable
+    Example: will print "False" in both cases
+        a = _BoolVariableFunction(False)
+        if a:
+            print("True")
+        else:
+            print("False")
+        if a():
+            print("True")
+        else:
+            print("False")
+    """
+
+    def __init__(self, value: bool):
+        self.value = value
+
+    def __bool__(self):
+        """To evaluate as a variable"""
+        return self.value
+
+    def __call__(self, *args, **kwargs):
+        """To evaluate as a function"""
+        return self.value
+
+    def __eq__(self, other):
+        """For comparisons"""
+        return self.value == other
+
+
+# Check for debugging, if so run debug server
+is_debugging = _BoolVariableFunction(True if sys.gettrace() else False)
+
+
+def to_list(value) -> list:
+    """
+    Converts a value to a list
+    :param value: a value that is not a list (or tuple)
+    :return: value converted into a list or tuple
+    """
+    if isinstance(value, (list, tuple)):
+        return value
+    return [value]
+
+
+"""
+Functions to detect under which OS the code is running
+"""
+
+
+class _PlatformVariableFunction(_BoolVariableFunction):
+    def __init__(self, platform_name: str):
+        self.platform_name = platform_name
+        super().__init__(platform.system() == self.platform_name)
+
+
+"""True if running in macos"""
+is_mac = _PlatformVariableFunction("Darwin")
+
+"""True if running Windows"""
+is_windows = _PlatformVariableFunction("Windows")
+
+"""True if running Linux"""
+is_linux = _PlatformVariableFunction("Linux")
+
+"""
+Functions to get current user and domain
+"""
+
+
+def get_current_user() -> str:
+    return os.getenv("USER", os.getenv("USERNAME"))
+
+
+def get_current_domain() -> str:
+    return os.getenv("USERDOMAIN", "")
+
+
+def get_computername() -> str:
+    return platform.node()
+
+
+if __name__ == '__main__':
+    print(f"{get_current_user()=}")
+    print(f"{get_current_domain()=}")
+    print(f"{get_computername()=}")
```

## ong_utils/web.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-"""
-General functions to deal with web servers
-"""
-import socket
-
-
-def find_available_port(initial_port: int = 5000, end_port: int = 9999, logger=None) -> int:
-    """
-    Tries to bind to a port, if not possible increments by one until a free port is found
-    :param initial_port: start port to try (defaults to 5000)
-    :param end_port: final port to try (defaults to 9999)
-    :param logger: and optional logger to log tries. If none, loger.info will be used to log retries
-    :return: the number of the first free port found
-    """
-    initial_port = int(initial_port)
-    for port in range(initial_port, end_port + 1):
-        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
-            if not s.connect_ex(('localhost', port)) == 0:     # Port NOT in use
-                if port != initial_port:
-                    info_msg = f"Port {initial_port} is in use. Using next available port: {port}"
-                    if logger is not None:
-                        logger.info(info_msg)
-                    else:
-                        print(info_msg)
-                return port
-    raise ConnectionRefusedError(f"No available ports in range from {initial_port} to {end_port}")
-
-
+"""
+General functions to deal with web servers
+"""
+import socket
+
+
+def find_available_port(initial_port: int = 5000, end_port: int = 9999, logger=None) -> int:
+    """
+    Tries to bind to a port, if not possible increments by one until a free port is found
+    :param initial_port: start port to try (defaults to 5000)
+    :param end_port: final port to try (defaults to 9999)
+    :param logger: and optional logger to log tries. If none, loger.info will be used to log retries
+    :return: the number of the first free port found
+    """
+    initial_port = int(initial_port)
+    for port in range(initial_port, end_port + 1):
+        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
+            if not s.connect_ex(('localhost', port)) == 0:     # Port NOT in use
+                if port != initial_port:
+                    info_msg = f"Port {initial_port} is in use. Using next available port: {port}"
+                    if logger is not None:
+                        logger.info(info_msg)
+                    else:
+                        print(info_msg)
+                return port
+    raise ConnectionRefusedError(f"No available ports in range from {initial_port} to {end_port}")
+
+
```

## ong_utils/office/__init__.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-"""
-Utils to open MS Office files using pywin32
+"""
+Utils to open MS Office files using pywin32
 """
```

## ong_utils/office/office_base.py

 * *Ordering differences only*

```diff
@@ -1,157 +1,157 @@
-"""
-Base class to use Office Automation. Creates the corresponding office app, cleans cache if needed and
-exits properly discarding changes
-"""
-import os.path
-
-from ong_utils.import_utils import raise_extra_exception
-
-try:
-    from win32com import client, __gen_path__
-except ModuleNotFoundError:
-    raise_extra_exception("office")
-from pathlib import Path
-import re
-from shutil import rmtree
-from abc import abstractmethod
-from functools import wraps
-
-
-def fix_filename(method):
-    @wraps(method)
-    def _impl(self, filename, *method_args, **method_kwargs):
-        filename = os.path.abspath(filename)
-        method_output = method(self, filename, *method_args, **method_kwargs)
-        return method_output
-
-    return _impl
-
-
-class _OfficeBase:
-    """
-    Base class for automation of office applications under windows.
-    """
-
-    @property
-    @abstractmethod
-    def client_name(self) -> str:
-        """This must return the client_name for EnsureDispatch, such as Excel.Application or Word.Application"""
-        return ""
-
-    def __init__(self, logger=None, quit_on_exit: bool = True):
-        """Creates an office instance, with an optional logger and closing or not client on exit"""
-        self.logger = logger
-        self.__client = None
-        self.file = None
-        self.__quit_on_exit = quit_on_exit
-
-    @abstractmethod
-    def open(self, filename: str):
-        """Opens a file from given path"""
-        pass
-
-    @property
-    def client(self):
-        """Initializes client"""
-        if self.__client is not None:
-            return self.__client
-        try:
-            self.__client = client.gencache.EnsureDispatch(self.client_name)
-            if hasattr(self.__client, "Visible"):
-                self.__client.Visible = True
-        except AttributeError as e:
-            # Sometimes we might have to clean the cache to open
-            m_failing_cache = re.search(r"win32com\.gen_py\.([\w\-]+)", str(e))
-            if m_failing_cache:
-                cache_folder_name = m_failing_cache.group(1)
-                if self.logger is not None:
-                    self.logger.warning(f"Cleaning cache for '{cache_folder_name}'")
-                cache_folder = Path(__gen_path__).joinpath(cache_folder_name)
-                rmtree(cache_folder)
-                self.__client = client.gencache.EnsureDispatch(self.client_name)
-            else:
-                raise
-        finally:
-            return self.__client
-
-    def quit(self):
-        """Exits discarding changes"""
-        if self.__client:
-            # Close file if already opened, discarding changes
-            if self.file:
-                if self.client_name.startswith("PowerPoint"):
-                    self.file.Close()
-                else:
-                    self.file.Close(False)
-                self.file = None
-            if self.client_name.startswith("Excel"):
-                self.__client.DisplayAlerts = False
-                self.__client.Quit()
-            elif self.client_name.startswith("Word"):
-                self.__client.Quit(SaveChanges=False)
-            else:
-                # In PowerPoint this could make a message to be shown if presentations are not saved before closing
-                self.__client.Quit()
-            self.__client = None
-
-    def __del__(self):
-        """Exits discarding changes, if quit_on_exit was True in class constructor"""
-        if self.__quit_on_exit:
-            try:
-                self.quit()
-            except Exception as e:
-                # exception could be risen if there are other opened documents not saved
-                print(e)
-                pass
-
-
-class ExcelBase(_OfficeBase):
-    @property
-    def client_name(self) -> str:
-        return "Excel.Application"
-
-    @fix_filename
-    def open(self, filename: str):
-        self.file = self.client.Workbooks.Open(filename)
-
-
-class WordBase(_OfficeBase):
-    @property
-    def client_name(self) -> str:
-        return "Word.Application"
-
-    @fix_filename
-    def open(self, filename: str):
-        """Opens a word document"""
-        self.file = self.client.Documents.Open(filename)
-
-
-class AccessBase(_OfficeBase):
-    @property
-    def client_name(self) -> str:
-        return "Access.Application"
-
-    @fix_filename
-    def open(self, filename: str):
-        self.file = self.client.OpenCurrentDatabase(filename)
-
-
-class PowerpointBase(_OfficeBase):
-    @property
-    def client_name(self) -> str:
-        return "PowerPoint.Application"
-
-    @fix_filename
-    def open(self, filename: str):
-        """Opens a ppt filename"""
-        self.file = self.client.Presentations.Open(FileName=filename, WithWindow=1)
-
-
-class OutlookBase(_OfficeBase):
-    @property
-    def client_name(self) -> str:
-        return "Outlook.Application"
-
-    def open(self, filename: str):
-        """Does nothing: opening outlook documents makes no sense"""
-        pass
+"""
+Base class to use Office Automation. Creates the corresponding office app, cleans cache if needed and
+exits properly discarding changes
+"""
+import os.path
+
+from ong_utils.import_utils import raise_extra_exception
+
+try:
+    from win32com import client, __gen_path__
+except ModuleNotFoundError:
+    raise_extra_exception("office")
+from pathlib import Path
+import re
+from shutil import rmtree
+from abc import abstractmethod
+from functools import wraps
+
+
+def fix_filename(method):
+    @wraps(method)
+    def _impl(self, filename, *method_args, **method_kwargs):
+        filename = os.path.abspath(filename)
+        method_output = method(self, filename, *method_args, **method_kwargs)
+        return method_output
+
+    return _impl
+
+
+class _OfficeBase:
+    """
+    Base class for automation of office applications under windows.
+    """
+
+    @property
+    @abstractmethod
+    def client_name(self) -> str:
+        """This must return the client_name for EnsureDispatch, such as Excel.Application or Word.Application"""
+        return ""
+
+    def __init__(self, logger=None, quit_on_exit: bool = True):
+        """Creates an office instance, with an optional logger and closing or not client on exit"""
+        self.logger = logger
+        self.__client = None
+        self.file = None
+        self.__quit_on_exit = quit_on_exit
+
+    @abstractmethod
+    def open(self, filename: str):
+        """Opens a file from given path"""
+        pass
+
+    @property
+    def client(self):
+        """Initializes client"""
+        if self.__client is not None:
+            return self.__client
+        try:
+            self.__client = client.gencache.EnsureDispatch(self.client_name)
+            if hasattr(self.__client, "Visible"):
+                self.__client.Visible = True
+        except AttributeError as e:
+            # Sometimes we might have to clean the cache to open
+            m_failing_cache = re.search(r"win32com\.gen_py\.([\w\-]+)", str(e))
+            if m_failing_cache:
+                cache_folder_name = m_failing_cache.group(1)
+                if self.logger is not None:
+                    self.logger.warning(f"Cleaning cache for '{cache_folder_name}'")
+                cache_folder = Path(__gen_path__).joinpath(cache_folder_name)
+                rmtree(cache_folder)
+                self.__client = client.gencache.EnsureDispatch(self.client_name)
+            else:
+                raise
+        finally:
+            return self.__client
+
+    def quit(self):
+        """Exits discarding changes"""
+        if self.__client:
+            # Close file if already opened, discarding changes
+            if self.file:
+                if self.client_name.startswith("PowerPoint"):
+                    self.file.Close()
+                else:
+                    self.file.Close(False)
+                self.file = None
+            if self.client_name.startswith("Excel"):
+                self.__client.DisplayAlerts = False
+                self.__client.Quit()
+            elif self.client_name.startswith("Word"):
+                self.__client.Quit(SaveChanges=False)
+            else:
+                # In PowerPoint this could make a message to be shown if presentations are not saved before closing
+                self.__client.Quit()
+            self.__client = None
+
+    def __del__(self):
+        """Exits discarding changes, if quit_on_exit was True in class constructor"""
+        if self.__quit_on_exit:
+            try:
+                self.quit()
+            except Exception as e:
+                # exception could be risen if there are other opened documents not saved
+                print(e)
+                pass
+
+
+class ExcelBase(_OfficeBase):
+    @property
+    def client_name(self) -> str:
+        return "Excel.Application"
+
+    @fix_filename
+    def open(self, filename: str):
+        self.file = self.client.Workbooks.Open(filename)
+
+
+class WordBase(_OfficeBase):
+    @property
+    def client_name(self) -> str:
+        return "Word.Application"
+
+    @fix_filename
+    def open(self, filename: str):
+        """Opens a word document"""
+        self.file = self.client.Documents.Open(filename)
+
+
+class AccessBase(_OfficeBase):
+    @property
+    def client_name(self) -> str:
+        return "Access.Application"
+
+    @fix_filename
+    def open(self, filename: str):
+        self.file = self.client.OpenCurrentDatabase(filename)
+
+
+class PowerpointBase(_OfficeBase):
+    @property
+    def client_name(self) -> str:
+        return "PowerPoint.Application"
+
+    @fix_filename
+    def open(self, filename: str):
+        """Opens a ppt filename"""
+        self.file = self.client.Presentations.Open(FileName=filename, WithWindow=1)
+
+
+class OutlookBase(_OfficeBase):
+    @property
+    def client_name(self) -> str:
+        return "Outlook.Application"
+
+    def open(self, filename: str):
+        """Does nothing: opening outlook documents makes no sense"""
+        pass
```

## Comparing `ong_utils-0.6.5.dist-info/METADATA` & `ong_utils-0.6.6.dist-info/METADATA`

 * *Files 13% similar despite different names*

```diff
@@ -1,717 +1,732 @@
-Metadata-Version: 2.1
-Name: ong_utils
-Version: 0.6.5
-Summary: Common utilities for python projects
-Author-email: Oscar Neira <oneirag@yahoo.es>
-Project-URL: Homepage, https://github.com/Oneirag/ong_utils
-Project-URL: Source, https://github.com/Oneirag/ong_utils
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Requires-Dist: pip-system-certs
-Requires-Dist: certifi
-Requires-Dist: urllib3
-Requires-Dist: pyopenssl
-Requires-Dist: python-dateutil
-Requires-Dist: pyyaml
-Requires-Dist: ujson
-Requires-Dist: idna
-Requires-Dist: keyring
-Provides-Extra: all
-Requires-Dist: selenium ; extra == 'all'
-Requires-Dist: selenium-wire ; extra == 'all'
-Requires-Dist: undetected-chromedriver ; extra == 'all'
-Requires-Dist: openpyxl ; extra == 'all'
-Requires-Dist: pandas ; extra == 'all'
-Requires-Dist: pyshortcuts ; extra == 'all'
-Requires-Dist: wheel ; extra == 'all'
-Requires-Dist: pyjwt ; extra == 'all'
-Requires-Dist: pywin32 ; extra == 'all'
-Requires-Dist: python-pam ; (platform_system != "Windows") and extra == 'all'
-Requires-Dist: pywin32 ; (platform_system == "Windows") and extra == 'all'
-Requires-Dist: Pillow ; (sys_platform != "darwin") and extra == 'all'
-Requires-Dist: icnsutil ; (sys_platform == "darwin") and extra == 'all'
-Provides-Extra: credentials
-Requires-Dist: python-pam ; (platform_system != "Windows") and extra == 'credentials'
-Requires-Dist: pywin32 ; (platform_system == "Windows") and extra == 'credentials'
-Provides-Extra: jwt
-Requires-Dist: pyjwt ; extra == 'jwt'
-Provides-Extra: office
-Requires-Dist: pywin32 ; extra == 'office'
-Provides-Extra: selenium
-Requires-Dist: selenium ; extra == 'selenium'
-Requires-Dist: selenium-wire ; extra == 'selenium'
-Requires-Dist: undetected-chromedriver ; extra == 'selenium'
-Provides-Extra: shortcuts
-Requires-Dist: pyshortcuts ; extra == 'shortcuts'
-Requires-Dist: wheel ; extra == 'shortcuts'
-Requires-Dist: Pillow ; (sys_platform != "darwin") and extra == 'shortcuts'
-Requires-Dist: icnsutil ; (sys_platform == "darwin") and extra == 'shortcuts'
-Provides-Extra: xlsx
-Requires-Dist: openpyxl ; extra == 'xlsx'
-Requires-Dist: pandas ; extra == 'xlsx'
-
-Ong_Utils
-=========
-
-## Description
-Simple package with some utils to import in any project:
-* class to manage configuration files in yaml or json [Read more](#configuration-files). It also uses `keyring` to store and retrieve passwords. [Read more](#passwords)  
-* logger and a timer to record elapsed times for optimizing some processes. [Read more](#timers)
-* a `create_pool_manager` function to create instances of urllib3.PoolManager with retries and timeouts and checking of 
-https connections. [Read more](#urllib3-utils)
-* a `TZ_LOCAL` variable with the local timezone
-of the computer).   
-* an `is_debugging` function that returns True when debugging code
-* a `to_list` function to convert any non-list value (specifically strings to avoid iterating char by char) into a list
-* a `cookies2header` that converts cookies in dict to header field 'Cookie' for use in urllib3. [Read more](#urllib3-utils)
-* a `get_cookies` function to extract a dict of cookies from a response of a urllib3 request. [Read more](#urllib3-utils)
-* a class to store any data into keyring (e.g. strings, dicts...). [Read more](#storing-long-data-in-keyring)
-* functions to parse html pages and extract javascript variables (such as CSRF tokens or links). [Read more](#parsing-html-pages)
-* Class to read/apply sensitivity labels to a file (Public, Internal...) [Read more](#add-sensitivy-labels-to-office-files). It is adapated from https://github.com/brunomsantiago/mip_python
-* functions to get current user and domain. [Read more](#get-current-user-and-domain)
-* functions for simple input dialogs with validations using tk [Read more](#simple-dialogs)
-* a function `fix_windows_gui_scale` to avoid blurry tkinter text elements in Windows 10 or 11. [Read more](#fix-windows-scaling)
-* Handlers to redirect prints and logging to an Entry tkinter widget [Read more](#print-and-logging-tkinter-handlers)
-### Optional dependencies
-Installing `pip install ong_utils[shortcuts]`:
-* functions to create desktop shortcuts for packages installed with pip. [Read more](#make-shortcuts-for-entry-points)
-
-Installing `pip install ong_utils[xlsx]`:
-* function to export a pandas dataframe into a xlsx excel sheet.[Read more](#nicer-output-pandas-dataframe-to-excel) 
-
-Installing `pip install ong_utils[jwt]`:
-* functions to decode access tokens. [Read more](#decoding-jwt-tokens)
-
-Installing `pip install ong_utils[selenium]`:
-* class to manage Chrome using selenium. [Read more](#control-webpages-with-selenium)
-
-Installing `pip install ong_utils[office]`:
-* Classes to interact with API of Office in windows. [Read more](#create-instances-of-office-programs)
-
-Installing `pip install ong_utils[credentials]`:
-* function to verify password of current log in user. [Read more](#control-webpages-with-selenium)
-
-## General usage
-Simple example of an __init__.py in a package ("mypackage") using ong_utils:
-```python
-import pandas as pd
-from ong_utils import OngConfig, LOCAL_TZ, OngTimer
-_cfg = OngConfig("mypackage")
-config = _cfg.config
-logger = _cfg.logger
-```
-And usage in other parts of the code of "mypackage":
-```python
-import pandas as pd
-from mypackage import config, logger, LOCAL_TZ, http
-local_now = pd.Timestamp.now(tz=LOCAL_TZ)
-res = http.request("GET", config('url'))
-logger.info("Sample log")
-```
-### Advanced usage
-Default values can be supplied, so a new file is created with the default values if it does not exist previously
-```python
-from ong_utils import OngConfig
-# The following code will create the config file with given default values and
-# will also raise an exception to stop the program so the user can review the file
-default_app_values = dict(a_kew=a_value)
-cfg = OngConfig(default_app_cfg=default_app_values)
-
-# The following code will create the config file with given default values and
-# but won't raise any exception, so the process will continue
-# This approach is usefull when the default values can be used without further edition
-default_app_values = dict(a_kew=a_value)
-cfg = OngConfig(default_app_cfg=default_app_values, 
-                write_default_file=True)
-
-```
-Values could be updated and writen to the config file during the execution of the code
-
-```python
-from ong_utils import OngConfig
-
-# Assume file already exists
-cfg = OngConfig("app_name")
-...
-# Add a new key and saves the config file. If the key existed, raises ValueError
-cfg.add_app_config("new key", "new value")
-print(cfg.config("new key"))  # Will print new value
-# Updates an existing key and saves in the config file. If the key did not exist, raises ValueError
-cfg.update_app_config("new key", "new value")
-print(cfg.config("new key"))  # Will print new value
-
-
-```
-
-
-
-## Configuration files
-Config files are yaml/json files located (by default) in `~/.config/ongpi/{project_name}.{extension}`. 
-The file extension can be yaml, yml, json or js.
-File can have this form:
-```yaml
-my_project:
-  sample_key1: sample_value1
-  sample_key2: sample_value2
-log:
-  optional_log_config: values
-# This is an optional section, for values used just in tests
-my_project_test:
-  sample_key1: sample_value1
-  sample_key2: sample_value2
-
-```
-or this
-```json
-{
-  "my_project": {
-    "sample_key1": sample_value1,
-    "sample_key2": "sample_value2"
-  },
-  "log": {
-    "optional_log_config": value
-  }
-}
-```
-Config files must have a section with the name the project.   OngConfig.config("key") will raise an Exception if "key" is undefined, unless
-a default value is used (OngConfig.config("key", "default_value"))  
-If a file_path is supplied as second argument to the constructor, that file will be used. In that case many projects
-can share the same config file. E.g. if config file is /etc/myconfig.yaml, ti can has this form:
-```yaml
-project_name1:
-  key_for_project1: value
-project_name2:
-  key_for_project2: value
-# Optional: test values for project_name2
-project_name2_test:
-  key_for_project2: value
-```
-and config method can only access to configuration of current project.
-
-New values can be added to the configuration in execution time by calling `add_app_config`. That will persist the new values in the configuration file.
-### Passwords
-Module uses keyring to store passwords
-```python
-from ong_utils import OngConfig
-# configuration file should have "service" and "user" keys
-_cfg = OngConfig("mypackage")
-config = _cfg.config
-get_password = _cfg.get_password
-set_password = _cfg.set_password
-
-# Sets password (prompts user)
-set_password("service", "user")
-# Equivalent to keyring.set_password(config("service"), config("user"), input())
-# Gets password
-pwd = get_password("service", "user")
-# Equivalent to keyring.get_password(config("service"), config("user"))
-```
-## Storing long data in keyring
-### Storing json-serializable data
-For storing long passwords (e.g. a jwt_token) or non string data (e.g. a dictionary of cookies), use `ong_utils.InternalStorage` class.
-```python
-from ong_utils import InternalStorage
-
-internal_storage = InternalStorage("your app name")
-for value to store in [
-        "long string" * 120,
-        {"an": "example", "of": "dictionary"}
-        ]:
-  key_name = "sample_key"
-  internal_storage.store_value(key_name, value)
-  stored = internal_storage.get_value("key name")
-  assert value == stored
-  internal_storage.remove_stored_value()
-
-```
-### Storing cookies from requests.session objects
-`CookieJar` objects are not json serializable. To store cookies you'll have to turn into list of dicts. 
-
-Use functions in `requests.cookies` package to make conversions before storing/retrieving them as dicts
-
-```python
-# Assume session is a request.session.Session object
-cookies = session.cookies
-cookie_dict = [dict(name=c.name, value=c.value, domain=c.domain, path=c.path, expires=c.expires)
-               for c in cookies]
-# Store cookie_dict normally
-
-# Code for updating session from cookie_dict
-import requests.cookies
-
-# Assume cookie_dict is the same as above
-cookies = [requests.cookies.create_cookie(**c) for c in cookies_dict]
-for cookie in cookies:
-    session.cookies.set_cookie(cookie)
-```
-
-## Timers
-`OngTimer` class uses `tic(msg)` to start timer and `toc(msg)` to stop timer and show a message with the elapsed time.
-Several timers can be created with different `msg`. The parameter `msg` is used to link methods `tic(msg)` and `toc(msg)`,
-so the time is measured from tic to toc.Before a toc there must be a tic, so if there is not a `tic(msg)` with the same `msg` as a `toc(msg)` 
-an exception is risen. 
-Additionally, it can be used as a context manager
-
-Example Usage:
-```python
-    from ong_utils import OngTimer
-    from time import sleep
-
-    #########################################################################################################
-    # Standard use (defining an instance and using tic, toc and toc_loop methods, changing decimal places)
-    #########################################################################################################
-    tic = OngTimer()  # if used OngTimer(False), all prints would be disabled
-    more_precise_tic = OngTimer(decimal_places=6)     # Use decimals parameter to increase decimals (defaults to 3)
-
-    tic.tic("Starting")
-    more_precise_tic.tic("Starting (6 decimals)")
-    for i in range(10):
-        tic.tic("Without loop")
-        sleep(0.15)
-        tic.toc("Without loop")
-        tic.tic("Loop")
-        sleep(0.1)
-        if i != 5:
-            tic.toc_loop("Loop")  # Will print elapsed time up to iter #5
-        else:
-            tic.toc("Loop")  # Will print in this case
-    sleep(1)
-    tic.print_loop("Loop")  # Forces print In any case it would be printed in destruction of tic instance
-    tic.toc("Starting")  # Will print total time of the whole loop
-    more_precise_tic.toc("Starting (6 decimals)")  # Will print total time with 6 decimals
-
-    ########################################################################################
-    # Using toc/toc_loop with a non previously defined msg will raise a ValueError Exception
-    ########################################################################################
-    try:
-        tic.toc("This msg has not been defined in a previous tick so ValueError Exception will be risen")
-    except ValueError as ve:
-        print(ve)
-
-    #############################################################
-    # Use as a context manager. Won't work accumulating in a loop
-    #############################################################
-    with OngTimer(msg="Testing sleep"):
-        print("hello context manager")
-        sleep(0.27)
-    with OngTimer().context_manager("Testing sleep"):  # Exactly same as above
-        print("hello context manager")
-        sleep(0.27)
-    # Use context manager (but testing that it can be disabled)
-    with OngTimer(msg="Testing sleep disabled", enabled=False):
-        print("hello disabled context manager")
-        sleep(0.22)
-    # use global timer as context manager
-    existing_instance = OngTimer()
-    with existing_instance.context_manager("Example using an existing context manager instance"):
-        sleep(.19)
-
-    # Optionally: write also tick using a logger
-    import logging
-    logging.basicConfig(level=logging.DEBUG)
-    with OngTimer(msg="Using a logger", logger=logging, log_level=logging.DEBUG):
-        sleep(0.2)
-
-    ##############################################################
-    # When a timer is deleted, any tic without toc will be printed
-    ##############################################################
-    forgoten_toc_timer = OngTimer()             # This timer will have tics without corresponding toc
-    standard_timer = OngTimer(decimals=6)
-    forgoten_toc_timer_disabled = OngTimer(enabled=False)
-    forgoten_toc_timer.tic("forgotten timer1")
-    forgoten_toc_timer.tic("forgotten timer2")
-    standard_timer.tic("unforgotten timer")
-    forgoten_toc_timer_disabled.tic("forgotten disabled timer")
-    sleep(0.1)
-    standard_timer.toc("unforgotten timer")
-    del forgoten_toc_timer   # Will print elapsed time, as are pending tocs
-    del standard_timer   # Prints nothing (as there is not pending tic)
-    del forgoten_toc_timer_disabled     # Prints nothing (is disabled)
-
-    #####################################################
-    # Use .msgs property to iterate over all named timers
-    #####################################################
-    loop_timer = OngTimer()
-    for _ in range(10):
-        loop_timer.tic("hello1")
-        loop_timer.tic("hello2")
-        sleep(0.1)
-        loop_timer.toc_loop("hello1")
-        loop_timer.toc_loop("hello2")
-    for msg in loop_timer.msgs:
-        loop_timer.print_loop(msg)
-
-```
-## Urllib3 utils
-Module ong_utils.urllib3 includes simple functions to treat cookies in urllib3.
-
-Example:
-```python
-from ong_utils import create_pool_manager, cookies2header, get_cookies
-url = "whichevervalidurl"
-http = create_pool_manager()    # Creates a PoolManager with retries
-req = http.request("get", url)
-# get cookies (as a dict)
-cookies = get_cookies(req)
-headers = {"Accept": "text/html;application/json"}
-# append cookies to the headers dict
-headers.update(cookies2header(cookies))
-req.http.request("get", url, headers=headers)       # Using cookies from previous response
-```
-
-## Make shortcuts for entry points
-
-You can create desktop shortcuts for each entry point in the script to easily launch them in your system.
-
-You have to install optional dependency `pip install ong_utils[shortcuts]`
-
-**NOTE**: for the shortcut to work, each entry point defined in e.g. `script_file` of package `package` must be
-executable with `python -m package.script_file`
-
-There are two ways to create shortcuts:
-
-* **Create shortcuts when installing with pip:** valid when installing from git (e.g. pip install
-  git+https://github.com/someone/somerepo.git). Uses a custom postinstall
-  script that creates the desktop launcher and modifies the wheel file (so they can be uninstalled) after building the
-  wheel file from sources.
-* **Create a script and run it manually after install:** valid for any other case. Create a entry_point
-  e.g. `post_install` and call it manually after installation. That scritp will create the shortcut(s) and add it/them
-  to
-  the `RECORD`file so the shortcut will be later uninstalled
-
-### Create the shortcut when installing with PIP
-
-Create a `setup.py` in your root directory and add the following code:
-
-```python
-from setuptools import setup
-from ong_utils.desktop_shortcut import PipCreateShortcut
-
-setup(cmdclass={'bdist_wheel': PipCreateShortcut})
-
-```
-
-In your `pyproject.toml` add the following:
-
-```toml
-[build-system]
-requires = [
-    "setuptools",
-    "wheel",
-    "ong_utils[shortcuts]"
-]
-[project.scripts]
-script1 = "package.file:function"
-```
-
-Then the program will install the wheel from pip and create a desktop shortcut for script1.
-
-### Create a manual script
-
-Provided that you have the following entry point in your `pyproject.toml`:
-
-```toml
-[project.scripts]
-script1 = "mypackage.myscript:myfunction"
-```
-
-You'll have to create a script in your code. Let's call it `post_install.py` with the following content:
-
-```python
-from ong_utils.desktop_shortcut import PostInstallCreateShortcut
-
-
-def main():
-    PostInstallCreateShortcut("your_library_name").make_shortcuts()
-
-
-if __name__ == '__main__':
-    main()
-```
-
-Assuming that `post_install.py` script is in the `mypackage` folder, then you have to ask the user to run it manually
-after installation:
-
-```bash
-pip install mypackage
-python -m mypackage.post_install
-```
-
-**NOTE**: optionally, you can add icons to the shorcut with png format or icns
-format (for mac), provided that the icons have the same name as the entry_point. The program will use the first icon
-that matches the name of the entry point.
-
-## Nicer output pandas DataFrame to Excel
-You can export a pandas DataFrame to Excel nicely formated (converted to an Excel Table, with autofilter enabled and columns widths autofitted)
-
-Example:
-```python
-import pandas as pd
-from ong_utils import df_to_excel
-
-with pd.ExcelWriter(filename) as writer:
-    df_to_excel(df, writer, sheet_name)
-```
-
-## Decoding jwt tokens
-Needs install extra packages with `pip install ong_utils[jwt]`
-
-Use `ong_utils.decode_jwt_token` to decode a jwt token into a dict. 
-
-Use `ong_utils.decode_jwt_token_expiry` to decode expiration as a datetime object. 
-
-## Parsing html pages
-To extract simple values without the need for BeautifulSoup, you can use `find_js_variable`
-
-```python
-from ong_utils import find_js_variable
-source = """
-Imagine this is a website
-var_name1="value1"
-var_name2={"key1":"value2"}
-"""
-find_js_variable(source, 'var_name1')       # returns "value1"
-find_js_variable(source, "var_name", ":")   # returns "value2"
-```
-
-## Control webpages with selenium
-Install `ong_utils[selenium]` to control websites with selenium
-
-```python
-from ong_utils import Chrome
-
-# Use it as a context manager
-with Chrome(block_pages="https://www.marca.com") as chrome:
-    driver = chrome.get_driver()
-    driver.get("https://www.google.com")
-    driver.implicitly_wait(5)
-    driver.get("https://www.marca.com")
-    driver.implicitly_wait(5)
-
-# Or close driver explicitly
-chrome = Chrome()
-driver = chrome.get_driver()
-driver.get("www.someserver.com")
-chrome.quit_driver()
-
-###############################
-# Wait for a cookie in a request
-###############################
-driver = chrome.wait_for_cookie("someserver.com", "somecookie", timeout_headless=10, timeout=60)
-if driver:
-  cookies = driver.get_cookies()
-  
-###############################
-# Wait for a certain request
-###############################
-req = chrome.wait_for_request("someserver.com", "someserver.com/api/interesting_endpoint", timeout_headless=10, timeout=60)
-if req:
-    auth = req.headers['Authorization'].split(" ")[-1]
-# or the same shorter...
-token = chrome.wait_for_auth_token("someserver.com", "someserver.com/api/interesting_endpoint", timeout_headless=10, timeout=60)
-if token:
-    do_stuff_here()
-```
-## Utilities for Office
-
-### Create instances of office programs
-Use classes in `ong_utils.office.office`, to open files with Offfice API in windows.
-
-Avoids problems with cache that might happen from time to time,
-
-Sample code:
-
-````python
-from ong_utils.office.office_base import WordBase, ExcelBase, PowerpointBase
-
-
-class MyWord(WordBase):
-  def __init__(self, file, logger):
-    super().__init__(logger)
-    self.file = self.client.Open(file)
-
-
-````
-
-### Add Sensitivy Labels to office files
-Use a sample office file to apply sensitivity labels to other file, or if you know the label name, apply the label name.
-
-Works properly with Internal and Public, might not work well with Private or Restricted files
-
-Sample code;
-````python
-from ong_utils import SensitivityLabel
-# Case 1: you know the sensitivity label to apply
-sl = SensitivityLabel("XXXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX")
-sl.apply(my_filename)
-# Case 2: you don't know label name, but what to clone an existing one (must be an Excel/Word/Powerpoint file)
-SensitivityLabel(reference_file).apply(my_file)
-# Case 3: get label name from a file and print it
-print(label_id:=SensitivityLabel(reference_file).label_id)
-# label_id can be used to apply to further docs, e.g.: SensitivityLabel(label_id).apply(filename)
-````
-
-## Get current user and domain
-Reads it from environ variables
-```python
-from ong_utils import get_current_user, get_current_domain
-print(get_current_user())       # Prints current user
-print(get_current_domain())     # Prints current domain. Could be empty
-```
-
-## Verify password of current log in user
-Install `ong_utils[credentials]` to check correct password for current user. Works in windows and linux/macos
-```python
-from ong_utils import verify_credentials
-username = "your current username" # get it from ong_utils.get_current_user()
-domain = "your domain, needed in windows"   # For linux/macos could be empty. Get it from ong_utils.get_current_domain()
-password = "your password goes here"
-if verify_credentials(username, domain, password):
-  print("Your password is ok")
-else:
-  print("Bad password")
-```
-
-## Simple dialogs
-Use `ong_utils.simple_dialog` for build a dialog with custom controls and validations.
-Use `user_domain_password_dialog` for a dialog that shows username, domain and password.
-
-### Custom dialog
-Use `ong_utils.dialog` to build a dialog with multiple string entry items and custom validations. You have to inform the elements of the dialog using a list of `ong_utils.ui.UiField` classes
-
-Sample code to show the following window:
-![dialog_form_macos.png](img%2Fdialog_form_macos.png)
-```python
-from ong_utils import simple_dialog, get_current_domain, get_current_user
-from ong_utils.ui import UiField
-# Optional function to validate credentials. Could be other function or None
-from ong_utils import verify_credentials
-field_list = [UiField(name="domain",        # Key of the dict in the return dictionary and for validation functions 
-                      label="Domain",       # Name to the shown for the user
-                      default_value=get_current_domain(),    # Default value to be used
-                      editable=False        # Not editable (by default all fields are editable)
-                      ),
-              UiField(name="username", label="User", default_value=get_current_user()),
-              UiField(name="password", label="Password", default_value="",
-                      show="*",         # Hides password by replacing with *
-                      validation_func=verify_credentials    # The validation function receives values of all fields, so should accept extra **kwargs
-                      ),
-              UiField(name="server", label="Server",
-                      width=40      # Use width parameter to make this Entry field longer. Use it in all to make all fields longer
-                      )]
-# Call the function to open the login window with custom options
-res = simple_dialog(title="Sample form", description="Show descriptive message for the user",
-                   field_list=field_list)
-print(res)
-```
-
-### Login dialog form for username, domain and password
-In the case of a simple login form such as
-![login_form_macos.png](img%2Flogin_form_macos.png)
-use the following code
-```python
-from ong_utils import user_domain_password_dialog
-
-def validation(**kwargs) -> bool:
-  """A function that receives a dict and returns bool
-  the dict receives the keys username, domain and password.
-  Could use the ong_utils.verify_credentials to verify against current log in user
-  """
-  if len(kwargs['password']) > 5:
-    return True
-  else:
-    return False
-
-# This will show a form with current username and domain (not editable) and a password (that will be shown with *)
-result = user_domain_password_dialog(title="your title goes here",
-                                     description="A label to show context to the user",
-                                     validate_password=validation, # pass None to skip validation
-                                     parent=None    # or the main window to use
-                                     )
-print(result)   # could be {} if user cancelled or a dict of "username", "domain", "password"
-```
-## Selecting folders, files and viewing passwords
-Use the `button` property of the `UiField` to allow selecting files, folders and viewing passwords, by creating a button 
-to the right of the entry fields: 
-* Add a `UiFileButton()` to select and validate for exiting files
-* Add a `UiFolderButton()` to select and validate for exiting folders
-* Add a `UiPasswordButton()` to a password field to show or hide passwords
-See the code bellow for this example:
-![dialog_buttons_win.png](img%2Fdialog_buttons_win.png)
-````python
-from ong_utils import simple_dialog
-from ong_utils.ui import UiField, UiFileButton, UiPasswordButton, UiFolderButton
-field_list = [UiField(name="domain",  # Key of the dict in the return dictionary and for validation functions
-                      label="Domain",  # Name to the shown for the user
-                      default_value="fake domain",  # Default value to be used
-                      editable=False  # Not editable
-                      ),
-              UiField(name="username", label="User", default_value="fake user",
-                      editable=False,
-                      ),
-              UiField(name="password", label="Password", default_value="",
-                      show="*",  # Hides password by replacing with *
-                      # validation_func=verify_credentials
-                      # The validation function receives values of all fields, so should accept extra **kwargs
-                      button=UiPasswordButton()
-                      ),
-              UiField(name="server", label="Server",
-                      width=40),
-              # Will ask for a folder and validate that exists
-              UiField(name="folder", label="Folder", button=UiFolderButton(), width=80),
-              # Will ask for a file and validate that exists
-              UiField(name="file", label="File", button=UiFileButton(), width=90),
-              ]
-# Call the function to open the login window with custom options
-res = simple_dialog(title="Sample form", description="Show descriptive message for the user",
-                    field_list=field_list)
-print(res)
-
-````
-
-## Print and logging tkinter handlers
-You can use `print2widget` and `log2widget` to redirect any `print` or log to an Entry tkinter widget. See the following example:
-````python
-import tkinter as tk
-import logging
-from ong_utils import print2widget, logger2widget
-
-class Simple:
-    def __init__(self, title: str = "Simple logger"):
-        self.root = tk.Tk()
-        self.title = title
-        
-        self.root.title(self.title)
-
-        # Central area for logs
-        self.text_area = tk.Text(self.root, font=("Arial", 12))
-        self.text_area.pack(fill='both', expand=True)
-        # Redirects all prints from now onwards to text_area
-        print2widget(self.text_area)
-        self.logger = logging.getLogger(__name__)
-        logger2widget(self.logger, self.text_area)
-        
-if __name__ == '__main__':
-    app = Simple()
-    app.root.mainloop()
-    """Any call to print() or logger.info() will be shown in app.text_area"""
- 
-````
-
-## Fix windows scaling
-As answered in [https://stackoverflow.com/a/43046744](https://stackoverflow.com/a/43046744), in Windows 10 or 11, tk applications texts look blurry, such as:
-
-![blurry_form_windows.png](img%2Fblurry_form_windows.png)
-
-Use the function `fix_windows_gui_scale` to make it look properly like this:
-
-![sharpened_form_windows.png](img%2Fsharpened_form_windows.png)
-
-Some sample code (works in any OS, but will only sharpen texts in Windows):
-````python
-from ong_utils import fix_windows_gui_scale
-fix_windows_gui_scale()
-import tkinter as tk
-from tkinter import ttk
-# write your GUI code here...
-````
+Metadata-Version: 2.1
+Name: ong_utils
+Version: 0.6.6
+Summary: Common utilities for python projects
+Author-email: Oscar Neira <oneirag@yahoo.es>
+Project-URL: Homepage, https://github.com/Oneirag/ong_utils
+Project-URL: Source, https://github.com/Oneirag/ong_utils
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+Requires-Dist: pip-system-certs
+Requires-Dist: certifi
+Requires-Dist: urllib3
+Requires-Dist: pyopenssl
+Requires-Dist: python-dateutil
+Requires-Dist: pyyaml
+Requires-Dist: ujson
+Requires-Dist: idna
+Requires-Dist: keyring
+Provides-Extra: all
+Requires-Dist: selenium ; extra == 'all'
+Requires-Dist: selenium-wire ; extra == 'all'
+Requires-Dist: undetected-chromedriver ; extra == 'all'
+Requires-Dist: openpyxl ; extra == 'all'
+Requires-Dist: pandas ; extra == 'all'
+Requires-Dist: pyshortcuts ; extra == 'all'
+Requires-Dist: wheel ; extra == 'all'
+Requires-Dist: pyjwt ; extra == 'all'
+Requires-Dist: pywin32 ; extra == 'all'
+Requires-Dist: python-pam ; (platform_system != "Windows") and extra == 'all'
+Requires-Dist: pywin32 ; (platform_system == "Windows") and extra == 'all'
+Requires-Dist: Pillow ; (sys_platform != "darwin") and extra == 'all'
+Requires-Dist: icnsutil ; (sys_platform == "darwin") and extra == 'all'
+Provides-Extra: credentials
+Requires-Dist: python-pam ; (platform_system != "Windows") and extra == 'credentials'
+Requires-Dist: pywin32 ; (platform_system == "Windows") and extra == 'credentials'
+Provides-Extra: jwt
+Requires-Dist: pyjwt ; extra == 'jwt'
+Provides-Extra: office
+Requires-Dist: pywin32 ; extra == 'office'
+Provides-Extra: selenium
+Requires-Dist: selenium ; extra == 'selenium'
+Requires-Dist: selenium-wire ; extra == 'selenium'
+Requires-Dist: undetected-chromedriver ; extra == 'selenium'
+Provides-Extra: shortcuts
+Requires-Dist: pyshortcuts ; extra == 'shortcuts'
+Requires-Dist: wheel ; extra == 'shortcuts'
+Requires-Dist: Pillow ; (sys_platform != "darwin") and extra == 'shortcuts'
+Requires-Dist: icnsutil ; (sys_platform == "darwin") and extra == 'shortcuts'
+Provides-Extra: xlsx
+Requires-Dist: openpyxl ; extra == 'xlsx'
+Requires-Dist: pandas ; extra == 'xlsx'
+
+Ong_Utils
+=========
+
+## Description
+Simple package with some utils to import in any project:
+* class to manage configuration files in yaml or json [Read more](#configuration-files). It also uses `keyring` to store and retrieve passwords. [Read more](#passwords)  
+* logger and a timer to record elapsed times for optimizing some processes. [Read more](#timers)
+* a `create_pool_manager` function to create instances of urllib3.PoolManager with retries and timeouts and checking of 
+https connections. [Read more](#urllib3-utils)
+* a `TZ_LOCAL` variable with the local timezone
+of the computer).   
+* an `is_debugging` function that returns True when debugging code
+* a `to_list` function to convert any non-list value (specifically strings to avoid iterating char by char) into a list
+* a `cookies2header` that converts cookies in dict to header field 'Cookie' for use in urllib3. [Read more](#urllib3-utils)
+* a `get_cookies` function to extract a dict of cookies from a response of a urllib3 request. [Read more](#urllib3-utils)
+* a class to store any data into keyring (e.g. strings, dicts...). [Read more](#storing-long-data-in-keyring)
+* functions to parse html pages and extract javascript variables (such as CSRF tokens or links). [Read more](#parsing-html-pages)
+* Class to read/apply sensitivity labels to a file (Public, Internal...) [Read more](#add-sensitivy-labels-to-office-files). It is adapated from https://github.com/brunomsantiago/mip_python
+* functions to get current user and domain. [Read more](#get-current-user-and-domain)
+* functions for simple input dialogs with validations using tk [Read more](#simple-dialogs)
+* a function `fix_windows_gui_scale` to avoid blurry tkinter text elements in Windows 10 or 11. [Read more](#fix-windows-scaling)
+* Handlers to redirect prints and logging to an Entry tkinter widget [Read more](#print-and-logging-tkinter-handlers)
+### Optional dependencies
+Installing `pip install ong_utils[shortcuts]`:
+* functions to create desktop shortcuts for packages installed with pip. [Read more](#make-shortcuts-for-entry-points)
+
+Installing `pip install ong_utils[xlsx]`:
+* function to export a pandas dataframe into a xlsx excel sheet.[Read more](#nicer-output-pandas-dataframe-to-excel) 
+
+Installing `pip install ong_utils[jwt]`:
+* functions to decode access tokens. [Read more](#decoding-jwt-tokens)
+
+Installing `pip install ong_utils[selenium]`:
+* class to manage Chrome using selenium. [Read more](#control-webpages-with-selenium)
+
+Installing `pip install ong_utils[office]`:
+* Classes to interact with API of Office in windows. [Read more](#create-instances-of-office-programs)
+
+Installing `pip install ong_utils[credentials]`:
+* function to verify password of current log in user. [Read more](#control-webpages-with-selenium)
+
+## General usage
+Simple example of an __init__.py in a package ("mypackage") using ong_utils:
+```python
+import pandas as pd
+from ong_utils import OngConfig, LOCAL_TZ, OngTimer
+_cfg = OngConfig("mypackage")
+config = _cfg.config
+logger = _cfg.logger
+```
+And usage in other parts of the code of "mypackage":
+```python
+import pandas as pd
+from mypackage import config, logger, LOCAL_TZ, http
+local_now = pd.Timestamp.now(tz=LOCAL_TZ)
+res = http.request("GET", config('url'))
+logger.info("Sample log")
+```
+### Advanced usage
+Default values can be supplied, so a new file is created with the default values if it does not exist previously
+```python
+from ong_utils import OngConfig
+# The following code will create the config file with given default values and
+# will also raise an exception to stop the program so the user can review the file
+default_app_values = dict(a_kew=a_value)
+cfg = OngConfig(default_app_cfg=default_app_values)
+
+# The following code will create the config file with given default values and
+# but won't raise any exception, so the process will continue
+# This approach is usefull when the default values can be used without further edition
+default_app_values = dict(a_kew=a_value)
+cfg = OngConfig(default_app_cfg=default_app_values, 
+                write_default_file=True)
+
+```
+Values could be updated and writen to the config file during the execution of the code
+
+```python
+from ong_utils import OngConfig
+
+# Assume file already exists
+cfg = OngConfig("app_name")
+...
+# Add a new key and saves the config file. If the key existed, raises ValueError
+cfg.add_app_config("new key", "new value")
+print(cfg.config("new key"))  # Will print new value
+# Updates an existing key and saves in the config file. If the key did not exist, raises ValueError
+cfg.update_app_config("new key", "new value")
+print(cfg.config("new key"))  # Will print new value
+
+
+```
+
+
+
+## Configuration files
+Config files are yaml/json files located (by default) in `~/.config/ongpi/{project_name}.{extension}`. 
+The file extension can be yaml, yml, json or js.
+File can have this form:
+```yaml
+my_project:
+  sample_key1: sample_value1
+  sample_key2: sample_value2
+log:
+  optional_log_config: values
+# This is an optional section, for values used just in tests
+my_project_test:
+  sample_key1: sample_value1
+  sample_key2: sample_value2
+
+```
+or this
+```json
+{
+  "my_project": {
+    "sample_key1": sample_value1,
+    "sample_key2": "sample_value2"
+  },
+  "log": {
+    "optional_log_config": value
+  }
+}
+```
+Config files must have a section with the name the project.   OngConfig.config("key") will raise an Exception if "key" is undefined, unless
+a default value is used (OngConfig.config("key", "default_value"))  
+If a file_path is supplied as second argument to the constructor, that file will be used. In that case many projects
+can share the same config file. E.g. if config file is /etc/myconfig.yaml, ti can has this form:
+```yaml
+project_name1:
+  key_for_project1: value
+project_name2:
+  key_for_project2: value
+# Optional: test values for project_name2
+project_name2_test:
+  key_for_project2: value
+```
+and config method can only access to configuration of current project.
+
+New values can be added to the configuration in execution time by calling `add_app_config`. That will persist the new values in the configuration file.
+### Passwords
+Module uses keyring to store passwords
+```python
+from ong_utils import OngConfig
+# configuration file should have "service" and "user" keys
+_cfg = OngConfig("mypackage")
+config = _cfg.config
+get_password = _cfg.get_password
+set_password = _cfg.set_password
+
+# Sets password (prompts user)
+set_password("service", "user")
+# Equivalent to keyring.set_password(config("service"), config("user"), input())
+# Gets password
+pwd = get_password("service", "user")
+# Equivalent to keyring.get_password(config("service"), config("user"))
+```
+## Storing long data in keyring
+### Storing json-serializable data
+For storing long passwords (e.g. a jwt_token) or non string data (e.g. a dictionary of cookies), use `ong_utils.InternalStorage` class.
+```python
+from ong_utils import InternalStorage
+
+internal_storage = InternalStorage("your app name")
+for value to store in [
+        "long string" * 120,
+        {"an": "example", "of": "dictionary"}
+        ]:
+  key_name = "sample_key"
+  internal_storage.store_value(key_name, value)
+  stored = internal_storage.get_value("key name")
+  assert value == stored
+  internal_storage.remove_stored_value()
+
+```
+### Storing cookies from requests.session objects
+`CookieJar` objects are not json serializable. To store cookies you'll have to turn into list of dicts. 
+
+Use functions in `requests.cookies` package to make conversions before storing/retrieving them as dicts
+
+```python
+# Assume session is a request.session.Session object
+cookies = session.cookies
+cookie_dict = [dict(name=c.name, value=c.value, domain=c.domain, path=c.path, expires=c.expires)
+               for c in cookies]
+# Store cookie_dict normally
+
+# Code for updating session from cookie_dict
+import requests.cookies
+
+# Assume cookie_dict is the same as above
+cookies = [requests.cookies.create_cookie(**c) for c in cookies_dict]
+for cookie in cookies:
+    session.cookies.set_cookie(cookie)
+```
+
+## Timers
+`OngTimer` class uses `tic(msg)` to start timer and `toc(msg)` to stop timer and show a message with the elapsed time.
+Several timers can be created with different `msg`. The parameter `msg` is used to link methods `tic(msg)` and `toc(msg)`,
+so the time is measured from tic to toc.Before a toc there must be a tic, so if there is not a `tic(msg)` with the same `msg` as a `toc(msg)` 
+an exception is risen. 
+Additionally, it can be used as a context manager
+
+Example Usage:
+```python
+    from ong_utils import OngTimer
+    from time import sleep
+
+    #########################################################################################################
+    # Standard use (defining an instance and using tic, toc and toc_loop methods, changing decimal places)
+    #########################################################################################################
+    tic = OngTimer()  # if used OngTimer(False), all prints would be disabled
+    more_precise_tic = OngTimer(decimal_places=6)     # Use decimals parameter to increase decimals (defaults to 3)
+
+    tic.tic("Starting")
+    more_precise_tic.tic("Starting (6 decimals)")
+    for i in range(10):
+        tic.tic("Without loop")
+        sleep(0.15)
+        tic.toc("Without loop")
+        tic.tic("Loop")
+        sleep(0.1)
+        if i != 5:
+            tic.toc_loop("Loop")  # Will print elapsed time up to iter #5
+        else:
+            tic.toc("Loop")  # Will print in this case
+    sleep(1)
+    tic.print_loop("Loop")  # Forces print In any case it would be printed in destruction of tic instance
+    tic.toc("Starting")  # Will print total time of the whole loop
+    more_precise_tic.toc("Starting (6 decimals)")  # Will print total time with 6 decimals
+
+    ########################################################################################
+    # Using toc/toc_loop with a non previously defined msg will raise a ValueError Exception
+    ########################################################################################
+    try:
+        tic.toc("This msg has not been defined in a previous tick so ValueError Exception will be risen")
+    except ValueError as ve:
+        print(ve)
+
+    #############################################################
+    # Use as a context manager. Won't work accumulating in a loop
+    #############################################################
+    with OngTimer(msg="Testing sleep"):
+        print("hello context manager")
+        sleep(0.27)
+    with OngTimer().context_manager("Testing sleep"):  # Exactly same as above
+        print("hello context manager")
+        sleep(0.27)
+    # Use context manager (but testing that it can be disabled)
+    with OngTimer(msg="Testing sleep disabled", enabled=False):
+        print("hello disabled context manager")
+        sleep(0.22)
+    # use global timer as context manager
+    existing_instance = OngTimer()
+    with existing_instance.context_manager("Example using an existing context manager instance"):
+        sleep(.19)
+
+    # Optionally: write also tick using a logger
+    import logging
+    logging.basicConfig(level=logging.DEBUG)
+    with OngTimer(msg="Using a logger", logger=logging, log_level=logging.DEBUG):
+        sleep(0.2)
+
+    ##############################################################
+    # When a timer is deleted, any tic without toc will be printed
+    ##############################################################
+    forgoten_toc_timer = OngTimer()             # This timer will have tics without corresponding toc
+    standard_timer = OngTimer(decimals=6)
+    forgoten_toc_timer_disabled = OngTimer(enabled=False)
+    forgoten_toc_timer.tic("forgotten timer1")
+    forgoten_toc_timer.tic("forgotten timer2")
+    standard_timer.tic("unforgotten timer")
+    forgoten_toc_timer_disabled.tic("forgotten disabled timer")
+    sleep(0.1)
+    standard_timer.toc("unforgotten timer")
+    del forgoten_toc_timer   # Will print elapsed time, as are pending tocs
+    del standard_timer   # Prints nothing (as there is not pending tic)
+    del forgoten_toc_timer_disabled     # Prints nothing (is disabled)
+
+    #####################################################
+    # Use .msgs property to iterate over all named timers
+    #####################################################
+    loop_timer = OngTimer()
+    for _ in range(10):
+        loop_timer.tic("hello1")
+        loop_timer.tic("hello2")
+        sleep(0.1)
+        loop_timer.toc_loop("hello1")
+        loop_timer.toc_loop("hello2")
+    for msg in loop_timer.msgs:
+        loop_timer.print_loop(msg)
+
+```
+## Urllib3 utils
+Module ong_utils.urllib3 includes simple functions to treat cookies in urllib3.
+
+Example:
+```python
+from ong_utils import create_pool_manager, cookies2header, get_cookies
+url = "whichevervalidurl"
+http = create_pool_manager()    # Creates a PoolManager with retries
+req = http.request("get", url)
+# get cookies (as a dict)
+cookies = get_cookies(req)
+headers = {"Accept": "text/html;application/json"}
+# append cookies to the headers dict
+headers.update(cookies2header(cookies))
+req.http.request("get", url, headers=headers)       # Using cookies from previous response
+```
+
+## Make shortcuts for entry points
+
+You can create desktop shortcuts for each entry point in the script to easily launch them in your system.
+
+You have to install optional dependency `pip install ong_utils[shortcuts]`
+
+**NOTE**: for the shortcut to work, each entry point defined in e.g. `script_file` of package `package` must be
+executable with `python -m package.script_file`
+
+There are two ways to create shortcuts:
+
+* **Create shortcuts when installing with pip:** valid when installing from git (e.g. pip install
+  git+https://github.com/someone/somerepo.git). Uses a custom postinstall
+  script that creates the desktop launcher and modifies the wheel file (so they can be uninstalled) after building the
+  wheel file from sources.
+* **Create a script and run it manually after install:** valid for any other case. Create a entry_point
+  e.g. `post_install` and call it manually after installation. That scritp will create the shortcut(s) and add it/them
+  to
+  the `RECORD`file so the shortcut will be later uninstalled
+
+### Create the shortcut when installing with PIP
+
+Create a `setup.py` in your root directory and add the following code:
+
+```python
+from setuptools import setup
+from ong_utils.desktop_shortcut import PipCreateShortcut
+
+setup(cmdclass={'bdist_wheel': PipCreateShortcut})
+
+```
+
+In your `pyproject.toml` add the following:
+
+```toml
+[build-system]
+requires = [
+    "setuptools",
+    "wheel",
+    "ong_utils[shortcuts]"
+]
+[project.scripts]
+script1 = "package.file:function"
+```
+
+Then the program will install the wheel from pip and create a desktop shortcut for script1.
+
+### Create a manual script
+
+Provided that you have the following entry point in your `pyproject.toml`:
+
+```toml
+[project.scripts]
+script1 = "mypackage.myscript:myfunction"
+```
+
+You'll have to create a script in your code. Let's call it `post_install.py` with the following content:
+
+```python
+from ong_utils.desktop_shortcut import PostInstallCreateShortcut
+
+
+def main():
+    PostInstallCreateShortcut("your_library_name").make_shortcuts()
+
+
+if __name__ == '__main__':
+    main()
+```
+
+Assuming that `post_install.py` script is in the `mypackage` folder, then you have to ask the user to run it manually
+after installation:
+
+```bash
+pip install mypackage
+python -m mypackage.post_install
+```
+
+**NOTE**: optionally, you can add icons to the shorcut with png format or icns
+format (for mac), provided that the icons have the same name as the entry_point. The program will use the first icon
+that matches the name of the entry point.
+
+## Nicer output pandas DataFrame to Excel
+You can export a pandas DataFrame to Excel nicely formated (converted to an Excel Table, with autofilter enabled and columns widths autofitted)
+
+Example:
+```python
+import pandas as pd
+from ong_utils import df_to_excel
+
+with pd.ExcelWriter(filename) as writer:
+    df_to_excel(df, writer, sheet_name)
+```
+
+## Decoding jwt tokens
+Needs install extra packages with `pip install ong_utils[jwt]`
+
+Use `ong_utils.decode_jwt_token` to decode a jwt token into a dict. 
+
+Use `ong_utils.decode_jwt_token_expiry` to decode expiration as a datetime object. 
+
+## Parsing html pages
+To extract simple values without the need for BeautifulSoup, you can use `find_js_variable`
+
+```python
+from ong_utils import find_js_variable
+source = """
+Imagine this is a website
+var_name1="value1"
+var_name2={"key1":"value2"}
+"""
+find_js_variable(source, 'var_name1')       # returns "value1"
+find_js_variable(source, "var_name", ":")   # returns "value2"
+```
+
+## Control webpages with selenium
+Install `ong_utils[selenium]` to control websites with selenium
+
+```python
+from ong_utils import Chrome
+
+# Use it as a context manager
+with Chrome(block_pages="https://www.marca.com") as chrome:
+    driver = chrome.get_driver()
+    driver.get("https://www.google.com")
+    driver.implicitly_wait(5)
+    driver.get("https://www.marca.com")
+    driver.implicitly_wait(5)
+
+# Or close driver explicitly
+chrome = Chrome()
+driver = chrome.get_driver()
+driver.get("www.someserver.com")
+chrome.quit_driver()
+
+###############################
+# Wait for a cookie in a request
+###############################
+driver = chrome.wait_for_cookie("someserver.com", "somecookie", timeout_headless=10, timeout=60)
+if driver:
+  cookies = driver.get_cookies()
+  
+###############################
+# Wait for a certain request
+###############################
+req = chrome.wait_for_request("someserver.com", "someserver.com/api/interesting_endpoint", timeout_headless=10, timeout=60)
+if req:
+    auth = req.headers['Authorization'].split(" ")[-1]
+# or the same shorter...
+token = chrome.wait_for_auth_token("someserver.com", "someserver.com/api/interesting_endpoint", timeout_headless=10, timeout=60)
+if token:
+    do_stuff_here()
+```
+## Utilities for Office
+
+### Create instances of office programs
+Use classes in `ong_utils.office.office`, to open files with Offfice API in windows.
+
+Avoids problems with cache that might happen from time to time,
+
+Sample code:
+
+````python
+from ong_utils.office.office_base import WordBase, ExcelBase, PowerpointBase
+
+
+class MyWord(WordBase):
+  def __init__(self, file, logger):
+    super().__init__(logger)
+    self.file = self.client.Open(file)
+
+
+````
+
+### Add Sensitivy Labels to office files
+Use a sample office file to apply sensitivity labels to other file, or if you know the label name, apply the label name.
+
+Works properly with Internal and Public, might not work well with Private or Restricted files
+
+Sample code;
+````python
+from ong_utils import SensitivityLabel
+# Case 1: you know the sensitivity label to apply
+sl = SensitivityLabel("XXXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX")
+sl.apply(my_filename)
+# Case 2: you don't know label name, but what to clone an existing one (must be an Excel/Word/Powerpoint file)
+SensitivityLabel(reference_file).apply(my_file)
+# Case 3: get label name from a file and print it
+print(label_id:=SensitivityLabel(reference_file).label_id)
+# label_id can be used to apply to further docs, e.g.: SensitivityLabel(label_id).apply(filename)
+````
+
+## Get current user and domain
+Reads it from environ variables
+```python
+from ong_utils import get_current_user, get_current_domain
+print(get_current_user())       # Prints current user
+print(get_current_domain())     # Prints current domain. Could be empty
+```
+
+## Verify password of current log in user
+Install `ong_utils[credentials]` to check correct password for current user. Works in windows and linux/macos
+```python
+from ong_utils import verify_credentials
+username = "your current username" # get it from ong_utils.get_current_user()
+domain = "your domain, needed in windows"   # For linux/macos could be empty. Get it from ong_utils.get_current_domain()
+password = "your password goes here"
+if verify_credentials(username, domain, password):
+  print("Your password is ok")
+else:
+  print("Bad password")
+```
+
+## Simple dialogs
+Use `ong_utils.simple_dialog` for build a dialog with custom controls and validations.
+Use `user_domain_password_dialog` for a dialog that shows username, domain and password.
+
+### Custom dialog
+Use `ong_utils.dialog` to build a dialog with multiple string entry items and custom validations. You have to inform the elements of the dialog using a list of `ong_utils.ui.UiField` classes
+
+Sample code to show the following window:
+![dialog_form_macos.png](img%2Fdialog_form_macos.png)
+```python
+from ong_utils import simple_dialog, get_current_domain, get_current_user
+from ong_utils.ui import UiField
+# Optional function to validate credentials. Could be other function or None
+from ong_utils import verify_credentials
+field_list = [UiField(name="domain",        # Key of the dict in the return dictionary and for validation functions 
+                      label="Domain",       # Name to the shown for the user
+                      default_value=get_current_domain(),    # Default value to be used
+                      editable=False        # Not editable (by default all fields are editable)
+                      ),
+              UiField(name="username", label="User", default_value=get_current_user()),
+              UiField(name="password", label="Password", default_value="",
+                      show="*",         # Hides password by replacing with *
+                      validation_func=verify_credentials    # The validation function receives values of all fields, so should accept extra **kwargs
+                      ),
+              UiField(name="server", label="Server",
+                      width=40      # Use width parameter to make this Entry field longer. Use it in all to make all fields longer
+                      ),
+              # This shows a combo box with values Yes and No, selecting Yes as default
+              UiField(name="combo", label="Select one",
+                      valid_values=['Yes', "No"],
+                      default_value="Yes",
+                      ),
+              # This shows an entry field to select a File, but  allows empty values (returns "")
+              UiField(name="file", label="Select File",
+                      allow_empy=True,
+                      button=UiFileButton()
+                      ),
+              
+              ]
+# Call the function to open the login window with custom options
+res = simple_dialog(title="Sample form", description="Show descriptive message for the user",
+                   field_list=field_list)
+print(res)
+```
+
+### Login dialog form for username, domain and password
+In the case of a simple login form such as
+![login_form_macos.png](img%2Flogin_form_macos.png)
+use the following code
+```python
+from ong_utils import user_domain_password_dialog
+
+def validation(**kwargs) -> bool:
+  """A function that receives a dict and returns bool
+  the dict receives the keys username, domain and password.
+  Could use the ong_utils.verify_credentials to verify against current log in user
+  """
+  if len(kwargs['password']) > 5:
+    return True
+  else:
+    return False
+
+# This will show a form with current username and domain (not editable) and a password (that will be shown with *)
+result = user_domain_password_dialog(title="your title goes here",
+                                     description="A label to show context to the user",
+                                     validate_password=validation, # pass None to skip validation
+                                     parent=None    # or the main window to use
+                                     )
+print(result)   # could be {} if user cancelled or a dict of "username", "domain", "password"
+```
+## Selecting folders, files and viewing passwords
+Use the `button` property of the `UiField` to allow selecting files, folders and viewing passwords, by creating a button 
+to the right of the entry fields: 
+* Add a `UiFileButton()` to select and validate for exiting files
+* Add a `UiFolderButton()` to select and validate for exiting folders
+* Add a `UiPasswordButton()` to a password field to show or hide passwords
+See the code bellow for this example:
+![dialog_buttons_win.png](img%2Fdialog_buttons_win.png)
+````python
+from ong_utils import simple_dialog
+from ong_utils.ui import UiField, UiFileButton, UiPasswordButton, UiFolderButton
+field_list = [UiField(name="domain",  # Key of the dict in the return dictionary and for validation functions
+                      label="Domain",  # Name to the shown for the user
+                      default_value="fake domain",  # Default value to be used
+                      editable=False  # Not editable
+                      ),
+              UiField(name="username", label="User", default_value="fake user",
+                      editable=False,
+                      ),
+              UiField(name="password", label="Password", default_value="",
+                      show="*",  # Hides password by replacing with *
+                      # validation_func=verify_credentials
+                      # The validation function receives values of all fields, so should accept extra **kwargs
+                      button=UiPasswordButton(),
+                      ),
+              UiField(name="server", label="Server",
+                      width=40),
+              # Will ask for a folder and validate that exists
+              UiField(name="folder", label="Folder", button=UiFolderButton(), width=80),
+              # Will ask for a file and validate that exists
+              UiField(name="file", label="File", button=UiFileButton(), width=90),
+              # Will ask for a file and validate that exists. If field is empty does not validate it and returns ""
+              UiField(name="empty_file", label="File (empty)", button=UiFileButton(), width=90,
+                      allow_empy=True),
+              ]
+# Call the function to open the login window with custom options
+res = simple_dialog(title="Sample form", description="Show descriptive message for the user",
+                    field_list=field_list)
+print(res)
+
+````
+
+## Print and logging tkinter handlers
+You can use `print2widget` and `log2widget` to redirect any `print` or log to an Entry tkinter widget. See the following example:
+````python
+import tkinter as tk
+import logging
+from ong_utils import print2widget, logger2widget
+
+class Simple:
+    def __init__(self, title: str = "Simple logger"):
+        self.root = tk.Tk()
+        self.title = title
+        
+        self.root.title(self.title)
+
+        # Central area for logs
+        self.text_area = tk.Text(self.root, font=("Arial", 12))
+        self.text_area.pack(fill='both', expand=True)
+        # Redirects all prints from now onwards to text_area
+        print2widget(self.text_area)
+        self.logger = logging.getLogger(__name__)
+        logger2widget(self.logger, self.text_area)
+        
+if __name__ == '__main__':
+    app = Simple()
+    app.root.mainloop()
+    """Any call to print() or logger.info() will be shown in app.text_area"""
+ 
+````
+
+## Fix windows scaling
+As answered in [https://stackoverflow.com/a/43046744](https://stackoverflow.com/a/43046744), in Windows 10 or 11, tk applications texts look blurry, such as:
+
+![blurry_form_windows.png](img%2Fblurry_form_windows.png)
+
+Use the function `fix_windows_gui_scale` to make it look properly like this:
+
+![sharpened_form_windows.png](img%2Fsharpened_form_windows.png)
+
+Some sample code (works in any OS, but will only sharpen texts in Windows):
+````python
+from ong_utils import fix_windows_gui_scale
+fix_windows_gui_scale()
+import tkinter as tk
+from tkinter import ttk
+# write your GUI code here...
+````
```

