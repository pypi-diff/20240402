# Comparing `tmp/sympy_plot_backends-3.1.1.tar.gz` & `tmp/sympy_plot_backends-3.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "sympy_plot_backends-3.1.1.tar", last modified: Tue Mar 19 09:09:11 2024, max compression
+gzip compressed data, was "sympy_plot_backends-3.2.0.tar", last modified: Tue Apr  2 19:34:10 2024, max compression
```

## Comparing `sympy_plot_backends-3.1.1.tar` & `sympy_plot_backends-3.2.0.tar`

### file list

```diff
@@ -1,167 +1,182 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.598389 sympy_plot_backends-3.1.1/
--rw-r--r--   0 runner    (1001) docker     (127)     1523 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (127)       89 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (127)     6543 2024-03-19 09:09:11.598389 sympy_plot_backends-3.1.1/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     4430 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/README.md
--rw-r--r--   0 runner    (1001) docker     (127)       38 2024-03-19 09:09:11.598389 sympy_plot_backends-3.1.1/setup.cfg
--rwxr-xr-x   0 runner    (1001) docker     (127)     2025 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.570389 sympy_plot_backends-3.1.1/spb/
--rw-r--r--   0 runner    (1001) docker     (127)     3670 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)       22 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/_version.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.570389 sympy_plot_backends-3.1.1/spb/backends/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    26372 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/base_backend.py
--rw-r--r--   0 runner    (1001) docker     (127)     2636 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/base_renderer.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.570389 sympy_plot_backends-3.1.1/spb/backends/bokeh/
--rw-r--r--   0 runner    (1001) docker     (127)       54 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    19859 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/bokeh.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.574389 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/
--rw-r--r--   0 runner    (1001) docker     (127)      698 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      806 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/arrow2d.py
--rw-r--r--   0 runner    (1001) docker     (127)     4546 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/complex.py
--rw-r--r--   0 runner    (1001) docker     (127)     1706 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/contour.py
--rw-r--r--   0 runner    (1001) docker     (127)      842 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/generic.py
--rw-r--r--   0 runner    (1001) docker     (127)      943 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/geometry.py
--rw-r--r--   0 runner    (1001) docker     (127)      646 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/hvline.py
--rw-r--r--   0 runner    (1001) docker     (127)     3904 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/line2d.py
--rw-r--r--   0 runner    (1001) docker     (127)     9708 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/vector2d.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.574389 sympy_plot_backends-3.1.1/spb/backends/k3d/
--rw-r--r--   0 runner    (1001) docker     (127)       48 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    16941 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/k3d.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.574389 sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/
--rw-r--r--   0 runner    (1001) docker     (127)      612 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      840 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/arrow3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     2711 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/complex.py
--rw-r--r--   0 runner    (1001) docker     (127)      262 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/geometry.py
--rw-r--r--   0 runner    (1001) docker     (127)      865 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/implicit3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     2424 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/line3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     2877 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/surface.py
--rw-r--r--   0 runner    (1001) docker     (127)     3225 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/vector3d.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.574389 sympy_plot_backends-3.1.1/spb/backends/matplotlib/
--rw-r--r--   0 runner    (1001) docker     (127)      142 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    29582 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/matplotlib.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.578389 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/
--rw-r--r--   0 runner    (1001) docker     (127)     1876 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1301 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/arrow2d.py
--rw-r--r--   0 runner    (1001) docker     (127)     2909 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/arrow3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     5639 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/complex.py
--rw-r--r--   0 runner    (1001) docker     (127)     2289 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/contour.py
--rw-r--r--   0 runner    (1001) docker     (127)      825 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/generic.py
--rw-r--r--   0 runner    (1001) docker     (127)     1604 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/geometry.py
--rw-r--r--   0 runner    (1001) docker     (127)      743 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/hvline.py
--rw-r--r--   0 runner    (1001) docker     (127)     3218 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/implicit2d.py
--rw-r--r--   0 runner    (1001) docker     (127)     3897 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/line2d.py
--rw-r--r--   0 runner    (1001) docker     (127)     2913 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/line3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     2962 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/mcircles.py
--rw-r--r--   0 runner    (1001) docker     (127)     4723 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/ngrid.py
--rw-r--r--   0 runner    (1001) docker     (127)     8928 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/nyquist.py
--rw-r--r--   0 runner    (1001) docker     (127)     1788 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/renderer.py
--rw-r--r--   0 runner    (1001) docker     (127)     2745 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/root_locus.py
--rw-r--r--   0 runner    (1001) docker     (127)     7386 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/sgrid.py
--rw-r--r--   0 runner    (1001) docker     (127)     2900 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/surface.py
--rw-r--r--   0 runner    (1001) docker     (127)     3880 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/vector2d.py
--rw-r--r--   0 runner    (1001) docker     (127)     3731 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/vector3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     3080 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/zgrid.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.578389 sympy_plot_backends-3.1.1/spb/backends/mayavi/
--rw-r--r--   0 runner    (1001) docker     (127)       58 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/mayavi/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9122 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/mayavi/mayavi.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.582388 sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/
--rw-r--r--   0 runner    (1001) docker     (127)      270 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1026 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/implicit3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     1106 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/line3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     1141 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/surface.py
--rw-r--r--   0 runner    (1001) docker     (127)     1405 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/vector3d.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.582388 sympy_plot_backends-3.1.1/spb/backends/plotly/
--rw-r--r--   0 runner    (1001) docker     (127)       57 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    20921 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/plotly.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.582388 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/
--rw-r--r--   0 runner    (1001) docker     (127)     1059 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1126 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/arrow2d.py
--rw-r--r--   0 runner    (1001) docker     (127)     7442 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/complex.py
--rw-r--r--   0 runner    (1001) docker     (127)     1181 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/contour.py
--rw-r--r--   0 runner    (1001) docker     (127)      940 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/generic.py
--rw-r--r--   0 runner    (1001) docker     (127)     1272 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/geometry.py
--rw-r--r--   0 runner    (1001) docker     (127)      729 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/hvline.py
--rw-r--r--   0 runner    (1001) docker     (127)      850 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/implicit3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     5663 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/line2d.py
--rw-r--r--   0 runner    (1001) docker     (127)     3553 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/line3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     1761 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/surface.py
--rw-r--r--   0 runner    (1001) docker     (127)     2212 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/vector2d.py
--rw-r--r--   0 runner    (1001) docker     (127)     3234 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/vector3d.py
--rw-r--r--   0 runner    (1001) docker     (127)    22021 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/backends/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.582388 sympy_plot_backends-3.1.1/spb/ccomplex/
--rw-r--r--   0 runner    (1001) docker     (127)      228 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/ccomplex/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      515 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/ccomplex/complex.py
--rw-r--r--   0 runner    (1001) docker     (127)      218 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/ccomplex/wegert.py
--rw-r--r--   0 runner    (1001) docker     (127)     1028 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/control.py
--rw-r--r--   0 runner    (1001) docker     (127)     8938 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/defaults.py
--rw-r--r--   0 runner    (1001) docker     (127)    13274 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/doc_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     1149 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/functions.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.586389 sympy_plot_backends-3.1.1/spb/graphics/
--rw-r--r--   0 runner    (1001) docker     (127)     1813 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/graphics/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    57633 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/graphics/complex_analysis.py
--rw-r--r--   0 runner    (1001) docker     (127)    95673 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/graphics/control.py
--rw-r--r--   0 runner    (1001) docker     (127)    67311 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/graphics/functions_2d.py
--rw-r--r--   0 runner    (1001) docker     (127)    58630 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/graphics/functions_3d.py
--rw-r--r--   0 runner    (1001) docker     (127)    12105 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/graphics/graphics.py
--rw-r--r--   0 runner    (1001) docker     (127)     6713 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/graphics/utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    31919 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/graphics/vectors.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.586389 sympy_plot_backends-3.1.1/spb/interactive/
--rw-r--r--   0 runner    (1001) docker     (127)     4863 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/interactive/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.586389 sympy_plot_backends-3.1.1/spb/interactive/bootstrap_spb/
--rw-r--r--   0 runner    (1001) docker     (127)     6213 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/interactive/bootstrap_spb/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3665 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/interactive/bootstrap_spb/bootstrap.css
--rw-r--r--   0 runner    (1001) docker     (127)     6582 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/interactive/bootstrap_spb/bootstrap.html
--rw-r--r--   0 runner    (1001) docker     (127)    14679 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/interactive/ipywidgets.py
--rw-r--r--   0 runner    (1001) docker     (127)    38256 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/interactive/panel.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.590389 sympy_plot_backends-3.1.1/spb/plot_functions/
--rw-r--r--   0 runner    (1001) docker     (127)      615 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/plot_functions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    43648 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/plot_functions/complex_analysis.py
--rw-r--r--   0 runner    (1001) docker     (127)    50414 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/plot_functions/control.py
--rw-r--r--   0 runner    (1001) docker     (127)    63806 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/plot_functions/functions_2d.py
--rw-r--r--   0 runner    (1001) docker     (127)    39225 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/plot_functions/functions_3d.py
--rw-r--r--   0 runner    (1001) docker     (127)    13615 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/plot_functions/vectors.py
--rw-r--r--   0 runner    (1001) docker     (127)    24407 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/plotgrid.py
--rw-r--r--   0 runner    (1001) docker     (127)   181552 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/series.py
--rw-r--r--   0 runner    (1001) docker     (127)    32173 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/utils.py
--rw-r--r--   0 runner    (1001) docker     (127)      304 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/vectors.py
--rw-r--r--   0 runner    (1001) docker     (127)    15898 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/spb/wegert.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.594389 sympy_plot_backends-3.1.1/sympy_plot_backends.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)     6543 2024-03-19 09:09:11.000000 sympy_plot_backends-3.1.1/sympy_plot_backends.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     4833 2024-03-19 09:09:11.000000 sympy_plot_backends-3.1.1/sympy_plot_backends.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-03-19 09:09:11.000000 sympy_plot_backends-3.1.1/sympy_plot_backends.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-03-19 09:09:11.000000 sympy_plot_backends-3.1.1/sympy_plot_backends.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (127)      435 2024-03-19 09:09:11.000000 sympy_plot_backends-3.1.1/sympy_plot_backends.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)       10 2024-03-19 09:09:11.000000 sympy_plot_backends-3.1.1/sympy_plot_backends.egg-info/top_level.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.590389 sympy_plot_backends-3.1.1/tests/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.594389 sympy_plot_backends-3.1.1/tests/backends/
--rw-r--r--   0 runner    (1001) docker     (127)      605 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/backends/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    29617 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/backends/make_tests.py
--rw-r--r--   0 runner    (1001) docker     (127)     8027 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/backends/test_base_backend.py
--rw-r--r--   0 runner    (1001) docker     (127)    42838 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/backends/test_bokeh.py
--rw-r--r--   0 runner    (1001) docker     (127)     3758 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/backends/test_color_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    30097 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/backends/test_k3d.py
--rw-r--r--   0 runner    (1001) docker     (127)    82547 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/backends/test_matplotlib.py
--rw-r--r--   0 runner    (1001) docker     (127)    64050 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/backends/test_plotly.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.594389 sympy_plot_backends-3.1.1/tests/graphics/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/graphics/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    15383 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/graphics/test_complex_analysis.py
--rw-r--r--   0 runner    (1001) docker     (127)    34151 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/graphics/test_control.py
--rw-r--r--   0 runner    (1001) docker     (127)     1526 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/graphics/test_control_min_module.py
--rw-r--r--   0 runner    (1001) docker     (127)    10457 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/graphics/test_functions_2d.py
--rw-r--r--   0 runner    (1001) docker     (127)    15142 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/graphics/test_functions_3d.py
--rw-r--r--   0 runner    (1001) docker     (127)     4687 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/graphics/test_graphics.py
--rw-r--r--   0 runner    (1001) docker     (127)    10885 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/graphics/test_vectors.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:11.594389 sympy_plot_backends-3.1.1/tests/plot_functions/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/plot_functions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    94547 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/plot_functions/test_complex.py
--rw-r--r--   0 runner    (1001) docker     (127)    40217 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/plot_functions/test_control.py
--rw-r--r--   0 runner    (1001) docker     (127)    51725 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/plot_functions/test_functions_2d.py
--rw-r--r--   0 runner    (1001) docker     (127)    33383 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/plot_functions/test_functions_3d.py
--rw-r--r--   0 runner    (1001) docker     (127)    52073 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/plot_functions/test_vectors.py
--rw-r--r--   0 runner    (1001) docker     (127)     5269 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/test_defaults.py
--rw-r--r--   0 runner    (1001) docker     (127)      935 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/test_deprecated_module.py
--rw-r--r--   0 runner    (1001) docker     (127)     8617 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/test_doc_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    26676 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/test_plotgrid.py
--rw-r--r--   0 runner    (1001) docker     (127)   144909 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/test_series.py
--rw-r--r--   0 runner    (1001) docker     (127)    14935 2024-03-19 09:09:07.000000 sympy_plot_backends-3.1.1/tests/test_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.314035 sympy_plot_backends-3.2.0/
+-rw-r--r--   0 runner    (1001) docker     (127)     1523 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)       89 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (127)     6543 2024-04-02 19:34:10.314035 sympy_plot_backends-3.2.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     4430 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)       38 2024-04-02 19:34:10.314035 sympy_plot_backends-3.2.0/setup.cfg
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2025 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.282035 sympy_plot_backends-3.2.0/spb/
+-rw-r--r--   0 runner    (1001) docker     (127)     3670 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)       22 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/_version.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.282035 sympy_plot_backends-3.2.0/spb/backends/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28636 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/base_backend.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2636 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/base_renderer.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.286035 sympy_plot_backends-3.2.0/spb/backends/bokeh/
+-rw-r--r--   0 runner    (1001) docker     (127)       54 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22406 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/bokeh.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.286035 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/
+-rw-r--r--   0 runner    (1001) docker     (127)     1386 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1289 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/arrow2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4723 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/complex.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1852 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/contour.py
+-rw-r--r--   0 runner    (1001) docker     (127)      897 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/generic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1379 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/geometry.py
+-rw-r--r--   0 runner    (1001) docker     (127)      646 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/hvline.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4338 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/line2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2088 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/mcircles.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4869 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/ngrid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4317 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/nichols.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13489 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/nyquist.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4082 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/polezero.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3746 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/root_locus.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9079 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/sgrid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9708 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/vector2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4970 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/zgrid.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.286035 sympy_plot_backends-3.2.0/spb/backends/k3d/
+-rw-r--r--   0 runner    (1001) docker     (127)       48 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17082 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/k3d.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.290035 sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/
+-rw-r--r--   0 runner    (1001) docker     (127)      612 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      840 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/arrow3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2711 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/complex.py
+-rw-r--r--   0 runner    (1001) docker     (127)      262 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/geometry.py
+-rw-r--r--   0 runner    (1001) docker     (127)      865 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/implicit3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2424 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/line3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2877 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/surface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3225 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/vector3d.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.290035 sympy_plot_backends-3.2.0/spb/backends/matplotlib/
+-rw-r--r--   0 runner    (1001) docker     (127)      142 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    30389 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/matplotlib.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.294035 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/
+-rw-r--r--   0 runner    (1001) docker     (127)     2069 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1301 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/arrow2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3273 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/arrow3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5830 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/complex.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2289 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/contour.py
+-rw-r--r--   0 runner    (1001) docker     (127)      825 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/generic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1604 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/geometry.py
+-rw-r--r--   0 runner    (1001) docker     (127)      743 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/hvline.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3218 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/implicit2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3897 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/line2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2913 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/line3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3020 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/mcircles.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4649 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/ngrid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3135 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/nichols.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8938 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/nyquist.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1125 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/polezero.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1788 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/renderer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2745 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/root_locus.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7386 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/sgrid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2918 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/surface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3880 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/vector2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3731 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/vector3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3111 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/zgrid.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.294035 sympy_plot_backends-3.2.0/spb/backends/mayavi/
+-rw-r--r--   0 runner    (1001) docker     (127)       58 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/mayavi/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9122 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/mayavi/mayavi.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.294035 sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/
+-rw-r--r--   0 runner    (1001) docker     (127)      270 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1026 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/implicit3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1106 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/line3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1141 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/surface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1405 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/vector3d.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.294035 sympy_plot_backends-3.2.0/spb/backends/plotly/
+-rw-r--r--   0 runner    (1001) docker     (127)       57 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22056 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/plotly.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.298035 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/
+-rw-r--r--   0 runner    (1001) docker     (127)     1059 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1126 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/arrow2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7442 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/complex.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1181 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/contour.py
+-rw-r--r--   0 runner    (1001) docker     (127)      940 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/generic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1272 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/geometry.py
+-rw-r--r--   0 runner    (1001) docker     (127)      865 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/hvline.py
+-rw-r--r--   0 runner    (1001) docker     (127)      850 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/implicit3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5663 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/line2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3553 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/line3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1761 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/surface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2212 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/vector2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3234 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/vector3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22021 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/backends/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.298035 sympy_plot_backends-3.2.0/spb/ccomplex/
+-rw-r--r--   0 runner    (1001) docker     (127)      228 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/ccomplex/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      515 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/ccomplex/complex.py
+-rw-r--r--   0 runner    (1001) docker     (127)      218 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/ccomplex/wegert.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1028 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/control.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9247 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/defaults.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13274 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/doc_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1149 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/functions.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.302035 sympy_plot_backends-3.2.0/spb/graphics/
+-rw-r--r--   0 runner    (1001) docker     (127)     1813 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/graphics/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    57633 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/graphics/complex_analysis.py
+-rw-r--r--   0 runner    (1001) docker     (127)    95949 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/graphics/control.py
+-rw-r--r--   0 runner    (1001) docker     (127)    67311 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/graphics/functions_2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)    58630 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/graphics/functions_3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12416 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/graphics/graphics.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6713 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/graphics/utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    31960 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/graphics/vectors.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.302035 sympy_plot_backends-3.2.0/spb/interactive/
+-rw-r--r--   0 runner    (1001) docker     (127)     6358 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/interactive/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.302035 sympy_plot_backends-3.2.0/spb/interactive/bootstrap_spb/
+-rw-r--r--   0 runner    (1001) docker     (127)     6213 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/interactive/bootstrap_spb/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3665 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/interactive/bootstrap_spb/bootstrap.css
+-rw-r--r--   0 runner    (1001) docker     (127)     6582 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/interactive/bootstrap_spb/bootstrap.html
+-rw-r--r--   0 runner    (1001) docker     (127)    15839 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/interactive/ipywidgets.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38079 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/interactive/panel.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.302035 sympy_plot_backends-3.2.0/spb/plot_functions/
+-rw-r--r--   0 runner    (1001) docker     (127)      615 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/plot_functions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43648 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/plot_functions/complex_analysis.py
+-rw-r--r--   0 runner    (1001) docker     (127)    50205 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/plot_functions/control.py
+-rw-r--r--   0 runner    (1001) docker     (127)    63806 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/plot_functions/functions_2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)    39225 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/plot_functions/functions_3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13615 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/plot_functions/vectors.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24407 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/plotgrid.py
+-rw-r--r--   0 runner    (1001) docker     (127)   184262 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/series.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32272 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)      304 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/vectors.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15898 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/spb/wegert.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.314035 sympy_plot_backends-3.2.0/sympy_plot_backends.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)     6543 2024-04-02 19:34:10.000000 sympy_plot_backends-3.2.0/sympy_plot_backends.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     5380 2024-04-02 19:34:10.000000 sympy_plot_backends-3.2.0/sympy_plot_backends.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-04-02 19:34:10.000000 sympy_plot_backends-3.2.0/sympy_plot_backends.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-04-02 19:34:10.000000 sympy_plot_backends-3.2.0/sympy_plot_backends.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (127)      435 2024-04-02 19:34:10.000000 sympy_plot_backends-3.2.0/sympy_plot_backends.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       10 2024-04-02 19:34:10.000000 sympy_plot_backends-3.2.0/sympy_plot_backends.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.306035 sympy_plot_backends-3.2.0/tests/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.306035 sympy_plot_backends-3.2.0/tests/backends/
+-rw-r--r--   0 runner    (1001) docker     (127)      605 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/backends/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24371 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/backends/make_tests.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12659 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/backends/test_base_backend.py
+-rw-r--r--   0 runner    (1001) docker     (127)    52074 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/backends/test_bokeh.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3758 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/backends/test_color_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28531 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/backends/test_k3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)    82714 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/backends/test_matplotlib.py
+-rw-r--r--   0 runner    (1001) docker     (127)    57115 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/backends/test_plotly.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.310035 sympy_plot_backends-3.2.0/tests/graphics/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/graphics/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15383 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/graphics/test_complex_analysis.py
+-rw-r--r--   0 runner    (1001) docker     (127)    34206 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/graphics/test_control.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1548 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/graphics/test_control_min_module.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10457 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/graphics/test_functions_2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15142 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/graphics/test_functions_3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4687 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/graphics/test_graphics.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10885 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/graphics/test_vectors.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.310035 sympy_plot_backends-3.2.0/tests/interactive/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/interactive/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7936 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/interactive/test_interactive.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3567 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/interactive/test_ipywidgets.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11460 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/interactive/test_panel.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:10.310035 sympy_plot_backends-3.2.0/tests/plot_functions/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/plot_functions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    94547 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/plot_functions/test_complex.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38150 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/plot_functions/test_control.py
+-rw-r--r--   0 runner    (1001) docker     (127)    51725 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/plot_functions/test_functions_2d.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33383 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/plot_functions/test_functions_3d.py
+-rw-r--r--   0 runner    (1001) docker     (127)    52073 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/plot_functions/test_vectors.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5513 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/test_defaults.py
+-rw-r--r--   0 runner    (1001) docker     (127)      935 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/test_deprecated_module.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8617 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/test_doc_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26676 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/test_plotgrid.py
+-rw-r--r--   0 runner    (1001) docker     (127)   147177 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/test_series.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15344 2024-04-02 19:34:06.000000 sympy_plot_backends-3.2.0/tests/test_utils.py
```

### Comparing `sympy_plot_backends-3.1.1/LICENSE` & `sympy_plot_backends-3.2.0/LICENSE`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/PKG-INFO` & `sympy_plot_backends-3.2.0/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sympy_plot_backends
-Version: 3.1.1
+Version: 3.2.0
 Summary: Backends for plotting with SymPy
 Home-page: https://github.com/Davide-sd/sympy-plot-backends
 Author: Davide Sandona
 Author-email: sandona.davide@gmail.com
 License: BSD License
 Keywords: sympy plot plotting backend plotly bokeh mayavi k3d panel
 Classifier: Development Status :: 5 - Production/Stable
```

### Comparing `sympy_plot_backends-3.1.1/README.md` & `sympy_plot_backends-3.2.0/README.md`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/setup.py` & `sympy_plot_backends-3.2.0/setup.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/__init__.py` & `sympy_plot_backends-3.2.0/spb/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/base_backend.py` & `sympy_plot_backends-3.2.0/spb/backends/base_backend.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,11 @@
 from itertools import cycle, islice
-from spb.series import BaseSeries, LineOver1DRangeSeries
+from spb.series import (
+    BaseSeries, LineOver1DRangeSeries, ComplexSurfaceBaseSeries
+)
 from spb.backends.utils import convert_colormap
 from sympy import Symbol
 from sympy.utilities.iterables import is_sequence
 from sympy.external import import_module
 
 
 class Plot:
@@ -180,15 +182,15 @@
     """
 
     _allowed_keys = [
         "aspect", "axis", "axis_center", "backend",
         "detect_poles", "grid", "legend", "show", "size", "title", "use_latex",
         "xlabel", "ylabel", "zlabel", "xlim", "ylim", "zlim", "show_axis",
         "xscale", "yscale", "zscale", "process_piecewise", "polar_axis",
-        "imodule"
+        "imodule", "update_event"
     ]
     """contains a list of public keyword arguments supported by the series.
     It will be used to validate the user-provided keyword arguments.
     """
 
     def _set_labels(self, wrapper="$%s$"):
         """Set the correct axis labels depending on wheter the backend support
@@ -381,14 +383,15 @@
         self.ylim = None
         check_and_set("ylim", kwargs.get("ylim", None))
         self.zlim = None
         check_and_set("zlim", kwargs.get("zlim", None))
         self.size = None
         check_and_set("size", kwargs.get("size", None))
         self.axis = kwargs.get("show_axis", kwargs.get("axis", True))
+        self._update_event = kwargs.get("update_event", False)
 
     def _copy_kwargs(self):
         """Copy the values of the plot attributes into a dictionary which will
         be later used to create a new `Plot` object having the same attributes.
         """
         return dict(
             title=self.title,
@@ -511,14 +514,68 @@
                 use_cyclic_cm = True
         return use_cyclic_cm
 
     def _set_piecewise_color(self, s, color):
         """Set the color to the given series of a piecewise function."""
         raise NotImplementedError
 
+    def _update_series_ranges(self, *limits):
+        """Update the ranges of data series in order to implement pan/zoom
+        update events.
+
+        Parameters
+        ==========
+        limits : iterable
+            Each element is a tuple (min, max).
+
+        Returns
+        =======
+        all_params : dict
+            A dictionary containing all the parameters used by the series
+        """
+        all_params = {}
+        # TODO: can ComplexSurfaceBaseSeries be modified such that it has
+        # two ranges instead of one? It would allow to simplify this code...
+        css = [s for s in self._series
+            if isinstance(s, ComplexSurfaceBaseSeries)]
+        ncss = [s for s in self._series
+            if not isinstance(s, ComplexSurfaceBaseSeries)]
+
+        for s in ncss:
+            # skip the ones that don't use `ranges`, like
+            # List2D/List3D/Arrow2D/Arrow3D
+            # as well as the parametric series
+            if (len(s.ranges) > 0) and (not s.is_parametric):
+                new_ranges = []
+                for r, l in zip(s.ranges, limits):
+                    if any(len(t.free_symbols) > 0 for t in r[1:]):
+                        # design choice: interactive ranges should not
+                        # be modified
+                        new_ranges.append(r)
+                    else:
+                        new_ranges.append((r[0], *l))
+                s.ranges = new_ranges
+                s._interactive_ranges = True
+                s.is_interactive = True
+            all_params = self.merge({}, all_params, s.params)
+
+        if len(css) > 0:
+            xlim, ylim = limits[:2]
+            lim = (xlim[0] + 1j * ylim[0], xlim[1] + 1j * ylim[1])
+            for s in css:
+                if all(len(t.free_symbols) == 0 for t in s.ranges[0][1:]):
+                    # design choice: interactive ranges should not
+                    # be modified
+                    s.ranges = [(s.ranges[0][0], *lim)]
+                    s._interactive_ranges = True
+                    s.is_interactive = True
+                all_params = self.merge({}, all_params, s.params)
+
+        return all_params
+
     @property
     def fig(self):
         """Returns the figure used to render/display the plots."""
         return self._fig
 
     @property
     def renderers(self):
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/base_renderer.py` & `sympy_plot_backends-3.2.0/spb/backends/base_renderer.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/bokeh.py` & `sympy_plot_backends-3.2.0/spb/backends/bokeh/bokeh.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,19 +1,26 @@
 import os
 from spb.defaults import cfg
 from spb.backends.base_backend import Plot
 from spb.backends.bokeh.renderers import (
     Line2DRenderer, Vector2DRenderer, ComplexRenderer, ContourRenderer,
-    GeometryRenderer, GenericRenderer, HVLineRenderer, Arrow2DRenderer
+    GeometryRenderer, GenericRenderer, HVLineRenderer, Arrow2DRenderer,
+    ZGridLineRenderer, SGridLineRenderer, NGridLineRenderer,
+    MCirclesRenderer, PoleZeroRenderer, RootLocusRenderer, NyquistRenderer,
+    NicholsLineRenderer
 )
 from spb.series import (
     LineOver1DRangeSeries, List2DSeries, Parametric2DLineSeries,
     ColoredLineOver1DRangeSeries, AbsArgLineSeries, ComplexPointSeries,
     Vector2DSeries, ComplexDomainColoringSeries, ContourSeries,
-    GeometrySeries, GenericDataSeries, HVLineSeries, Arrow2DSeries
+    GeometrySeries, GenericDataSeries, HVLineSeries, Arrow2DSeries,
+    ZGridLineSeries, SGridLineSeries, NGridLineSeries, NicholsLineSeries,
+    MCirclesSeries, PoleZeroSeries, PoleZeroWithSympySeries,
+    SystemResponseSeries, ColoredSystemResponseSeries, RootLocusSeries,
+    NyquistLineSeries
 )
 from sympy.external import import_module
 
 
 class BokehBackend(Plot):
     """
     A backend for plotting SymPy's symbolic expressions using Bokeh.
@@ -56,14 +63,19 @@
     axis : boolean, optional
         Turns on/off the axis visibility (and associated tick labels).
         Default to True (axis are visible).
 
     theme : str, optional
         Set the theme. Find more Bokeh themes at [#fn2]_ .
 
+    update_event : bool, optional
+        If True, it binds pan/zoom events in order to automatically compute
+        new data as the user interact with the plot.
+        Default to False.
+
     annotations : list, optional
         A list of dictionaries specifying the type of annotation
         required. The keys in the dictionary should be equivalent
         to the arguments of the `bokeh.models.LabelSet` class.
         This feature is experimental. It might get removed in the future.
 
     markers : list, optional
@@ -118,30 +130,46 @@
         Vector2DSeries: Vector2DRenderer,
         ComplexDomainColoringSeries: ComplexRenderer,
         ContourSeries: ContourRenderer,
         GeometrySeries: GeometryRenderer,
         GenericDataSeries: GenericRenderer,
         HVLineSeries: HVLineRenderer,
         Arrow2DSeries: Arrow2DRenderer,
+        RootLocusSeries: RootLocusRenderer,
+        SGridLineSeries: SGridLineRenderer,
+        ZGridLineSeries: ZGridLineRenderer,
+        SystemResponseSeries: Line2DRenderer,
+        ColoredSystemResponseSeries: Line2DRenderer,
+        PoleZeroSeries: PoleZeroRenderer,
+        PoleZeroWithSympySeries: PoleZeroRenderer,
+        NGridLineSeries: NGridLineRenderer,
+        NicholsLineSeries: NicholsLineRenderer,
+        MCirclesSeries: MCirclesRenderer,
+        NyquistLineSeries: NyquistRenderer,
     }
 
     pole_line_kw = {"line_color": "#000000", "line_dash": "dotted"}
+    grid_line_kw = {"line_color": "#aaa", "line_dash": "dotted"}
+    sgrid_line_kw = {"line_color": "#aaa", "line_dash": "dotted"}
+    ngrid_line_kw = {"line_color": "#aaa", "line_dash": "dotted"}
+    mcircles_line_kw = {"line_color": "#aaa", "line_dash": "dotted"}
 
     def __init__(self, *args, **kwargs):
         self.np = import_module('numpy')
         self.bokeh = import_module(
             'bokeh',
             import_kwargs={
                 'fromlist': [
                     'models', 'events', 'plotting', 'io',
                     'palettes', 'embed', 'resources'
                 ]
             },
             warn_not_installed=True,
-            min_module_version='2.3.0')
+            min_module_version='2.3.0'
+        )
         bp = self.bokeh.palettes
         cc = import_module(
             'colorcet',
             min_module_version='3.0.0')
         matplotlib = import_module(
             'matplotlib',
             import_kwargs={'fromlist': ['pyplot', 'cm']},
@@ -181,39 +209,24 @@
             (not type(self).colorloop) and
             not ("process_piecewise" in kwargs.keys())
         ):
             # add colors if needed
             self.colorloop = bp.Category20[20]
 
         self._handles = dict()
-
-        # empty plots (len(series)==0) should only have x, y tooltips
-        TOOLTIPS = [("x", "$x"), ("y", "$y")]
-        if len(self.series) > 0:
-            if all([s.is_parametric for s in self.series]):
-                # with parametric plots, also visualize the parameter
-                TOOLTIPS += [("u", "@us")]
-            if any([s.is_complex and s.is_domain_coloring for s
-                    in self.series]):
-                # with complex domain coloring, shows the magnitude and phase
-                # in the tooltip
-                TOOLTIPS += [("Abs", "@abs"), ("Arg", "@arg")]
-
         sizing_mode = cfg["bokeh"]["sizing_mode"]
-
         title, xlabel, ylabel, zlabel = self._get_title_and_labels()
         kw = dict(
             title=title,
             x_axis_label=xlabel if xlabel else "x",
             y_axis_label=ylabel if ylabel else "y",
             sizing_mode="fixed" if self.size else sizing_mode,
             width=int(self.size[0]) if self.size else cfg["bokeh"]["width"],
             height=int(self.size[1]) if self.size else cfg["bokeh"]["height"],
-            tools="pan,wheel_zoom,box_zoom,reset,hover,save",
-            tooltips=TOOLTIPS,
+            tools="pan,wheel_zoom,box_zoom,reset,save",
             match_aspect=True if self.aspect == "equal" else False,
         )
         if self.xlim:
             kw["x_range"] = self.xlim
         if self.ylim:
             kw["y_range"] = self.ylim
         if self.xscale:
@@ -231,29 +244,46 @@
         if cfg["bokeh"]["show_minor_grid"]:
             self._fig.grid.minor_grid_line_alpha = cfg["bokeh"]["minor_grid_line_alpha"]
             self._fig.grid.minor_grid_line_color = self._fig.grid.grid_line_color[0]
             self._fig.grid.minor_grid_line_dash = cfg["bokeh"]["minor_grid_line_dash"]
         if self._invert_x_axis:
             self._fig.x_range.flipped = True
 
+        self._update_event = kwargs.get(
+            "update_event", cfg["bokeh"]["update_event"])
+        if self._update_event:
+            self._fig.on_event(self.bokeh.events.RangesUpdate, self._ranges_update)
+
         self._create_renderers()
 
+    def _ranges_update(self, event):
+        xlim = (event.x0, event.x1)
+        ylim = (event.y0, event.y1)
+        params = self._update_series_ranges(xlim, ylim)
+        self.update_interactive(params)
+
     def _init_cyclers(self):
         start_index_cl, start_index_cm = None, None
         if self._use_existing_figure:
             fig = self._use_existing_figure if self._fig is None else self._fig
             # attempt to determine how many lines are plotted
             # on the user-provided figure
             start_index_cl = len(fig.renderers)
         super()._init_cyclers(start_index_cl, 0)
 
     @property
     def fig(self):
         """Returns the figure."""
-        if len(self.renderers) > 0 and len(self.renderers[0].handles) == 0:
+        if (
+            (len(self.renderers) > 0) and
+            (
+                (self.renderers[0] and len(self.renderers[0].handles) == 0)
+                or (self.renderers[0] is None)
+            )
+        ):
             # if the backend was created without showing it
             self.draw()
         return self._fig
 
     def draw(self):
         """ Loop over data renderers, generates numerical data and add it to
         the figure. Note that this method doesn't show the plot.
@@ -287,44 +317,59 @@
             # we don't want to erase its content.
 
             # Must clear both the renderers as well as the
             # colorbars which are added to the right side.
             self._fig.renderers = []
             self._fig.right = []
 
+        xlims, ylims = [], []
         for r, s in zip(self.renderers, self.series):
             self._check_supported_series(r, s)
             r.draw()
+            if hasattr(r, "_xlims"):
+                xlims.extend(r._xlims)
+                ylims.extend(r._ylims)
+
+        if (len(xlims) > 0) and (self.xlim is None):
+            # this is used in order to properly visualized some *GridSeries
+            np = import_module("numpy")
+            xlims = np.array(xlims)
+            xlim = (np.nanmin(xlims[:, 0]), np.nanmax(xlims[:, 1]))
+            ylims = np.array(ylims)
+            ylim = (np.nanmin(ylims[:, 0]), np.nanmax(ylims[:, 1]))
+            self._fig.x_range = self.bokeh.models.Range1d(*xlim)
+            self._fig.y_range = self.bokeh.models.Range1d(*ylim)
 
         if len(self._fig.legend) > 0:
             # hide default legend
             self._fig.legend.visible = False
             # add a new legend only showing the appropriate items
             legend_items = []
             end = 0
             if self._use_existing_figure:
                 legend_items = self._fig.legend.items
                 # keep existing legend entries if we are dealing with a
                 # user-provided figure
                 end = len(legend_items) - len(self.series)
                 legend_items = legend_items[:end]
-            # if user-provided figures, self.series and self._fig.renderers
-            # are not "synchronized"
-            start = end if self._use_existing_figure else 0
-            for i, s in enumerate(self.series):
-                if (start+i) < len(self._fig.renderers):
-                    r = self._fig.renderers[start+i]
-                    if (
-                        s.show_in_legend and
-                        (s.is_2Dline or s.is_geometry) and
-                        (not s.use_cm)
-                    ):
-                        legend_items.append(
-                            self.bokeh.models.LegendItem(
-                                label=s.get_label(self._use_latex), renderers=[r]))
+            for s, r in zip(self.series, self.renderers):
+                if (
+                    s.show_in_legend and
+                    (s.is_2Dline or s.is_geometry) and
+                    (not s.use_cm)
+                ):
+                    if hasattr(r.handles[0][0], "__iter__"):
+                        bokeh_renderer = r.handles[0][0][0]
+                    else:
+                        bokeh_renderer = r.handles[0][0]
+                    legend_items.append(
+                        self.bokeh.models.LegendItem(
+                            label=s.get_label(self._use_latex),
+                            renderers=[bokeh_renderer])
+                    )
             if self.legend and (len(legend_items) > 0):
                 legend = self.bokeh.models.Legend(items=legend_items)
                 # interactive legend
                 legend.click_policy = "hide"
                 self._fig.add_layout(legend, "right")
 
     def _get_img(self, img):
@@ -332,48 +377,46 @@
         new_img = np.zeros(img.shape[:2], dtype=np.uint32)
         pixel = new_img.view(dtype=np.uint8).reshape((*img.shape[:2], 4))
         for i in range(img.shape[1]):
             for j in range(img.shape[0]):
                 pixel[j, i] = [*img[j, i], 255]
         return new_img
 
-    def _get_segments(self, x, y, u):
+    def _get_segments(self, x, y, *others):
         # MultiLine works with line segments, not with line points! :|
         xs = [x[i - 1 : i + 1] for i in range(1, len(x))]
         ys = [y[i - 1 : i + 1] for i in range(1, len(y))]
         # let n be the number of points. Then, the number of segments
         # will be (n - 1). Therefore, we remove one parameter. If n is
         # sufficiently high, there shouldn't be any noticeable problem in
         # the visualization.
-        us = u[:-1]
-        return xs, ys, us
+        others = list(others)
+        for i, o in enumerate(others):
+            others[i] = o[:-1]
+        return [xs, ys, *others]
 
     def _create_gradient_line(
-        self, x, y, u, colormap, name, line_kw, is_point=False
+        self, x_key, y_key, p_key, source, colormap, name, line_kw,
+        is_point=False
     ):
-        merge = self.merge
-        if not is_point:
-            xs, ys, us = self._get_segments(x, y, u)
-        else:
-            xs, ys, us = x, y, u
+        param = source[p_key]
         color_mapper = self.bokeh.models.LinearColorMapper(
-            palette=colormap, low=min(us), high=max(us))
-        data_source = self.bokeh.models.ColumnDataSource(
-            dict(xs=xs, ys=ys, us=us))
+            palette=colormap, low=min(param), high=max(param))
+        data_source = self.bokeh.models.ColumnDataSource(source)
 
         lkw = dict(
             line_width=2,
             name=name,
-            line_color={"field": "us", "transform": color_mapper},
+            line_color={"field": p_key, "transform": color_mapper},
         )
-        kw = merge({}, lkw, line_kw)
+        kw = self.merge({}, lkw, line_kw)
         if not is_point:
-            glyph = self.bokeh.models.MultiLine(xs="xs", ys="ys", **kw)
+            glyph = self.bokeh.models.MultiLine(xs=x_key, ys=y_key, **kw)
         else:
-            glyph = self.bokeh.models.Scatter(x="xs", y="ys", **kw)
+            glyph = self.bokeh.models.Scatter(x=x_key, y=y_key, **kw)
         colorbar = self.bokeh.models.ColorBar(
             color_mapper=color_mapper, title=name, width=8)
         return data_source, glyph, colorbar, kw
 
     def update_interactive(self, params):
         """Implement the logic to update the data generated by
         interactive-widget plots.
@@ -437,24 +480,38 @@
             self.bokeh.io.export_svg(self.fig, filename=path)
         else:
             if ext == "":
                 path += ".png"
             self._fig.output_backend = "canvas"
             self.bokeh.io.export_png(self._fig, filename=path)
 
+    def _launch_server(self, doc):
+        """ By launching a server application, we can use Python callbacks
+        associated to events.
+        """
+        doc.theme = self._theme
+        doc.add_root(self._fig)
+
     def show(self):
         """Visualize the plot on the screen."""
         if len(self._fig.renderers) != len(self.series):
             self._process_renderers()
-        # if the backend it running from a python interpreter, the server
-        # wont' work. Hence, launch a static figure, which doesn't listen
-        # to events (no pan-auto-update).
-        curdoc = self.bokeh.io.curdoc
-        curdoc().theme = self._theme
-        self.bokeh.plotting.show(self._fig)
+
+        if self._update_event:
+            # TODO: the current way we are launching the server only works within
+            # Jupyter Notebook. Is there another way of launching it so that it can
+            # run from any Python interpreter?
+            self.bokeh.plotting.show(self._launch_server)
+        else:
+            # if the backend it running from a python interpreter, the server
+            # wont' work. Hence, launch a static figure, which doesn't listen
+            # to events (no pan-auto-update).
+            curdoc = self.bokeh.io.curdoc
+            curdoc().theme = self._theme
+            self.bokeh.plotting.show(self._fig)
 
     def _get_quivers_data(self, xs, ys, u, v, **quiver_kw):
         """Compute the segments coordinates to plot quivers.
 
         Parameters
         ==========
         xs : np.ndarray
@@ -499,14 +556,17 @@
             nyoff, pyoff = yoffsets, yoffsets
         elif pivot == "tip":
             nxoff, pxoff = 0, xoffsets * 2
             nyoff, pyoff = 0, yoffsets * 2
         elif pivot == "tail":
             nxoff, pxoff = xoffsets * 2, 0
             nyoff, pyoff = yoffsets * 2, 0
+        else:
+            raise ValueError(
+                "`pivot` must be one of ['mid', 'tip', 'tail']")
         x0s, x1s = (xs + nxoff, xs - pxoff)
         y0s, y1s = (ys + nyoff, ys - pyoff)
 
         if arrow_heads:
             arrow_len = lens / 4.0
             xa1s = x0s - np.cos(rads + np.pi / 4) * arrow_len
             ya1s = y0s - np.sin(rads + np.pi / 4) * arrow_len
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/__init__.py` & `sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,13 +2,23 @@
 from spb.backends.bokeh.renderers.contour import ContourRenderer
 from spb.backends.bokeh.renderers.geometry import GeometryRenderer
 from spb.backends.bokeh.renderers.vector2d import Vector2DRenderer
 from spb.backends.bokeh.renderers.complex import ComplexRenderer
 from spb.backends.bokeh.renderers.generic import GenericRenderer
 from spb.backends.bokeh.renderers.hvline import HVLineRenderer
 from spb.backends.bokeh.renderers.arrow2d import Arrow2DRenderer
+from spb.backends.bokeh.renderers.zgrid import ZGridLineRenderer
+from spb.backends.bokeh.renderers.sgrid import SGridLineRenderer
+from spb.backends.bokeh.renderers.ngrid import NGridLineRenderer
+from spb.backends.bokeh.renderers.mcircles import MCirclesRenderer
+from spb.backends.bokeh.renderers.polezero import PoleZeroRenderer
+from spb.backends.bokeh.renderers.root_locus import RootLocusRenderer
+from spb.backends.bokeh.renderers.nyquist import NyquistRenderer
+from spb.backends.bokeh.renderers.nichols import NicholsLineRenderer
 
 __all__ = [
     "Line2DRenderer", "ContourRenderer", "GeometryRenderer",
     "Vector2DRenderer", "ComplexRenderer", "GenericRenderer",
-    "HVLineRenderer", "Arrow2DRenderer"
+    "HVLineRenderer", "Arrow2DRenderer", "ZGridLineRenderer",
+    "SGridLineRenderer", "NGridLineRenderer", "MCirclesRenderer",
+    "PoleZeroRenderer", "RootLocusRenderer", "NicholsLineRenderer"
 ]
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/arrow2d.py` & `sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/arrow3d.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,39 +1,37 @@
+import numpy as np
 from spb.backends.base_renderer import Renderer
 
 
-def _draw_arrow_2d(renderer, data):
+def _draw_arrow_3d(renderer, data):
     p, s = renderer.plot, renderer.series
-    x, y, u, v = data
-
-    color = next(p._cl)
-    akw = dict(
-        end=p.bokeh.models.VeeHead(
-            size=10, fill_color=color, line_width=0
-        ),
-        line_color=color,
-        x_start=x,
-        y_start=y,
-        x_end=u,
-        y_end=v
+    xx, yy, zz, uu, vv, ww = data
+    uu -= xx
+    vv -= yy
+    ww -= zz
+
+    color = p._rgb_to_int([int(255*t) for t in next(p._cl)])
+    pkw = dict(
+        origin_color=color,
+        head_color=color
     )
-    kw = p.merge({}, akw, s.rendering_kw)
-    arrow = p.bokeh.models.Arrow(**kw)
-    p._fig.add_layout(arrow)
+    kw = p.merge({}, pkw, s.rendering_kw)
+    arrow = p.k3d.vectors([xx, yy, zz], [uu, vv, ww], **kw)
+    p._fig += arrow
 
     return [arrow]
 
 
-def _update_arrow_2d(renderer, data, handle):
-    x, y, u, v = data
-    arrow = handle[0]
-
-    arrow.x_start = x
-    arrow.y_start = y
-    arrow.x_end = u
-    arrow.y_end = v
+def _update_arrow3d(renderer, data, handle):
+    p = renderer.plot
+    xx, yy, zz, uu, vv, ww = data
+    uu -= xx
+    vv -= yy
+    ww -= zz
+    handle[0].origins = np.array([xx, yy, zz])
+    handle[0].vectors = np.array([uu, vv, ww])
 
 
-class Arrow2DRenderer(Renderer):
+class Arrow3DRenderer(Renderer):
     draw_update_map = {
-        _draw_arrow_2d: _update_arrow_2d
+        _draw_arrow_3d: _update_arrow3d
     }
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/complex.py` & `sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/complex.py`

 * *Files 10% similar despite different names*

```diff
@@ -31,14 +31,18 @@
     handle = p._fig.image_rgba(
         source=source,
         x=x.min(),
         y=y.min(),
         dw=x.max() - x.min(),
         dh=y.max() - y.min(),
     )
+    p._fig.add_tools(p.bokeh.models.HoverTool(
+        tooltips=[("x", "$x"), ("y", "$y"), ("Abs", "@abs"), ("Arg", "@arg")],
+        renderers=[handle]
+    ))
 
     if (colors is not None) and s.colorbar:
         # chroma/phase-colorbar
         cm1 = p.bokeh.models.LinearColorMapper(
             palette=[tuple(c) for c in colors],
             low=-np.pi, high=np.pi)
         ticks = [-np.pi, -np.pi / 2, 0, np.pi / 2, np.pi]
@@ -82,15 +86,15 @@
             p.bokeh.models.LabelSet(
                 x="x", y="y", text="labels",
                 x_offset="x_offset", y_offset="y_offset", source=source,
                 text_baseline="middle", text_align="center",
                 text_font_style="bold", text_color="#000000"
             ))
 
-    return handle
+    return [handle]
 
 
 def _update_domain_coloring_helper(renderer, data, handle):
     p, s = renderer.plot, renderer.series
     np = p.np
 
     x, y, mag, angle, img, _ = data
@@ -106,19 +110,19 @@
             np.flip(np.flip(t, axis=0), axis=1) for t in [mag, angle]
         ]
     source = {
         "image": [img],
         "abs": [mag],
         "arg": [angle],
     }
-    handle.data_source.data.update(source)
-    handle.glyph.x = minx
-    handle.glyph.y = miny
-    handle.glyph.dw = abs(maxx - minx)
-    handle.glyph.dh = abs(maxy - miny)
+    handle[0].data_source.data.update(source)
+    handle[0].glyph.x = minx
+    handle[0].glyph.y = miny
+    handle[0].glyph.dw = abs(maxx - minx)
+    handle[0].glyph.dh = abs(maxy - miny)
 
 
 def _draw_3d_helper(renderer, data):
     raise NotImplementedError
 
 
 def _update_3d_helper(renderer, data):
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/contour.py` & `sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/contour.py`

 * *Files 15% similar despite different names*

```diff
@@ -25,14 +25,18 @@
         x=minx,
         y=miny,
         dw=abs(maxx - minx),
         dh=abs(maxy - miny),
         **kw
     )
     handle.append(h)
+    p._fig.add_tools(p.bokeh.models.HoverTool(
+        tooltips=[("x", "$x"), ("y", "$y"), ("z", "@image")],
+        renderers=[handle[0]]
+    ))
 
     if s.colorbar:
         colormapper = p.bokeh.models.LinearColorMapper(
             palette=cm, low=minz, high=maxz)
         cbkw = dict(width=8, title=s.get_label(p._use_latex))
         colorbar = p.bokeh.models.ColorBar(
             color_mapper=colormapper, **cbkw)
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/generic.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/generic.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,24 +1,27 @@
 from spb.backends.base_renderer import Renderer
 
 
 class GenericRenderer(Renderer):
     def draw(self):
         s = self.series
         p = self.plot
-
         if s.type == "markers":
-            kw = p.merge({}, {"color": next(p._cl)}, s.rendering_kw)
-            p._fig.scatter(*s.args, **kw)
+            kw = p.merge({}, {"line_color": next(p._cl)}, s.rendering_kw)
+            p._fig.add_trace(p.go.Scatter(*s.args, **kw))
         elif s.type == "annotations":
-            p._fig.add_layout(
-                p.bokeh.models.LabelSet(*s.args, **s.rendering_kw))
+            kw = p.merge({}, {
+                "line_color": next(p._cl),
+                "mode": "text",
+                }, s.rendering_kw)
+            p._fig.add_trace(p.go.Scatter(*s.args, **kw))
         elif s.type == "fill":
-            kw = p.merge({}, {"fill_color": next(p._cl)}, s.rendering_kw)
-            p._fig.varea(*s.args, **kw)
+            kw = p.merge({}, {
+                "line_color": next(p._cl),
+                "fill": "tozeroy"
+                }, s.rendering_kw)
+            p._fig.add_trace(p.go.Scatter(*s.args, **kw))
         elif s.type == "rectangles":
-            kw = p.merge({}, {"fill_color": next(p._cl)}, s.rendering_kw)
-            glyph = p.bokeh.models.Rect(**kw)
-            p._fig.add_glyph(*s.args, glyph)
+            p._fig.add_shape(*s.args, **s.rendering_kw)
 
     def update(self, params):
         raise NotImplementedError
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/geometry.py` & `sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/geometry.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,23 +7,37 @@
 def _draw_geometry_helper(renderer, data):
     p, s = renderer.plot, renderer.series
 
     x, y = data
     color = next(p._cl)
     pkw = dict(alpha=0.5, line_width=2, line_color=color, fill_color=color)
     kw = p.merge({}, pkw, s.rendering_kw)
+
+    alpha = kw["alpha"]
+
+    # need a scatter in order to show tooltips
+    source = {"x": x, "y": y}
+    tooltips=[("x", "@x"), ("y", "@y")]
+    scatter = p._fig.scatter("x", "y", source=source, color=color,
+        size=4, alpha=alpha)
+    p._fig.add_tools(p.bokeh.models.HoverTool(
+        tooltips=tooltips,
+        renderers=[scatter]
+    ))
     handle = p._fig.patch(x, y, **kw)
 
-    return handle
+    return [handle, scatter]
 
 
 def _update_geometry_helper(renderer, data, handle):
     x, y = data
     source = {"x": x, "y": y}
-    handle.data_source.data.update(source)
+    geometry, scatter = handle
+    geometry.data_source.data.update(source)
+    scatter.data_source.data.update(source)
 
 
 class GeometryRenderer(Renderer):
     draw_update_map = {
         _draw_geometry_helper: _update_geometry_helper
     }
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/hvline.py` & `sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/hvline.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/line2d.py` & `sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/line2d.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,37 +4,43 @@
 def _draw_line2d_helper(renderer, data):
     p, s = renderer.plot, renderer.series
     np = p.np
     handle = []
 
     if s.is_parametric and s.use_cm:
         x, y, param = data
+        if not s.is_point:
+            x, y, param = p._get_segments(x, y, param)
         colormap = (
             next(p._cyccm)
             if p._use_cyclic_cm(param, s.is_complex)
             else next(p._cm)
         )
+        source = {"xs": x, "ys": y, "us": param}
         ds, line, cb, kw = p._create_gradient_line(
-            x, y, param, colormap, s.get_label(p._use_latex),
+            "xs", "ys", "us", source, colormap, s.get_label(p._use_latex),
             s.rendering_kw, s.is_point)
         h = p._fig.add_glyph(ds, line)
         handle.append(h)
+        tooltips = [("x", "@xs"), ("y", "@ys"), ("u", "@us")]
         if s.colorbar:
             handle.append(cb)
             p._fig.add_layout(cb, "right")
     else:
         if s.is_parametric:
             x, y, param = data
             source = {"xs": x, "ys": y, "us": param}
+            tooltips = [("x", "@xs"), ("y", "@ys"), ("u", "@us")]
         else:
             x, y = data
             source = {
                 "xs": x if not s.is_polar else y * np.cos(x),
                 "ys": y if not s.is_polar else y * np.sin(x)
             }
+            tooltips=[("x", "@xs"), ("y", "@ys")]
 
         if s.get_label(False) != "__k__":
             color = next(p._cl) if s.line_color is None else s.line_color
         else:
             color = "#000000"
         lkw = dict(
             line_width=2, color=color,
@@ -47,14 +53,19 @@
             lkw["size"] = 8
             lkw["marker"] = "circle"
             if not s.is_filled:
                 lkw["fill_color"] = "white"
             kw = p.merge({}, lkw, s.rendering_kw)
             handle = [p._fig.scatter("xs", "ys", source=source, **kw)]
 
+    p._fig.add_tools(p.bokeh.models.HoverTool(
+        tooltips=tooltips,
+        renderers=[handle[0]]
+    ))
+
     # add vertical lines at discontinuities
     vlines = []
     for x_loc in s.poles_locations:
         vl = p.bokeh.models.Span(
             location=float(x_loc), dimension="height", **p.pole_line_kw)
         p._fig.add_layout(vl)
         vlines.append(vl)
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/bokeh/renderers/vector2d.py` & `sympy_plot_backends-3.2.0/spb/backends/bokeh/renderers/vector2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/k3d/k3d.py` & `sympy_plot_backends-3.2.0/spb/backends/k3d/k3d.py`

 * *Files 2% similar despite different names*

```diff
@@ -201,15 +201,21 @@
             )
 
         self._create_renderers()
 
     @property
     def fig(self):
         """Returns the figure."""
-        if len(self.renderers) > 0 and len(self.renderers[0].handles) == 0:
+        if (
+            (len(self.renderers) > 0) and
+            (
+                (self.renderers[0] and len(self.renderers[0].handles) == 0)
+                or (self.renderers[0] is None)
+            )
+        ):
             # if the backend was created without showing it
             self._process_renderers()
         return self._fig
 
     def draw(self):
         """ Loop over data renderers, generates numerical data and add it to
         the figure. Note that this method doesn't show the plot.
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/__init__.py` & `sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/complex.py` & `sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/complex.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/implicit3d.py` & `sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/implicit3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/line3d.py` & `sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/line3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/surface.py` & `sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/surface.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/k3d/renderers/vector3d.py` & `sympy_plot_backends-3.2.0/spb/backends/k3d/renderers/vector3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/matplotlib.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/matplotlib.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,29 +3,30 @@
 from spb.backends.base_backend import Plot
 from spb.backends.matplotlib.renderers import (
     Line2DRenderer, Line3DRenderer, Vector2DRenderer, Vector3DRenderer,
     Implicit2DRenderer, ComplexRenderer, ContourRenderer, SurfaceRenderer,
     GeometryRenderer, GenericRenderer, HVLineRenderer,
     NyquistRenderer, Arrow2DRendererFancyArrowPatch,
     Arrow3DRendererFancyArrowPatch, RootLocusRenderer, SGridLineRenderer,
-    ZGridLineRenderer, NGridLineRenderer, MCirclesRenderer
+    ZGridLineRenderer, NGridLineRenderer, MCirclesRenderer, PoleZeroRenderer,
+    NicholsLineRenderer
 )
 from spb.series import (
     LineOver1DRangeSeries, List2DSeries, Parametric2DLineSeries,
     ColoredLineOver1DRangeSeries, AbsArgLineSeries, ComplexPointSeries,
     Parametric3DLineSeries, ComplexParametric3DLineSeries,
     List3DSeries, Vector2DSeries, Vector3DSeries, SliceVector3DSeries,
     ImplicitSeries, RiemannSphereSeries,
     ComplexDomainColoringSeries, ComplexSurfaceSeries,
     ContourSeries, SurfaceOver2DRangeSeries, ParametricSurfaceSeries,
     PlaneSeries, GeometrySeries, GenericDataSeries,
     HVLineSeries, NyquistLineSeries, NicholsLineSeries,
     Arrow2DSeries, Arrow3DSeries, RootLocusSeries, SGridLineSeries,
     ZGridLineSeries, SystemResponseSeries, ColoredSystemResponseSeries,
-    PoleZeroSeries, NGridLineSeries,
+    PoleZeroSeries, NGridLineSeries, PoleZeroWithSympySeries,
     MCirclesSeries
 )
 from sympy.external import import_module
 from packaging import version
 import warnings
 
 # Global variable
@@ -87,17 +88,18 @@
         * Refer to [#fn8]_ to customize 3D scatter plots.
         * Refer to [#fn11]_ to customize 2D arrows.
 
     axis : boolean, optional
         Turns on/off the axis visibility (and associated tick labels).
         Default to True (axis are visible).
 
-    use_cm : boolean, optional
-        If True, apply a color map to the mesh/surface or parametric lines.
-        If False, solid colors will be used instead. Default to True.
+    update_event : bool, optional
+        If True, it binds pan/zoom events in order to automatically compute
+        new data as the user interact with the plot.
+        Default to False.
 
     annotations : list, optional
         A list of dictionaries specifying the type of annotation
         required. The keys in the dictionary should be equivalent
         to the arguments of the `matplotlib.axes.Axes.annotate` method.
         This feature is experimental. It might get removed in the future.
 
@@ -170,25 +172,26 @@
         SurfaceOver2DRangeSeries: SurfaceRenderer,
         ParametricSurfaceSeries: SurfaceRenderer,
         PlaneSeries: SurfaceRenderer,
         GeometrySeries: GeometryRenderer,
         GenericDataSeries: GenericRenderer,
         HVLineSeries: HVLineRenderer,
         NyquistLineSeries: NyquistRenderer,
-        NicholsLineSeries: Line2DRenderer,
+        NicholsLineSeries: NicholsLineRenderer,
         Arrow2DSeries: Arrow2DRendererFancyArrowPatch,
         Arrow3DSeries: Arrow3DRendererFancyArrowPatch,
         RootLocusSeries: RootLocusRenderer,
         SGridLineSeries: SGridLineRenderer,
         ZGridLineSeries: ZGridLineRenderer,
         SystemResponseSeries: Line2DRenderer,
         ColoredSystemResponseSeries: Line2DRenderer,
-        PoleZeroSeries: Line2DRenderer,
         NGridLineSeries: NGridLineRenderer,
-        MCirclesSeries: MCirclesRenderer
+        MCirclesSeries: MCirclesRenderer,
+        PoleZeroSeries: PoleZeroRenderer,
+        PoleZeroWithSympySeries: PoleZeroRenderer,
     }
 
     pole_line_kw = {"color": "k", "linestyle": ":"}
     grid_line_kw = {"color": '0.75', "linestyle": '--', "linewidth": 0.75}
     sgrid_line_kw = {"color": '0.75', "linestyle": '--', "linewidth": 0.75,
         "zorder": 0}
     ngrid_line_kw = {"color": 'lightgray', "linestyle": ':',
@@ -268,14 +271,16 @@
 
         self._legend_handles = []
 
         # when using plotgrid, set imagegrid=True to require matplotlib to
         # use ImageGrid, which is suited to create equal aspect ratio axes
         # sharing colorbar
         self._imagegrid = kwargs.get("imagegrid", False)
+        self._update_event = kwargs.get(
+            "update_event", cfg["matplotlib"]["update_event"])
 
         self._create_renderers()
 
     def _set_piecewise_color(self, s, color):
         """Set the color to the given series"""
         if "color" not in s.rendering_kw:
             # only set the color if the user didn't do that already
@@ -340,14 +345,20 @@
             elif (
                 self.polar_axis and
                 any(s.is_2Dline or s.is_contour for s in self.series)
             ):
                 kwargs["projection"] = "polar"
             self._ax = self._fig.add_subplot(1, 1, 1, **kwargs)
 
+        if self._update_event:
+            self._fig.canvas.mpl_connect(
+                'button_release_event', self._update_axis_limits)
+            self._fig.canvas.mpl_connect(
+                'resize_event', self._update_axis_limits)
+
     def _create_ax_if_not_available(self):
         if (not hasattr(self, "_ax")):
             # if the backend was created without showing it
             self.draw()
 
     @property
     def fig(self):
@@ -597,14 +608,23 @@
         if self.xlim:
             self._ax.set_xlim(self.xlim)
         if self.ylim:
             self._ax.set_ylim(self.ylim)
         if self.zlim:
             self._ax.set_zlim(self.zlim)
 
+    def _update_axis_limits(self, event):
+        xlim = self._ax.get_xlim()
+        ylim = self._ax.get_ylim()
+        limits = [xlim, ylim]
+        if isinstance(self._ax, self.Axes3D):
+            limits += self._ax.get_zlim()
+        params = self._update_series_ranges(*limits)
+        self.update_interactive(params)
+
     def _add_colorbar(self, c, label, show_cb, norm=None, cmap=None):
         """Add a colorbar for the specificied collection
 
         Parameters
         ==========
 
         c : collection
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/__init__.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -15,17 +15,20 @@
     Arrow2DRendererQuivers, Arrow2DRendererFancyArrowPatch
 )
 from spb.backends.matplotlib.renderers.arrow3d import Arrow3DRendererFancyArrowPatch
 from spb.backends.matplotlib.renderers.sgrid import SGridLineRenderer
 from spb.backends.matplotlib.renderers.zgrid import ZGridLineRenderer
 from spb.backends.matplotlib.renderers.ngrid import NGridLineRenderer
 from spb.backends.matplotlib.renderers.mcircles import MCirclesRenderer
+from spb.backends.matplotlib.renderers.polezero import PoleZeroRenderer
+from spb.backends.matplotlib.renderers.nichols import NicholsLineRenderer
 
 __all__ = [
     "Line2DRenderer", "Line3DRenderer", "ContourRenderer", "SurfaceRenderer",
     "GeometryRenderer", "Implicit2DRenderer", "Vector2DRenderer",
     "Vector3DRenderer", "ComplexRenderer", "GenericRenderer",
     "HVLineRenderer", "NyquistRenderer",
     "Arrow2DRendererQuivers", "Arrow2DRendererFancyArrowPatch",
     "Arrow3DRendererFancyArrowPatch", "RootLocusRenderer", "SGridLineRenderer",
-    "ZGridLineRenderer", "NGridLineRenderer", "MCirclesRenderer"
+    "ZGridLineRenderer", "NGridLineRenderer", "MCirclesRenderer",
+    "PoleZeroRenderer", "NicholsLineRenderer"
 ]
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/arrow2d.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/arrow2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/arrow3d.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/arrow3d.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 from matplotlib.patches import FancyArrowPatch
-import numpy as np
 from sympy.external import import_module
 from spb.backends.matplotlib.renderers.renderer import MatplotlibRenderer
 from spb.backends.matplotlib.renderers.vector2d import (
     _draw_vector2d_helper, _update_vector2d_helper
 )
 
 
@@ -20,24 +19,31 @@
     def __init__(self, x, y, z, dx, dy, dz, *args, **kwargs):
         super().__init__((0, 0), (0, 0), *args, **kwargs)
         self._xyz = (x, y, z)
         self._dxdydz = (dx, dy, dz)
         mpl_toolkits = import_module("mpl_toolkits")
         self.proj_transform = mpl_toolkits.mplot3d.proj3d.proj_transform
 
+    # NOTE: when looking at coverage results, draw() and do_3d_projection()
+    # appears to be unused.
+    # One might be inclined to removed them. Don't! Matplotlib probably
+    # executes these methods at visualization time, when the figure is actually
+    # shown on screen. They are not going to be executed when the figure is
+    # created.
     def draw(self, renderer):
         x1, y1, z1 = self._xyz
         dx, dy, dz = self._dxdydz
         x2, y2, z2 = (x1 + dx, y1 + dy, z1 + dz)
 
         xs, ys, zs = self.proj_transform((x1, x2), (y1, y2), (z1, z2), self.axes.M)
         self.set_positions((xs[0], ys[0]), (xs[1], ys[1]))
         super().draw(renderer)
 
     def do_3d_projection(self, renderer=None):
+        np = import_module("numpy")
         x1, y1, z1 = self._xyz
         dx, dy, dz = self._dxdydz
         x2, y2, z2 = (x1 + dx, y1 + dy, z1 + dz)
 
         xs, ys, zs = self.proj_transform((x1, x2), (y1, y2), (z1, z2), self.axes.M)
         self.set_positions((xs[0], ys[0]), (xs[1], ys[1]))
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/complex.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/complex.py`

 * *Files 3% similar despite different names*

```diff
@@ -120,14 +120,18 @@
     p, s = renderer.plot, renderer.series
     np = p.np
 
     if not s.is_3Dsurface:
         x, y, _, _, img, colors = data
         if s.at_infinity:
             img = np.flip(np.flip(img, axis=0), axis=1)
+            extent = [np.amax(x), np.amin(x), np.amin(y), np.amax(y)]
+        else:
+            extent = [np.amin(x), np.amax(x), np.amin(y), np.amax(y)]
+        handle[0].set_extent(extent)
         handle[0].set_data(img)
     else:
         x, y, mag, arg, facecolors, colorscale = data
         handle[0].remove()
         kw = handle[1]
         if s.use_cm:
             kw["facecolors"] = facecolors / 255
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/contour.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/contour.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/generic.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/generic.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/geometry.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/geometry.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/hvline.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/hvline.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/implicit2d.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/implicit2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/line2d.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/line2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/line3d.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/line3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/mcircles.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/mcircles.py`

 * *Files 5% similar despite different names*

```diff
@@ -38,14 +38,18 @@
                 verticalalignment="center",
                 bbox=dict(
                     facecolor="white", edgecolor="none",
                     boxstyle='square,pad=0'
                 )
             )
         handles.append([h1, h2])
+
+    # Mark the -1 point
+    p._ax.plot([-1], [0], 'r+')
+
     return handles
 
 
 def _update_mcircles_helper(renderer, data, handles):
     p = renderer.plot
     s = renderer.series
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/ngrid.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/ngrid.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-from spb.backends.matplotlib.renderers.renderer import MatplotlibRenderer
 from spb.backends.matplotlib.renderers.sgrid import (
     SGridLineRenderer, _text_position_limits, _find_data_axis_limits,
     _modify_axis_limits
 )
 from spb.series import NGridLineSeries, NicholsLineSeries
 from sympy.external import import_module
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/nyquist.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/nyquist.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,10 @@
 from spb.backends.matplotlib.renderers.renderer import MatplotlibRenderer
 from spb.utils import unwrap
-
-import numpy as np
-import matplotlib as mpl
-import matplotlib.font_manager as font_manager
-import matplotlib.text as text
+from sympy.external import import_module
 import warnings
 
 
 def _draw_arrows_helper(
     ax, line, arrow_locs=[0.2, 0.4, 0.6, 0.8], arrowstyle='-|>', dir=1
 ):
     """
@@ -31,14 +27,16 @@
 
     Based on:
     https://stackoverflow.com/questions/26911898/
 
     Based on:
     https://github.com/python-control/python-control/blob/main/control/freqplot.py
     """
+    np = import_module("numpy")
+    mpl = import_module("matplotlib")
     if not isinstance(line, mpl.lines.Line2D):
         raise ValueError("expected a matplotlib.lines.Line2D object")
     x, y = line.get_xdata(), line.get_ydata()
 
     arrow_kw = {
         "arrowstyle": arrowstyle,
     }
@@ -118,14 +116,15 @@
             style = [pskw1, pskw2]
         else:
             style = user_provided_style
     return style
 
 
 def _draw_nyquist_helper(renderer, data):
+    mpl = import_module("matplotlib")
     p, s = renderer.plot, renderer.series
     color = next(p._cl)
     ax = p.ax
 
     x_reg, y_reg, x_scl, y_scl, x_inv1, y_inv1, x_inv2, y_inv2, curve_offset = data
 
     primary_style = ['-', '-.']
@@ -194,26 +193,24 @@
         smkw = {"marker": "o", "markersize": 4, "color": color}
         if isinstance(s.start_marker, str):
             smkw["marker"] = s.start_marker
         elif isinstance(s.start_marker, dict):
             smkw = p.merge({}, s.start_marker)
         start_marker_handle, = ax.plot(x_reg[0], y_reg[0], **smkw)
 
-    # Mark the -1 point
-    ax.plot([-1], [0], 'r+')
-
     handles = [
         primary_line, scl_primary_line, invisible_primary_line,
         secondary_line, scl_secondary_line, invisible_secondary_line,
         start_marker_handle, arrows_handles
     ]
     return handles
 
 
 def _update_nyquist_helper(renderer, data, handles):
+    mpl = import_module("matplotlib")
     p, s = renderer.plot, renderer.series
     ax = p.ax
     primary_line, scl_primary_line, invisible_primary_line = handles[:3]
     secondary_line, scl_secondary_line, invisible_secondary_line = handles[3:6]
     start_marker_handle = handles[-2]
     arrows_handles = handles[-1]
     arrow_style = mpl.patches.ArrowStyle('simple', head_width=6, head_length=6)
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/renderer.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/renderer.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/root_locus.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/root_locus.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/sgrid.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/sgrid.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/surface.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/surface.py`

 * *Files 4% similar despite different names*

```diff
@@ -30,15 +30,15 @@
 
     kw = p.merge({}, skw, s.rendering_kw)
     if s.use_cm:
         # facecolors must be computed here because s.rendering_kw
         # might have its own cmap
         cmap = kw["cmap"]
         if isinstance(cmap, str):
-            cmap = p.cm.get_cmap(cmap)
+            cmap = p.matplotlib.colormaps[cmap]
         kw["facecolors"] = cmap(norm(facecolors))
     c = p._ax.plot_surface(x, y, z, **kw)
     is_cb_added = p._add_colorbar(
         c, s.get_label(p._use_latex),
         s.use_cm and s.colorbar,
         norm=norm,
         cmap=cmap
@@ -63,15 +63,15 @@
         # shown with legend=False, this won't get executed.
         # In widget plots, the surface will never change color.
         vmin = s.rendering_kw.get("vmin", p.np.amin(facecolors))
         vmax = s.rendering_kw.get("vmax", p.np.amax(facecolors))
         norm = p.Normalize(vmin=vmin, vmax=vmax)
         cmap = kw["cmap"]
         if isinstance(cmap, str):
-            cmap = p.cm.get_cmap(cmap)
+            cmap = p.matplotlib.colormaps[cmap]
         kw["facecolors"] = cmap(norm(facecolors))
     handle[0].remove()
     handle[0] = p._ax.plot_surface(
         x, y, z, **kw)
 
     if is_cb_added:
         p._update_colorbar(
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/vector2d.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/vector2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/vector3d.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/vector3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/matplotlib/renderers/zgrid.py` & `sympy_plot_backends-3.2.0/spb/backends/matplotlib/renderers/zgrid.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 from spb.backends.matplotlib.renderers.renderer import MatplotlibRenderer
-import numpy as np
 
 
 def _draw_zgrid_helper(renderer, data):
     p, s = renderer.plot, renderer.series
     xi_dict, wn_dict, tp_dict, ts_dict = data
 
     lkw = p.grid_line_kw
@@ -22,15 +21,15 @@
         xi_handles.append([h1, h2, h3])
 
     # natural frequency lines
     wn_handles = []
     for k, v in wn_dict.items():
         h1, = p._ax.plot(v["x"], v["y"], **kw)
         h2 = p._ax.annotate(
-            v["label"], xy=(v["lx"], v["ly"]),
+            v["label"](p._use_latex), xy=(v["lx"], v["ly"]),
             xytext=(v["lx"], v["ly"]), size=9,
             horizontalalignment="center",
             verticalalignment="center")
         wn_handles.append([h1, h2])
 
     # peak time lines
     tp_handles = []
@@ -58,29 +57,30 @@
         p._ax.axhline(0, **kw)
         p._ax.axvline(0, **kw)
 
     return [xi_handles, wn_handles, tp_handles, ts_handles]
 
 
 def _update_zgrid_helper(renderer, data, handles):
+    p = renderer.plot
     xi_handles, wn_handles, tp_handles, ts_handles = handles
     xi_dict, wn_dict, tp_dict, ts_dict = data
 
     for v, handles in zip(xi_dict.values(), xi_handles):
         h1, h2, h3 = handles
         h1.set_data(v["x1"], v["y1"])
         h2.set_data(v["x2"], v["y2"])
         h3.set_position([v["lx"], v["ly"]])
         h3.set_text(v["label"])
 
     for v, handles in zip(wn_dict.values(), wn_handles):
         h1, h2 = handles
         h1.set_data(v["x"], v["y"])
         h2.set_position([v["lx"], v["ly"]])
-        h2.set_text(v["label"])
+        h2.set_text(v["label"](p._use_latex))
 
     for v, handles in zip(tp_dict.values(), tp_handles):
         h1, h2 = handles
         h1.set_data(v["x"], v["y"])
         h2.set_position([v["lx"], v["ly"]])
         h2.set_text(v["label"])
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/mayavi/mayavi.py` & `sympy_plot_backends-3.2.0/spb/backends/mayavi/mayavi.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/implicit3d.py` & `sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/implicit3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/line3d.py` & `sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/line3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/surface.py` & `sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/surface.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/mayavi/renderers/vector3d.py` & `sympy_plot_backends-3.2.0/spb/backends/mayavi/renderers/vector3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/plotly.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/plotly.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,14 +15,15 @@
     RiemannSphereSeries, Implicit3DSeries,
     ComplexDomainColoringSeries, ComplexSurfaceSeries,
     ContourSeries, SurfaceOver2DRangeSeries, ParametricSurfaceSeries,
     PlaneSeries, GeometrySeries, GenericDataSeries,
     HVLineSeries, Arrow2DSeries
 )
 from sympy.external import import_module
+import warnings
 
 
 class PlotlyBackend(Plot):
     """
     A backend for plotting SymPy's symbolic expressions using Plotly.
 
     Parameters
@@ -73,17 +74,18 @@
         Turns on/off the axis visibility (and associated tick labels).
         Default to True (axis are visible).
 
     theme : str, optional
         Set the theme. Default to ``"plotly_dark"``. Find more Plotly themes at
         [#fn10]_ .
 
-    use_cm : boolean, optional
-        If True, apply a color map to the meshes/surface. If False, solid
-        colors will be used instead. Default to True.
+    update_event : bool, optional
+        If True, it binds pan/zoom events in order to automatically compute
+        new data as the user interact with the plot.
+        Default to False.
 
     annotations : list, optional
         A list of dictionaries specifying the type the markers required.
         The keys in the dictionary should be equivalent to the arguments
         of the Plotly's `graph_objects.Scatter` class. Refer to [#fn15]_
         for more information.
         This feature is experimental. It might get removed in the future.
@@ -218,24 +220,37 @@
         # with dark or light theme respectively... Need a better selection
         # of colors. Although, they are placed in the middle of the loop,
         # so they are unlikely going to be used.
         self.quivers_colors = [
             "magenta", "crimson", "darkorange", "dodgerblue", "wheat",
             "slategrey", "white", "black", "darkred", "indigo"]
 
+        self._update_event = kwargs.get(
+            "update_event", cfg["plotly"]["update_event"])
+        if (self._update_event and any(isinstance(s, Vector2DSeries) for
+            s in series)):
+            warnings.warn(
+                "You are trying to use `update_event=True` with a 2D quiver "
+                "plot. This is likely going to cause a render-loop. You might "
+                "need to interrupt the kernel."
+            )
+
         # _init_cyclers needs to know if an existing figure was provided
         self._use_existing_figure = kwargs.get("fig", False)
         self._fig = None
         self._init_cyclers()
         super().__init__(*series, **kwargs)
         if self._use_existing_figure:
             self._fig = self._use_existing_figure
             self._use_existing_figure = True
         else:
-            if self.is_iplot and (self.imodule == "ipywidgets"):
+            if (
+                (self.is_iplot and (self.imodule == "ipywidgets"))
+                or self._update_event
+            ):
                 self._fig = self.go.FigureWidget()
             else:
                 self._fig = self.go.Figure()
 
         # NOTE: Plotly 3D currently doesn't support latex labels
         # https://github.com/plotly/plotly.js/issues/608
         self._use_latex = kwargs.get("use_latex", cfg["plotly"]["use_latex"])
@@ -266,14 +281,32 @@
             any(s.use_cm for s in self.series) and
             any((not s.use_cm) for s in self.series)
         )
         self._show_2D_vectors = any(s.is_2Dvector for s in self.series)
         self._create_renderers()
         self._n_annotations = 0
 
+        if self._update_event:
+            self._fig.layout.on_change(
+                lambda obj, xrange, yrange: self._update_axis_limits(xrange, yrange),
+                ('xaxis', 'range'), ('yaxis', 'range'))
+
+    def _update_axis_limits(self, *limits):
+        """Update the ranges of data series in order to implement pan/zoom
+        update events.
+
+        Parameters
+        ==========
+        limits : iterable
+            Tuples of (min, max) values.
+        """
+
+        params = self._update_series_ranges(*limits)
+        self.update_interactive(params)
+
     @property
     def fig(self):
         """Returns the figure."""
         if len(self.renderers) > 0 and len(self.renderers[0].handles) == 0:
             # if the backend was created without showing it
             self.draw()
         return self._fig
```

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/__init__.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/arrow2d.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/arrow2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/complex.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/complex.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/contour.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/contour.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/geometry.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/geometry.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/implicit3d.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/implicit3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/line2d.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/line2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/line3d.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/line3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/surface.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/surface.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/vector2d.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/vector2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/plotly/renderers/vector3d.py` & `sympy_plot_backends-3.2.0/spb/backends/plotly/renderers/vector3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/backends/utils.py` & `sympy_plot_backends-3.2.0/spb/backends/utils.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/ccomplex/complex.py` & `sympy_plot_backends-3.2.0/spb/ccomplex/complex.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/control.py` & `sympy_plot_backends-3.2.0/spb/control.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/defaults.py` & `sympy_plot_backends-3.2.0/spb/defaults.py`

 * *Files 7% similar despite different names*

```diff
@@ -21,14 +21,16 @@
         plotly={
             # More themes at: https://plotly.com/python/templates/
             "theme": "seaborn",
             # Show/hide main grid
             "grid": True,
             # Render latex with Plotly
             "use_latex": False,
+            # automatically compute new data when zoom/pan are used
+            "update_event": False,
         },
         bokeh={
             # More themes at:
             # https://docs.bokeh.org/en/latest/docs/reference/themes.html
             "theme": "caliber",
             # How will the plot resizes to fill the available space.
             "sizing_mode": "stretch_width",
@@ -42,14 +44,16 @@
             # Depending on the used Bokeh `themes`, probably need
             # to adjust the opacity of the minor grid lines
             "minor_grid_line_alpha": 0.6,
             # Controls the spacing of the dashes in minor grid lines
             "minor_grid_line_dash": [2, 2],
             # Render latex with Bokeh
             "use_latex": False,
+            # automatically compute new data when zoom/pan are used
+            "update_event": False,
         },
         k3d={
             # Background color
             "bg_color": 0xFFFFFF,       # 3620427
             # Grid color
             "grid_color": 0xE6E6E6,     # 0x888888
             # Color of the labels
@@ -71,14 +75,16 @@
             "axis_center": None,
             # Show/hide main grid
             "grid": True,
             # Show/hide minor grid
             "show_minor_grid": False,
             # Render latex with Matplotlib
             "use_latex": True,
+            # automatically compute new data when zoom/pan are used
+            "update_event": False,
         },
         mayavi={
             "size": (800, 500),
             "bg_color": None,
             "fg_color": None,
             # Show/hide main grid
             "grid": True,
```

### Comparing `sympy_plot_backends-3.1.1/spb/doc_utils.py` & `sympy_plot_backends-3.2.0/spb/doc_utils.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/functions.py` & `sympy_plot_backends-3.2.0/spb/functions.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/graphics/__init__.py` & `sympy_plot_backends-3.2.0/spb/graphics/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/graphics/complex_analysis.py` & `sympy_plot_backends-3.2.0/spb/graphics/complex_analysis.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/graphics/control.py` & `sympy_plot_backends-3.2.0/spb/graphics/control.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 from spb.defaults import TWO_D_B
 from spb.series import (
-    List2DSeries, LineOver1DRangeSeries, HVLineSeries, NyquistLineSeries,
+    PoleZeroWithSympySeries, LineOver1DRangeSeries, HVLineSeries,
+    NyquistLineSeries,
     NicholsLineSeries, RootLocusSeries, SGridLineSeries, ZGridLineSeries,
     SystemResponseSeries, PoleZeroSeries, NGridLineSeries, MCirclesSeries
 )
 from spb.utils import (
     prange, is_number, tf_to_sympy, tf_to_control, _get_initial_params,
     is_discrete_time, tf_find_time_delay
 )
@@ -272,65 +273,45 @@
     if not isinstance(system, sm.control.lti.TransferFunction):
         system = tf_to_sympy(system)
 
     zeros, poles = _get_zeros_poles_from_symbolic_tf(system)
     zeros_re, zeros_im = [re(z) for z in zeros], [im(z) for z in zeros]
     poles_re, poles_im = [re(p) for p in poles], [im(p) for p in poles]
 
-    prk, zrk, p_label, z_label = _pole_zero_common_keyword_arguments(
-        pole_markersize, zero_markersize, **kwargs
-    )
-    z_series = List2DSeries(
-        zeros_re, zeros_im, z_label,
+    prk, zrk, p_label, z_label = _pole_zero_common_keyword_arguments(**kwargs)
+    z_series = PoleZeroWithSympySeries(
+        zeros_re, zeros_im, z_label, return_poles=False,
         scatter=True, is_filled=True, rendering_kw=zrk,
-        **kwargs
+        zero_markersize=zero_markersize, **kwargs
     )
-    p_series = List2DSeries(
-        poles_re, poles_im, p_label,
+    p_series = PoleZeroWithSympySeries(
+        poles_re, poles_im, p_label, return_poles=True,
         scatter=True, is_filled=True, rendering_kw=prk,
-        **kwargs
+        pole_markersize=pole_markersize, **kwargs
     )
     return [p_series, z_series]
 
 
 def _pole_zero_with_control_helper(
     system, pole_markersize, zero_markersize,
     **kwargs
 ):
-    params = kwargs.get("params", {})
-    prk, zrk, p_label, z_label = _pole_zero_common_keyword_arguments(
-        pole_markersize, zero_markersize, **kwargs
-    )
+    prk, zrk, p_label, z_label = _pole_zero_common_keyword_arguments(**kwargs)
     return [
         PoleZeroSeries(system, p_label, return_poles=True,
-            rendering_kw=prk, params=params),
+            rendering_kw=prk, pole_markersize=pole_markersize, **kwargs),
         PoleZeroSeries(system, z_label, return_poles=False,
-            rendering_kw=zrk, params=params),
+            rendering_kw=zrk, zero_markersize=zero_markersize, **kwargs),
     ]
 
 
-def _pole_zero_common_keyword_arguments(
-    pole_markersize, zero_markersize, **kwargs
-):
+def _pole_zero_common_keyword_arguments(**kwargs):
     label = kwargs.get("label", None)
-    Backend = kwargs.get("backend", TWO_D_B)
     z_rendering_kw = kwargs.pop("z_rendering_kw", {})
     p_rendering_kw = kwargs.pop("p_rendering_kw", {})
-    z_kw, p_kw = {}, {}
-    if hasattr(Backend, "_library") and (Backend._library == "matplotlib"):
-        z_kw = dict(marker="o", markersize=zero_markersize)
-        p_kw = dict(marker="x", markersize=pole_markersize)
-        zero_color = kwargs.pop("zero_color", None)
-        if zero_color:
-            z_kw["color"] = zero_color
-        pole_color = kwargs.pop("pole_color", None)
-        if pole_color:
-            z_kw["color"] = pole_color
-    z_rendering_kw = merge(z_kw, z_rendering_kw)
-    p_rendering_kw = merge(p_kw, p_rendering_kw)
     get_label = lambda t: t + " of " + label if label else t
     z_label = get_label("zeros")
     p_label = get_label("poles")
     return p_rendering_kw, z_rendering_kw, p_label, z_label
 
 
 def pole_zero(
@@ -405,15 +386,15 @@
     Returns
     =======
 
     A list containing:
 
     * one instance of ``SGridLineSeries`` if ``sgrid=True``.
     * one instance of ``ZGridLineSeries`` if ``zgrid=True``.
-    * one or more instances of ``List2DSeries`` if ``control=False``.
+    * one or more instances of ``PoleZeroWithSympySeries`` if ``control=False``.
     * one or more instances of ``PoleZeroSeries`` if ``control=True``.
 
     Examples
     ========
 
     .. plot::
         :context: reset
@@ -482,15 +463,15 @@
     ==========
 
     .. [1] https://en.wikipedia.org/wiki/Pole%E2%80%93zero_plot
 
     See Also
     ========
 
-    sgrid, zgrid
+    sgrid, zgrid, root_locus
 
     """
     control = _check_if_control_is_installed(use_control=control)
     systems = _unpack_mimo_systems(
         system,
         "" if label is None else label,
         input, output
@@ -581,16 +562,17 @@
     # allows parametric lower_limit
     lower_limit = sympify(lower_limit)
     if lower_limit.is_Number and lower_limit < 0:
         raise ValueError(
             "Lower limit of time must be greater than or equal to zero."
         )
     if (
-        (lower_limit.is_Number and lower_limit > 0) or
-        (len(lower_limit.free_symbols) > 0)
+        control and
+        ((lower_limit.is_Number and lower_limit > 0) or
+        (len(lower_limit.free_symbols) > 0))
     ):
         warnings.warn(
             "You are evaluating a transfer function using the ``control`` "
             "module, but you also set ``lower_limit != 0``. This is likely "
             "going to produce incorrect results. Please, consider "
             "setting ``control=False`` when using ``lower_limit != 0``."
         )
@@ -742,17 +724,16 @@
        tf2 = TransferFunction(s**2 + a*s + b, s**3 + c*s**2 + d*s + e, s)
        params = {
            a: (3.7, 0, 5),
            b: (10, 0, 20),
            c: (7, 0, 8),
            d: (6, 0, 25),
            e: (16, 0, 25),
-           # NOTE: remove `None` if using ipywidgets
-           f: (0, 0, 10, 50, None, "lower limit"),
-           g: (10, 0, 25, 50, None, "upper limit"),
+           f: (0, 0, 10, 50, "lower limit"),
+           g: (10, 0, 25, 50, "upper limit"),
        }
        graphics(
            line(Heaviside(t), (t, -1, 10), label="step"),
            step_response(
                tf1, label="A", lower_limit=f, upper_limit=g, params=params,
                control=False),
            step_response(
@@ -975,17 +956,16 @@
        params = {
            a: (4, 0, 10),
            b: (24, 0, 40),
            c: (50, 0, 50),
            d: (3, 0, 25),
            e: (12.5, 0, 25),
            f: (17.5, 0, 50),
-           # NOTE: remove `None` if using ipywidgets
-           g: (0, 0, 10, 50, None, "lower limit"),
-           h: (8, 0, 25, 50, None, "upper limit"),
+           g: (0, 0, 10, 50, "lower limit"),
+           h: (8, 0, 25, 50, "upper limit"),
        }
        graphics(
            impulse_response(
                tf1, label="A", lower_limit=g, upper_limit=h, params=params,
                control=True),
            impulse_response(
                tf2, label="B", lower_limit=g, upper_limit=h, params=params,
@@ -1221,18 +1201,17 @@
        from spb import *
        a, b, c, xi, wn, s, t = symbols("a, b, c, xi, omega_n, s, t")
        tf1 = TransferFunction(25, s**2 + 10*s + 25, s)
        tf2 = TransferFunction(wn**2, s**2 + 2*xi*wn*s + wn**2, s)
        params = {
            xi: (6, 0, 10),
            wn: (25, 0, 50),
-           # NOTE: remove `None` if using ipywidgets
-           a: (1, 0, 10, 50, None, "slope"),
-           b: (0, 0, 5, 50, None, "lower limit"),
-           c: (5, 2, 10, 50, None, "upper limit"),
+           a: (1, 0, 10, 50, "slope"),
+           b: (0, 0, 5, 50, "lower limit"),
+           c: (5, 2, 10, 50, "upper limit"),
        }
        graphics(
            line(a*t, (t, 0, c), params=params, label="ramp"),
            ramp_response(
                tf1, label="A", slope=a, lower_limit=b, upper_limit=c,
                params=params, control=False),
            ramp_response(
@@ -1944,23 +1923,28 @@
     system = tf_to_sympy(system)
     s = system.var
     omega = Dummy("omega")
     _range, omega_limits = _compute_range_helper(system, **kwargs)
     _range = prange(omega, *_range[1:])
 
     system_expr = system.to_expr()
+    # closed loop system is used to generate data for tooltips
+    cl_system_expr = (system_expr / (1 + system_expr)).simplify().expand().together()
+
     system_expr = system_expr.subs(s, I * omega)
+    cl_system_expr = cl_system_expr.subs(s, I * omega)
 
     kwargs.setdefault("use_cm", False)
     kwargs.setdefault("xscale", "log")
     return NicholsLineSeries(
-        arg(system_expr), Abs(system_expr), _range, label, **kwargs)
+        system, arg(system_expr), Abs(system_expr),
+        arg(cl_system_expr), Abs(cl_system_expr), _range, label, **kwargs)
 
 
-def nichols(system, label=None, rendering_kw=None, ngrid=True,
+def nichols(system, label=None, rendering_kw=None, ngrid=True, arrows=True,
     input=None, output=None, **kwargs):
     """Nichols plot for a system over a (optional) frequency range.
 
     Parameters
     ==========
 
     system : LTI system type
@@ -1973,14 +1957,22 @@
         * an instance of :py:class:`scipy.signal.TransferFunction`
         * a symbolic expression in rational form, which will be converted to
           an object of type
           :py:class:`sympy.physics.control.lti.TransferFunction`.
         * a tuple of two or three elements: ``(num, den, generator [opt])``,
           which will be converted to an object of type
           :py:class:`sympy.physics.control.lti.TransferFunction`.
+    arrows : bol, int or 1D array of floats, optional
+        Specify the number of arrows to plot on the Nichols curve.  If an
+        integer is passed, that number of equally spaced arrows will be
+        plotted on each of the primary segment and the mirror image.  If a 1D
+        array is passed, it should consist of a sorted list of floats between
+        0 and 1, indicating the location along the curve to plot an arrow.
+        If True, a default number of arrows is shown. If False, no arrows
+        are shown.
     ngrid : bool, optional
         Turn on/off the [Nichols]_ grid lines.
     omega_limits : array_like of two values, optional
         Limits to the range of frequencies.
     label : str, optional
         The label to be shown on the legend.
     rendering_kw : dict, optional
@@ -2080,16 +2072,16 @@
     )
 
     series = []
     for s, l in systems:
         s = _preprocess_system(s, **kwargs)
         _check_system(s)
         series.append(
-            _nichols_helper(s, l, rendering_kw=rendering_kw, **kwargs.copy())
-        )
+            _nichols_helper(s, l, rendering_kw=rendering_kw,
+                arrows=arrows,**kwargs.copy()))
 
     grid = []
     if ngrid:
         grid = ngrid_function()
     return grid + series
 
 
@@ -2196,15 +2188,15 @@
            root_locus(G, params=params),
            grid=False, xlim=(-4, 1), ylim=(-2.5, 2.5),
            xlabel="Real", ylabel="Imaginary")
 
     See Also
     ========
 
-    sgrid, zgrid
+    sgrid, zgrid, pole_zero
     """
     control = _check_if_control_is_installed(force_stop=True)
     systems = _unpack_mimo_systems(
         system,
         "" if label is None else label,
         input, output
     )
@@ -2616,32 +2608,41 @@
             **kwargs)
     ]
 
 
 ngrid_function = ngrid
 
 
-def mcircles(magnitudes_db=None, rendering_kw=None, **kwargs):
+def mcircles(
+    magnitudes_db=None, rendering_kw=None, show_minus_one=True, **kwargs
+):
     """Draw M-circles of constant closed-loop magnitude.
 
     Parameters
     ==========
     magnitudes_db : float, iterable or None
         Specify the magnitudes in dB.
         If None, a list of default magnitudes will be used.
     rendering_kw : dict or None, optional
         A dictionary of keywords/values which is passed to the backend's
         function to customize the appearance of lines. Refer to the
         plotting library (backend) manual for more informations.
+    show_minus_one : bool
+        Show a marker at (x, y) = (-1, 0).
 
     Returns
     =======
 
     A list containing one instance of ``MCirclesSeries``.
 
+    See Also
+    ========
+
+    nyquist
+
     Examples
     ========
 
     .. plot::
        :context: close-figs
        :include-source: True
 
@@ -2671,15 +2672,15 @@
         dbs = [magnitudes_db]
     else:
         dbs = magnitudes_db
 
     magnitudes = [10**(t / 20) for t in dbs]
     return [
         MCirclesSeries(dbs, magnitudes,
-            rendering_kw=rendering_kw, **kwargs)
+            rendering_kw=rendering_kw, show_minus_one=show_minus_one, **kwargs)
     ]
 
 mcircles_func = mcircles
 
 def _default_frequency_exponent_range(
     syslist, Hz=None, feature_periphery_decades=None
 ):
```

### Comparing `sympy_plot_backends-3.1.1/spb/graphics/functions_2d.py` & `sympy_plot_backends-3.2.0/spb/graphics/functions_2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/graphics/functions_3d.py` & `sympy_plot_backends-3.2.0/spb/graphics/functions_3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/graphics/graphics.py` & `sympy_plot_backends-3.2.0/spb/graphics/graphics.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,15 +8,16 @@
 )
 from spb.utils import _instantiate_backend
 
 
 def graphics(
     *args, aspect=None, axis_center=None, is_polar=None, legend=None,
     show=True, size=None, title=None, xlabel=None, ylabel=None, zlabel=None,
-    xlim=None, ylim=None, zlim=None, fig=None, ax=None, **kwargs
+    xlim=None, ylim=None, zlim=None, fig=None, ax=None,
+    update_event=None, **kwargs
 ):
     """Plots a collection of data series.
 
     Parameters
     ==========
 
     *args :
@@ -49,14 +50,17 @@
         by calling the ``save()`` and ``show()`` methods respectively.
     size : (float, float), optional
         A tuple in the form (width, height) to specify the size of
         the overall figure. The default value is set to ``None``, meaning
         the size will be set by the backend.
     title : str, optional
         Title of the plot.
+    update_event : bool
+        If True, enable auto-update on panning. Default to False.
+        Some backend may not implement this feature.
     use_latex : boolean, optional
         Turn on/off the rendering of latex labels. If the backend doesn't
         support latex, it will render the string representations instead.
     xlabel, ylabel, zlabel : str, optional
         Labels for the x-axis, y-axis or z-axis, respectively.
     xscale, yscale, zscale : 'linear' or 'log', optional
         Sets the scaling of the x-axis, y-axis, z-axis, respectively.
@@ -75,29 +79,30 @@
         If any of the data series is interactive (``params`` has been set)
         then an instance of ``InteractivePlot`` is returned, otherwise an
         instance of the ``Plot`` class is returned.
 
     Examples
     ========
 
-    Combining together multiple data series of the same type:
+    Combining together multiple data series of the same type, enabling
+    auto-update on pan:
 
     .. plot::
        :context: close-figs
        :format: doctest
        :include-source: True
 
        >>> from sympy import *
        >>> from spb import *
        >>> x = symbols("x")
        >>> graphics(
        ...     line(cos(x), label="a"),
        ...     line(sin(x), (x, -pi, pi), label="b"),
        ...     line(log(x), rendering_kw={"linestyle": "--"}),
-       ...     title="My title", ylabel="y"
+       ...     title="My title", ylabel="y", update_event=True
        ... )
        Plot object containing:
        [0]: cartesian line: cos(x) for x over (-10.0, 10.0)
        [1]: cartesian line: sin(x) for x over (-3.141592653589793, 3.141592653589793)
        [2]: cartesian line: log(x) for x over (-10.0, 10.0)
 
 
@@ -154,15 +159,15 @@
        >>> noise = (np.random.random_sample(len(xx)) - 0.5) / 5
        >>> yy = yy * (1+noise)
        >>> ax.scatter(xx, yy, marker="*", color="m")  # doctest: +SKIP
        >>> # plot a symbolic expression
        >>> x = symbols("x")
        >>> graphics(
        ...     line(cos(x), (x, -pi, pi), rendering_kw={"ls": "--", "lw": 0.8}),
-       ...     ax=ax)
+       ...     ax=ax, update_event=True)
        Plot object containing:
        [0]: cartesian line: cos(x) for x over (-3.141592653589793, 3.141592653589793)
 
 
     Interactive-widget plot combining together data series of different types:
 
     .. panel-screenshot::
@@ -283,16 +288,18 @@
         kwargs["zlabel"] = zlabel
 
     if any(s.is_interactive for s in series):
         return create_interactive_plot(
             *series,
             aspect=aspect, axis_center=axis_center, is_polar=is_polar,
             legend=legend, show=show, size=size, title=title,
-            xlim=xlim, ylim=ylim, zlim=zlim, ax=ax, fig=fig, **kwargs)
+            xlim=xlim, ylim=ylim, zlim=zlim, ax=ax, fig=fig,
+            update_event=update_event, **kwargs)
 
     is_3D = any(s.is_3D for s in series)
     Backend = kwargs.pop("backend", TWO_D_B if is_3D else THREE_D_B)
     return _instantiate_backend(
         Backend, *series,
         aspect=aspect, axis_center=axis_center,
         is_polar=is_polar, legend=legend, show=show, size=size,
-        title=title, xlim=xlim, ylim=ylim, zlim=zlim, ax=ax, fig=fig, **kwargs)
+        title=title, xlim=xlim, ylim=ylim, zlim=zlim, ax=ax, fig=fig,
+        update_event=update_event, **kwargs)
```

### Comparing `sympy_plot_backends-3.1.1/spb/graphics/utils.py` & `sympy_plot_backends-3.2.0/spb/graphics/utils.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/graphics/vectors.py` & `sympy_plot_backends-3.2.0/spb/graphics/vectors.py`

 * *Files 1% similar despite different names*

```diff
@@ -713,16 +713,16 @@
        >>> from spb import *
        >>> graphics(
        ...     arrow_2d((0, 0), (1, 1)),
        ...     arrow_2d((0, 0), (-1, 1)),
        ...     grid=False, aspect="equal"
        ... )
        Plot object containing:
-       [0]: 2D arrow from [0. 0.] to [1. 1.]
-       [1]: 2D arrow from [0. 0.] to [-1.  1.]
+       [0]: 2D arrow from (0.0, 0.0) to (1.0, 1.0)
+       [1]: 2D arrow from (0.0, 0.0) to (-1.0, 1.0)
 
     Interactive-widget plot of arrows. Refer to the interactive
     sub-module documentation to learn more about the ``params`` dictionary.
 
     .. panel-screenshot::
        :small-size: 800, 610
 
@@ -808,17 +808,17 @@
        ...              rendering_kw={
        ...                  "mutation_scale": 20,
        ...                  "arrowstyle": "-|>",
        ...                  "linestyle": 'dashed',
        ...              }),
        ...     xlabel="x", ylabel="y", zlabel="z")
        Plot object containing:
-       [0]: 3D arrow from [0. 0. 0.] to [1. 0. 0.]
-       [1]: 3D arrow from [0. 0. 0.] to [0. 1. 0.]
-       [2]: 3D arrow from [0. 0. 0.] to [0. 0. 1.]
+       [0]: 3D arrow from (0.0, 0.0, 0.0) to (1.0, 0.0, 0.0)
+       [1]: 3D arrow from (0.0, 0.0, 0.0) to (0.0, 1.0, 0.0)
+       [2]: 3D arrow from (0.0, 0.0, 0.0) to (0.0, 0.0, 1.0)
 
     Interactive-widget plot of arrows. Refer to the interactive
     sub-module documentation to learn more about the ``params`` dictionary.
 
     .. panel-screenshot::
        :small-size: 800, 610
```

### Comparing `sympy_plot_backends-3.1.1/spb/interactive/__init__.py` & `sympy_plot_backends-3.2.0/spb/interactive/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,11 @@
+from collections import Counter
+import math
 from spb.defaults import cfg
+from spb.utils import is_number
 from sympy import latex
 from sympy.external import import_module
 
 
 def _tuple_to_dict(k, v, use_latex=False, latex_wrapper="$%s$"):
     """Create a dictionary of keyword arguments to be later used to
     instantiate sliders.
@@ -33,34 +36,78 @@
                 Label of the slider. Default to None. If None, the string or
                 latex representation will be used. See use_latex for more
                 information.
             spacing : str
                 Discretization spacing. Can be "linear" or "log".
                 Default to "linear".
     """
+    bokeh = import_module("bokeh", import_kwargs={'fromlist': ['models']})
+    TickFormatter = bokeh.models.formatters.TickFormatter if bokeh else None
+
     if not hasattr(v, "__iter__"):
         raise TypeError(
             "Provide a tuple or list for the parameter {}".format(k))
+    if len(v) < 3:
+        raise ValueError(
+            "The parameter-tuple must have at least 3 elements: "
+            "value, min, max. Received: %s" % list(v))
+    if any(not is_number(t) for t in v[:3]):
+        raise TypeError(
+            "The first three elements of the parameter-tuple must be numbers. "
+            "Received: %s" % list(v[:3]))
 
-    N = 40
-    defaults_keys = ["value", "min", "max", "step", "description", "type"]
-    defaults_values = [1, 0, 2, N,
+    defaults_keys = [
+        "value", "min", "max", "step", "formatter", "description", "type"]
+    defaults_values = [1, 0, 2, 0.1, None,
         latex_wrapper % latex(k) if use_latex else str(k),
         "linear",
     ]
-    values = defaults_values.copy()
-    values[: len(v)] = v
-    values[:3] = [float(t) for t in values[:3]]
-    # set the step increment for the slider
-    _min, _max = float(values[1]), float(values[2])
-    if values[3] > 0:
-        N = int(values[3])
-        values[3] = (_max - _min) / N
+
+    # find min, max, value from what the user provided.
+    n1, n2, n3 = [float(t) for t in v[:3]]
+    _min = min(n1, n2, n3)
+    _max = max(n1, n2, n3)
+    if math.isclose(_min, _max):
+        raise ValueError(
+            "The minimum value of the slider must be different from the "
+            "maximum value.")
+    c = Counter([n1, n2, n3])
+    if c[_min] == 2:
+        _val = _min
+    elif c[_max] == 2:
+        _val = _max
     else:
-        values[3] = 1
+        _val = set([n1, n2, n3]).difference([_min, _max]).pop()
+
+    N, formatter, label, spacing = None, None, None, None
+    for a in v[3:]:
+        if is_number(a):
+            N = int(a)
+        elif TickFormatter and isinstance(a, TickFormatter):
+            formatter = a
+        elif isinstance(a, str):
+            b = a.lower()
+            if b in ["linear", "log"]:
+                spacing = b
+            elif b[0] == ".":
+                formatter = a
+            else:
+                label = a
+
+    N = N if N else 40
+    step = (_max - _min) / N
+
+    values = defaults_values.copy()
+    values[:4] = [_val, _min, _max, step]
+    if formatter:
+        values[4] = formatter
+    if label:
+        values[5] = label
+    if spacing:
+        values[6] = spacing
 
     return {k: v for k, v in zip(defaults_keys, values)}
 
 
 def create_interactive_plot(*series, **kwargs):
     """Select which interactive module to use.
     """
```

### Comparing `sympy_plot_backends-3.1.1/spb/interactive/bootstrap_spb/__init__.py` & `sympy_plot_backends-3.2.0/spb/interactive/bootstrap_spb/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/interactive/bootstrap_spb/bootstrap.css` & `sympy_plot_backends-3.2.0/spb/interactive/bootstrap_spb/bootstrap.css`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/interactive/bootstrap_spb/bootstrap.html` & `sympy_plot_backends-3.2.0/spb/interactive/bootstrap_spb/bootstrap.html`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/interactive/ipywidgets.py` & `sympy_plot_backends-3.2.0/spb/interactive/ipywidgets.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,29 +1,39 @@
 import ipywidgets
 from sympy.external import import_module
 from spb.defaults import TWO_D_B, THREE_D_B
 from spb.interactive import _tuple_to_dict, IPlot
 from spb import BB, MB, PlotGrid
 from IPython.display import clear_output
+import warnings
 
 
 def _build_widgets(params, use_latex=True):
     widgets = []
     for s, v in params.items():
         if hasattr(v, "__iter__") and (not isinstance(v, str)):
             d = _tuple_to_dict(s, v, use_latex=use_latex)
+            formatter = d.pop("formatter")
+            if formatter and not isinstance(formatter, str):
+                warnings.warn(
+                    "`ipywidgets` requires ``formatter`` to be of type str.\n"
+                    "Received: %s\nFor example, try '.5f'" % type(formatter)
+                )
             if d.pop("type") == "linear":
-                widgets.append(ipywidgets.FloatSlider(**d))
+                d2 = d.copy()
+                if formatter and isinstance(formatter, str):
+                    d2["readout_format"] = formatter
+                widgets.append(ipywidgets.FloatSlider(**d2))
             else:
                 widgets.append(ipywidgets.FloatLogSlider(**d))
         elif isinstance(v, ipywidgets.Widget):
             widgets.append(v)
         else:
-            raise ValueError("Cannot build a widget with the provided input:"
-                "%s" % v)
+            raise ValueError(
+                "Cannot build a widget with the provided input: %s" % v)
     return widgets
 
 
 def _build_grid_layout(widgets, ncols):
     np = import_module('numpy')
 
     if ncols <= 0:
@@ -67,20 +77,23 @@
 
         if plotgrid:
             self._backend = plotgrid
         else:
             # assure that each series has the correct values associated
             # to parameters
             for s in series:
-                s.params = {k: v.value for k, v in self._params_widgets.items()}
+                if s.is_interactive:
+                    s.params = {
+                        k: v.value for k, v in self._params_widgets.items()}
 
             is_3D = all([s.is_3D for s in series])
             Backend = kwargs.pop("backend", THREE_D_B if is_3D else TWO_D_B)
             kwargs["is_iplot"] = True
             kwargs["imodule"] = "ipywidgets"
+            kwargs["use_latex"] = self._use_latex
             self._backend = Backend(*series, **kwargs)
 
     def _get_iplot_kw(self):
         return {
             "backend": type(self._backend),
             "layout": self._layout,
             "ncols": self._ncols,
@@ -113,14 +126,22 @@
             # won't be any update
             self._backend.plt.ioff()
             if isinstance(self._backend, PlotGrid):
                 if not self._backend.imagegrid:
                     self._backend.fig.tight_layout()
             self._output_figure = ipywidgets.Box([self._backend.fig.canvas])
         elif isinstance(self._backend, BB):
+            if self._backend._update_event:
+                warnings.warn(
+                    "You are trying to generate an interactive plot with "
+                    "Bokeh using `update_event=True`. This mode of operation "
+                    "is not supported. However, setting "
+                    "`imodule='panel', servable=True` "
+                    "with BokehBackend works just fine."
+                )
             self._output_figure = ipywidgets.Output()
             bokeh = import_module(
                 'bokeh',
                 import_kwargs={'fromlist': ['io']},
                 warn_not_installed=True,
                 min_module_version='2.3.0')
             with self._output_figure:
@@ -171,14 +192,17 @@
            where:
 
            - default, min, max : float
                 Default value, minimum value and maximum value of the slider,
                 respectively. Must be finite numbers.
            - N : int, optional
                 Number of steps of the slider.
+           - tick_format : str or None, optional
+                Provide a formatter for the tick value of the slider.
+                Default to ``".2f"``.
            - label: str, optional
                 Custom text associated to the slider.
            - spacing : str, optional
                 Specify the discretization spacing. Default to ``"linear"``,
                 can be changed to ``"log"``.
 
         Note that the parameters cannot be linked together (ie, one parameter
```

### Comparing `sympy_plot_backends-3.1.1/spb/interactive/panel.py` & `sympy_plot_backends-3.2.0/spb/interactive/panel.py`

 * *Files 6% similar despite different names*

```diff
@@ -42,37 +42,36 @@
     # works inside a Jupyter Notebook. Maybe it's possible to use PyQt or Tk.
 
     # Each one of the dynamically added parameters (widgets) will execute a
     # function that modify this parameter, which in turns will trigger an
     # overall update.
     check_val = param.Integer(default=0)
 
-    def _tuple_to_dict_panel(self, k, v):
+    def _dict_to_panel_dict(self, d):
         np = import_module('numpy')
+        _min, _max, default = d["min"], d["max"], d["value"]
+        step, label, _type = d["step"], d["description"], d["type"]
 
-        d = _tuple_to_dict(k, v, self._use_latex, "$$%s$$")
-        values = list(d.values())
-
-        if values[-1] == "log":
+        if _type == "log":
             # In case of a logarithm slider, we need to instantiate the
             # custom parameter MyList.
+            N = int((_max - _min) / step)
 
-            N = 40 if len(v) <= 3 else int(v[3])
-            _min, _max = values[1:3]
-            # # divide the range in N steps evenly spaced in a log scale
+            # divide the range in N steps evenly spaced in a log scale
             options = np.geomspace(_min, _max, N)
             # the provided default value may not be in the computed options.
             # If that's the case, I chose the closest value
-            default = values[0]
             if default not in options:
                 default = min(options, key=lambda x: abs(x - default))
-            return MyList(default=default, objects=list(options), label=values[4])
+            return MyList(
+                default=default, objects=list(options),
+                label=label)
 
         defaults_keys = ["default", "softbounds", "step", "label", "type"]
-        values = [values[0], tuple(values[1:3]), *values[3:]]
+        values = [default, (_min, _max), step, label, _type]
         return {k: v for k, v in zip(defaults_keys, values)}
 
     def __init__(self, *args, name="", params=None, **kwargs):
         bokeh = import_module(
             'bokeh',
             import_kwargs={'fromlist': ['models']},
             min_module_version='2.3.0',
@@ -106,33 +105,31 @@
         # parameter, which will be stored in the following dictionary and
         # later used in the instantiation of the widgets.
         self.formatters = {}
 
         # create and attach the params to the class
         for i, (k, v) in enumerate(params.items()):
             # store the formatter
-            formatter = None
-            if isinstance(v, (list, tuple)) and (len(v) >= 5):
-                if (v[4] is not None) and (not isinstance(v[4], TickFormatter)):
-                    raise TypeError(
-                        "To format the tick value of the widget associated " +
-                        "to the symbol {}, an instance of ".format(k) +
-                        "bokeh.models.formatters.TickFormatter is expected. " +
-                        "Instead, an instance of {} was given.".format(
-                            type(v[4])))
-                formatter = v[4]
-            self.formatters[k] = formatter
+            self.formatters[k] = None
 
             if not isinstance(v, param.parameterized.Parameter):
-                if len(v) >= 5:
-                    # remove tick_format, as it won't be used for the creation
-                    # of the parameter. Its value has already been stored.
-                    v = list(v)
-                    v.pop(4)
-                v = self._tuple_to_dict_panel(k, v)
+                d = _tuple_to_dict(k, v, self._use_latex, "$$%s$$")
+                if (
+                    (d["formatter"] is not None) and
+                    (not isinstance(d["formatter"], TickFormatter))
+                ):
+                    raise TypeError(
+                        "To format the tick value of the widget associated "
+                        "to the symbol %s, an instance of "
+                        "bokeh.models.formatters.TickFormatter is expected. "
+                        "Instead, an instance of %s was given." % (
+                            k, type(d["formatter"])))
+                self.formatters[k] = d["formatter"]
+                v = self._dict_to_panel_dict(d)
+
                 # at this stage, v could be a dictionary representing a number,
                 # or a MyList parameter, representing a log slider
                 if not isinstance(v, param.parameterized.Parameter):
                     v.pop("type", None)
                     v = param.Number(**v)
 
             param_name = "dyn_param_{}".format(i)
@@ -463,15 +460,16 @@
         if plotgrid:
             self._backend = plotgrid
         else:
             # assure that each series has the correct values associated
             # to parameters
             series = list(series)
             for s in series:
-                s.params = self.read_parameters()
+                if s.is_interactive:
+                    s.params = self.read_parameters()
 
             is_3D = all([s.is_3D for s in series])
             Backend = kwargs.pop("backend", THREE_D_B if is_3D else TWO_D_B)
             kwargs["is_iplot"] = True
             kwargs["imodule"] = "panel"
             self._backend = Backend(*series, **kwargs)
             _validate_kwargs(self._backend, **original_kwargs)
@@ -951,15 +949,15 @@
        from sympy.abc import x, y, z
        from spb.interactive import create_widgets
        import param
        from bokeh.models.formatters import PrintfTickFormatter
        formatter = PrintfTickFormatter(format="%.4f")
        r = create_widgets({
            x: (0.035, -0.035, 0.035, 100, formatter),
-           y: (200, 1, 1000, 10, None, "test", "log"),
+           y: (200, 1, 1000, 10, "test", "log"),
            z: param.Integer(3, softbounds=(3, 10), label="n")
        })
 
 
     References
     ==========
```

### Comparing `sympy_plot_backends-3.1.1/spb/plot_functions/__init__.py` & `sympy_plot_backends-3.2.0/spb/plot_functions/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/plot_functions/complex_analysis.py` & `sympy_plot_backends-3.2.0/spb/plot_functions/complex_analysis.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/plot_functions/control.py` & `sympy_plot_backends-3.2.0/spb/plot_functions/control.py`

 * *Files 2% similar despite different names*

```diff
@@ -350,17 +350,16 @@
            (tf1, "A"), (tf2, "B"), lower_limit=f, upper_limit=g,
            params={
                a: (3.7, 0, 5),
                b: (10, 0, 20),
                c: (7, 0, 8),
                d: (6, 0, 25),
                e: (16, 0, 25),
-               # NOTE: remove `None` if using ipywidgets
-               f: (0, 0, 10, 50, None, "lower limit"),
-               g: (10, 0, 25, 50, None, "upper limit"),
+               f: (0, 0, 10, 50, "lower limit"),
+               g: (10, 0, 25, 50, "upper limit"),
            })
 
     See Also
     ========
 
     plot_impulse_response, plot_ramp_response
 
@@ -517,17 +516,16 @@
            params={
                a: (4, 0, 10),
                b: (24, 0, 40),
                c: (50, 0, 50),
                d: (3, 0, 25),
                e: (12.5, 0, 25),
                f: (17.5, 0, 50),
-               # NOTE: remove `None` if using ipywidgets
-               g: (0, 0, 10, 50, None, "lower limit"),
-               h: (8, 0, 25, 50, None, "upper limit"),
+               g: (0, 0, 10, 50, "lower limit"),
+               h: (8, 0, 25, 50, "upper limit"),
            })
 
 
     See Also
     ========
 
     plot_step_response, plot_ramp_response
@@ -684,18 +682,17 @@
        from spb import plot_ramp_response
        a, b, c, xi, wn, s, t = symbols("a, b, c, xi, omega_n, s, t")
        tf1 = TransferFunction(25, s**2 + 10*s + 25, s)
        tf2 = TransferFunction(wn**2, s**2 + 2*xi*wn*s + wn**2, s)
        params = {
            xi: (6, 0, 10),
            wn: (25, 0, 50),
-           # NOTE: remove `None` if using ipywidgets
-           a: (1, 0, 10, 50, None, "slope"),
-           b: (0, 0, 5, 50, None, "lower limit"),
-           c: (5, 2, 10, 50, None, "upper limit"),
+           a: (1, 0, 10, 50, "slope"),
+           b: (0, 0, 5, 50, "lower limit"),
+           c: (5, 2, 10, 50, "upper limit"),
        }
        plot_ramp_response(
            (tf1, "A"), (tf2, "B"),
            slope=a, lower_limit=b, upper_limit=c,
            params=params)
 
     See Also
```

### Comparing `sympy_plot_backends-3.1.1/spb/plot_functions/functions_2d.py` & `sympy_plot_backends-3.2.0/spb/plot_functions/functions_2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/plot_functions/functions_3d.py` & `sympy_plot_backends-3.2.0/spb/plot_functions/functions_3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/plot_functions/vectors.py` & `sympy_plot_backends-3.2.0/spb/plot_functions/vectors.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/plotgrid.py` & `sympy_plot_backends-3.2.0/spb/plotgrid.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/spb/series.py` & `sympy_plot_backends-3.2.0/spb/series.py`

 * *Files 0% similar despite different names*

```diff
@@ -2028,9320 +2028,9490 @@
 00007eb0: 6f6e 6c79 5f69 6e74 6567 6572 7322 2c20  only_integers", 
 00007ec0: 226d 6f64 756c 6573 222c 2022 6973 5f70  "modules", "is_p
 00007ed0: 6f6c 6172 220a 2020 2020 5d0a 0a20 2020  olar".    ]..   
 00007ee0: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
 00007ef0: 6c66 2c20 2a61 7267 732c 202a 2a6b 7761  lf, *args, **kwa
 00007f00: 7267 7329 3a0a 2020 2020 2020 2020 7375  rgs):.        su
 00007f10: 7065 7228 292e 5f5f 696e 6974 5f5f 282a  per().__init__(*
-00007f20: 6172 6773 2c20 2a2a 6b77 6172 6773 2923  args, **kwargs)#
-00007f30: 206c 6973 7420 6f66 206e 756d 6572 6963   list of numeric
-00007f40: 616c 2066 756e 6374 696f 6e73 2072 6570  al functions rep
-00007f50: 7265 7365 6e74 696e 6720 7468 6520 6578  resenting the ex
-00007f60: 7072 6573 7369 6f6e 7320 746f 2065 7661  pressions to eva
-00007f70: 6c75 6174 650a 2020 2020 2020 2020 7365  luate.        se
-00007f80: 6c66 2e5f 6675 6e63 7469 6f6e 7320 3d20  lf._functions = 
-00007f90: 5b5d 0a20 2020 2020 2020 2023 2073 6967  [].        # sig
-00007fa0: 6e61 7475 7265 206f 6620 666f 7220 7468  nature of for th
-00007fb0: 6520 6e75 6d65 7269 6361 6c20 6675 6e63  e numerical func
-00007fc0: 7469 6f6e 730a 2020 2020 2020 2020 7365  tions.        se
-00007fd0: 6c66 2e5f 7369 676e 6174 7572 6520 3d20  lf._signature = 
-00007fe0: 5b5d 0a20 2020 2020 2020 2023 2073 6f6d  [].        # som
-00007ff0: 6520 6578 7072 6573 7369 6f6e 7320 646f  e expressions do
-00008000: 6e27 7420 6c69 6b65 2074 6f20 6265 2065  n't like to be e
-00008010: 7661 6c75 6174 6564 206f 7665 7220 636f  valuated over co
-00008020: 6d70 6c65 7820 6461 7461 2e0a 2020 2020  mplex data..    
-00008030: 2020 2020 2320 6966 2074 6861 7427 7320      # if that's 
-00008040: 7468 6520 6361 7365 2c20 7365 7420 7468  the case, set th
-00008050: 6973 2074 6f20 5472 7565 0a20 2020 2020  is to True.     
-00008060: 2020 2073 656c 662e 5f66 6f72 6365 5f72     self._force_r
-00008070: 6561 6c5f 6576 616c 203d 206b 7761 7267  eal_eval = kwarg
-00008080: 732e 6765 7428 2266 6f72 6365 5f72 6561  s.get("force_rea
-00008090: 6c5f 6576 616c 222c 204e 6f6e 6529 0a20  l_eval", None). 
-000080a0: 2020 2020 2020 2023 2065 7665 6e74 7561         # eventua
-000080b0: 6c6c 7920 6974 2077 696c 6c20 636f 6e74  lly it will cont
-000080c0: 6169 6e20 6120 6469 6374 696f 6e61 7279  ain a dictionary
-000080d0: 2077 6974 6820 7468 6520 6469 7363 7265   with the discre
-000080e0: 7469 7a65 6420 7261 6e67 6573 0a20 2020  tized ranges.   
-000080f0: 2020 2020 2073 656c 662e 5f64 6973 6372       self._discr
-00008100: 6574 697a 6564 5f64 6f6d 6169 6e20 3d20  etized_domain = 
-00008110: 4e6f 6e65 0a20 2020 2020 2020 2023 204e  None.        # N
-00008120: 4f54 453a 2063 6f6e 7369 6465 7220 6120  OTE: consider a 
-00008130: 6765 6e65 7269 6320 7375 6d6d 6174 696f  generic summatio
-00008140: 6e2c 2066 6f72 2065 7861 6d70 6c65 3a0a  n, for example:.
-00008150: 2020 2020 2020 2020 2320 2020 7320 3d20          #   s = 
-00008160: 5375 6d28 636f 7328 7069 202a 2078 292c  Sum(cos(pi * x),
-00008170: 2028 782c 2031 2c20 7929 290a 2020 2020   (x, 1, y)).    
-00008180: 2020 2020 2320 5468 6973 2067 6574 7320      # This gets 
-00008190: 6c61 6d62 6469 6669 6564 2074 6f20 736f  lambdified to so
-000081a0: 6d65 7468 696e 673a 0a20 2020 2020 2020  mething:.       
-000081b0: 2023 2020 2073 756d 2863 6f73 2870 692a   #   sum(cos(pi*
-000081c0: 7829 2066 6f72 2078 2069 6e20 7261 6e67  x) for x in rang
-000081d0: 6528 312c 2079 2b31 2929 0a20 2020 2020  e(1, y+1)).     
-000081e0: 2020 2023 2048 656e 6365 2c20 7920 6e65     # Hence, y ne
-000081f0: 6564 7320 746f 2062 6520 616e 2069 6e74  eds to be an int
-00008200: 6567 6572 2c20 6f74 6865 7277 6973 6520  eger, otherwise 
-00008210: 6974 2072 6169 7365 733a 0a20 2020 2020  it raises:.     
-00008220: 2020 2023 2020 2054 7970 6545 7272 6f72     #   TypeError
-00008230: 3a20 2763 6f6d 706c 6578 2720 6f62 6a65  : 'complex' obje
-00008240: 6374 2063 616e 6e6f 7420 6265 2069 6e74  ct cannot be int
-00008250: 6572 7072 6574 6564 2061 7320 616e 2069  erpreted as an i
-00008260: 6e74 6567 6572 0a20 2020 2020 2020 2023  nteger.        #
-00008270: 2054 6869 7320 6c69 7374 2077 696c 6c20   This list will 
-00008280: 636f 6e74 6169 6e73 2073 796d 626f 6c73  contains symbols
-00008290: 2074 6861 7420 6172 6520 7570 7065 7220   that are upper 
-000082a0: 626f 756e 6420 746f 2073 756d 6d61 7469  bound to summati
-000082b0: 6f6e 730a 2020 2020 2020 2020 2320 6f72  ons.        # or
-000082c0: 2070 726f 6475 6374 730a 2020 2020 2020   products.      
-000082d0: 2020 7365 6c66 2e5f 6e65 6564 735f 746f    self._needs_to
-000082e0: 5f62 655f 696e 7420 3d20 5b5d 0a20 2020  _be_int = [].   
-000082f0: 2020 2020 2023 2064 6973 6372 6574 697a       # discretiz
-00008300: 6520 7468 6520 646f 6d61 696e 2075 7369  e the domain usi
-00008310: 6e67 206f 6e6c 7920 696e 7465 6765 7220  ng only integer 
-00008320: 6e75 6d62 6572 730a 2020 2020 2020 2020  numbers.        
-00008330: 7365 6c66 2e6f 6e6c 795f 696e 7465 6765  self.only_intege
-00008340: 7273 203d 206b 7761 7267 732e 6765 7428  rs = kwargs.get(
-00008350: 226f 6e6c 795f 696e 7465 6765 7273 222c  "only_integers",
-00008360: 2046 616c 7365 290a 2020 2020 2020 2020   False).        
-00008370: 6966 2068 6173 6174 7472 2873 656c 662c  if hasattr(self,
-00008380: 2022 6164 6170 7469 7665 2229 2061 6e64   "adaptive") and
-00008390: 2073 656c 662e 6164 6170 7469 7665 2061   self.adaptive a
-000083a0: 6e64 2073 656c 662e 6f6e 6c79 5f69 6e74  nd self.only_int
-000083b0: 6567 6572 733a 0a20 2020 2020 2020 2020  egers:.         
-000083c0: 2020 2077 6172 6e69 6e67 732e 7761 726e     warnings.warn
-000083d0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000083e0: 2020 2260 606f 6e6c 795f 696e 7465 6765    "``only_intege
-000083f0: 7273 3d54 7275 6560 6020 6973 206e 6f74  rs=True`` is not
-00008400: 2073 7570 706f 7274 6564 2062 7920 7468   supported by th
-00008410: 6520 6164 6170 7469 7665 2022 0a20 2020  e adaptive ".   
-00008420: 2020 2020 2020 2020 2020 2020 2022 616c               "al
-00008430: 676f 7269 7468 6d2e 2041 7574 6f6d 6174  gorithm. Automat
-00008440: 6963 616c 6c79 2073 6574 7469 6e67 2060  ically setting `
-00008450: 6061 6461 7074 6976 653d 4661 6c73 6560  `adaptive=False`
-00008460: 602e 220a 2020 2020 2020 2020 2020 2020  `.".            
-00008470: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
-00008480: 6c66 2e61 6461 7074 6976 6520 3d20 4661  lf.adaptive = Fa
-00008490: 6c73 650a 2020 2020 2020 2020 2320 7265  lse.        # re
-000084a0: 7072 6573 656e 7473 2074 6865 2065 7661  presents the eva
-000084b0: 6c75 6174 696f 6e20 6d6f 6475 6c65 7320  luation modules 
-000084c0: 746f 2062 6520 7573 6564 2062 7920 6c61  to be used by la
-000084d0: 6d62 6469 6679 0a20 2020 2020 2020 2073  mbdify.        s
-000084e0: 656c 662e 6d6f 6475 6c65 7320 3d20 6b77  elf.modules = kw
-000084f0: 6172 6773 2e67 6574 2822 6d6f 6475 6c65  args.get("module
-00008500: 7322 2c20 4e6f 6e65 290a 2020 2020 2020  s", None).      
-00008510: 2020 2320 4966 2054 7275 652c 2074 6865    # If True, the
-00008520: 2062 6163 6b65 6e64 2077 696c 6c20 6174   backend will at
-00008530: 7465 6d70 7420 746f 2072 656e 6465 7220  tempt to render 
-00008540: 6974 206f 6e20 6120 706f 6c61 722d 7072  it on a polar-pr
-00008550: 6f6a 6563 7469 6f6e 0a20 2020 2020 2020  ojection.       
-00008560: 2023 2061 7869 732c 206f 7220 7573 696e   # axis, or usin
-00008570: 6720 6120 706f 6c61 7220 6469 7363 7265  g a polar discre
-00008580: 7469 7a61 7469 6f6e 2069 6620 6120 3344  tization if a 3D
-00008590: 2070 6c6f 7420 6973 2072 6571 7565 7374   plot is request
-000085a0: 6564 0a20 2020 2020 2020 2073 656c 662e  ed.        self.
-000085b0: 6973 5f70 6f6c 6172 203d 206b 7761 7267  is_polar = kwarg
-000085c0: 732e 6765 7428 2269 735f 706f 6c61 7222  s.get("is_polar"
-000085d0: 2c20 4661 6c73 6529 0a0a 2020 2020 6465  , False)..    de
-000085e0: 6620 5f63 7265 6174 655f 6c61 6d62 6461  f _create_lambda
-000085f0: 5f66 756e 6328 7365 6c66 293a 0a20 2020  _func(self):.   
-00008600: 2020 2020 2022 2222 4372 6561 7465 2074       """Create t
-00008610: 6865 206c 616d 6264 6120 6675 6e63 7469  he lambda functi
-00008620: 6f6e 7320 746f 2062 6520 7573 6564 2062  ons to be used b
-00008630: 7920 7468 6520 756e 6966 6f72 6d20 6d65  y the uniform me
-00008640: 7368 696e 670a 2020 2020 2020 2020 7374  shing.        st
-00008650: 7261 7465 6779 2e0a 2020 2020 2020 2020  rategy..        
-00008660: 2222 220a 2020 2020 2020 2020 6578 7072  """.        expr
-00008670: 7320 3d20 7365 6c66 2e65 7870 7220 6966  s = self.expr if
-00008680: 2068 6173 6174 7472 2873 656c 662e 6578   hasattr(self.ex
-00008690: 7072 2c20 225f 5f69 7465 725f 5f22 2920  pr, "__iter__") 
-000086a0: 656c 7365 205b 7365 6c66 2e65 7870 725d  else [self.expr]
-000086b0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-000086c0: 616e 7928 6361 6c6c 6162 6c65 2865 2920  any(callable(e) 
-000086d0: 666f 7220 6520 696e 2065 7870 7273 293a  for e in exprs):
-000086e0: 0a20 2020 2020 2020 2020 2020 2066 7320  .            fs 
-000086f0: 3d20 5f67 6574 5f66 7265 655f 7379 6d62  = _get_free_symb
-00008700: 6f6c 7328 6578 7072 7329 0a20 2020 2020  ols(exprs).     
-00008710: 2020 2020 2020 2073 656c 662e 5f73 6967         self._sig
-00008720: 6e61 7475 7265 203d 2073 6f72 7465 6428  nature = sorted(
-00008730: 6673 2c20 6b65 793d 6c61 6d62 6461 2074  fs, key=lambda t
-00008740: 3a20 742e 6e61 6d65 290a 0a20 2020 2020  : t.name)..     
-00008750: 2020 2020 2020 2023 2047 656e 6572 6174         # Generat
-00008760: 6520 6120 6c69 7374 206f 6620 6c61 6d62  e a list of lamb
-00008770: 6461 2066 756e 6374 696f 6e73 2c20 7477  da functions, tw
-00008780: 6f20 666f 7220 6561 6368 2065 7870 7265  o for each expre
-00008790: 7373 696f 6e3a 0a20 2020 2020 2020 2020  ssion:.         
-000087a0: 2020 2023 2031 2e20 7468 6520 6465 6661     # 1. the defa
-000087b0: 756c 7420 6f6e 652e 0a20 2020 2020 2020  ult one..       
-000087c0: 2020 2020 2023 2032 2e20 7468 6520 6261       # 2. the ba
-000087d0: 636b 7570 206f 6e65 2c20 696e 2063 6173  ckup one, in cas
-000087e0: 6520 6f66 2066 6169 6c75 7265 7320 7769  e of failures wi
-000087f0: 7468 2074 6865 2064 6566 6175 6c74 206f  th the default o
-00008800: 6e65 2e0a 2020 2020 2020 2020 2020 2020  ne..            
-00008810: 7365 6c66 2e5f 6675 6e63 7469 6f6e 7320  self._functions 
-00008820: 3d20 5b5d 0a20 2020 2020 2020 2020 2020  = [].           
-00008830: 2066 6f72 2065 2069 6e20 6578 7072 733a   for e in exprs:
-00008840: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008850: 2023 2054 4f44 4f3a 2073 6574 2063 7365   # TODO: set cse
-00008860: 3d54 7275 6520 6f6e 6365 2074 6869 7320  =True once this 
-00008870: 6973 7375 6520 6973 2073 6f6c 7665 643a  issue is solved:
-00008880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008890: 2023 2068 7474 7073 3a2f 2f67 6974 6875   # https://githu
-000088a0: 622e 636f 6d2f 7379 6d70 792f 7379 6d70  b.com/sympy/symp
-000088b0: 792f 6973 7375 6573 2f32 3432 3436 0a20  y/issues/24246. 
-000088c0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000088d0: 656c 662e 5f66 756e 6374 696f 6e73 2e61  elf._functions.a
-000088e0: 7070 656e 6428 5b0a 2020 2020 2020 2020  ppend([.        
-000088f0: 2020 2020 2020 2020 2020 2020 6c61 6d62              lamb
-00008900: 6469 6679 2873 656c 662e 5f73 6967 6e61  dify(self._signa
-00008910: 7475 7265 2c20 652c 206d 6f64 756c 6573  ture, e, modules
-00008920: 3d73 656c 662e 6d6f 6475 6c65 7329 2c0a  =self.modules),.
-00008930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008940: 2020 2020 6c61 6d62 6469 6679 2873 656c      lambdify(sel
-00008950: 662e 5f73 6967 6e61 7475 7265 2c20 652c  f._signature, e,
-00008960: 206d 6f64 756c 6573 3d22 7379 6d70 7922   modules="sympy"
-00008970: 2c20 6475 6d6d 6966 793d 5472 7565 292c  , dummify=True),
-00008980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008990: 205d 290a 2020 2020 2020 2020 656c 7365   ]).        else
-000089a0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-000089b0: 6c66 2e5f 7369 676e 6174 7572 6520 3d20  lf._signature = 
-000089c0: 736f 7274 6564 285b 725b 305d 2066 6f72  sorted([r[0] for
-000089d0: 2072 2069 6e20 7365 6c66 2e72 616e 6765   r in self.range
-000089e0: 735d 2c20 6b65 793d 6c61 6d62 6461 2074  s], key=lambda t
-000089f0: 3a20 742e 6e61 6d65 290a 2020 2020 2020  : t.name).      
-00008a00: 2020 2020 2020 7365 6c66 2e5f 6675 6e63        self._func
-00008a10: 7469 6f6e 7320 3d20 5b28 652c 204e 6f6e  tions = [(e, Non
-00008a20: 6529 2066 6f72 2065 2069 6e20 6578 7072  e) for e in expr
-00008a30: 735d 0a0a 2020 2020 2020 2020 2320 6465  s]..        # de
-00008a40: 616c 2077 6974 6820 7379 6d62 6f6c 6963  al with symbolic
-00008a50: 2063 6f6c 6f72 5f66 756e 630a 2020 2020   color_func.    
-00008a60: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
-00008a70: 6528 7365 6c66 2e63 6f6c 6f72 5f66 756e  e(self.color_fun
-00008a80: 632c 2045 7870 7229 3a0a 2020 2020 2020  c, Expr):.      
-00008a90: 2020 2020 2020 7365 6c66 2e63 6f6c 6f72        self.color
-00008aa0: 5f66 756e 6320 3d20 6c61 6d62 6469 6679  _func = lambdify
-00008ab0: 2873 656c 662e 5f73 6967 6e61 7475 7265  (self._signature
-00008ac0: 2c20 7365 6c66 2e63 6f6c 6f72 5f66 756e  , self.color_fun
-00008ad0: 6329 0a20 2020 2020 2020 2020 2020 2073  c).            s
-00008ae0: 656c 662e 5f65 7661 6c5f 636f 6c6f 725f  elf._eval_color_
-00008af0: 6675 6e63 5f77 6974 685f 7369 676e 6174  func_with_signat
-00008b00: 7572 6520 3d20 5472 7565 0a0a 2020 2020  ure = True..    
-00008b10: 6465 6620 5f63 7265 6174 655f 6469 7363  def _create_disc
-00008b20: 7265 7469 7a65 645f 646f 6d61 696e 2873  retized_domain(s
-00008b30: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-00008b40: 2244 6973 6372 6574 697a 6520 7468 6520  "Discretize the 
-00008b50: 7261 6e67 6573 2066 6f72 2075 6e69 666f  ranges for unifo
-00008b60: 726d 206d 6573 6869 6e67 2073 7472 6174  rm meshing strat
-00008b70: 6567 792e 0a20 2020 2020 2020 2022 2222  egy..        """
-00008b80: 0a20 2020 2020 2020 2023 204e 4f54 453a  .        # NOTE:
-00008b90: 2074 6865 2067 6f61 6c20 6973 2074 6f20   the goal is to 
-00008ba0: 6372 6561 7465 2061 2064 6963 7469 6f6e  create a diction
-00008bb0: 6172 7920 7374 6f72 6564 2069 6e0a 2020  ary stored in.  
-00008bc0: 2020 2020 2020 2320 7365 6c66 2e5f 6469        # self._di
-00008bd0: 7363 7265 7469 7a65 645f 646f 6d61 696e  scretized_domain
-00008be0: 2c20 6d61 7070 696e 6720 7379 6d62 6f6c  , mapping symbol
-00008bf0: 7320 746f 2061 206e 756d 7079 2061 7272  s to a numpy arr
-00008c00: 6179 0a20 2020 2020 2020 2023 2072 6570  ay.        # rep
-00008c10: 7265 7365 6e74 696e 6720 7468 6520 6469  resenting the di
-00008c20: 7363 7265 7469 7a61 7469 6f6e 0a20 2020  scretization.   
-00008c30: 2020 2020 2064 6973 6372 5f73 796d 626f       discr_symbo
-00008c40: 6c73 203d 205b 5d0a 2020 2020 2020 2020  ls = [].        
-00008c50: 6469 7363 7265 7469 7a61 7469 6f6e 7320  discretizations 
-00008c60: 3d20 5b5d 0a0a 2020 2020 2020 2020 2320  = []..        # 
-00008c70: 6372 6561 7465 2061 2031 4420 6469 7363  create a 1D disc
-00008c80: 7265 7469 7a61 7469 6f6e 0a20 2020 2020  retization.     
-00008c90: 2020 2066 6f72 2069 2c20 7220 696e 2065     for i, r in e
-00008ca0: 6e75 6d65 7261 7465 2873 656c 662e 7261  numerate(self.ra
-00008cb0: 6e67 6573 293a 0a20 2020 2020 2020 2020  nges):.         
-00008cc0: 2020 2064 6973 6372 5f73 796d 626f 6c73     discr_symbols
-00008cd0: 2e61 7070 656e 6428 725b 305d 290a 2020  .append(r[0]).  
-00008ce0: 2020 2020 2020 2020 2020 635f 7374 6172            c_star
-00008cf0: 7420 3d20 7365 6c66 2e5f 7570 6461 7465  t = self._update
-00008d00: 5f72 616e 6765 5f76 616c 7565 2872 5b31  _range_value(r[1
-00008d10: 5d29 0a20 2020 2020 2020 2020 2020 2063  ]).            c
-00008d20: 5f65 6e64 203d 2073 656c 662e 5f75 7064  _end = self._upd
-00008d30: 6174 655f 7261 6e67 655f 7661 6c75 6528  ate_range_value(
-00008d40: 725b 325d 290a 2020 2020 2020 2020 2020  r[2]).          
-00008d50: 2020 7374 6172 7420 3d20 635f 7374 6172    start = c_star
-00008d60: 742e 7265 616c 2069 6620 635f 7374 6172  t.real if c_star
-00008d70: 742e 696d 6167 203d 3d20 635f 656e 642e  t.imag == c_end.
-00008d80: 696d 6167 203d 3d20 3020 656c 7365 2063  imag == 0 else c
-00008d90: 5f73 7461 7274 0a20 2020 2020 2020 2020  _start.         
-00008da0: 2020 2065 6e64 203d 2063 5f65 6e64 2e72     end = c_end.r
-00008db0: 6561 6c20 6966 2063 5f73 7461 7274 2e69  eal if c_start.i
-00008dc0: 6d61 6720 3d3d 2063 5f65 6e64 2e69 6d61  mag == c_end.ima
-00008dd0: 6720 3d3d 2030 2065 6c73 6520 635f 656e  g == 0 else c_en
-00008de0: 640a 2020 2020 2020 2020 2020 2020 6e65  d.            ne
-00008df0: 6564 735f 696e 7465 6765 725f 6469 7363  eds_integer_disc
-00008e00: 7220 3d20 7365 6c66 2e6f 6e6c 795f 696e  r = self.only_in
-00008e10: 7465 6765 7273 206f 7220 2872 5b30 5d20  tegers or (r[0] 
-00008e20: 696e 2073 656c 662e 5f6e 6565 6473 5f74  in self._needs_t
-00008e30: 6f5f 6265 5f69 6e74 290a 2020 2020 2020  o_be_int).      
-00008e40: 2020 2020 2020 6420 3d20 4261 7365 5365        d = BaseSe
-00008e50: 7269 6573 2e5f 6469 7363 7265 7469 7a65  ries._discretize
-00008e60: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00008e70: 2020 7374 6172 742c 2065 6e64 2c20 7365    start, end, se
-00008e80: 6c66 2e6e 5b69 5d2c 0a20 2020 2020 2020  lf.n[i],.       
-00008e90: 2020 2020 2020 2020 2073 6361 6c65 3d73           scale=s
-00008ea0: 656c 662e 7363 616c 6573 5b69 5d2c 0a20  elf.scales[i],. 
-00008eb0: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-00008ec0: 6e6c 795f 696e 7465 6765 7273 3d6e 6565  nly_integers=nee
-00008ed0: 6473 5f69 6e74 6567 6572 5f64 6973 6372  ds_integer_discr
-00008ee0: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
-00008ef0: 2020 2020 2020 2020 2020 2020 6966 2028              if (
-00008f00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008f10: 2028 6e6f 7420 7365 6c66 2e5f 666f 7263   (not self._forc
-00008f20: 655f 7265 616c 5f65 7661 6c29 2061 6e64  e_real_eval) and
-00008f30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008f40: 2028 6e6f 7420 6e65 6564 735f 696e 7465   (not needs_inte
-00008f50: 6765 725f 6469 7363 7229 2061 6e64 0a20  ger_discr) and. 
-00008f60: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-00008f70: 642e 6474 7970 6520 213d 2022 636f 6d70  d.dtype != "comp
-00008f80: 6c65 7822 290a 2020 2020 2020 2020 2020  lex").          
-00008f90: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
-00008fa0: 2020 2020 2064 203d 2064 202b 2031 6a20       d = d + 1j 
-00008fb0: 2a20 635f 7374 6172 742e 696d 6167 0a0a  * c_start.imag..
-00008fc0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-00008fd0: 6565 6473 5f69 6e74 6567 6572 5f64 6973  eeds_integer_dis
-00008fe0: 6372 3a0a 2020 2020 2020 2020 2020 2020  cr:.            
-00008ff0: 2020 2020 6420 3d20 642e 6173 7479 7065      d = d.astype
-00009000: 2869 6e74 290a 0a20 2020 2020 2020 2020  (int)..         
-00009010: 2020 2064 6973 6372 6574 697a 6174 696f     discretizatio
-00009020: 6e73 2e61 7070 656e 6428 6429 0a0a 2020  ns.append(d)..  
-00009030: 2020 2020 2020 2320 6372 6561 7465 2032        # create 2
-00009040: 4420 6f72 2033 440a 2020 2020 2020 2020  D or 3D.        
-00009050: 7365 6c66 2e5f 6372 6561 7465 5f64 6973  self._create_dis
-00009060: 6372 6574 697a 6564 5f64 6f6d 6169 6e5f  cretized_domain_
-00009070: 6865 6c70 6572 2864 6973 6372 5f73 796d  helper(discr_sym
-00009080: 626f 6c73 2c20 6469 7363 7265 7469 7a61  bols, discretiza
-00009090: 7469 6f6e 7329 0a0a 2020 2020 6465 6620  tions)..    def 
-000090a0: 5f63 7265 6174 655f 6469 7363 7265 7469  _create_discreti
-000090b0: 7a65 645f 646f 6d61 696e 5f68 656c 7065  zed_domain_helpe
-000090c0: 7228 7365 6c66 2c20 6469 7363 725f 7379  r(self, discr_sy
-000090d0: 6d62 6f6c 732c 2064 6973 6372 6574 697a  mbols, discretiz
-000090e0: 6174 696f 6e73 293a 0a20 2020 2020 2020  ations):.       
-000090f0: 2022 2222 4372 6561 7465 2032 4420 6f72   """Create 2D or
-00009100: 2033 4420 6469 7363 7265 7469 7a65 6420   3D discretized 
-00009110: 6772 6964 732e 0a0a 2020 2020 2020 2020  grids...        
-00009120: 5375 6263 6c61 7373 6573 2073 686f 756c  Subclasses shoul
-00009130: 6420 6f76 6572 7269 6465 2074 6869 7320  d override this 
-00009140: 6d65 7468 6f64 2069 6e20 6f72 6465 7220  method in order 
-00009150: 746f 2069 6d70 6c65 6d65 6e74 2061 0a20  to implement a. 
-00009160: 2020 2020 2020 2064 6966 6665 7265 6e74         different
-00009170: 2062 6568 6176 696f 7572 2e0a 2020 2020   behaviour..    
-00009180: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00009190: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
-000091a0: 6c65 2827 6e75 6d70 7927 290a 0a20 2020  le('numpy')..   
-000091b0: 2020 2020 2023 2064 6973 6372 6574 697a       # discretiz
-000091c0: 6174 696f 6e20 7375 6974 6162 6c65 2066  ation suitable f
-000091d0: 6f72 2032 4420 6c69 6e65 2070 6c6f 7473  or 2D line plots
-000091e0: 2c20 3344 2073 7572 6661 6365 2070 6c6f  , 3D surface plo
-000091f0: 7473 2c0a 2020 2020 2020 2020 2320 636f  ts,.        # co
-00009200: 6e74 6f75 7273 2070 6c6f 7473 2c20 7665  ntours plots, ve
-00009210: 6374 6f72 2070 6c6f 7473 0a20 2020 2020  ctor plots.     
-00009220: 2020 2023 204e 4f54 453a 2077 6879 2069     # NOTE: why i
-00009230: 6e64 6578 696e 673d 2769 6a27 3f20 4265  ndexing='ij'? Be
-00009240: 6361 7573 6520 6974 2070 726f 6475 6365  cause it produce
-00009250: 7320 636f 6e73 6973 7465 6e74 2072 6573  s consistent res
-00009260: 756c 7473 2077 6974 680a 2020 2020 2020  ults with.      
-00009270: 2020 2320 6e70 2e6d 6772 6964 2e20 5468    # np.mgrid. Th
-00009280: 6973 2069 7320 696d 706f 7274 616e 7420  is is important 
-00009290: 6173 204d 6179 6176 6920 7265 7175 6972  as Mayavi requir
-000092a0: 6573 2074 6869 7320 696e 6465 7869 6e67  es this indexing
-000092b0: 0a20 2020 2020 2020 2023 2074 6f20 636f  .        # to co
-000092c0: 7272 6563 746c 7920 636f 6d70 7574 6520  rrectly compute 
-000092d0: 3344 2073 7472 6561 6d6c 696e 6573 2e20  3D streamlines. 
-000092e0: 5654 4b20 6973 2061 626c 6520 746f 2063  VTK is able to c
-000092f0: 6f6d 7075 7465 2074 6865 6d0a 2020 2020  ompute them.    
-00009300: 2020 2020 2320 6e6f 6e65 7468 656c 6573      # nonetheles
-00009310: 732c 2062 7574 2069 7420 7072 6f64 7563  s, but it produc
-00009320: 6573 2022 7374 7261 6e67 6522 2072 6573  es "strange" res
-00009330: 756c 7473 2077 6974 6820 2276 6f69 6473  ults with "voids
-00009340: 2220 696e 746f 2074 6865 0a20 2020 2020  " into the.     
-00009350: 2020 2023 2064 6973 6372 6574 697a 6174     # discretizat
-00009360: 696f 6e20 766f 6c75 6d65 2e20 5468 6973  ion volume. This
-00009370: 2069 6e64 6578 696e 6720 736f 6c76 6573   indexing solves
-00009380: 2074 6865 2070 726f 626c 656d 2e0a 2020   the problem..  
-00009390: 2020 2020 2020 2320 416c 736f 206e 6f74        # Also not
-000093a0: 6520 7468 6174 206d 6174 706c 6f74 6c69  e that matplotli
-000093b0: 6220 3244 2073 7472 6561 6d6c 696e 6573  b 2D streamlines
-000093c0: 2072 6571 7569 7265 7320 696e 6465 7869   requires indexi
-000093d0: 6e67 3d27 7879 272e 0a20 2020 2020 2020  ng='xy'..       
-000093e0: 2069 6e64 6578 696e 6720 3d20 2278 7922   indexing = "xy"
-000093f0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00009400: 2e69 735f 3344 7665 6374 6f72 206f 7220  .is_3Dvector or 
-00009410: 2873 656c 662e 6973 5f33 4473 7572 6661  (self.is_3Dsurfa
-00009420: 6365 2061 6e64 2073 656c 662e 6973 5f69  ce and self.is_i
-00009430: 6d70 6c69 6369 7429 3a0a 2020 2020 2020  mplicit):.      
-00009440: 2020 2020 2020 696e 6465 7869 6e67 203d        indexing =
-00009450: 2022 696a 220a 2020 2020 2020 2020 6d65   "ij".        me
-00009460: 7368 6573 203d 206e 702e 6d65 7368 6772  shes = np.meshgr
-00009470: 6964 282a 6469 7363 7265 7469 7a61 7469  id(*discretizati
-00009480: 6f6e 732c 2069 6e64 6578 696e 673d 696e  ons, indexing=in
-00009490: 6465 7869 6e67 290a 2020 2020 2020 2020  dexing).        
-000094a0: 7365 6c66 2e5f 6469 7363 7265 7469 7a65  self._discretize
-000094b0: 645f 646f 6d61 696e 203d 207b 0a20 2020  d_domain = {.   
-000094c0: 2020 2020 2020 2020 206b 3a20 7620 666f           k: v fo
-000094d0: 7220 6b2c 2076 2069 6e20 7a69 7028 6469  r k, v in zip(di
-000094e0: 7363 725f 7379 6d62 6f6c 732c 206d 6573  scr_symbols, mes
-000094f0: 6865 7329 7d0a 0a20 2020 2064 6566 205f  hes)}..    def _
-00009500: 6576 616c 7561 7465 2873 656c 662c 2063  evaluate(self, c
-00009510: 6173 745f 746f 5f72 6561 6c3d 5472 7565  ast_to_real=True
-00009520: 293a 0a20 2020 2020 2020 2022 2222 4576  ):.        """Ev
-00009530: 616c 7561 7469 6f6e 206f 6620 7468 6520  aluation of the 
-00009540: 7379 6d62 6f6c 6963 2065 7870 7265 7373  symbolic express
-00009550: 696f 6e20 286f 7220 6578 7072 6573 7369  ion (or expressi
-00009560: 6f6e 7329 2077 6974 6820 7468 650a 2020  ons) with the.  
-00009570: 2020 2020 2020 756e 6966 6f72 6d20 6d65        uniform me
-00009580: 7368 696e 6720 7374 7261 7465 6779 2c20  shing strategy, 
-00009590: 6261 7365 6420 6f6e 2063 7572 7265 6e74  based on current
-000095a0: 2076 616c 7565 7320 6f66 2074 6865 2070   values of the p
-000095b0: 6172 616d 6574 6572 732e 0a20 2020 2020  arameters..     
-000095c0: 2020 2022 2222 0a20 2020 2020 2020 206e     """.        n
-000095d0: 7020 3d20 696d 706f 7274 5f6d 6f64 756c  p = import_modul
-000095e0: 6528 276e 756d 7079 2729 0a0a 2020 2020  e('numpy')..    
-000095f0: 2020 2020 2320 6372 6561 7465 206c 616d      # create lam
-00009600: 6264 6120 6675 6e63 7469 6f6e 730a 2020  bda functions.  
-00009610: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
-00009620: 662e 5f66 756e 6374 696f 6e73 3a0a 2020  f._functions:.  
-00009630: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
-00009640: 6372 6561 7465 5f6c 616d 6264 615f 6675  create_lambda_fu
-00009650: 6e63 2829 0a20 2020 2020 2020 2023 2063  nc().        # c
-00009660: 7265 6174 6520 286f 7220 7570 6461 7465  reate (or update
-00009670: 2920 7468 6520 6469 7363 7265 7469 7a65  ) the discretize
-00009680: 6420 646f 6d61 696e 0a20 2020 2020 2020  d domain.       
-00009690: 2069 6620 286e 6f74 2073 656c 662e 5f64   if (not self._d
-000096a0: 6973 6372 6574 697a 6564 5f64 6f6d 6169  iscretized_domai
-000096b0: 6e29 206f 7220 7365 6c66 2e5f 696e 7465  n) or self._inte
-000096c0: 7261 6374 6976 655f 7261 6e67 6573 3a0a  ractive_ranges:.
-000096d0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-000096e0: 2e5f 6372 6561 7465 5f64 6973 6372 6574  ._create_discret
-000096f0: 697a 6564 5f64 6f6d 6169 6e28 290a 2020  ized_domain().  
-00009700: 2020 2020 2020 2320 656e 7375 7265 2074        # ensure t
-00009710: 6861 7420 6469 7363 7265 7469 7a65 6420  hat discretized 
-00009720: 646f 6d61 696e 7320 6172 6520 7265 7475  domains are retu
-00009730: 726e 6564 2077 6974 6820 7468 6520 7072  rned with the pr
-00009740: 6f70 6572 206f 7264 6572 0a20 2020 2020  oper order.     
-00009750: 2020 2064 6973 6372 203d 205b 7365 6c66     discr = [self
-00009760: 2e5f 6469 7363 7265 7469 7a65 645f 646f  ._discretized_do
-00009770: 6d61 696e 5b73 5b30 5d5d 2066 6f72 2073  main[s[0]] for s
-00009780: 2069 6e20 7365 6c66 2e72 616e 6765 735d   in self.ranges]
-00009790: 0a0a 2020 2020 2020 2020 6172 6773 203d  ..        args =
-000097a0: 2073 656c 662e 5f61 6767 7265 6761 7465   self._aggregate
-000097b0: 5f61 7267 7328 290a 0a20 2020 2020 2020  _args()..       
-000097c0: 2072 6573 756c 7473 203d 205b 5d0a 2020   results = [].  
-000097d0: 2020 2020 2020 666f 7220 6620 696e 2073        for f in s
-000097e0: 656c 662e 5f66 756e 6374 696f 6e73 3a0a  elf._functions:.
-000097f0: 2020 2020 2020 2020 2020 2020 7220 3d20              r = 
-00009800: 5f75 6e69 666f 726d 5f65 7661 6c28 2a66  _uniform_eval(*f
-00009810: 2c20 2a61 7267 732c 206d 6f64 756c 6573  , *args, modules
-00009820: 3d73 656c 662e 6d6f 6475 6c65 7329 0a20  =self.modules). 
-00009830: 2020 2020 2020 2020 2020 2023 2074 6865             # the
-00009840: 2065 7661 6c75 6174 696f 6e20 6d69 6768   evaluation migh
-00009850: 7420 7072 6f64 7563 6520 616e 2069 6e74  t produce an int
-00009860: 2f66 6c6f 6174 2e20 4e65 6564 2074 6869  /float. Need thi
-00009870: 7320 636f 7272 6563 7469 6f6e 2e0a 2020  s correction..  
-00009880: 2020 2020 2020 2020 2020 7220 3d20 7365            r = se
-00009890: 6c66 2e5f 636f 7272 6563 745f 7368 6170  lf._correct_shap
-000098a0: 6528 6e70 2e61 7272 6179 2872 292c 2064  e(np.array(r), d
-000098b0: 6973 6372 5b30 5d29 0a20 2020 2020 2020  iscr[0]).       
-000098c0: 2020 2020 2023 2073 6f6d 6574 696d 6520       # sometime 
-000098d0: 7468 6520 6576 616c 7561 7469 6f6e 2069  the evaluation i
-000098e0: 7320 7065 7266 6f72 6d65 6420 6f76 6572  s performed over
-000098f0: 2061 7272 6179 7320 6f66 2074 7970 6520   arrays of type 
-00009900: 6f62 6a65 6374 2e0a 2020 2020 2020 2020  object..        
-00009910: 2020 2020 2320 6865 6e63 652c 2060 7265      # hence, `re
-00009920: 7375 6c74 6020 6d69 6768 7420 6265 206f  sult` might be o
-00009930: 6620 7479 7065 206f 626a 6563 742c 2077  f type object, w
-00009940: 6869 6368 2064 6f6e 2774 2077 6f72 6b20  hich don't work 
-00009950: 7765 6c6c 0a20 2020 2020 2020 2020 2020  well.           
-00009960: 2023 2077 6974 6820 6e75 6d70 7920 7265   # with numpy re
-00009970: 616c 2061 6e64 2069 6d61 6720 6675 6e63  al and imag func
-00009980: 7469 6f6e 732e 0a20 2020 2020 2020 2020  tions..         
-00009990: 2020 2072 203d 2072 2e61 7374 7970 6528     r = r.astype(
-000099a0: 636f 6d70 6c65 7829 0a20 2020 2020 2020  complex).       
-000099b0: 2020 2020 2072 6573 756c 7473 2e61 7070       results.app
-000099c0: 656e 6428 7229 0a0a 2020 2020 2020 2020  end(r)..        
-000099d0: 6966 2063 6173 745f 746f 5f72 6561 6c3a  if cast_to_real:
-000099e0: 0a20 2020 2020 2020 2020 2020 2064 6973  .            dis
-000099f0: 6372 203d 205b 6e70 2e72 6561 6c28 642e  cr = [np.real(d.
-00009a00: 6173 7479 7065 2863 6f6d 706c 6578 2929  astype(complex))
-00009a10: 2066 6f72 2064 2069 6e20 6469 7363 725d   for d in discr]
-00009a20: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00009a30: 5b2a 6469 7363 722c 202a 7265 7375 6c74  [*discr, *result
-00009a40: 735d 0a0a 2020 2020 6465 6620 5f61 6767  s]..    def _agg
-00009a50: 7265 6761 7465 5f61 7267 7328 7365 6c66  regate_args(self
-00009a60: 293a 0a20 2020 2020 2020 2061 7267 7320  ):.        args 
-00009a70: 3d20 5b5d 0a20 2020 2020 2020 2066 6f72  = [].        for
-00009a80: 2073 2069 6e20 7365 6c66 2e5f 7369 676e   s in self._sign
-00009a90: 6174 7572 653a 0a20 2020 2020 2020 2020  ature:.         
-00009aa0: 2020 2069 6620 7320 696e 2073 656c 662e     if s in self.
-00009ab0: 5f70 6172 616d 732e 6b65 7973 2829 3a0a  _params.keys():.
-00009ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ad0: 6172 6773 2e61 7070 656e 6428 0a20 2020  args.append(.   
-00009ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009af0: 2069 6e74 2873 656c 662e 5f70 6172 616d   int(self._param
-00009b00: 735b 735d 2920 6966 2073 2069 6e20 7365  s[s]) if s in se
-00009b10: 6c66 2e5f 6e65 6564 735f 746f 5f62 655f  lf._needs_to_be_
-00009b20: 696e 7420 656c 7365 0a20 2020 2020 2020  int else.       
-00009b30: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00009b40: 662e 5f70 6172 616d 735b 735d 2069 6620  f._params[s] if 
-00009b50: 7365 6c66 2e5f 666f 7263 655f 7265 616c  self._force_real
-00009b60: 5f65 7661 6c0a 2020 2020 2020 2020 2020  _eval.          
-00009b70: 2020 2020 2020 2020 2020 656c 7365 2063            else c
-00009b80: 6f6d 706c 6578 2873 656c 662e 5f70 6172  omplex(self._par
-00009b90: 616d 735b 735d 2929 0a20 2020 2020 2020  ams[s])).       
-00009ba0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00009bb0: 2020 2020 2020 2020 2020 2061 7267 732e             args.
-00009bc0: 6170 7065 6e64 2873 656c 662e 5f64 6973  append(self._dis
-00009bd0: 6372 6574 697a 6564 5f64 6f6d 6169 6e5b  cretized_domain[
-00009be0: 735d 290a 2020 2020 2020 2020 7265 7475  s]).        retu
-00009bf0: 726e 2061 7267 730a 0a20 2020 2040 7072  rn args..    @pr
-00009c00: 6f70 6572 7479 0a20 2020 2064 6566 2065  operty.    def e
-00009c10: 7870 7228 7365 6c66 293a 0a20 2020 2020  xpr(self):.     
-00009c20: 2020 2022 2222 5265 7475 726e 2074 6865     """Return the
-00009c30: 2065 7870 7265 7373 696f 6e20 286f 7220   expression (or 
-00009c40: 6578 7072 6573 7369 6f6e 7329 206f 6620  expressions) of 
-00009c50: 7468 6520 7365 7269 6573 2e22 2222 0a20  the series.""". 
-00009c60: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00009c70: 6c66 2e5f 6578 7072 0a0a 2020 2020 4065  lf._expr..    @e
-00009c80: 7870 722e 7365 7474 6572 0a20 2020 2064  xpr.setter.    d
-00009c90: 6566 2065 7870 7228 7365 6c66 2c20 6529  ef expr(self, e)
-00009ca0: 3a0a 2020 2020 2020 2020 2222 2253 6574  :.        """Set
-00009cb0: 2074 6865 2065 7870 7265 7373 696f 6e20   the expression 
-00009cc0: 286f 7220 6578 7072 6573 7369 6f6e 7329  (or expressions)
-00009cd0: 206f 6620 7468 6520 7365 7269 6573 2e22   of the series."
-00009ce0: 2222 0a20 2020 2020 2020 2069 735f 6974  "".        is_it
-00009cf0: 6572 203d 2068 6173 6174 7472 2865 2c20  er = hasattr(e, 
-00009d00: 225f 5f69 7465 725f 5f22 290a 2020 2020  "__iter__").    
-00009d10: 2020 2020 6973 5f63 616c 6c61 626c 6520      is_callable 
-00009d20: 3d20 6361 6c6c 6162 6c65 2865 2920 6966  = callable(e) if
-00009d30: 206e 6f74 2069 735f 6974 6572 2065 6c73   not is_iter els
-00009d40: 6520 616e 7928 6361 6c6c 6162 6c65 2874  e any(callable(t
-00009d50: 2920 666f 7220 7420 696e 2065 290a 2020  ) for t in e).  
-00009d60: 2020 2020 2020 6966 2069 735f 6361 6c6c        if is_call
-00009d70: 6162 6c65 3a0a 2020 2020 2020 2020 2020  able:.          
-00009d80: 2020 7365 6c66 2e5f 6578 7072 203d 2065    self._expr = e
-00009d90: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-00009da0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00009db0: 5f65 7870 7220 3d20 7379 6d70 6966 7928  _expr = sympify(
-00009dc0: 6529 2069 6620 6e6f 7420 6973 5f69 7465  e) if not is_ite
-00009dd0: 7220 656c 7365 2054 7570 6c65 282a 6529  r else Tuple(*e)
-00009de0: 0a20 2020 2020 2020 2020 2020 2073 203d  .            s =
-00009df0: 2073 6574 2829 0a20 2020 2020 2020 2020   set().         
-00009e00: 2020 2066 6f72 2065 2069 6e20 7365 6c66     for e in self
-00009e10: 2e5f 6578 7072 2e61 746f 6d73 2853 756d  ._expr.atoms(Sum
-00009e20: 2c20 5072 6f64 7563 7429 3a0a 2020 2020  , Product):.    
-00009e30: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00009e40: 6120 696e 2065 2e61 7267 735b 313a 5d3a  a in e.args[1:]:
-00009e50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009e60: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
-00009e70: 6365 2861 5b2d 315d 2c20 5379 6d62 6f6c  ce(a[-1], Symbol
-00009e80: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00009e90: 2020 2020 2020 2020 2020 2073 2e61 6464             s.add
-00009ea0: 2861 5b2d 315d 290a 2020 2020 2020 2020  (a[-1]).        
-00009eb0: 2020 2020 7365 6c66 2e5f 6e65 6564 735f      self._needs_
-00009ec0: 746f 5f62 655f 696e 7420 3d20 6c69 7374  to_be_int = list
-00009ed0: 2873 290a 0a20 2020 2020 2020 2020 2020  (s)..           
-00009ee0: 2023 206c 6973 7420 6f66 2073 796d 7079   # list of sympy
-00009ef0: 2066 756e 6374 696f 6e73 2074 6861 7420   functions that 
-00009f00: 7768 656e 206c 616d 6264 6966 6965 642c  when lambdified,
-00009f10: 2074 6865 2063 6f72 7265 7370 6f6e 6469   the correspondi
-00009f20: 6e67 0a20 2020 2020 2020 2020 2020 2023  ng.            #
-00009f30: 206e 756d 7079 2066 756e 6374 696f 6e73   numpy functions
-00009f40: 2064 6f6e 2774 206c 696b 6520 636f 6d70   don't like comp
-00009f50: 6c65 782d 7479 7065 2061 7267 756d 656e  lex-type argumen
-00009f60: 7473 0a20 2020 2020 2020 2020 2020 2070  ts.            p
-00009f70: 6620 3d20 5b63 6569 6c69 6e67 2c20 666c  f = [ceiling, fl
-00009f80: 6f6f 722c 2061 7461 6e32 2c20 6672 6163  oor, atan2, frac
-00009f90: 2c20 7a65 7461 2c20 496e 7465 6772 616c  , zeta, Integral
-00009fa0: 2c20 6879 7065 725d 0a20 2020 2020 2020  , hyper].       
-00009fb0: 2020 2020 2069 6620 7365 6c66 2e5f 666f       if self._fo
-00009fc0: 7263 655f 7265 616c 5f65 7661 6c20 6973  rce_real_eval is
-00009fd0: 206e 6f74 2054 7275 653a 0a20 2020 2020   not True:.     
-00009fe0: 2020 2020 2020 2020 2020 2063 6865 636b             check
-00009ff0: 5f72 6573 203d 205b 7365 6c66 2e5f 6578  _res = [self._ex
-0000a000: 7072 2e68 6173 2866 2920 666f 7220 6620  pr.has(f) for f 
-0000a010: 696e 2070 665d 0a20 2020 2020 2020 2020  in pf].         
-0000a020: 2020 2020 2020 2073 656c 662e 5f66 6f72         self._for
-0000a030: 6365 5f72 6561 6c5f 6576 616c 203d 2061  ce_real_eval = a
-0000a040: 6e79 2863 6865 636b 5f72 6573 290a 2020  ny(check_res).  
-0000a050: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000a060: 2073 656c 662e 5f66 6f72 6365 5f72 6561   self._force_rea
-0000a070: 6c5f 6576 616c 2061 6e64 2028 0a20 2020  l_eval and (.   
-0000a080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a090: 2028 7365 6c66 2e6d 6f64 756c 6573 2069   (self.modules i
-0000a0a0: 7320 4e6f 6e65 2920 6f72 0a20 2020 2020  s None) or.     
-0000a0b0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-0000a0c0: 6973 696e 7374 616e 6365 2873 656c 662e  isinstance(self.
-0000a0d0: 6d6f 6475 6c65 732c 2073 7472 2920 616e  modules, str) an
-0000a0e0: 6420 226e 756d 7079 2220 696e 2073 656c  d "numpy" in sel
-0000a0f0: 662e 6d6f 6475 6c65 7329 0a20 2020 2020  f.modules).     
-0000a100: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
-0000a110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a120: 2020 6675 6e63 7320 3d20 5b66 2066 6f72    funcs = [f for
-0000a130: 2066 2c20 6320 696e 207a 6970 2870 662c   f, c in zip(pf,
-0000a140: 2063 6865 636b 5f72 6573 2920 6966 2063   check_res) if c
-0000a150: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0000a160: 2020 2020 2020 7761 726e 696e 6773 2e77        warnings.w
-0000a170: 6172 6e28 0a20 2020 2020 2020 2020 2020  arn(.           
-0000a180: 2020 2020 2020 2020 2020 2020 2022 4e75               "Nu
-0000a190: 6d50 7920 6973 2075 6e61 626c 6520 746f  mPy is unable to
-0000a1a0: 2065 7661 6c75 6174 6520 7769 7468 2063   evaluate with c
-0000a1b0: 6f6d 706c 6578 2022 0a20 2020 2020 2020  omplex ".       
-0000a1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a1d0: 2022 6e75 6d62 6572 7320 736f 6d65 206f   "numbers some o
-0000a1e0: 6620 7468 6520 6675 6e63 7469 6f6e 7320  f the functions 
-0000a1f0: 696e 636c 7564 6564 2069 6e20 7468 6973  included in this
-0000a200: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
-0000a210: 2020 2020 2020 2020 2020 2022 7379 6d62             "symb
-0000a220: 6f6c 6963 2065 7870 7265 7373 696f 6e3a  olic expression:
-0000a230: 2025 732e 2022 2025 2066 756e 6373 202b   %s. " % funcs +
-0000a240: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a250: 2020 2020 2020 2020 2022 4865 6e63 652c           "Hence,
-0000a260: 2074 6865 2065 7661 6c75 6174 696f 6e20   the evaluation 
-0000a270: 7769 6c6c 2075 7365 2072 6561 6c20 6e75  will use real nu
-0000a280: 6d62 6572 732e 2022 0a20 2020 2020 2020  mbers. ".       
-0000a290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a2a0: 2022 4966 2079 6f75 2062 656c 6965 7665   "If you believe
-0000a2b0: 2074 6865 2072 6573 756c 7469 6e67 2070   the resulting p
-0000a2c0: 6c6f 7420 6973 2069 6e63 6f72 7265 6374  lot is incorrect
-0000a2d0: 2c20 220a 2020 2020 2020 2020 2020 2020  , ".            
-0000a2e0: 2020 2020 2020 2020 2020 2020 2263 6861              "cha
-0000a2f0: 6e67 6520 7468 6520 6576 616c 7561 7469  nge the evaluati
-0000a300: 6f6e 206d 6f64 756c 6520 6279 2073 6574  on module by set
-0000a310: 7469 6e67 2074 6865 2022 0a20 2020 2020  ting the ".     
-0000a320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a330: 2020 2022 606d 6f64 756c 6573 6020 6b65     "`modules` ke
-0000a340: 7977 6f72 6420 6172 6775 6d65 6e74 2e22  yword argument."
-0000a350: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-0000a360: 2073 656c 662e 5f66 756e 6374 696f 6e73   self._functions
-0000a370: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000a380: 2020 2320 7570 6461 7465 206c 616d 6264    # update lambd
-0000a390: 6120 6675 6e63 7469 6f6e 730a 2020 2020  a functions.    
-0000a3a0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000a3b0: 2e5f 6372 6561 7465 5f6c 616d 6264 615f  ._create_lambda_
-0000a3c0: 6675 6e63 2829 0a0a 2020 2020 4070 726f  func()..    @pro
-0000a3d0: 7065 7274 790a 2020 2020 6465 6620 6e28  perty.    def n(
-0000a3e0: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
-0000a3f0: 2222 5265 7475 726e 7320 6120 6c69 7374  ""Returns a list
-0000a400: 205b 6e31 2c20 6e32 2c20 6e33 5d20 6f66   [n1, n2, n3] of
-0000a410: 206e 756d 6265 7273 206f 6620 6469 7363   numbers of disc
-0000a420: 7261 7469 7a61 7469 6f6e 2070 6f69 6e74  ratization point
-0000a430: 732e 0a20 2020 2020 2020 2022 2222 0a20  s..        """. 
-0000a440: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-0000a450: 6c66 2e5f 6e0a 0a20 2020 2040 6e2e 7365  lf._n..    @n.se
-0000a460: 7474 6572 0a20 2020 2064 6566 206e 2873  tter.    def n(s
-0000a470: 656c 662c 2076 293a 0a20 2020 2020 2020  elf, v):.       
-0000a480: 2073 7570 6572 2829 2e6e 203d 2076 0a20   super().n = v. 
-0000a490: 2020 2020 2020 2069 6620 7365 6c66 2e5f         if self._
-0000a4a0: 6469 7363 7265 7469 7a65 645f 646f 6d61  discretized_doma
-0000a4b0: 696e 3a0a 2020 2020 2020 2020 2020 2020  in:.            
-0000a4c0: 2320 7570 6461 7465 2074 6865 2064 6973  # update the dis
-0000a4d0: 6372 6574 697a 6564 2064 6f6d 6169 6e0a  cretized domain.
-0000a4e0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000a4f0: 2e5f 6372 6561 7465 5f64 6973 6372 6574  ._create_discret
-0000a500: 697a 6564 5f64 6f6d 6169 6e28 290a 0a20  ized_domain().. 
-0000a510: 2020 2064 6566 205f 706f 7374 5f69 6e69     def _post_ini
-0000a520: 7428 7365 6c66 293a 0a20 2020 2020 2020  t(self):.       
-0000a530: 2065 7870 7273 203d 2073 656c 662e 6578   exprs = self.ex
-0000a540: 7072 2069 6620 6861 7361 7474 7228 7365  pr if hasattr(se
-0000a550: 6c66 2e65 7870 722c 2022 5f5f 6974 6572  lf.expr, "__iter
-0000a560: 5f5f 2229 2065 6c73 6520 5b73 656c 662e  __") else [self.
-0000a570: 6578 7072 5d0a 2020 2020 2020 2020 6966  expr].        if
-0000a580: 2061 6e79 2863 616c 6c61 626c 6528 6529   any(callable(e)
-0000a590: 2066 6f72 2065 2069 6e20 6578 7072 7329   for e in exprs)
-0000a5a0: 2061 6e64 2073 656c 662e 7061 7261 6d73   and self.params
-0000a5b0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-0000a5c0: 6973 6520 5479 7065 4572 726f 7228 0a20  ise TypeError(. 
-0000a5d0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-0000a5e0: 6070 6172 616d 7360 2077 6173 2070 726f  `params` was pro
-0000a5f0: 7669 6465 642c 2068 656e 6365 2061 6e20  vided, hence an 
-0000a600: 696e 7465 7261 6374 6976 6520 706c 6f74  interactive plot
-0000a610: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
-0000a620: 2020 2022 6973 2065 7870 6563 7465 642e     "is expected.
-0000a630: 2048 6f77 6576 6572 2c20 696e 7465 7261   However, intera
-0000a640: 6374 6976 6520 706c 6f74 7320 646f 206e  ctive plots do n
-0000a650: 6f74 2073 7570 706f 7274 2022 0a20 2020  ot support ".   
-0000a660: 2020 2020 2020 2020 2020 2020 2022 7573               "us
-0000a670: 6572 2d70 726f 7669 6465 6420 6e75 6d65  er-provided nume
-0000a680: 7269 6361 6c20 6675 6e63 7469 6f6e 732e  rical functions.
-0000a690: 2229 0a0a 2020 2020 2020 2020 2320 6966  ")..        # if
-0000a6a0: 2074 6865 2065 7870 7265 7373 696f 6e73   the expressions
-0000a6b0: 2069 7320 6120 6c61 6d62 6461 2066 756e   is a lambda fun
-0000a6c0: 6374 696f 6e20 616e 6420 6e6f 206c 6162  ction and no lab
-0000a6d0: 656c 2068 6173 2062 6565 6e0a 2020 2020  el has been.    
-0000a6e0: 2020 2020 2320 7072 6f76 6964 6564 2c20      # provided, 
-0000a6f0: 7468 656e 2069 7473 2062 6574 7465 7220  then its better 
-0000a700: 746f 2064 6f20 7468 6520 666f 6c6c 6f77  to do the follow
-0000a710: 696e 6720 696e 206f 7264 6572 2074 6f20  ing in order to 
-0000a720: 6176 6f69 640a 2020 2020 2020 2020 2320  avoid.        # 
-0000a730: 7375 7072 6973 6573 206f 6e20 7468 6520  suprises on the 
-0000a740: 6261 636b 656e 640a 2020 2020 2020 2020  backend.        
-0000a750: 6966 2061 6e79 2863 616c 6c61 626c 6528  if any(callable(
-0000a760: 6529 2066 6f72 2065 2069 6e20 6578 7072  e) for e in expr
-0000a770: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-0000a780: 6966 2073 656c 662e 5f6c 6162 656c 203d  if self._label =
-0000a790: 3d20 7374 7228 7365 6c66 2e65 7870 7229  = str(self.expr)
-0000a7a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000a7b0: 2020 7365 6c66 2e6c 6162 656c 203d 2022    self.label = "
-0000a7c0: 220a 0a20 2020 2020 2020 2073 656c 662e  "..        self.
-0000a7d0: 5f63 6865 636b 5f66 7328 290a 0a20 2020  _check_fs()..   
-0000a7e0: 2020 2020 2069 6620 6861 7361 7474 7228       if hasattr(
-0000a7f0: 7365 6c66 2c20 2261 6461 7074 6976 6522  self, "adaptive"
-0000a800: 2920 616e 6420 7365 6c66 2e61 6461 7074  ) and self.adapt
-0000a810: 6976 6520 616e 6420 7365 6c66 2e70 6172  ive and self.par
-0000a820: 616d 733a 0a20 2020 2020 2020 2020 2020  ams:.           
-0000a830: 2077 6172 6e69 6e67 732e 7761 726e 280a   warnings.warn(.
-0000a840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a850: 2260 7061 7261 6d73 6020 7761 7320 7072  "`params` was pr
-0000a860: 6f76 6964 6564 2c20 6865 6e63 6520 616e  ovided, hence an
-0000a870: 2069 6e74 6572 6163 7469 7665 2070 6c6f   interactive plo
-0000a880: 7420 220a 2020 2020 2020 2020 2020 2020  t ".            
-0000a890: 2020 2020 2269 7320 6578 7065 6374 6564      "is expected
-0000a8a0: 2e20 486f 7765 7665 722c 2069 6e74 6572  . However, inter
-0000a8b0: 6163 7469 7665 2070 6c6f 7473 2064 6f20  active plots do 
-0000a8c0: 6e6f 7420 7375 7070 6f72 7420 220a 2020  not support ".  
-0000a8d0: 2020 2020 2020 2020 2020 2020 2020 2261                "a
-0000a8e0: 6461 7074 6976 6520 6576 616c 7561 7469  daptive evaluati
-0000a8f0: 6f6e 2e20 4175 746f 6d61 7469 6361 6c6c  on. Automaticall
-0000a900: 7920 7377 6974 6368 6564 2074 6f20 220a  y switched to ".
-0000a910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a920: 2261 6461 7074 6976 653d 4661 6c73 652e  "adaptive=False.
-0000a930: 2229 0a20 2020 2020 2020 2020 2020 2073  ").            s
-0000a940: 656c 662e 6164 6170 7469 7665 203d 2046  elf.adaptive = F
-0000a950: 616c 7365 0a0a 0a64 6566 205f 6465 7465  alse...def _dete
-0000a960: 6374 5f70 6f6c 6573 5f6e 756d 6572 6963  ct_poles_numeric
-0000a970: 616c 5f68 656c 7065 7228 0a20 2020 2078  al_helper(.    x
-0000a980: 2c20 792c 2065 7073 3d30 2e30 312c 2065  , y, eps=0.01, e
-0000a990: 7870 723d 4e6f 6e65 2c20 7379 6d62 3d4e  xpr=None, symb=N
-0000a9a0: 6f6e 652c 2073 796d 626f 6c69 633d 4661  one, symbolic=Fa
-0000a9b0: 6c73 650a 293a 0a20 2020 2022 2222 436f  lse.):.    """Co
-0000a9c0: 6d70 7574 6520 7468 6520 7374 6565 706e  mpute the steepn
-0000a9d0: 6573 7320 6f66 2065 6163 6820 7365 676d  ess of each segm
-0000a9e0: 656e 742e 2049 6620 6974 2773 2067 7265  ent. If it's gre
-0000a9f0: 6174 6572 2074 6861 6e20 610a 2020 2020  ater than a.    
-0000aa00: 7468 7265 7368 6f6c 642c 2073 6574 2074  threshold, set t
-0000aa10: 6865 2072 6967 6874 2d70 6f69 6e74 2079  he right-point y
-0000aa20: 2d76 616c 7565 206e 6f6e 204e 614e 2061  -value non NaN a
-0000aa30: 6e64 2072 6563 6f72 6420 7468 650a 2020  nd record the.  
-0000aa40: 2020 636f 7272 6573 706f 6e64 696e 6720    corresponding 
-0000aa50: 782d 6c6f 6361 7469 6f6e 2066 6f72 2066  x-location for f
-0000aa60: 7572 7468 6572 2070 726f 6365 7373 696e  urther processin
-0000aa70: 672e 0a0a 2020 2020 5265 7475 726e 730a  g...    Returns.
-0000aa80: 2020 2020 3d3d 3d3d 3d3d 3d0a 2020 2020      =======.    
-0000aa90: 7820 3a20 6e70 2e6e 6461 7272 6179 0a20  x : np.ndarray. 
-0000aaa0: 2020 2020 2020 2055 6e63 6861 6e67 6564         Unchanged
-0000aab0: 2078 2d64 6174 612e 0a20 2020 2079 7920   x-data..    yy 
-0000aac0: 3a20 6e70 2e6e 6461 7272 6179 0a20 2020  : np.ndarray.   
-0000aad0: 2020 2020 204d 6f64 6966 6965 6420 792d       Modified y-
-0000aae0: 6461 7461 2077 6974 6820 4e61 4e20 7661  data with NaN va
-0000aaf0: 6c75 6573 2e0a 2020 2020 2222 220a 2020  lues..    """.  
-0000ab00: 2020 6e70 203d 2069 6d70 6f72 745f 6d6f    np = import_mo
-0000ab10: 6475 6c65 2827 6e75 6d70 7927 290a 0a20  dule('numpy').. 
-0000ab20: 2020 2079 7920 3d20 792e 636f 7079 2829     yy = y.copy()
-0000ab30: 0a20 2020 2074 6872 6573 686f 6c64 203d  .    threshold =
-0000ab40: 206e 702e 7069 202f 2032 202d 2065 7073   np.pi / 2 - eps
-0000ab50: 0a20 2020 2066 6f72 2069 2069 6e20 7261  .    for i in ra
-0000ab60: 6e67 6528 6c65 6e28 7829 202d 2031 293a  nge(len(x) - 1):
-0000ab70: 0a20 2020 2020 2020 2064 7820 3d20 785b  .        dx = x[
-0000ab80: 6920 2b20 315d 202d 2078 5b69 5d0a 2020  i + 1] - x[i].  
-0000ab90: 2020 2020 2020 6479 203d 2061 6273 2879        dy = abs(y
-0000aba0: 5b69 202b 2031 5d20 2d20 795b 695d 290a  [i + 1] - y[i]).
-0000abb0: 2020 2020 2020 2020 616e 676c 6520 3d20          angle = 
-0000abc0: 6e70 2e61 7263 7461 6e28 6479 202f 2064  np.arctan(dy / d
-0000abd0: 7829 0a20 2020 2020 2020 2069 6620 6162  x).        if ab
-0000abe0: 7328 616e 676c 6529 203e 3d20 7468 7265  s(angle) >= thre
-0000abf0: 7368 6f6c 643a 0a20 2020 2020 2020 2020  shold:.         
-0000ac00: 2020 2079 795b 6920 2b20 315d 203d 206e     yy[i + 1] = n
-0000ac10: 702e 6e61 6e0a 0a20 2020 2072 6574 7572  p.nan..    retur
-0000ac20: 6e20 782c 2079 790a 0a0a 6465 6620 5f64  n x, yy...def _d
-0000ac30: 6574 6563 745f 706f 6c65 735f 7379 6d62  etect_poles_symb
-0000ac40: 6f6c 6963 5f68 656c 7065 7228 6578 7072  olic_helper(expr
-0000ac50: 2c20 7379 6d62 2c20 7374 6172 742c 2065  , symb, start, e
-0000ac60: 6e64 293a 0a20 2020 2022 2222 4174 7465  nd):.    """Atte
-0000ac70: 6d70 7473 2074 6f20 636f 6d70 7574 6520  mpts to compute 
-0000ac80: 7379 6d62 6f6c 6963 2064 6973 636f 6e74  symbolic discont
-0000ac90: 696e 7569 7469 6573 2e0a 0a20 2020 2052  inuities...    R
-0000aca0: 6574 7572 6e73 0a20 2020 203d 3d3d 3d3d  eturns.    =====
-0000acb0: 3d3d 0a20 2020 2070 6f6c 6520 3a20 6c69  ==.    pole : li
-0000acc0: 7374 0a20 2020 2020 2020 204c 6973 7420  st.        List 
-0000acd0: 6f66 2073 796d 626f 6c69 6320 706f 6c65  of symbolic pole
-0000ace0: 732c 2070 6f73 7369 6269 6c79 2065 6d70  s, possibily emp
-0000acf0: 7479 2e0a 2020 2020 2222 220a 2020 2020  ty..    """.    
-0000ad00: 706f 6c65 7320 3d20 5b5d 0a20 2020 2069  poles = [].    i
-0000ad10: 6e74 6572 7661 6c20 3d20 496e 7465 7276  nterval = Interv
-0000ad20: 616c 286e 7369 6d70 6c69 6679 2873 7461  al(nsimplify(sta
-0000ad30: 7274 292c 206e 7369 6d70 6c69 6679 2865  rt), nsimplify(e
-0000ad40: 6e64 2929 0a20 2020 2072 6573 203d 2063  nd)).    res = c
-0000ad50: 6f6e 7469 6e75 6f75 735f 646f 6d61 696e  ontinuous_domain
-0000ad60: 2865 7870 722c 2073 796d 622c 2069 6e74  (expr, symb, int
-0000ad70: 6572 7661 6c29 0a20 2020 2072 6573 203d  erval).    res =
-0000ad80: 2072 6573 2e73 696d 706c 6966 7928 290a   res.simplify().
-0000ad90: 2020 2020 6966 2072 6573 203d 3d20 696e      if res == in
-0000ada0: 7465 7276 616c 3a0a 2020 2020 2020 2020  terval:.        
-0000adb0: 7061 7373 0a20 2020 2065 6c69 6620 2869  pass.    elif (i
-0000adc0: 7369 6e73 7461 6e63 6528 7265 732c 2055  sinstance(res, U
-0000add0: 6e69 6f6e 2920 616e 640a 2020 2020 2020  nion) and.      
-0000ade0: 2020 616c 6c28 6973 696e 7374 616e 6365    all(isinstance
-0000adf0: 2874 2c20 496e 7465 7276 616c 2920 666f  (t, Interval) fo
-0000ae00: 7220 7420 696e 2072 6573 2e61 7267 7329  r t in res.args)
-0000ae10: 293a 0a20 2020 2020 2020 2070 6f6c 6573  ):.        poles
-0000ae20: 203d 205b 5d0a 2020 2020 2020 2020 666f   = [].        fo
-0000ae30: 7220 7320 696e 2072 6573 2e61 7267 733a  r s in res.args:
-0000ae40: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000ae50: 732e 6c65 6674 5f6f 7065 6e3a 0a20 2020  s.left_open:.   
-0000ae60: 2020 2020 2020 2020 2020 2020 2070 6f6c               pol
-0000ae70: 6573 2e61 7070 656e 6428 732e 6c65 6674  es.append(s.left
-0000ae80: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-0000ae90: 2073 2e72 6967 6874 5f6f 7065 6e3a 0a20   s.right_open:. 
-0000aea0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000aeb0: 6f6c 6573 2e61 7070 656e 6428 732e 7269  oles.append(s.ri
-0000aec0: 6768 7429 0a20 2020 2020 2020 2070 6f6c  ght).        pol
-0000aed0: 6573 203d 206c 6973 7428 7365 7428 706f  es = list(set(po
-0000aee0: 6c65 7329 290a 2020 2020 656c 7365 3a0a  les)).    else:.
-0000aef0: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-0000af00: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
-0000af10: 2020 2020 2020 6622 436f 756c 6420 6e6f        f"Could no
-0000af20: 7420 7061 7273 6520 7468 6520 666f 6c6c  t parse the foll
-0000af30: 6f77 696e 6720 6f62 6a65 6374 3a20 7b72  owing object: {r
-0000af40: 6573 7d20 2e5c 6e22 0a20 2020 2020 2020  es} .\n".       
-0000af50: 2020 2020 2022 506c 6561 7365 2c20 7375       "Please, su
-0000af60: 626d 6974 2074 6869 7320 6173 2061 2062  bmit this as a b
-0000af70: 7567 2e20 436f 6e73 6964 6572 2061 6c73  ug. Consider als
-0000af80: 6f20 746f 2073 6574 2022 0a20 2020 2020  o to set ".     
-0000af90: 2020 2020 2020 2022 6064 6574 6563 745f         "`detect_
-0000afa0: 706f 6c65 733d 5472 7565 602e 220a 2020  poles=True`.".  
-0000afb0: 2020 2020 2020 290a 2020 2020 7265 7475        ).    retu
-0000afc0: 726e 2070 6f6c 6573 0a0a 0a64 6566 205f  rn poles...def _
-0000afd0: 6368 6563 6b5f 7374 6570 7328 7374 6570  check_steps(step
-0000afe0: 7329 3a0a 2020 2020 6966 2069 7369 6e73  s):.    if isins
-0000aff0: 7461 6e63 6528 7374 6570 732c 2073 7472  tance(steps, str
-0000b000: 293a 0a20 2020 2020 2020 2073 7465 7073  ):.        steps
-0000b010: 203d 2073 7465 7073 2e6c 6f77 6572 2829   = steps.lower()
-0000b020: 0a20 2020 2070 6f73 7369 626c 655f 7661  .    possible_va
-0000b030: 6c75 6573 203d 205b 2270 7265 222c 2022  lues = ["pre", "
-0000b040: 706f 7374 222c 2022 6d69 6422 2c20 5472  post", "mid", Tr
-0000b050: 7565 2c20 4661 6c73 652c 204e 6f6e 655d  ue, False, None]
-0000b060: 0a20 2020 2069 6620 6e6f 7420 2873 7465  .    if not (ste
-0000b070: 7073 2069 6e20 706f 7373 6962 6c65 5f76  ps in possible_v
-0000b080: 616c 7565 7329 3a0a 2020 2020 2020 2020  alues):.        
-0000b090: 7761 726e 696e 6773 2e77 6172 6e28 0a20  warnings.warn(. 
-0000b0a0: 2020 2020 2020 2020 2020 2022 6060 7374             "``st
-0000b0b0: 6570 7360 6020 6e6f 7420 7265 636f 676e  eps`` not recogn
-0000b0c0: 697a 6564 2e20 506f 7373 6962 6c65 2076  ized. Possible v
-0000b0d0: 616c 7565 7320 6172 653a 2022 2025 2070  alues are: " % p
-0000b0e0: 6f73 7369 626c 655f 7661 6c75 6573 0a20  ossible_values. 
-0000b0f0: 2020 2020 2020 2029 0a20 2020 2072 6574         ).    ret
-0000b100: 7572 6e20 7374 6570 730a 0a0a 636c 6173  urn steps...clas
-0000b110: 7320 4c69 6e65 3244 4261 7365 5365 7269  s Line2DBaseSeri
-0000b120: 6573 2842 6173 6553 6572 6965 7329 3a0a  es(BaseSeries):.
-0000b130: 2020 2020 2222 2241 2062 6173 6520 636c      """A base cl
-0000b140: 6173 7320 666f 7220 3244 206c 696e 6573  ass for 2D lines
-0000b150: 2e22 2222 0a0a 2020 2020 6973 5f32 446c  ."""..    is_2Dl
-0000b160: 696e 6520 3d20 5472 7565 0a20 2020 205f  ine = True.    _
-0000b170: 4e20 3d20 3130 3030 0a20 2020 205f 616c  N = 1000.    _al
-0000b180: 6c6f 7765 645f 6b65 7973 203d 205b 0a20  lowed_keys = [. 
-0000b190: 2020 2020 2020 2022 7374 6570 7322 2c20         "steps", 
-0000b1a0: 2273 6361 7474 6572 222c 2022 6973 5f66  "scatter", "is_f
-0000b1b0: 696c 6c65 6422 2c20 2266 696c 6c22 2c20  illed", "fill", 
-0000b1c0: 226c 696e 655f 636f 6c6f 7222 2c20 2264  "line_color", "d
-0000b1d0: 6574 6563 745f 706f 6c65 7322 2c0a 2020  etect_poles",.  
-0000b1e0: 2020 2020 2020 2265 7073 222c 2022 6973        "eps", "is
-0000b1f0: 5f70 6f6c 6172 222c 2022 756e 7772 6170  _polar", "unwrap
-0000b200: 222c 2022 6578 636c 7564 6522 2c0a 2020  ", "exclude",.  
-0000b210: 2020 5d0a 0a20 2020 2064 6566 205f 5f69    ]..    def __i
-0000b220: 6e69 745f 5f28 7365 6c66 2c20 2a61 7267  nit__(self, *arg
-0000b230: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
-0000b240: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
-0000b250: 696e 6974 5f5f 282a 6172 6773 2c20 2a2a  init__(*args, **
-0000b260: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
-0000b270: 2320 6d6f 6469 6679 2074 6865 2063 6f6d  # modify the com
-0000b280: 7075 7465 6420 636f 6f72 6469 6e61 7465  puted coordinate
-0000b290: 7320 696e 206f 7264 6572 2074 6f20 6f62  s in order to ob
-0000b2a0: 7461 696e 2061 2073 7465 702d 6c69 6b65  tain a step-like
-0000b2b0: 2070 6c6f 740a 2020 2020 2020 2020 7365   plot.        se
-0000b2c0: 6c66 2e73 7465 7073 203d 205f 6368 6563  lf.steps = _chec
-0000b2d0: 6b5f 7374 6570 7328 6b77 6172 6773 2e67  k_steps(kwargs.g
-0000b2e0: 6574 2822 7374 6570 7322 2c20 4661 6c73  et("steps", Fals
-0000b2f0: 6529 290a 2020 2020 2020 2020 2320 7768  e)).        # wh
-0000b300: 6574 6865 7220 746f 2063 7265 6174 6520  ether to create 
-0000b310: 7363 6174 7465 7220 6f72 2061 2063 6f6e  scatter or a con
-0000b320: 7469 6e75 6f75 7320 6c69 6e65 0a20 2020  tinuous line.   
-0000b330: 2020 2020 2073 656c 662e 6973 5f70 6f69       self.is_poi
-0000b340: 6e74 203d 206b 7761 7267 732e 6765 7428  nt = kwargs.get(
-0000b350: 2273 6361 7474 6572 222c 206b 7761 7267  "scatter", kwarg
-0000b360: 732e 6765 7428 2269 735f 706f 696e 7422  s.get("is_point"
-0000b370: 2c20 4661 6c73 6529 290a 2020 2020 2020  , False)).      
-0000b380: 2020 2320 7768 6574 6865 7220 7363 6174    # whether scat
-0000b390: 7465 7227 7320 6d61 726b 6572 7320 6172  ter's markers ar
-0000b3a0: 6520 6669 6c6c 6564 206f 7220 766f 6964  e filled or void
-0000b3b0: 0a20 2020 2020 2020 2073 656c 662e 6973  .        self.is
-0000b3c0: 5f66 696c 6c65 6420 3d20 6b77 6172 6773  _filled = kwargs
-0000b3d0: 2e67 6574 2822 6973 5f66 696c 6c65 6422  .get("is_filled"
-0000b3e0: 2c20 6b77 6172 6773 2e67 6574 2822 6669  , kwargs.get("fi
-0000b3f0: 6c6c 222c 2054 7275 6529 290a 2020 2020  ll", True)).    
-0000b400: 2020 2020 2320 7768 6574 6865 7220 746f      # whether to
-0000b410: 2075 7365 2061 2063 6f6c 6f72 6d61 7020   use a colormap 
-0000b420: 6f72 2061 2073 6f6c 6964 206c 696e 6520  or a solid line 
-0000b430: 636f 6c6f 720a 2020 2020 2020 2020 7365  color.        se
-0000b440: 6c66 2e75 7365 5f63 6d20 3d20 6b77 6172  lf.use_cm = kwar
-0000b450: 6773 2e67 6574 2822 7573 655f 636d 222c  gs.get("use_cm",
-0000b460: 2046 616c 7365 290a 2020 2020 2020 2020   False).        
-0000b470: 2320 666f 7220 6261 636b 2d63 6f6d 7061  # for back-compa
-0000b480: 7469 6269 6c69 7479 2077 6974 6820 6f6c  tibility with ol
-0000b490: 6420 7379 6d70 792e 706c 6f74 7469 6e67  d sympy.plotting
-0000b4a0: 0a20 2020 2020 2020 2073 656c 662e 6c69  .        self.li
-0000b4b0: 6e65 5f63 6f6c 6f72 203d 206b 7761 7267  ne_color = kwarg
-0000b4c0: 732e 6765 7428 226c 696e 655f 636f 6c6f  s.get("line_colo
-0000b4d0: 7222 2c20 4e6f 6e65 290a 2020 2020 2020  r", None).      
-0000b4e0: 2020 2320 7768 6574 6865 7220 746f 2064    # whether to d
-0000b4f0: 6574 6563 7420 726f 6f74 7320 6f66 2064  etect roots of d
-0000b500: 656e 6f6d 696e 6174 6f72 0a20 2020 2020  enominator.     
-0000b510: 2020 2073 656c 662e 6465 7465 6374 5f70     self.detect_p
-0000b520: 6f6c 6573 203d 206b 7761 7267 732e 6765  oles = kwargs.ge
-0000b530: 7428 2264 6574 6563 745f 706f 6c65 7322  t("detect_poles"
-0000b540: 2c20 4661 6c73 6529 0a20 2020 2020 2020  , False).       
-0000b550: 2023 2061 2070 6172 616d 6574 6572 2074   # a parameter t
-0000b560: 6f20 636f 6e74 726f 6c20 7468 6520 6465  o control the de
-0000b570: 7465 6374 5f70 6f6c 6573 2061 6c67 6f72  tect_poles algor
-0000b580: 6974 686d 0a20 2020 2020 2020 2073 656c  ithm.        sel
-0000b590: 662e 6570 7320 3d20 6b77 6172 6773 2e67  f.eps = kwargs.g
-0000b5a0: 6574 2822 6570 7322 2c20 302e 3031 290a  et("eps", 0.01).
-0000b5b0: 2020 2020 2020 2020 2320 7768 656e 2064          # when d
-0000b5c0: 6574 6563 745f 706f 6c65 733d 2273 796d  etect_poles="sym
-0000b5d0: 626f 6c69 6322 2c20 7374 6f72 6573 2074  bolic", stores t
-0000b5e0: 6865 206c 6f63 6174 696f 6e20 6f66 2070  he location of p
-0000b5f0: 6f6c 6573 2073 6f20 7468 6174 0a20 2020  oles so that.   
-0000b600: 2020 2020 2023 2074 6865 7920 6361 6e20       # they can 
-0000b610: 6265 2061 7070 726f 7072 6961 7465 6c79  be appropriately
-0000b620: 2072 656e 6465 7265 640a 2020 2020 2020   rendered.      
-0000b630: 2020 7365 6c66 2e70 6f6c 6573 5f6c 6f63    self.poles_loc
-0000b640: 6174 696f 6e73 203d 205b 5d0a 2020 2020  ations = [].    
-0000b650: 2020 2020 2320 7768 6574 6865 7220 746f      # whether to
-0000b660: 2063 6f6e 7665 7220 7468 6520 636f 6d70   conver the comp
-0000b670: 7574 6564 2063 6f6f 7264 696e 6174 6573  uted coordinates
-0000b680: 2074 6f20 706f 6c61 7220 636f 6f72 6469   to polar coordi
-0000b690: 6e61 7465 730a 2020 2020 2020 2020 7365  nates.        se
-0000b6a0: 6c66 2e69 735f 706f 6c61 7220 3d20 6b77  lf.is_polar = kw
-0000b6b0: 6172 6773 2e67 6574 2822 6973 5f70 6f6c  args.get("is_pol
-0000b6c0: 6172 222c 2046 616c 7365 290a 2020 2020  ar", False).    
-0000b6d0: 2020 2020 2320 7768 6574 6865 7220 746f      # whether to
-0000b6e0: 2075 7365 206e 756d 7079 2e75 6e77 7261   use numpy.unwra
-0000b6f0: 7028 290a 2020 2020 2020 2020 7365 6c66  p().        self
-0000b700: 2e75 6e77 7261 7020 3d20 6b77 6172 6773  .unwrap = kwargs
-0000b710: 2e67 6574 2822 756e 7772 6170 222c 2046  .get("unwrap", F
-0000b720: 616c 7365 290a 2020 2020 2020 2020 2320  alse).        # 
-0000b730: 6c69 7374 206f 6620 782d 636f 6f72 6469  list of x-coordi
-0000b740: 6e61 7465 7320 746f 2062 6520 6578 636c  nates to be excl
-0000b750: 7564 6564 2066 726f 6d20 6576 616c 7561  uded from evalua
-0000b760: 7469 6f6e 0a20 2020 2020 2020 2065 7863  tion.        exc
-0000b770: 6c75 6465 203d 206b 7761 7267 732e 6765  lude = kwargs.ge
-0000b780: 7428 2265 7863 6c75 6465 222c 205b 5d29  t("exclude", [])
-0000b790: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
-0000b7a0: 7374 616e 6365 2865 7863 6c75 6465 2c20  stance(exclude, 
-0000b7b0: 5365 7429 3a0a 2020 2020 2020 2020 2020  Set):.          
-0000b7c0: 2020 6578 636c 7564 6520 3d20 6c69 7374    exclude = list
-0000b7d0: 2865 7874 7261 6374 5f73 6f6c 7574 696f  (extract_solutio
-0000b7e0: 6e28 6578 636c 7564 652c 206e 3d31 3030  n(exclude, n=100
-0000b7f0: 2929 0a20 2020 2020 2020 2069 6620 6e6f  )).        if no
-0000b800: 7420 6861 7361 7474 7228 6578 636c 7564  t hasattr(exclud
-0000b810: 652c 2022 5f5f 6974 6572 5f5f 2229 3a0a  e, "__iter__"):.
-0000b820: 2020 2020 2020 2020 2020 2020 6578 636c              excl
-0000b830: 7564 6520 3d20 5b65 7863 6c75 6465 5d0a  ude = [exclude].
-0000b840: 2020 2020 2020 2020 6578 636c 7564 6520          exclude 
-0000b850: 3d20 5b66 6c6f 6174 2865 2920 666f 7220  = [float(e) for 
-0000b860: 6520 696e 2065 7863 6c75 6465 5d0a 2020  e in exclude].  
-0000b870: 2020 2020 2020 7365 6c66 2e65 7863 6c75        self.exclu
-0000b880: 6465 203d 2073 6f72 7465 6428 6578 636c  de = sorted(excl
-0000b890: 7564 6529 0a0a 2020 2020 6465 6620 6765  ude)..    def ge
-0000b8a0: 745f 6461 7461 2873 656c 6629 3a0a 2020  t_data(self):.  
-0000b8b0: 2020 2020 2020 2222 2252 6574 7572 6e20        """Return 
-0000b8c0: 636f 6f72 6469 6e61 7465 7320 666f 7220  coordinates for 
-0000b8d0: 706c 6f74 7469 6e67 2074 6865 206c 696e  plotting the lin
-0000b8e0: 652e 0a0a 2020 2020 2020 2020 5265 7475  e...        Retu
-0000b8f0: 726e 730a 2020 2020 2020 2020 3d3d 3d3d  rns.        ====
-0000b900: 3d3d 3d0a 0a20 2020 2020 2020 2078 3a20  ===..        x: 
-0000b910: 6e70 2e6e 6461 7272 6179 0a20 2020 2020  np.ndarray.     
-0000b920: 2020 2020 2020 2078 2d63 6f6f 7264 696e         x-coordin
-0000b930: 6174 6573 0a20 2020 2020 2020 2079 3a20  ates.        y: 
-0000b940: 6e70 2e6e 6461 7272 6179 0a20 2020 2020  np.ndarray.     
-0000b950: 2020 2020 2020 2079 2d63 6f6f 7264 696e         y-coordin
-0000b960: 6174 6573 0a20 2020 2020 2020 207a 3a20  ates.        z: 
-0000b970: 6e70 2e6e 6461 7272 6179 2028 6f70 7469  np.ndarray (opti
-0000b980: 6f6e 616c 290a 2020 2020 2020 2020 2020  onal).          
-0000b990: 2020 7a2d 636f 6f72 6469 6e61 7465 7320    z-coordinates 
-0000b9a0: 696e 2063 6173 6520 6f66 2050 6172 616d  in case of Param
-0000b9b0: 6574 7269 6333 444c 696e 6553 6572 6965  etric3DLineSerie
-0000b9c0: 730a 2020 2020 2020 2020 7061 7261 6d20  s.        param 
-0000b9d0: 3a20 6e70 2e6e 6461 7272 6179 2028 6f70  : np.ndarray (op
-0000b9e0: 7469 6f6e 616c 290a 2020 2020 2020 2020  tional).        
-0000b9f0: 2020 2020 5468 6520 7061 7261 6d65 7465      The paramete
-0000ba00: 7220 696e 2063 6173 6520 6f66 2050 6172  r in case of Par
-0000ba10: 616d 6574 7269 6332 444c 696e 6553 6572  ametric2DLineSer
-0000ba20: 6965 732c 0a20 2020 2020 2020 2020 2020  ies,.           
-0000ba30: 2050 6172 616d 6574 7269 6333 444c 696e   Parametric3DLin
-0000ba40: 6553 6572 6965 7320 6f72 2041 6273 4172  eSeries or AbsAr
-0000ba50: 674c 696e 6553 6572 6965 732e 0a20 2020  gLineSeries..   
-0000ba60: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0000ba70: 206e 7020 3d20 696d 706f 7274 5f6d 6f64   np = import_mod
-0000ba80: 756c 6528 276e 756d 7079 2729 0a20 2020  ule('numpy').   
-0000ba90: 2020 2020 2070 6f69 6e74 7320 3d20 7365       points = se
-0000baa0: 6c66 2e5f 6765 745f 6461 7461 5f68 656c  lf._get_data_hel
-0000bab0: 7065 7228 290a 0a20 2020 2020 2020 2069  per()..        i
-0000bac0: 6620 280a 2020 2020 2020 2020 2020 2020  f (.            
-0000bad0: 6973 696e 7374 616e 6365 2873 656c 662c  isinstance(self,
-0000bae0: 204c 696e 654f 7665 7231 4452 616e 6765   LineOver1DRange
-0000baf0: 5365 7269 6573 2920 616e 640a 2020 2020  Series) and.    
-0000bb00: 2020 2020 2020 2020 2873 656c 662e 6465          (self.de
-0000bb10: 7465 6374 5f70 6f6c 6573 203d 3d20 2273  tect_poles == "s
-0000bb20: 796d 626f 6c69 6322 290a 2020 2020 2020  ymbolic").      
-0000bb30: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
-0000bb40: 2070 6f6c 6573 203d 205f 6465 7465 6374   poles = _detect
-0000bb50: 5f70 6f6c 6573 5f73 796d 626f 6c69 635f  _poles_symbolic_
-0000bb60: 6865 6c70 6572 280a 2020 2020 2020 2020  helper(.        
-0000bb70: 2020 2020 2020 2020 7365 6c66 2e65 7870          self.exp
-0000bb80: 722e 7375 6273 2873 656c 662e 7061 7261  r.subs(self.para
-0000bb90: 6d73 292c 202a 7365 6c66 2e72 616e 6765  ms), *self.range
-0000bba0: 735b 305d 290a 2020 2020 2020 2020 2020  s[0]).          
-0000bbb0: 2020 706f 6c65 7320 3d20 6e70 2e61 7272    poles = np.arr
-0000bbc0: 6179 285b 666c 6f61 7428 7429 2066 6f72  ay([float(t) for
-0000bbd0: 2074 2069 6e20 706f 6c65 735d 290a 2020   t in poles]).  
-0000bbe0: 2020 2020 2020 2020 2020 7420 3d20 6c61            t = la
-0000bbf0: 6d62 6461 2078 2c20 7472 616e 7366 6f72  mbda x, transfor
-0000bc00: 6d3a 2078 2069 6620 7472 616e 7366 6f72  m: x if transfor
-0000bc10: 6d20 6973 204e 6f6e 6520 656c 7365 2074  m is None else t
-0000bc20: 7261 6e73 666f 726d 2878 290a 2020 2020  ransform(x).    
-0000bc30: 2020 2020 2020 2020 7365 6c66 2e70 6f6c          self.pol
-0000bc40: 6573 5f6c 6f63 6174 696f 6e73 203d 2074  es_locations = t
-0000bc50: 286e 702e 6172 7261 7928 706f 6c65 7329  (np.array(poles)
-0000bc60: 2c20 7365 6c66 2e5f 7478 290a 0a20 2020  , self._tx)..   
-0000bc70: 2020 2020 2023 2070 6f73 7470 726f 6365       # postproce
-0000bc80: 7373 696e 670a 2020 2020 2020 2020 706f  ssing.        po
-0000bc90: 696e 7473 203d 2073 656c 662e 5f61 7070  ints = self._app
-0000bca0: 6c79 5f74 7261 6e73 666f 726d 282a 706f  ly_transform(*po
-0000bcb0: 696e 7473 290a 0a20 2020 2020 2020 2069  ints)..        i
-0000bcc0: 6620 7365 6c66 2e69 735f 3244 6c69 6e65  f self.is_2Dline
-0000bcd0: 2061 6e64 2073 656c 662e 6465 7465 6374   and self.detect
-0000bce0: 5f70 6f6c 6573 3a0a 2020 2020 2020 2020  _poles:.        
-0000bcf0: 2020 2020 6966 206c 656e 2870 6f69 6e74      if len(point
-0000bd00: 7329 203d 3d20 323a 0a20 2020 2020 2020  s) == 2:.       
-0000bd10: 2020 2020 2020 2020 2078 2c20 7920 3d20           x, y = 
-0000bd20: 706f 696e 7473 0a20 2020 2020 2020 2020  points.         
-0000bd30: 2020 2020 2020 2078 2c20 7920 3d20 5f64         x, y = _d
-0000bd40: 6574 6563 745f 706f 6c65 735f 6e75 6d65  etect_poles_nume
-0000bd50: 7269 6361 6c5f 6865 6c70 6572 280a 2020  rical_helper(.  
-0000bd60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bd70: 2020 782c 2079 2c20 7365 6c66 2e65 7073    x, y, self.eps
-0000bd80: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000bd90: 2020 706f 696e 7473 203d 2028 782c 2079    points = (x, y
-0000bda0: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
-0000bdb0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000bdc0: 2020 2020 782c 2079 2c20 7020 3d20 706f      x, y, p = po
-0000bdd0: 696e 7473 0a20 2020 2020 2020 2020 2020  ints.           
-0000bde0: 2020 2020 2078 2c20 7920 3d20 5f64 6574       x, y = _det
-0000bdf0: 6563 745f 706f 6c65 735f 6e75 6d65 7269  ect_poles_numeri
-0000be00: 6361 6c5f 6865 6c70 6572 2878 2c20 792c  cal_helper(x, y,
-0000be10: 2073 656c 662e 6570 7329 0a20 2020 2020   self.eps).     
-0000be20: 2020 2020 2020 2020 2020 2070 6f69 6e74             point
-0000be30: 7320 3d20 2878 2c20 792c 2070 290a 0a20  s = (x, y, p).. 
-0000be40: 2020 2020 2020 2069 6620 7365 6c66 2e75         if self.u
-0000be50: 6e77 7261 703a 0a20 2020 2020 2020 2020  nwrap:.         
-0000be60: 2020 206b 7720 3d20 7b7d 0a20 2020 2020     kw = {}.     
-0000be70: 2020 2020 2020 2069 6620 7365 6c66 2e75         if self.u
-0000be80: 6e77 7261 7020 6973 206e 6f74 2054 7275  nwrap is not Tru
-0000be90: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000bea0: 2020 206b 7720 3d20 7365 6c66 2e75 6e77     kw = self.unw
-0000beb0: 7261 700a 2020 2020 2020 2020 2020 2020  rap.            
-0000bec0: 6966 2073 656c 662e 6973 5f32 446c 696e  if self.is_2Dlin
-0000bed0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000bee0: 2020 2069 6620 6c65 6e28 706f 696e 7473     if len(points
-0000bef0: 2920 3d3d 2032 3a0a 2020 2020 2020 2020  ) == 2:.        
-0000bf00: 2020 2020 2020 2020 2020 2020 782c 2079              x, y
-0000bf10: 203d 2070 6f69 6e74 730a 2020 2020 2020   = points.      
-0000bf20: 2020 2020 2020 2020 2020 2020 2020 7920                y 
-0000bf30: 3d20 6e70 2e75 6e77 7261 7028 792c 202a  = np.unwrap(y, *
-0000bf40: 2a6b 7729 0a20 2020 2020 2020 2020 2020  *kw).           
-0000bf50: 2020 2020 2020 2020 2070 6f69 6e74 7320           points 
-0000bf60: 3d20 2878 2c20 7929 0a20 2020 2020 2020  = (x, y).       
-0000bf70: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000bf80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bf90: 2020 2078 2c20 792c 2070 203d 2070 6f69     x, y, p = poi
-0000bfa0: 6e74 730a 2020 2020 2020 2020 2020 2020  nts.            
-0000bfb0: 2020 2020 2020 2020 7920 3d20 6e70 2e75          y = np.u
-0000bfc0: 6e77 7261 7028 792c 202a 2a6b 7729 0a20  nwrap(y, **kw). 
-0000bfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bfe0: 2020 2070 6f69 6e74 7320 3d20 2878 2c20     points = (x, 
-0000bff0: 792c 2070 290a 0a20 2020 2020 2020 2069  y, p)..        i
-0000c000: 6620 2873 656c 662e 7374 6570 7320 6973  f (self.steps is
-0000c010: 2054 7275 6529 206f 7220 2873 656c 662e   True) or (self.
-0000c020: 7374 6570 7320 3d3d 2022 7072 6522 293a  steps == "pre"):
-0000c030: 0a20 2020 2020 2020 2020 2020 2070 6f69  .            poi
-0000c040: 6e74 7320 3d20 7074 735f 746f 5f70 7265  nts = pts_to_pre
-0000c050: 7374 6570 282a 706f 696e 7473 290a 2020  step(*points).  
-0000c060: 2020 2020 2020 656c 6966 2073 656c 662e        elif self.
-0000c070: 7374 6570 7320 3d3d 2022 706f 7374 223a  steps == "post":
-0000c080: 0a20 2020 2020 2020 2020 2020 2070 6f69  .            poi
-0000c090: 6e74 7320 3d20 7074 735f 746f 5f70 6f73  nts = pts_to_pos
-0000c0a0: 7473 7465 7028 2a70 6f69 6e74 7329 0a20  tstep(*points). 
-0000c0b0: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-0000c0c0: 2e73 7465 7073 203d 3d20 226d 6964 223a  .steps == "mid":
-0000c0d0: 0a20 2020 2020 2020 2020 2020 2070 6f69  .            poi
-0000c0e0: 6e74 7320 3d20 7074 735f 746f 5f6d 6964  nts = pts_to_mid
-0000c0f0: 7374 6570 282a 706f 696e 7473 290a 0a20  step(*points).. 
-0000c100: 2020 2020 2020 2070 6f69 6e74 7320 3d20         points = 
-0000c110: 7365 6c66 2e5f 696e 7365 7274 5f65 7863  self._insert_exc
-0000c120: 6c75 7369 6f6e 7328 706f 696e 7473 290a  lusions(points).
-0000c130: 2020 2020 2020 2020 7265 7475 726e 2070          return p
-0000c140: 6f69 6e74 730a 0a20 2020 2064 6566 205f  oints..    def _
-0000c150: 696e 7365 7274 5f65 7863 6c75 7369 6f6e  insert_exclusion
-0000c160: 7328 7365 6c66 2c20 706f 696e 7473 293a  s(self, points):
-0000c170: 0a20 2020 2020 2020 2022 2222 4164 6420  .        """Add 
-0000c180: 4e61 4e20 746f 2065 6163 6820 6f66 2074  NaN to each of t
-0000c190: 6865 2065 7863 6c75 7369 6f6e 2070 6f69  he exclusion poi
-0000c1a0: 6e74 2e20 5072 6163 7469 6361 6c6c 792c  nt. Practically,
-0000c1b0: 2074 6869 7320 6164 6473 2061 0a20 2020   this adds a.   
-0000c1c0: 2020 2020 204e 614e 2074 6f20 7468 6520       NaN to the 
-0000c1d0: 6578 6c75 7369 6f6e 2070 6f69 6e74 2c20  exlusion point, 
-0000c1e0: 706c 7573 2074 776f 206f 7468 6572 206e  plus two other n
-0000c1f0: 6561 7262 7920 706f 696e 7473 2065 7661  earby points eva
-0000c200: 6c75 6174 6564 2077 6974 680a 2020 2020  luated with.    
-0000c210: 2020 2020 7468 6520 6e75 6d65 7269 6361      the numerica
-0000c220: 6c20 6675 6e63 7469 6f6e 7320 6173 736f  l functions asso
-0000c230: 6369 6174 6564 2074 6f20 7468 6973 2064  ciated to this d
-0000c240: 6174 6120 7365 7269 6573 2e0a 2020 2020  ata series..    
-0000c250: 2020 2020 5468 6573 6520 6e65 6172 6279      These nearby
-0000c260: 2070 6f69 6e74 7320 6172 6520 696d 706f   points are impo
-0000c270: 7274 616e 7420 7768 656e 2074 6865 206e  rtant when the n
-0000c280: 756d 6265 7220 6f66 2064 6973 6372 6574  umber of discret
-0000c290: 697a 6174 696f 6e0a 2020 2020 2020 2020  ization.        
-0000c2a0: 706f 696e 7473 2069 7320 6c6f 772c 206f  points is low, o
-0000c2b0: 7220 7468 6520 7363 616c 6520 6973 206c  r the scale is l
-0000c2c0: 6f67 6172 6974 686d 2e0a 0a20 2020 2020  ogarithm...     
-0000c2d0: 2020 204e 4f54 453a 2069 7420 776f 756c     NOTE: it woul
-0000c2e0: 6420 6265 2065 6173 6965 7220 746f 206a  d be easier to j
-0000c2f0: 7573 7420 6164 6420 6578 636c 7573 696f  ust add exclusio
-0000c300: 6e20 706f 696e 7473 2074 6f20 7468 650a  n points to the.
-0000c310: 2020 2020 2020 2020 6469 7363 7265 7469          discreti
-0000c320: 7a65 6420 646f 6d61 696e 2062 6566 6f72  zed domain befor
-0000c330: 6520 6576 616c 7561 7469 6f6e 2c20 7468  e evaluation, th
-0000c340: 656e 2061 6674 6572 2065 7661 6c75 6174  en after evaluat
-0000c350: 696f 6e20 6164 6420 4e61 4e0a 2020 2020  ion add NaN.    
-0000c360: 2020 2020 746f 2074 6865 2065 7863 6c75      to the exclu
-0000c370: 7369 6f6e 2070 6f69 6e74 732e 2042 7574  sion points. But
-0000c380: 2074 6861 7427 7320 6f6e 6c79 2077 6f72   that's only wor
-0000c390: 6b20 7769 7468 2061 6461 7074 6976 653d  k with adaptive=
-0000c3a0: 4661 6c73 652e 0a20 2020 2020 2020 2054  False..        T
-0000c3b0: 6865 2066 6f6c 6c6f 7769 6e67 2061 7070  he following app
-0000c3c0: 726f 6163 6820 776f 726b 2065 7665 6e20  roach work even 
-0000c3d0: 7769 7468 2061 6461 7074 6976 653d 5472  with adaptive=Tr
-0000c3e0: 7565 2e0a 2020 2020 2020 2020 2222 220a  ue..        """.
-0000c3f0: 2020 2020 2020 2020 6966 206c 656e 2873          if len(s
-0000c400: 656c 662e 6578 636c 7564 6529 203d 3d20  elf.exclude) == 
-0000c410: 303a 0a20 2020 2020 2020 2020 2020 2072  0:.            r
-0000c420: 6574 7572 6e20 706f 696e 7473 0a0a 2020  eturn points..  
-0000c430: 2020 2020 2020 6e70 203d 2069 6d70 6f72        np = impor
-0000c440: 745f 6d6f 6475 6c65 2822 6e75 6d70 7922  t_module("numpy"
-0000c450: 290a 2020 2020 2020 2020 706f 696e 7473  ).        points
-0000c460: 203d 206c 6973 7428 706f 696e 7473 290a   = list(points).
-0000c470: 2020 2020 2020 2020 6e20 3d20 6c65 6e28          n = len(
-0000c480: 706f 696e 7473 290a 2020 2020 2020 2020  points).        
-0000c490: 2320 696e 6465 7820 6f66 2074 6865 2078  # index of the x
-0000c4a0: 2d63 6f6f 7264 696e 6174 6520 2866 6f72  -coordinate (for
-0000c4b0: 2032 6420 706c 6f74 7329 206f 7220 7061   2d plots) or pa
-0000c4c0: 7261 6d65 7465 7220 2866 6f72 2032 642f  rameter (for 2d/
-0000c4d0: 3364 0a20 2020 2020 2020 2023 2070 6172  3d.        # par
-0000c4e0: 616d 6574 7269 6320 706c 6f74 7329 0a20  ametric plots). 
-0000c4f0: 2020 2020 2020 206b 203d 206e 202d 2031         k = n - 1
-0000c500: 0a20 2020 2020 2020 2069 6620 6e20 3d3d  .        if n ==
-0000c510: 2032 3a0a 2020 2020 2020 2020 2020 2020   2:.            
-0000c520: 6b20 3d20 300a 2020 2020 2020 2020 2320  k = 0.        # 
-0000c530: 696e 6465 6365 7320 6f66 2074 6865 206f  indeces of the o
-0000c540: 7468 6572 2063 6f6f 7264 696e 6174 6573  ther coordinates
-0000c550: 0a20 2020 2020 2020 206a 5f69 6e64 6563  .        j_indec
-0000c560: 6573 203d 2073 6f72 7465 6428 7365 7428  es = sorted(set(
-0000c570: 7261 6e67 6528 6e29 292e 6469 6666 6572  range(n)).differ
-0000c580: 656e 6365 285b 6b5d 2929 0a20 2020 2020  ence([k])).     
-0000c590: 2020 2023 2054 4f44 4f3a 2066 6f72 206e     # TODO: for n
-0000c5a0: 6f77 2c20 4920 6173 7375 6d65 2074 6861  ow, I assume tha
-0000c5b0: 7420 6e75 6d70 7920 6675 6e63 7469 6f6e  t numpy function
-0000c5c0: 7320 6172 6520 676f 696e 6720 746f 2073  s are going to s
-0000c5d0: 7563 6365 6564 0a20 2020 2020 2020 2066  ucceed.        f
-0000c5e0: 756e 6373 203d 205b 665b 305d 2066 6f72  uncs = [f[0] for
-0000c5f0: 2066 2069 6e20 7365 6c66 2e5f 6675 6e63   f in self._func
-0000c600: 7469 6f6e 735d 0a0a 2020 2020 2020 2020  tions]..        
-0000c610: 666f 7220 6520 696e 2073 656c 662e 6578  for e in self.ex
-0000c620: 636c 7564 653a 0a20 2020 2020 2020 2020  clude:.         
-0000c630: 2020 2072 6573 203d 2070 6f69 6e74 735b     res = points[
-0000c640: 6b5d 202d 2065 203e 3d20 300a 2020 2020  k] - e >= 0.    
-0000c650: 2020 2020 2020 2020 2320 6966 2072 6573          # if res
-0000c660: 2063 6f6e 7461 696e 7320 626f 7468 2054   contains both T
-0000c670: 7275 6520 616e 6420 4661 6c73 652c 2069  rue and False, i
-0000c680: 652c 2069 6620 6520 6973 2066 6f75 6e64  e, if e is found
-0000c690: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000c6a0: 616e 7928 7265 7329 2061 6e64 2061 6e79  any(res) and any
-0000c6b0: 287e 7265 7329 3a0a 2020 2020 2020 2020  (~res):.        
-0000c6c0: 2020 2020 2020 2020 6964 7820 3d20 6e70          idx = np
-0000c6d0: 2e6e 616e 6172 676d 6178 2872 6573 290a  .nanargmax(res).
-0000c6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c6f0: 2320 7365 6c65 6374 2074 6865 2070 7265  # select the pre
-0000c700: 7669 6f75 7320 706f 696e 7420 7769 7468  vious point with
-0000c710: 2072 6573 7065 6374 2074 6f20 650a 2020   respect to e.  
-0000c720: 2020 2020 2020 2020 2020 2020 2020 6964                id
-0000c730: 7820 2d3d 2031 0a20 2020 2020 2020 2020  x -= 1.         
-0000c740: 2020 2020 2020 2023 2054 4f44 4f3a 2077         # TODO: w
-0000c750: 6861 7420 6966 2070 6f69 6e74 735b 6b5d  hat if points[k]
-0000c760: 5b69 6478 5d3d 3d65 206f 7220 706f 696e  [idx]==e or poin
-0000c770: 7473 5b6b 5d5b 6964 782b 315d 3d3d 653f  ts[k][idx+1]==e?
-0000c780: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000c790: 2020 6966 2069 6478 203e 2030 2061 6e64    if idx > 0 and
-0000c7a0: 2069 6478 203c 206c 656e 2870 6f69 6e74   idx < len(point
-0000c7b0: 735b 6b5d 2920 2d20 313a 0a20 2020 2020  s[k]) - 1:.     
-0000c7c0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-0000c7d0: 656c 7461 5f70 7265 7620 3d20 6162 7328  elta_prev = abs(
-0000c7e0: 6520 2d20 706f 696e 7473 5b6b 5d5b 6964  e - points[k][id
-0000c7f0: 785d 290a 2020 2020 2020 2020 2020 2020  x]).            
-0000c800: 2020 2020 2020 2020 6465 6c74 615f 706f          delta_po
-0000c810: 7374 203d 2061 6273 2865 202d 2070 6f69  st = abs(e - poi
-0000c820: 6e74 735b 6b5d 5b69 6478 202b 2031 5d29  nts[k][idx + 1])
-0000c830: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c840: 2020 2020 2064 656c 7461 203d 206d 696e       delta = min
-0000c850: 2864 656c 7461 5f70 7265 762c 2064 656c  (delta_prev, del
-0000c860: 7461 5f70 6f73 7429 202f 2031 3030 0a20  ta_post) / 100. 
-0000c870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c880: 2020 2070 7265 7620 3d20 6520 2d20 6465     prev = e - de
-0000c890: 6c74 610a 2020 2020 2020 2020 2020 2020  lta.            
-0000c8a0: 2020 2020 2020 2020 706f 7374 203d 2065          post = e
-0000c8b0: 202b 2064 656c 7461 0a0a 2020 2020 2020   + delta..      
-0000c8c0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000c8d0: 6164 6420 706f 696e 7473 2074 6f20 7468  add points to th
-0000c8e0: 6520 782d 636f 6f72 6420 6f72 2074 6865  e x-coord or the
-0000c8f0: 2070 6172 616d 6574 6572 0a20 2020 2020   parameter.     
-0000c900: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000c910: 6f69 6e74 735b 6b5d 203d 206e 702e 636f  oints[k] = np.co
-0000c920: 6e63 6174 656e 6174 6528 0a20 2020 2020  ncatenate(.     
-0000c930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c940: 2020 2028 706f 696e 7473 5b6b 5d5b 3a69     (points[k][:i
-0000c950: 6478 5d2c 205b 7072 6576 2c20 652c 2070  dx], [prev, e, p
-0000c960: 6f73 745d 2c20 706f 696e 7473 5b6b 5d5b  ost], points[k][
-0000c970: 6964 782b 313a 5d29 290a 0a20 2020 2020  idx+1:]))..     
-0000c980: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000c990: 2061 6464 2070 6f69 6e74 7320 746f 2074   add points to t
-0000c9a0: 6865 206f 7468 6572 2063 6f6f 7264 696e  he other coordin
-0000c9b0: 6174 6573 0a20 2020 2020 2020 2020 2020  ates.           
-0000c9c0: 2020 2020 2020 2020 2063 203d 2030 0a20           c = 0. 
-0000c9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c9e0: 2020 2066 6f72 206a 2069 6e20 6a5f 696e     for j in j_in
-0000c9f0: 6465 6365 733a 0a20 2020 2020 2020 2020  deces:.         
-0000ca00: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-0000ca10: 616c 7565 7320 3d20 6675 6e63 735b 635d  alues = funcs[c]
-0000ca20: 286e 702e 6172 7261 7928 5b70 7265 762c  (np.array([prev,
-0000ca30: 2070 6f73 745d 2929 0a20 2020 2020 2020   post])).       
-0000ca40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ca50: 2063 202b 3d20 310a 2020 2020 2020 2020   c += 1.        
-0000ca60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ca70: 706f 696e 7473 5b6a 5d20 3d20 6e70 2e63  points[j] = np.c
-0000ca80: 6f6e 6361 7465 6e61 7465 280a 2020 2020  oncatenate(.    
-0000ca90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000caa0: 2020 2020 2020 2020 2870 6f69 6e74 735b          (points[
-0000cab0: 6a5d 5b3a 6964 785d 2c20 5b76 616c 7565  j][:idx], [value
-0000cac0: 735b 305d 2c20 6e70 2e6e 616e 2c20 7661  s[0], np.nan, va
-0000cad0: 6c75 6573 5b31 5d5d 2c20 706f 696e 7473  lues[1]], points
-0000cae0: 5b6a 5d5b 6964 782b 313a 5d29 290a 2020  [j][idx+1:])).  
-0000caf0: 2020 2020 2020 7265 7475 726e 2070 6f69        return poi
-0000cb00: 6e74 730a 0a20 2020 2040 7072 6f70 6572  nts..    @proper
-0000cb10: 7479 0a20 2020 2064 6566 2076 6172 2873  ty.    def var(s
-0000cb20: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-0000cb30: 7475 726e 204e 6f6e 6520 6966 206e 6f74  turn None if not
-0000cb40: 2073 656c 662e 7261 6e67 6573 2065 6c73   self.ranges els
-0000cb50: 6520 7365 6c66 2e72 616e 6765 735b 305d  e self.ranges[0]
-0000cb60: 5b30 5d0a 0a20 2020 2040 7072 6f70 6572  [0]..    @proper
-0000cb70: 7479 0a20 2020 2064 6566 2073 7461 7274  ty.    def start
-0000cb80: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000cb90: 6966 206e 6f74 2073 656c 662e 7261 6e67  if not self.rang
-0000cba0: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
-0000cbb0: 7265 7475 726e 204e 6f6e 650a 2020 2020  return None.    
-0000cbc0: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-0000cbd0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0000cbe0: 2e5f 6361 7374 2873 656c 662e 7261 6e67  ._cast(self.rang
-0000cbf0: 6573 5b30 5d5b 315d 290a 2020 2020 2020  es[0][1]).      
-0000cc00: 2020 6578 6365 7074 2045 7863 6570 7469    except Excepti
-0000cc10: 6f6e 3a0a 2020 2020 2020 2020 2020 2020  on:.            
-0000cc20: 7265 7475 726e 2073 656c 662e 7261 6e67  return self.rang
-0000cc30: 6573 5b30 5d5b 315d 0a0a 2020 2020 4070  es[0][1]..    @p
-0000cc40: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-0000cc50: 656e 6428 7365 6c66 293a 0a20 2020 2020  end(self):.     
-0000cc60: 2020 2069 6620 6e6f 7420 7365 6c66 2e72     if not self.r
-0000cc70: 616e 6765 733a 0a20 2020 2020 2020 2020  anges:.         
-0000cc80: 2020 2072 6574 7572 6e20 4e6f 6e65 0a20     return None. 
-0000cc90: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-0000cca0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0000ccb0: 656c 662e 5f63 6173 7428 7365 6c66 2e72  elf._cast(self.r
-0000ccc0: 616e 6765 735b 305d 5b32 5d29 0a20 2020  anges[0][2]).   
-0000ccd0: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
-0000cce0: 7074 696f 6e3a 0a20 2020 2020 2020 2020  ption:.         
-0000ccf0: 2020 2072 6574 7572 6e20 7365 6c66 2e72     return self.r
-0000cd00: 616e 6765 735b 305d 5b32 5d0a 0a20 2020  anges[0][2]..   
-0000cd10: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-0000cd20: 6566 206c 696e 655f 636f 6c6f 7228 7365  ef line_color(se
-0000cd30: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-0000cd40: 7572 6e20 7365 6c66 2e5f 6c69 6e65 5f63  urn self._line_c
-0000cd50: 6f6c 6f72 0a0a 2020 2020 406c 696e 655f  olor..    @line_
-0000cd60: 636f 6c6f 722e 7365 7474 6572 0a20 2020  color.setter.   
-0000cd70: 2064 6566 206c 696e 655f 636f 6c6f 7228   def line_color(
-0000cd80: 7365 6c66 2c20 7661 6c29 3a0a 2020 2020  self, val):.    
-0000cd90: 2020 2020 7365 6c66 2e5f 6c69 6e65 5f73      self._line_s
-0000cda0: 7572 6661 6365 5f63 6f6c 6f72 2822 5f6c  urface_color("_l
-0000cdb0: 696e 655f 636f 6c6f 7222 2c20 7661 6c29  ine_color", val)
-0000cdc0: 0a0a 0a63 6c61 7373 204c 6973 7432 4453  ...class List2DS
-0000cdd0: 6572 6965 7328 4c69 6e65 3244 4261 7365  eries(Line2DBase
-0000cde0: 5365 7269 6573 293a 0a20 2020 2022 2222  Series):.    """
-0000cdf0: 5265 7072 6573 656e 7461 7469 6f6e 2066  Representation f
-0000ce00: 6f72 2061 206c 696e 6520 636f 6e73 6973  or a line consis
-0000ce10: 7469 6e67 206f 6620 6c69 7374 206f 6620  ting of list of 
-0000ce20: 706f 696e 7473 2e22 2222 0a0a 2020 2020  points."""..    
-0000ce30: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-0000ce40: 662c 206c 6973 745f 782c 206c 6973 745f  f, list_x, list_
-0000ce50: 792c 206c 6162 656c 3d22 222c 202a 2a6b  y, label="", **k
-0000ce60: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
-0000ce70: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-0000ce80: 286c 6162 656c 3d6c 6162 656c 2c20 2a2a  (label=label, **
-0000ce90: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
-0000cea0: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
-0000ceb0: 6c65 2827 6e75 6d70 7927 290a 2020 2020  le('numpy').    
-0000cec0: 2020 2020 6966 206c 656e 286c 6973 745f      if len(list_
-0000ced0: 7829 2021 3d20 6c65 6e28 6c69 7374 5f79  x) != len(list_y
-0000cee0: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-0000cef0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-0000cf00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cf10: 2022 5468 6520 7477 6f20 6c69 7374 7320   "The two lists 
-0000cf20: 6f66 2063 6f6f 7264 696e 6174 6573 206d  of coordinates m
-0000cf30: 7573 7420 6861 7665 2074 6865 2073 616d  ust have the sam
-0000cf40: 6520 220a 2020 2020 2020 2020 2020 2020  e ".            
-0000cf50: 2020 2020 226e 756d 6265 7220 6f66 2065      "number of e
-0000cf60: 6c65 6d65 6e74 732e 5c6e 5265 6365 6976  lements.\nReceiv
-0000cf70: 6564 3a20 6c65 6e28 6c69 7374 5f78 2920  ed: len(list_x) 
-0000cf80: 3d20 2573 2022 0a20 2020 2020 2020 2020  = %s ".         
-0000cf90: 2020 2020 2020 2022 616e 6420 6c65 6e28         "and len(
-0000cfa0: 6c69 7374 5f79 2920 3d20 2573 2220 2520  list_y) = %s" % 
-0000cfb0: 286c 656e 286c 6973 745f 7829 2c20 6c65  (len(list_x), le
-0000cfc0: 6e28 6c69 7374 5f79 2929 0a20 2020 2020  n(list_y)).     
-0000cfd0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-0000cfe0: 2073 656c 662e 5f62 6c6f 636b 5f6c 616d   self._block_lam
-0000cff0: 6264 615f 6675 6e63 7469 6f6e 7328 6c69  bda_functions(li
-0000d000: 7374 5f78 2c20 6c69 7374 5f79 290a 2020  st_x, list_y).  
-0000d010: 2020 2020 2020 6368 6563 6b20 3d20 6c61        check = la
-0000d020: 6d62 6461 206c 3a20 5b69 7369 6e73 7461  mbda l: [isinsta
-0000d030: 6e63 6528 742c 2045 7870 7229 2061 6e64  nce(t, Expr) and
-0000d040: 2028 6e6f 7420 742e 6973 5f6e 756d 6265   (not t.is_numbe
-0000d050: 7229 2066 6f72 2074 2069 6e20 6c5d 0a20  r) for t in l]. 
-0000d060: 2020 2020 2020 2069 6620 616e 7928 6368         if any(ch
-0000d070: 6563 6b28 6c69 7374 5f78 2920 2b20 6368  eck(list_x) + ch
-0000d080: 6563 6b28 6c69 7374 5f79 2929 206f 7220  eck(list_y)) or 
-0000d090: 7365 6c66 2e70 6172 616d 733a 0a20 2020  self.params:.   
-0000d0a0: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-0000d0b0: 7365 6c66 2e70 6172 616d 733a 0a20 2020  self.params:.   
-0000d0c0: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-0000d0d0: 7365 2056 616c 7565 4572 726f 7228 0a20  se ValueError(. 
-0000d0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d0f0: 2020 2022 536f 6d65 206f 7220 616c 6c20     "Some or all 
-0000d100: 656c 656d 656e 7473 206f 6620 7468 6520  elements of the 
-0000d110: 7072 6f76 6964 6564 206c 6973 7473 2022  provided lists "
-0000d120: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d130: 2020 2020 2022 6172 6520 7379 6d62 6f6c       "are symbol
-0000d140: 6963 2065 7870 7265 7373 696f 6e73 2c20  ic expressions, 
-0000d150: 6275 7420 7468 6520 6060 7061 7261 6d73  but the ``params
-0000d160: 6060 2064 6963 7469 6f6e 6172 7920 220a  `` dictionary ".
-0000d170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d180: 2020 2020 2277 6173 206e 6f74 2070 726f      "was not pro
-0000d190: 7669 6465 643a 2074 686f 7365 2065 6c65  vided: those ele
-0000d1a0: 6d65 6e74 7320 6361 6e27 7420 6265 2065  ments can't be e
-0000d1b0: 7661 6c75 6174 6564 2e22 290a 2020 2020  valuated.").    
-0000d1c0: 2020 2020 2020 2020 7365 6c66 2e6c 6973          self.lis
-0000d1d0: 745f 7820 3d20 5475 706c 6528 2a6c 6973  t_x = Tuple(*lis
-0000d1e0: 745f 7829 0a20 2020 2020 2020 2020 2020  t_x).           
-0000d1f0: 2073 656c 662e 6c69 7374 5f79 203d 2054   self.list_y = T
-0000d200: 7570 6c65 282a 6c69 7374 5f79 290a 2020  uple(*list_y).  
-0000d210: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000d220: 2020 2020 2020 2020 7365 6c66 2e6c 6973          self.lis
-0000d230: 745f 7820 3d20 6e70 2e61 7272 6179 286c  t_x = np.array(l
-0000d240: 6973 745f 782c 2064 7479 7065 3d6e 702e  ist_x, dtype=np.
-0000d250: 666c 6f61 7436 3429 0a20 2020 2020 2020  float64).       
-0000d260: 2020 2020 2073 656c 662e 6c69 7374 5f79       self.list_y
-0000d270: 203d 206e 702e 6172 7261 7928 6c69 7374   = np.array(list
-0000d280: 5f79 2c20 6474 7970 653d 6e70 2e66 6c6f  _y, dtype=np.flo
-0000d290: 6174 3634 290a 0a20 2020 2020 2020 2073  at64)..        s
-0000d2a0: 656c 662e 5f65 7870 7220 3d20 2873 656c  elf._expr = (sel
-0000d2b0: 662e 6c69 7374 5f78 2c20 7365 6c66 2e6c  f.list_x, self.l
-0000d2c0: 6973 745f 7929 0a20 2020 2020 2020 2069  ist_y).        i
-0000d2d0: 6620 6e6f 7420 616e 7928 6973 696e 7374  f not any(isinst
-0000d2e0: 616e 6365 2874 2c20 6e70 2e6e 6461 7272  ance(t, np.ndarr
-0000d2f0: 6179 2920 666f 7220 7420 696e 205b 7365  ay) for t in [se
-0000d300: 6c66 2e6c 6973 745f 782c 2073 656c 662e  lf.list_x, self.
-0000d310: 6c69 7374 5f79 5d29 3a0a 2020 2020 2020  list_y]):.      
-0000d320: 2020 2020 2020 7365 6c66 2e5f 6368 6563        self._chec
-0000d330: 6b5f 6673 2829 0a0a 2020 2020 2020 2020  k_fs()..        
-0000d340: 6966 2073 656c 662e 7573 655f 636d 2061  if self.use_cm a
-0000d350: 6e64 2073 656c 662e 636f 6c6f 725f 6675  nd self.color_fu
-0000d360: 6e63 3a0a 2020 2020 2020 2020 2020 2020  nc:.            
-0000d370: 7365 6c66 2e69 735f 7061 7261 6d65 7472  self.is_parametr
-0000d380: 6963 203d 2054 7275 650a 2020 2020 2020  ic = True.      
-0000d390: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-0000d3a0: 6e63 6528 7365 6c66 2e63 6f6c 6f72 5f66  nce(self.color_f
-0000d3b0: 756e 632c 2045 7870 7229 3a0a 2020 2020  unc, Expr):.    
-0000d3c0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-0000d3d0: 6520 5479 7065 4572 726f 7228 0a20 2020  e TypeError(.   
-0000d3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d3f0: 2022 2573 2064 6f6e 2774 2073 7570 706f   "%s don't suppo
-0000d400: 7274 2073 796d 626f 6c69 6320 2220 2520  rt symbolic " % 
-0000d410: 7365 6c66 2e5f 5f63 6c61 7373 5f5f 2e5f  self.__class__._
-0000d420: 5f6e 616d 655f 5f20 2b0a 2020 2020 2020  _name__ +.      
-0000d430: 2020 2020 2020 2020 2020 2020 2020 2265                "e
-0000d440: 7870 7265 7373 696f 6e20 666f 7220 6063  xpression for `c
-0000d450: 6f6c 6f72 5f66 756e 6360 2e22 290a 0a20  olor_func`.").. 
-0000d460: 2020 2064 6566 205f 5f73 7472 5f5f 2873     def __str__(s
-0000d470: 656c 6629 3a0a 2020 2020 2020 2020 7072  elf):.        pr
-0000d480: 6520 3d20 2232 4422 2069 6620 7365 6c66  e = "2D" if self
-0000d490: 2e69 735f 3244 6c69 6e65 2065 6c73 6520  .is_2Dline else 
-0000d4a0: 2233 4422 0a20 2020 2020 2020 2072 6574  "3D".        ret
-0000d4b0: 7572 6e20 7072 6520 2b20 2220 6c69 7374  urn pre + " list
-0000d4c0: 2070 6c6f 7422 0a0a 2020 2020 6465 6620   plot"..    def 
-0000d4d0: 5f67 6574 5f64 6174 615f 6865 6c70 6572  _get_data_helper
-0000d4e0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000d4f0: 2222 2252 6574 7572 6e73 2063 6f6f 7264  """Returns coord
-0000d500: 696e 6174 6573 2074 6861 7420 6e65 6564  inates that need
-0000d510: 7320 746f 2062 6520 706f 7374 7072 6f63  s to be postproc
-0000d520: 6573 7365 642e 2222 220a 2020 2020 2020  essed.""".      
-0000d530: 2020 6c78 2c20 6c79 203d 2073 656c 662e    lx, ly = self.
-0000d540: 6c69 7374 5f78 2c20 7365 6c66 2e6c 6973  list_x, self.lis
-0000d550: 745f 790a 0a20 2020 2020 2020 2069 6620  t_y..        if 
-0000d560: 6e6f 7420 7365 6c66 2e69 735f 696e 7465  not self.is_inte
-0000d570: 7261 6374 6976 653a 0a20 2020 2020 2020  ractive:.       
-0000d580: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0000d590: 2e5f 6576 616c 5f63 6f6c 6f72 5f66 756e  ._eval_color_fun
-0000d5a0: 635f 616e 645f 7265 7475 726e 286c 782c  c_and_return(lx,
-0000d5b0: 206c 7929 0a0a 2020 2020 2020 2020 6e70   ly)..        np
-0000d5c0: 203d 2069 6d70 6f72 745f 6d6f 6475 6c65   = import_module
-0000d5d0: 2827 6e75 6d70 7927 290a 2020 2020 2020  ('numpy').      
-0000d5e0: 2020 6c78 203d 206e 702e 6172 7261 7928    lx = np.array(
-0000d5f0: 5b74 2e65 7661 6c66 2873 7562 733d 7365  [t.evalf(subs=se
-0000d600: 6c66 2e70 6172 616d 7329 2066 6f72 2074  lf.params) for t
-0000d610: 2069 6e20 6c78 5d2c 2064 7479 7065 3d66   in lx], dtype=f
-0000d620: 6c6f 6174 290a 2020 2020 2020 2020 6c79  loat).        ly
-0000d630: 203d 206e 702e 6172 7261 7928 5b74 2e65   = np.array([t.e
-0000d640: 7661 6c66 2873 7562 733d 7365 6c66 2e70  valf(subs=self.p
-0000d650: 6172 616d 7329 2066 6f72 2074 2069 6e20  arams) for t in 
-0000d660: 6c79 5d2c 2064 7479 7065 3d66 6c6f 6174  ly], dtype=float
-0000d670: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-0000d680: 2073 656c 662e 5f65 7661 6c5f 636f 6c6f   self._eval_colo
-0000d690: 725f 6675 6e63 5f61 6e64 5f72 6574 7572  r_func_and_retur
-0000d6a0: 6e28 6c78 2c20 6c79 290a 0a20 2020 2064  n(lx, ly)..    d
-0000d6b0: 6566 205f 6576 616c 5f63 6f6c 6f72 5f66  ef _eval_color_f
-0000d6c0: 756e 635f 616e 645f 7265 7475 726e 2873  unc_and_return(s
-0000d6d0: 656c 662c 202a 6461 7461 293a 0a20 2020  elf, *data):.   
-0000d6e0: 2020 2020 2069 6620 7365 6c66 2e75 7365       if self.use
-0000d6f0: 5f63 6d20 616e 6420 6361 6c6c 6162 6c65  _cm and callable
-0000d700: 2873 656c 662e 636f 6c6f 725f 6675 6e63  (self.color_func
-0000d710: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-0000d720: 6574 7572 6e20 5b2a 6461 7461 2c20 7365  eturn [*data, se
-0000d730: 6c66 2e65 7661 6c5f 636f 6c6f 725f 6675  lf.eval_color_fu
-0000d740: 6e63 282a 6461 7461 295d 0a20 2020 2020  nc(*data)].     
-0000d750: 2020 2072 6574 7572 6e20 6461 7461 0a0a     return data..
-0000d760: 0a63 6c61 7373 204c 6973 7433 4453 6572  .class List3DSer
-0000d770: 6965 7328 4c69 7374 3244 5365 7269 6573  ies(List2DSeries
-0000d780: 293a 0a20 2020 2069 735f 3244 6c69 6e65  ):.    is_2Dline
-0000d790: 203d 2046 616c 7365 0a20 2020 2069 735f   = False.    is_
-0000d7a0: 3344 6c69 6e65 203d 2054 7275 650a 0a20  3Dline = True.. 
-0000d7b0: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
-0000d7c0: 7365 6c66 2c20 6c69 7374 5f78 2c20 6c69  self, list_x, li
-0000d7d0: 7374 5f79 2c20 6c69 7374 5f7a 2c20 6c61  st_y, list_z, la
-0000d7e0: 6265 6c3d 2222 2c20 2a2a 6b77 6172 6773  bel="", **kwargs
-0000d7f0: 293a 0a20 2020 2020 2020 2023 2054 4f44  ):.        # TOD
-0000d800: 4f3a 2074 6869 7320 6361 6e20 6465 6669  O: this can defi
-0000d810: 6e69 7465 6c79 2062 6520 646f 6e65 2062  nitely be done b
-0000d820: 6574 7465 720a 2020 2020 2020 2020 7375  etter.        su
-0000d830: 7065 7228 292e 5f5f 696e 6974 5f5f 286c  per().__init__(l
-0000d840: 6973 745f 782c 206c 6973 745f 792c 206c  ist_x, list_y, l
-0000d850: 6162 656c 2c20 2a2a 6b77 6172 6773 290a  abel, **kwargs).
-0000d860: 2020 2020 2020 2020 6e70 203d 2069 6d70          np = imp
-0000d870: 6f72 745f 6d6f 6475 6c65 2827 6e75 6d70  ort_module('nump
-0000d880: 7927 290a 2020 2020 2020 2020 6966 206c  y').        if l
-0000d890: 656e 286c 6973 745f 7a29 2021 3d20 6c65  en(list_z) != le
-0000d8a0: 6e28 6c69 7374 5f78 293a 0a20 2020 2020  n(list_x):.     
-0000d8b0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-0000d8c0: 7565 4572 726f 7228 0a20 2020 2020 2020  ueError(.       
-0000d8d0: 2020 2020 2020 2020 2022 5468 6520 7468           "The th
-0000d8e0: 7265 6520 6c69 7374 7320 6f66 2063 6f6f  ree lists of coo
-0000d8f0: 7264 696e 6174 6573 206d 7573 7420 6861  rdinates must ha
-0000d900: 7665 2074 6865 2073 616d 6520 220a 2020  ve the same ".  
-0000d910: 2020 2020 2020 2020 2020 2020 2020 226e                "n
-0000d920: 756d 6265 7220 6f66 2065 6c65 6d65 6e74  umber of element
-0000d930: 732e 5c6e 220a 2020 2020 2020 2020 2020  s.\n".          
-0000d940: 2020 2020 2020 2252 6563 6569 7665 643a        "Received:
-0000d950: 206c 656e 286c 6973 745f 7829 203d 206c   len(list_x) = l
-0000d960: 656e 286c 6973 745f 7929 203d 207b 7d20  en(list_y) = {} 
-0000d970: 222e 666f 726d 6174 286c 656e 286c 6973  ".format(len(lis
-0000d980: 745f 7829 2920 2b0a 2020 2020 2020 2020  t_x)) +.        
-0000d990: 2020 2020 2020 2020 2261 6e64 206c 656e          "and len
-0000d9a0: 286c 6973 745f 7a29 203d 207b 7d22 2e66  (list_z) = {}".f
-0000d9b0: 6f72 6d61 7428 6c65 6e28 6c69 7374 5f7a  ormat(len(list_z
-0000d9c0: 2929 0a20 2020 2020 2020 2020 2020 2029  )).            )
-0000d9d0: 0a20 2020 2020 2020 2073 656c 662e 5f62  .        self._b
-0000d9e0: 6c6f 636b 5f6c 616d 6264 615f 6675 6e63  lock_lambda_func
-0000d9f0: 7469 6f6e 7328 6c69 7374 5f7a 290a 2020  tions(list_z).  
-0000da00: 2020 2020 2020 6368 6563 6b20 3d20 6c61        check = la
-0000da10: 6d62 6461 206c 3a20 5b69 7369 6e73 7461  mbda l: [isinsta
-0000da20: 6e63 6528 742c 2045 7870 7229 2061 6e64  nce(t, Expr) and
-0000da30: 2028 6e6f 7420 742e 6973 5f6e 756d 6265   (not t.is_numbe
-0000da40: 7229 2066 6f72 2074 2069 6e20 6c5d 0a20  r) for t in l]. 
-0000da50: 2020 2020 2020 2069 6620 616e 7928 6368         if any(ch
-0000da60: 6563 6b28 6c69 7374 5f7a 2929 3a0a 2020  eck(list_z)):.  
-0000da70: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
-0000da80: 2073 656c 662e 7061 7261 6d73 3a0a 2020   self.params:.  
-0000da90: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-0000daa0: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
-0000dab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dac0: 2020 2020 2253 6f6d 6520 6f72 2061 6c6c      "Some or all
-0000dad0: 2065 6c65 6d65 6e74 7320 6f66 2074 6865   elements of the
-0000dae0: 2070 726f 7669 6465 6420 6c69 7374 7320   provided lists 
-0000daf0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-0000db00: 2020 2020 2020 2261 7265 2073 796d 626f        "are symbo
-0000db10: 6c69 6320 6578 7072 6573 7369 6f6e 732c  lic expressions,
-0000db20: 2062 7574 2074 6865 2060 6070 6172 616d   but the ``param
-0000db30: 7360 6020 6469 6374 696f 6e61 7279 2022  s`` dictionary "
-0000db40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000db50: 2020 2020 2022 7761 7320 6e6f 7420 7072       "was not pr
-0000db60: 6f76 6964 6564 3a20 7468 6f73 6520 656c  ovided: those el
-0000db70: 656d 656e 7473 2063 616e 2774 2062 6520  ements can't be 
-0000db80: 6576 616c 7561 7465 642e 2229 0a20 2020  evaluated.").   
-0000db90: 2020 2020 2020 2020 2073 656c 662e 6c69           self.li
-0000dba0: 7374 5f7a 203d 2054 7570 6c65 282a 6c69  st_z = Tuple(*li
-0000dbb0: 7374 5f7a 290a 2020 2020 2020 2020 2020  st_z).          
-0000dbc0: 2020 7365 6c66 2e5f 6368 6563 6b5f 6673    self._check_fs
-0000dbd0: 2829 0a20 2020 2020 2020 2065 6c73 653a  ().        else:
-0000dbe0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0000dbf0: 662e 6c69 7374 5f7a 203d 206e 702e 6172  f.list_z = np.ar
-0000dc00: 7261 7928 6c69 7374 5f7a 2c20 6474 7970  ray(list_z, dtyp
-0000dc10: 653d 6e70 2e66 6c6f 6174 3634 290a 0a20  e=np.float64).. 
-0000dc20: 2020 2020 2020 2073 656c 662e 5f65 7870         self._exp
-0000dc30: 7220 3d20 2873 656c 662e 6c69 7374 5f78  r = (self.list_x
-0000dc40: 2c20 7365 6c66 2e6c 6973 745f 792c 2073  , self.list_y, s
-0000dc50: 656c 662e 6c69 7374 5f7a 290a 0a20 2020  elf.list_z)..   
-0000dc60: 2064 6566 205f 6765 745f 6461 7461 5f68   def _get_data_h
-0000dc70: 656c 7065 7228 7365 6c66 293a 0a20 2020  elper(self):.   
-0000dc80: 2020 2020 2022 2222 5265 7475 726e 7320       """Returns 
-0000dc90: 636f 6f72 6469 6e61 7465 7320 7468 6174  coordinates that
-0000dca0: 206e 6565 6473 2074 6f20 6265 2070 6f73   needs to be pos
-0000dcb0: 7470 726f 6365 7373 6564 2e22 2222 0a20  tprocessed.""". 
-0000dcc0: 2020 2020 2020 206c 782c 206c 792c 206c         lx, ly, l
-0000dcd0: 7a20 3d20 7365 6c66 2e6c 6973 745f 782c  z = self.list_x,
-0000dce0: 2073 656c 662e 6c69 7374 5f79 2c20 7365   self.list_y, se
-0000dcf0: 6c66 2e6c 6973 745f 7a0a 0a20 2020 2020  lf.list_z..     
-0000dd00: 2020 2069 6620 6e6f 7420 7365 6c66 2e69     if not self.i
-0000dd10: 735f 696e 7465 7261 6374 6976 653a 0a20  s_interactive:. 
-0000dd20: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000dd30: 6e20 7365 6c66 2e5f 6576 616c 5f63 6f6c  n self._eval_col
-0000dd40: 6f72 5f66 756e 635f 616e 645f 7265 7475  or_func_and_retu
-0000dd50: 726e 286c 782c 206c 792c 206c 7a29 0a0a  rn(lx, ly, lz)..
-0000dd60: 2020 2020 2020 2020 6e70 203d 2069 6d70          np = imp
-0000dd70: 6f72 745f 6d6f 6475 6c65 2827 6e75 6d70  ort_module('nump
-0000dd80: 7927 290a 2020 2020 2020 2020 6c78 203d  y').        lx =
-0000dd90: 206e 702e 6172 7261 7928 5b74 2e65 7661   np.array([t.eva
-0000dda0: 6c66 2873 7562 733d 7365 6c66 2e70 6172  lf(subs=self.par
-0000ddb0: 616d 7329 2066 6f72 2074 2069 6e20 6c78  ams) for t in lx
-0000ddc0: 5d2c 2064 7479 7065 3d66 6c6f 6174 290a  ], dtype=float).
-0000ddd0: 2020 2020 2020 2020 6c79 203d 206e 702e          ly = np.
-0000dde0: 6172 7261 7928 5b74 2e65 7661 6c66 2873  array([t.evalf(s
-0000ddf0: 7562 733d 7365 6c66 2e70 6172 616d 7329  ubs=self.params)
-0000de00: 2066 6f72 2074 2069 6e20 6c79 5d2c 2064   for t in ly], d
-0000de10: 7479 7065 3d66 6c6f 6174 290a 2020 2020  type=float).    
-0000de20: 2020 2020 6c7a 203d 206e 702e 6172 7261      lz = np.arra
-0000de30: 7928 5b74 2e65 7661 6c66 2873 7562 733d  y([t.evalf(subs=
-0000de40: 7365 6c66 2e70 6172 616d 7329 2066 6f72  self.params) for
-0000de50: 2074 2069 6e20 6c7a 5d2c 2064 7479 7065   t in lz], dtype
-0000de60: 3d66 6c6f 6174 290a 2020 2020 2020 2020  =float).        
-0000de70: 7265 7475 726e 2073 656c 662e 5f65 7661  return self._eva
-0000de80: 6c5f 636f 6c6f 725f 6675 6e63 5f61 6e64  l_color_func_and
-0000de90: 5f72 6574 7572 6e28 6c78 2c20 6c79 2c20  _return(lx, ly, 
-0000dea0: 6c7a 290a 0a0a 636c 6173 7320 4c69 6e65  lz)...class Line
-0000deb0: 4f76 6572 3144 5261 6e67 6553 6572 6965  Over1DRangeSerie
-0000dec0: 7328 0a20 2020 2043 6f6d 6d6f 6e41 6461  s(.    CommonAda
-0000ded0: 7074 6976 6545 7661 6c75 6174 696f 6e2c  ptiveEvaluation,
-0000dee0: 2043 6f6d 6d6f 6e55 6e69 666f 726d 4576   CommonUniformEv
-0000def0: 616c 7561 7469 6f6e 2c20 4c69 6e65 3244  aluation, Line2D
-0000df00: 4261 7365 5365 7269 6573 0a29 3a0a 2020  BaseSeries.):.  
-0000df10: 2020 2222 2252 6570 7265 7365 6e74 6174    """Representat
-0000df20: 696f 6e20 666f 7220 6120 6c69 6e65 2063  ion for a line c
-0000df30: 6f6e 7369 7374 696e 6720 6f66 2061 2053  onsisting of a S
-0000df40: 796d 5079 2065 7870 7265 7373 696f 6e20  ymPy expression 
-0000df50: 6f76 6572 2061 0a20 2020 2072 6561 6c20  over a.    real 
-0000df60: 7261 6e67 652e 2222 220a 0a20 2020 205f  range."""..    _
-0000df70: 616c 6c6f 7765 645f 6b65 7973 203d 205b  allowed_keys = [
-0000df80: 0a20 2020 2020 2020 2022 6162 7361 7267  .        "absarg
-0000df90: 222c 2022 6973 5f63 6f6d 706c 6578 222c  ", "is_complex",
-0000dfa0: 2022 6973 5f70 6f6c 6172 220a 2020 2020   "is_polar".    
-0000dfb0: 5d0a 0a20 2020 2064 6566 205f 5f6e 6577  ]..    def __new
-0000dfc0: 5f5f 2863 6c73 2c20 2a61 7267 732c 202a  __(cls, *args, *
-0000dfd0: 2a6b 7761 7267 7329 3a0a 2020 2020 2020  *kwargs):.      
-0000dfe0: 2020 6966 206b 7761 7267 732e 6765 7428    if kwargs.get(
-0000dff0: 2261 6273 6172 6722 2c20 4661 6c73 6529  "absarg", False)
-0000e000: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000e010: 7475 726e 2073 7570 6572 2829 2e5f 5f6e  turn super().__n
-0000e020: 6577 5f5f 2841 6273 4172 674c 696e 6553  ew__(AbsArgLineS
-0000e030: 6572 6965 7329 0a20 2020 2020 2020 2063  eries).        c
-0000e040: 6620 3d20 6b77 6172 6773 2e67 6574 2822  f = kwargs.get("
-0000e050: 636f 6c6f 725f 6675 6e63 222c 204e 6f6e  color_func", Non
-0000e060: 6529 0a20 2020 2020 2020 206c 6320 3d20  e).        lc = 
-0000e070: 6b77 6172 6773 2e67 6574 2822 6c69 6e65  kwargs.get("line
-0000e080: 5f63 6f6c 6f72 222c 204e 6f6e 6529 0a20  _color", None). 
-0000e090: 2020 2020 2020 2069 6620 2863 616c 6c61         if (calla
-0000e0a0: 626c 6528 6366 2920 6f72 2063 616c 6c61  ble(cf) or calla
-0000e0b0: 626c 6528 6c63 2920 6f72 2069 7369 6e73  ble(lc) or isins
-0000e0c0: 7461 6e63 6528 6366 2c20 4578 7072 2929  tance(cf, Expr))
-0000e0d0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000e0e0: 7475 726e 2073 7570 6572 2829 2e5f 5f6e  turn super().__n
-0000e0f0: 6577 5f5f 2843 6f6c 6f72 6564 4c69 6e65  ew__(ColoredLine
-0000e100: 4f76 6572 3144 5261 6e67 6553 6572 6965  Over1DRangeSerie
-0000e110: 7329 0a20 2020 2020 2020 2072 6574 7572  s).        retur
-0000e120: 6e20 6f62 6a65 6374 2e5f 5f6e 6577 5f5f  n object.__new__
-0000e130: 2863 6c73 290a 0a20 2020 2064 6566 205f  (cls)..    def _
-0000e140: 5f69 6e69 745f 5f28 7365 6c66 2c20 6578  _init__(self, ex
-0000e150: 7072 2c20 7661 725f 7374 6172 745f 656e  pr, var_start_en
-0000e160: 642c 206c 6162 656c 3d22 222c 202a 2a6b  d, label="", **k
-0000e170: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
-0000e180: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-0000e190: 282a 2a6b 7761 7267 7329 0a20 2020 2020  (**kwargs).     
-0000e1a0: 2020 2073 656c 662e 6578 7072 203d 2065     self.expr = e
-0000e1b0: 7870 7220 6966 2063 616c 6c61 626c 6528  xpr if callable(
-0000e1c0: 6578 7072 2920 656c 7365 2073 796d 7069  expr) else sympi
-0000e1d0: 6679 2865 7870 7229 0a20 2020 2020 2020  fy(expr).       
-0000e1e0: 2073 656c 662e 5f6c 6162 656c 203d 2073   self._label = s
-0000e1f0: 7472 2873 656c 662e 6578 7072 2920 6966  tr(self.expr) if
-0000e200: 206c 6162 656c 2069 7320 4e6f 6e65 2065   label is None e
-0000e210: 6c73 6520 6c61 6265 6c0a 2020 2020 2020  lse label.      
-0000e220: 2020 7365 6c66 2e5f 6c61 7465 785f 6c61    self._latex_la
-0000e230: 6265 6c20 3d20 6c61 7465 7828 7365 6c66  bel = latex(self
-0000e240: 2e65 7870 7229 2069 6620 6c61 6265 6c20  .expr) if label 
-0000e250: 6973 204e 6f6e 6520 656c 7365 206c 6162  is None else lab
-0000e260: 656c 0a20 2020 2020 2020 2073 656c 662e  el.        self.
-0000e270: 7261 6e67 6573 203d 205b 7661 725f 7374  ranges = [var_st
-0000e280: 6172 745f 656e 645d 0a20 2020 2020 2020  art_end].       
-0000e290: 2023 2074 6869 7320 6973 2075 7365 6420   # this is used 
-0000e2a0: 746f 2063 6173 7420 7468 6520 7661 6c75  to cast the valu
-0000e2b0: 6573 206f 6620 7261 6e67 6573 2077 6865  es of ranges whe
-0000e2c0: 6e20 7365 6c66 2e73 7461 7274 2f73 656c  n self.start/sel
-0000e2d0: 662e 656e 640a 2020 2020 2020 2020 2320  f.end.        # 
-0000e2e0: 6172 6520 6361 6c6c 6564 2e20 5573 6564  are called. Used
-0000e2f0: 2066 6f72 2062 6163 6b2d 636f 6d70 6174   for back-compat
-0000e300: 6962 696c 6974 7920 7769 7468 206f 6c64  ibility with old
-0000e310: 2073 796d 7079 2e70 6c6f 7474 696e 672c   sympy.plotting,
-0000e320: 0a20 2020 2020 2020 2023 2069 7420 6973  .        # it is
-0000e330: 206e 6f77 2064 6966 6669 6375 6c74 2074   now difficult t
-0000e340: 6f20 7265 6d6f 7665 2e0a 2020 2020 2020  o remove..      
-0000e350: 2020 7365 6c66 2e5f 6361 7374 203d 2063    self._cast = c
-0000e360: 6f6d 706c 6578 0a20 2020 2020 2020 2023  omplex.        #
-0000e370: 2066 6f72 2063 6f6d 706c 6578 2d72 656c   for complex-rel
-0000e380: 6174 6564 2064 6174 6120 7365 7269 6573  ated data series
-0000e390: 2c20 7468 6973 2064 6574 6572 6d69 6e65  , this determine
-0000e3a0: 7320 7768 6174 2064 6174 6120 746f 2072  s what data to r
-0000e3b0: 6574 7572 6e0a 2020 2020 2020 2020 2320  eturn.        # 
-0000e3c0: 6f6e 2074 6865 2079 2d61 7869 730a 2020  on the y-axis.  
-0000e3d0: 2020 2020 2020 7365 6c66 2e5f 7265 7475        self._retu
-0000e3e0: 726e 203d 206b 7761 7267 732e 6765 7428  rn = kwargs.get(
-0000e3f0: 2272 6574 7572 6e22 2c20 4e6f 6e65 290a  "return", None).
-0000e400: 2020 2020 2020 2020 7365 6c66 2e5f 706f          self._po
-0000e410: 7374 5f69 6e69 7428 290a 0a20 2020 2020  st_init()..     
-0000e420: 2020 2069 6620 6e6f 7420 7365 6c66 2e5f     if not self._
-0000e430: 696e 7465 7261 6374 6976 655f 7261 6e67  interactive_rang
-0000e440: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
-0000e450: 2320 4e4f 5445 3a20 7468 6520 666f 6c6c  # NOTE: the foll
-0000e460: 6f77 696e 6720 6368 6563 6b20 6973 206f  owing check is o
-0000e470: 6e6c 7920 706f 7373 6962 6c65 2077 6865  nly possible whe
-0000e480: 6e20 7468 6520 6d69 6e69 6d75 6d20 616e  n the minimum an
-0000e490: 640a 2020 2020 2020 2020 2020 2020 2320  d.            # 
-0000e4a0: 6d61 7869 6d75 6d20 7661 6c75 6573 206f  maximum values o
-0000e4b0: 6620 6120 706c 6f74 7469 6e67 2072 616e  f a plotting ran
-0000e4c0: 6765 2061 7265 206e 756d 6572 6963 0a20  ge are numeric. 
-0000e4d0: 2020 2020 2020 2020 2020 2073 7461 7274             start
-0000e4e0: 2c20 656e 6420 3d20 5b63 6f6d 706c 6578  , end = [complex
-0000e4f0: 2874 2920 666f 7220 7420 696e 2073 656c  (t) for t in sel
-0000e500: 662e 7261 6e67 6573 5b30 5d5b 313a 5d5d  f.ranges[0][1:]]
-0000e510: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000e520: 696d 2873 7461 7274 2920 213d 2069 6d28  im(start) != im(
-0000e530: 656e 6429 3a0a 2020 2020 2020 2020 2020  end):.          
-0000e540: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-0000e550: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
-0000e560: 2020 2020 2020 2020 2020 2020 2225 7320              "%s 
-0000e570: 7265 7175 6972 6573 2074 6865 2069 6d61  requires the ima
-0000e580: 6769 6e61 7279 2022 2025 2073 656c 662e  ginary " % self.
-0000e590: 5f5f 636c 6173 735f 5f2e 5f5f 6e61 6d65  __class__.__name
-0000e5a0: 5f5f 202b 0a20 2020 2020 2020 2020 2020  __ +.           
-0000e5b0: 2020 2020 2020 2020 2022 7061 7274 206f           "part o
-0000e5c0: 6620 7468 6520 7374 6172 7420 616e 6420  f the start and 
-0000e5d0: 656e 6420 7661 6c75 6573 206f 6620 7468  end values of th
-0000e5e0: 6520 7261 6e67 6520 220a 2020 2020 2020  e range ".      
-0000e5f0: 2020 2020 2020 2020 2020 2020 2020 2274                "t
-0000e600: 6f20 6265 2074 6865 2073 616d 652e 2229  o be the same.")
-0000e610: 0a0a 2020 2020 6465 6620 5f5f 7374 725f  ..    def __str_
-0000e620: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
-0000e630: 2064 6566 2066 2874 293a 0a20 2020 2020   def f(t):.     
-0000e640: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-0000e650: 616e 6365 2874 2c20 636f 6d70 6c65 7829  ance(t, complex)
-0000e660: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000e670: 2020 6966 2074 2e69 6d61 6720 213d 2030    if t.imag != 0
-0000e680: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000e690: 2020 2020 2020 7265 7475 726e 2074 0a20        return t. 
-0000e6a0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000e6b0: 6574 7572 6e20 742e 7265 616c 0a20 2020  eturn t.real.   
-0000e6c0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000e6d0: 740a 2020 2020 2020 2020 7072 6520 3d20  t.        pre = 
-0000e6e0: 2269 6e74 6572 6163 7469 7665 2022 2069  "interactive " i
-0000e6f0: 6620 7365 6c66 2e69 735f 696e 7465 7261  f self.is_intera
-0000e700: 6374 6976 6520 656c 7365 2022 220a 2020  ctive else "".  
-0000e710: 2020 2020 2020 706f 7374 203d 2022 220a        post = "".
-0000e720: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-0000e730: 6973 5f69 6e74 6572 6163 7469 7665 3a0a  is_interactive:.
-0000e740: 2020 2020 2020 2020 2020 2020 706f 7374              post
-0000e750: 203d 2022 2061 6e64 2070 6172 616d 6574   = " and paramet
-0000e760: 6572 7320 2220 2b20 7374 7228 7475 706c  ers " + str(tupl
-0000e770: 6528 7365 6c66 2e70 6172 616d 732e 6b65  e(self.params.ke
-0000e780: 7973 2829 2929 0a20 2020 2020 2020 2077  ys())).        w
-0000e790: 7261 7070 6572 203d 205f 6765 745f 7772  rapper = _get_wr
-0000e7a0: 6170 7065 725f 666f 725f 6578 7072 2873  apper_for_expr(s
-0000e7b0: 656c 662e 5f72 6574 7572 6e29 0a20 2020  elf._return).   
-0000e7c0: 2020 2020 2072 6574 7572 6e20 7072 6520       return pre 
-0000e7d0: 2b20 2263 6172 7465 7369 616e 206c 696e  + "cartesian lin
-0000e7e0: 653a 2025 7320 666f 7220 2573 206f 7665  e: %s for %s ove
-0000e7f0: 7220 2573 2220 2520 280a 2020 2020 2020  r %s" % (.      
-0000e800: 2020 2020 2020 7772 6170 7065 7220 2520        wrapper % 
-0000e810: 7365 6c66 2e65 7870 722c 0a20 2020 2020  self.expr,.     
-0000e820: 2020 2020 2020 2073 7472 2873 656c 662e         str(self.
-0000e830: 7661 7229 2c0a 2020 2020 2020 2020 2020  var),.          
-0000e840: 2020 7374 7228 2866 2873 656c 662e 7374    str((f(self.st
-0000e850: 6172 7429 2c20 6628 7365 6c66 2e65 6e64  art), f(self.end
-0000e860: 2929 292c 0a20 2020 2020 2020 2029 202b  ))),.        ) +
-0000e870: 2070 6f73 740a 0a20 2020 2064 6566 205f   post..    def _
-0000e880: 6164 6170 7469 7665 5f73 616d 706c 696e  adaptive_samplin
-0000e890: 6728 7365 6c66 293a 0a20 2020 2020 2020  g(self):.       
-0000e8a0: 206e 7020 3d20 696d 706f 7274 5f6d 6f64   np = import_mod
-0000e8b0: 756c 6528 276e 756d 7079 2729 0a0a 2020  ule('numpy')..  
-0000e8c0: 2020 2020 2020 6465 6620 6675 6e63 2866        def func(f
-0000e8d0: 2c20 696d 6167 2c20 7829 3a0a 2020 2020  , imag, x):.    
-0000e8e0: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
-0000e8f0: 2020 2020 2020 2020 2020 2020 2077 203d               w =
-0000e900: 2063 6f6d 706c 6578 2866 2878 202b 2031   complex(f(x + 1
-0000e910: 6a20 2a20 696d 6167 2929 0a20 2020 2020  j * imag)).     
-0000e920: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000e930: 6e20 772e 7265 616c 2c20 772e 696d 6167  n w.real, w.imag
-0000e940: 0a20 2020 2020 2020 2020 2020 2065 7863  .            exc
-0000e950: 6570 7420 285a 6572 6f44 6976 6973 696f  ept (ZeroDivisio
-0000e960: 6e45 7272 6f72 2c20 4f76 6572 666c 6f77  nError, Overflow
-0000e970: 4572 726f 7229 3a0a 2020 2020 2020 2020  Error):.        
-0000e980: 2020 2020 2020 2020 7265 7475 726e 206e          return n
-0000e990: 702e 6e61 6e2c 206e 702e 6e61 6e0a 0a20  p.nan, np.nan.. 
-0000e9a0: 2020 2020 2020 2064 6174 6120 3d20 5f61         data = _a
-0000e9b0: 6461 7074 6976 655f 6576 616c 280a 2020  daptive_eval(.  
-0000e9c0: 2020 2020 2020 2020 2020 6675 6e63 2c20            func, 
-0000e9d0: 5b73 656c 662e 7661 725d 2c20 7365 6c66  [self.var], self
-0000e9e0: 2e65 7870 722c 0a20 2020 2020 2020 2020  .expr,.         
-0000e9f0: 2020 205b 636f 6d70 6c65 7828 7365 6c66     [complex(self
-0000ea00: 2e73 7461 7274 292e 7265 616c 2c20 636f  .start).real, co
-0000ea10: 6d70 6c65 7828 7365 6c66 2e65 6e64 292e  mplex(self.end).
-0000ea20: 7265 616c 5d2c 0a20 2020 2020 2020 2020  real],.         
-0000ea30: 2020 2063 6f6d 706c 6578 2873 656c 662e     complex(self.
-0000ea40: 7374 6172 7429 2e69 6d61 672c 0a20 2020  start).imag,.   
-0000ea50: 2020 2020 2020 2020 206d 6f64 756c 6573           modules
-0000ea60: 3d73 656c 662e 6d6f 6475 6c65 732c 0a20  =self.modules,. 
-0000ea70: 2020 2020 2020 2020 2020 2061 6461 7074             adapt
-0000ea80: 6976 655f 676f 616c 3d73 656c 662e 6164  ive_goal=self.ad
-0000ea90: 6170 7469 7665 5f67 6f61 6c2c 0a20 2020  aptive_goal,.   
-0000eaa0: 2020 2020 2020 2020 206c 6f73 735f 666e           loss_fn
-0000eab0: 3d73 656c 662e 6c6f 7373 5f66 6e29 0a20  =self.loss_fn). 
-0000eac0: 2020 2020 2020 2072 6574 7572 6e20 6461         return da
-0000ead0: 7461 5b3a 2c20 305d 2c20 6461 7461 5b3a  ta[:, 0], data[:
-0000eae0: 2c20 315d 2c20 6461 7461 5b3a 2c20 325d  , 1], data[:, 2]
-0000eaf0: 0a0a 2020 2020 6465 6620 5f75 6e69 666f  ..    def _unifo
-0000eb00: 726d 5f73 616d 706c 696e 6728 7365 6c66  rm_sampling(self
-0000eb10: 293a 0a20 2020 2020 2020 206e 7020 3d20  ):.        np = 
-0000eb20: 696d 706f 7274 5f6d 6f64 756c 6528 276e  import_module('n
-0000eb30: 756d 7079 2729 0a0a 2020 2020 2020 2020  umpy')..        
-0000eb40: 782c 2072 6573 756c 7420 3d20 7365 6c66  x, result = self
-0000eb50: 2e5f 6576 616c 7561 7465 2829 0a20 2020  ._evaluate().   
-0000eb60: 2020 2020 205f 7265 2c20 5f69 6d20 3d20       _re, _im = 
-0000eb70: 6e70 2e72 6561 6c28 7265 7375 6c74 292c  np.real(result),
-0000eb80: 206e 702e 696d 6167 2872 6573 756c 7429   np.imag(result)
-0000eb90: 0a20 2020 2020 2020 205f 7265 203d 2073  .        _re = s
-0000eba0: 656c 662e 5f63 6f72 7265 6374 5f73 6861  elf._correct_sha
-0000ebb0: 7065 285f 7265 2c20 7829 0a20 2020 2020  pe(_re, x).     
-0000ebc0: 2020 205f 696d 203d 2073 656c 662e 5f63     _im = self._c
-0000ebd0: 6f72 7265 6374 5f73 6861 7065 285f 696d  orrect_shape(_im
-0000ebe0: 2c20 7829 0a20 2020 2020 2020 2072 6574  , x).        ret
-0000ebf0: 7572 6e20 782c 205f 7265 2c20 5f69 6d0a  urn x, _re, _im.
-0000ec00: 0a20 2020 2064 6566 205f 6765 745f 7265  .    def _get_re
-0000ec10: 616c 5f69 6d61 6728 7365 6c66 293a 0a20  al_imag(self):. 
-0000ec20: 2020 2020 2020 2022 2222 2042 7920 6576         """ By ev
-0000ec30: 616c 7561 7469 6e67 2074 6865 2066 756e  aluating the fun
-0000ec40: 6374 696f 6e20 6f76 6572 2061 2063 6f6d  ction over a com
-0000ec50: 706c 6578 2072 616e 6765 2069 7420 7368  plex range it sh
-0000ec60: 6f75 6c64 0a20 2020 2020 2020 2072 6574  ould.        ret
-0000ec70: 7572 6e20 636f 6d70 6c65 7820 7661 6c75  urn complex valu
-0000ec80: 6573 2e20 5468 6520 696d 6167 696e 6172  es. The imaginar
-0000ec90: 7920 7061 7274 2063 616e 2062 6520 7573  y part can be us
-0000eca0: 6564 2074 6f20 6d61 736b 206f 7574 2074  ed to mask out t
-0000ecb0: 6865 0a20 2020 2020 2020 2075 6e77 616e  he.        unwan
-0000ecc0: 7465 6420 7661 6c75 6573 2e0a 2020 2020  ted values..    
-0000ecd0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000ece0: 6966 2073 656c 662e 6164 6170 7469 7665  if self.adaptive
-0000ecf0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000ed00: 7475 726e 2073 656c 662e 5f61 6461 7074  turn self._adapt
-0000ed10: 6976 655f 7361 6d70 6c69 6e67 2829 0a20  ive_sampling(). 
-0000ed20: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-0000ed30: 6c66 2e5f 756e 6966 6f72 6d5f 7361 6d70  lf._uniform_samp
-0000ed40: 6c69 6e67 2829 0a0a 2020 2020 6465 6620  ling()..    def 
-0000ed50: 5f67 6574 5f64 6174 615f 6865 6c70 6572  _get_data_helper
-0000ed60: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000ed70: 2222 2252 6574 7572 6e73 2063 6f6f 7264  """Returns coord
-0000ed80: 696e 6174 6573 2074 6861 7420 6e65 6564  inates that need
-0000ed90: 7320 746f 2062 6520 706f 7374 7072 6f63  s to be postproc
-0000eda0: 6573 7365 642e 0a20 2020 2020 2020 2022  essed..        "
-0000edb0: 2222 0a20 2020 2020 2020 206e 7020 3d20  "".        np = 
-0000edc0: 696d 706f 7274 5f6d 6f64 756c 6528 276e  import_module('n
-0000edd0: 756d 7079 2729 0a0a 2020 2020 2020 2020  umpy')..        
-0000ede0: 782c 205f 7265 2c20 5f69 6d20 3d20 7365  x, _re, _im = se
-0000edf0: 6c66 2e5f 6765 745f 7265 616c 5f69 6d61  lf._get_real_ima
-0000ee00: 6728 290a 0a20 2020 2020 2020 2069 6620  g()..        if 
-0000ee10: 7365 6c66 2e5f 7265 7475 726e 2069 7320  self._return is 
-0000ee20: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0000ee30: 2020 2320 5468 6520 6576 616c 7561 7469    # The evaluati
-0000ee40: 6f6e 2063 6f75 6c64 2070 726f 6475 6365  on could produce
-0000ee50: 2063 6f6d 706c 6578 206e 756d 6265 7273   complex numbers
-0000ee60: 2e20 5365 7420 7265 616c 2065 6c65 6d65  . Set real eleme
-0000ee70: 6e74 730a 2020 2020 2020 2020 2020 2020  nts.            
-0000ee80: 2320 746f 204e 614e 2077 6865 7265 2074  # to NaN where t
-0000ee90: 6865 7265 2061 7265 206e 6f6e 2d7a 6572  here are non-zer
-0000eea0: 6f20 696d 6167 696e 6172 7920 656c 656d  o imaginary elem
-0000eeb0: 656e 7473 0a20 2020 2020 2020 2020 2020  ents.           
-0000eec0: 205f 7265 5b6e 702e 696e 7665 7274 286e   _re[np.invert(n
-0000eed0: 702e 6973 636c 6f73 6528 5f69 6d2c 206e  p.isclose(_im, n
-0000eee0: 702e 7a65 726f 735f 6c69 6b65 285f 696d  p.zeros_like(_im
-0000eef0: 2929 295d 203d 206e 702e 6e61 6e0a 2020  )))] = np.nan.  
-0000ef00: 2020 2020 2020 656c 6966 2073 656c 662e        elif self.
-0000ef10: 5f72 6574 7572 6e20 3d3d 2022 7265 616c  _return == "real
-0000ef20: 223a 0a20 2020 2020 2020 2020 2020 2070  ":.            p
-0000ef30: 6173 730a 2020 2020 2020 2020 656c 6966  ass.        elif
-0000ef40: 2073 656c 662e 5f72 6574 7572 6e20 3d3d   self._return ==
-0000ef50: 2022 696d 6167 223a 0a20 2020 2020 2020   "imag":.       
-0000ef60: 2020 2020 205f 7265 203d 205f 696d 0a20       _re = _im. 
-0000ef70: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-0000ef80: 2e5f 7265 7475 726e 203d 3d20 2261 6273  ._return == "abs
-0000ef90: 223a 0a20 2020 2020 2020 2020 2020 205f  ":.            _
-0000efa0: 7265 203d 206e 702e 7371 7274 285f 7265  re = np.sqrt(_re
-0000efb0: 2a2a 3220 2b20 5f69 6d2a 2a32 290a 2020  **2 + _im**2).  
-0000efc0: 2020 2020 2020 656c 6966 2073 656c 662e        elif self.
-0000efd0: 5f72 6574 7572 6e20 3d3d 2022 6172 6722  _return == "arg"
-0000efe0: 3a0a 2020 2020 2020 2020 2020 2020 5f72  :.            _r
-0000eff0: 6520 3d20 6e70 2e61 7263 7461 6e32 285f  e = np.arctan2(_
-0000f000: 696d 2c20 5f72 6529 0a20 2020 2020 2020  im, _re).       
-0000f010: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000f020: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-0000f030: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
-0000f040: 2020 2020 2022 605f 7265 7475 726e 6020       "`_return` 
-0000f050: 6e6f 7420 7265 636f 676e 697a 6564 2e20  not recognized. 
-0000f060: 5265 6365 6976 6564 3a20 2573 2220 2520  Received: %s" % 
-0000f070: 7365 6c66 2e5f 7265 7475 726e 290a 0a20  self._return).. 
-0000f080: 2020 2020 2020 2072 6574 7572 6e20 782c         return x,
-0000f090: 205f 7265 0a0a 0a63 6c61 7373 2043 6f6c   _re...class Col
-0000f0a0: 6f72 6564 4c69 6e65 4f76 6572 3144 5261  oredLineOver1DRa
-0000f0b0: 6e67 6553 6572 6965 7328 4c69 6e65 4f76  ngeSeries(LineOv
-0000f0c0: 6572 3144 5261 6e67 6553 6572 6965 7329  er1DRangeSeries)
-0000f0d0: 3a0a 2020 2020 2222 2252 6570 7265 7365  :.    """Represe
-0000f0e0: 6e74 7320 6120 3244 206c 696e 6520 7365  nts a 2D line se
-0000f0f0: 7269 6573 2069 6e20 7768 6963 6820 6063  ries in which `c
-0000f100: 6f6c 6f72 5f66 756e 6360 2069 7320 6120  olor_func` is a 
-0000f110: 6361 6c6c 6162 6c65 2e0a 2020 2020 2222  callable..    ""
-0000f120: 220a 2020 2020 6973 5f70 6172 616d 6574  ".    is_paramet
-0000f130: 7269 6320 3d20 5472 7565 0a0a 2020 2020  ric = True..    
-0000f140: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-0000f150: 662c 202a 6172 6773 2c20 2a2a 6b77 6172  f, *args, **kwar
-0000f160: 6773 293a 0a20 2020 2020 2020 2073 7570  gs):.        sup
-0000f170: 6572 2829 2e5f 5f69 6e69 745f 5f28 2a61  er().__init__(*a
-0000f180: 7267 732c 202a 2a6b 7761 7267 7329 0a20  rgs, **kwargs). 
-0000f190: 2020 2020 2020 2073 656c 662e 7573 655f         self.use_
-0000f1a0: 636d 203d 206b 7761 7267 732e 6765 7428  cm = kwargs.get(
-0000f1b0: 2275 7365 5f63 6d22 2c20 5472 7565 290a  "use_cm", True).
-0000f1c0: 0a20 2020 2064 6566 205f 6765 745f 6461  .    def _get_da
-0000f1d0: 7461 5f68 656c 7065 7228 7365 6c66 293a  ta_helper(self):
-0000f1e0: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
-0000f1f0: 726e 7320 636f 6f72 6469 6e61 7465 7320  rns coordinates 
-0000f200: 7468 6174 206e 6565 6473 2074 6f20 6265  that needs to be
-0000f210: 2070 6f73 7470 726f 6365 7373 6564 2e0a   postprocessed..
-0000f220: 2020 2020 2020 2020 4465 7065 6e64 696e          Dependin
-0000f230: 6720 6f6e 2074 6865 2060 6164 6170 7469  g on the `adapti
-0000f240: 7665 6020 6f70 7469 6f6e 2c20 7468 6973  ve` option, this
-0000f250: 2066 756e 6374 696f 6e20 7769 6c6c 2065   function will e
-0000f260: 6974 6865 7220 7573 6520 616e 0a20 2020  ither use an.   
-0000f270: 2020 2020 2061 6461 7074 6976 6520 616c       adaptive al
-0000f280: 676f 7269 7468 6d20 6f72 2069 7420 7769  gorithm or it wi
-0000f290: 6c6c 2075 6e69 666f 726d 6c79 2073 616d  ll uniformly sam
-0000f2a0: 706c 6520 7468 6520 6578 7072 6573 7369  ple the expressi
-0000f2b0: 6f6e 206f 7665 7220 7468 650a 2020 2020  on over the.    
-0000f2c0: 2020 2020 7072 6f76 6964 6564 2072 616e      provided ran
-0000f2d0: 6765 2e0a 2020 2020 2020 2020 2222 220a  ge..        """.
-0000f2e0: 2020 2020 2020 2020 782c 2079 203d 2073          x, y = s
-0000f2f0: 7570 6572 2829 2e5f 6765 745f 6461 7461  uper()._get_data
-0000f300: 5f68 656c 7065 7228 290a 2020 2020 2020  _helper().      
-0000f310: 2020 7265 7475 726e 2078 2c20 792c 2073    return x, y, s
-0000f320: 656c 662e 6576 616c 5f63 6f6c 6f72 5f66  elf.eval_color_f
-0000f330: 756e 6328 782c 2079 290a 0a0a 636c 6173  unc(x, y)...clas
-0000f340: 7320 4162 7341 7267 4c69 6e65 5365 7269  s AbsArgLineSeri
-0000f350: 6573 284c 696e 654f 7665 7231 4452 616e  es(LineOver1DRan
-0000f360: 6765 5365 7269 6573 293a 0a20 2020 2022  geSeries):.    "
-0000f370: 2222 5265 7072 6573 656e 7473 2074 6865  ""Represents the
-0000f380: 2061 6273 6f6c 7574 6520 7661 6c75 6520   absolute value 
-0000f390: 6f66 2061 2063 6f6d 706c 6578 2066 756e  of a complex fun
-0000f3a0: 6374 696f 6e20 636f 6c6f 7265 6420 6279  ction colored by
-0000f3b0: 2069 7473 0a20 2020 2061 7267 756d 656e   its.    argumen
-0000f3c0: 7420 6f76 6572 2061 2063 6f6d 706c 6578  t over a complex
-0000f3d0: 2072 616e 6765 2028 6120 2b20 492a 622c   range (a + I*b,
-0000f3e0: 2063 202b 2049 202a 2062 292e 0a20 2020   c + I * b)..   
-0000f3f0: 204e 6f74 6520 7468 6174 2074 6865 2069   Note that the i
-0000f400: 6d61 6769 6e61 7279 2070 6172 7420 6f66  maginary part of
-0000f410: 2074 6865 2073 7461 7274 2061 6e64 2065   the start and e
-0000f420: 6e64 206d 7573 7420 6265 2074 6865 2073  nd must be the s
-0000f430: 616d 652e 0a20 2020 2022 2222 0a0a 2020  ame..    """..  
-0000f440: 2020 6973 5f70 6172 616d 6574 7269 6320    is_parametric 
-0000f450: 3d20 5472 7565 0a20 2020 2069 735f 636f  = True.    is_co
-0000f460: 6d70 6c65 7820 3d20 5472 7565 0a0a 2020  mplex = True..  
-0000f470: 2020 6465 6620 5f5f 6e65 775f 5f28 636c    def __new__(cl
-0000f480: 732c 202a 6172 6773 2c20 2a2a 6b77 6172  s, *args, **kwar
-0000f490: 6773 293a 0a20 2020 2020 2020 2072 6574  gs):.        ret
-0000f4a0: 7572 6e20 6f62 6a65 6374 2e5f 5f6e 6577  urn object.__new
-0000f4b0: 5f5f 2863 6c73 290a 0a20 2020 2064 6566  __(cls)..    def
-0000f4c0: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
-0000f4d0: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
-0000f4e0: 3a0a 2020 2020 2020 2020 7375 7065 7228  :.        super(
-0000f4f0: 292e 5f5f 696e 6974 5f5f 282a 6172 6773  ).__init__(*args
-0000f500: 2c20 2a2a 6b77 6172 6773 290a 2020 2020  , **kwargs).    
-0000f510: 2020 2020 7365 6c66 2e75 7365 5f63 6d20      self.use_cm 
-0000f520: 3d20 6b77 6172 6773 2e67 6574 2822 7573  = kwargs.get("us
-0000f530: 655f 636d 222c 2054 7275 6529 0a0a 2020  e_cm", True)..  
-0000f540: 2020 6465 6620 5f5f 7374 725f 5f28 7365    def __str__(se
-0000f550: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-0000f560: 7572 6e20 7365 6c66 2e5f 7374 725f 6865  urn self._str_he
-0000f570: 6c70 6572 2822 6361 7274 6573 6961 6e20  lper("cartesian 
-0000f580: 6162 732d 6172 6720 6c69 6e65 3a20 2573  abs-arg line: %s
-0000f590: 2066 6f72 2025 7320 6f76 6572 2025 7322   for %s over %s"
-0000f5a0: 2025 2028 0a20 2020 2020 2020 2020 2020   % (.           
-0000f5b0: 2073 7472 2873 656c 662e 6578 7072 292c   str(self.expr),
-0000f5c0: 0a20 2020 2020 2020 2020 2020 2073 7472  .            str
-0000f5d0: 2873 656c 662e 7661 7229 2c0a 2020 2020  (self.var),.    
-0000f5e0: 2020 2020 2020 2020 7374 7228 2873 656c          str((sel
-0000f5f0: 662e 7374 6172 742c 2073 656c 662e 656e  f.start, self.en
-0000f600: 6429 2929 290a 0a20 2020 2064 6566 205f  d))))..    def _
-0000f610: 6765 745f 6461 7461 5f68 656c 7065 7228  get_data_helper(
-0000f620: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
-0000f630: 2222 5265 7475 726e 7320 636f 6f72 6469  ""Returns coordi
-0000f640: 6e61 7465 7320 7468 6174 206e 6565 6473  nates that needs
-0000f650: 2074 6f20 6265 2070 6f73 7470 726f 6365   to be postproce
-0000f660: 7373 6564 2e0a 2020 2020 2020 2020 4465  ssed..        De
-0000f670: 7065 6e64 696e 6720 6f6e 2074 6865 2060  pending on the `
-0000f680: 6164 6170 7469 7665 6020 6f70 7469 6f6e  adaptive` option
-0000f690: 2c20 7468 6973 2066 756e 6374 696f 6e20  , this function 
-0000f6a0: 7769 6c6c 2065 6974 6865 7220 7573 6520  will either use 
-0000f6b0: 616e 0a20 2020 2020 2020 2061 6461 7074  an.        adapt
-0000f6c0: 6976 6520 616c 676f 7269 7468 6d20 6f72  ive algorithm or
-0000f6d0: 2069 7420 7769 6c6c 2075 6e69 666f 726d   it will uniform
-0000f6e0: 6c79 2073 616d 706c 6520 7468 6520 6578  ly sample the ex
-0000f6f0: 7072 6573 7369 6f6e 206f 7665 7220 7468  pression over th
-0000f700: 650a 2020 2020 2020 2020 7072 6f76 6964  e.        provid
-0000f710: 6564 2072 616e 6765 2e0a 2020 2020 2020  ed range..      
-0000f720: 2020 2222 220a 2020 2020 2020 2020 6e70    """.        np
-0000f730: 203d 2069 6d70 6f72 745f 6d6f 6475 6c65   = import_module
-0000f740: 2827 6e75 6d70 7927 290a 0a20 2020 2020  ('numpy')..     
-0000f750: 2020 2078 2c20 5f72 652c 205f 696d 203d     x, _re, _im =
-0000f760: 2073 656c 662e 5f67 6574 5f72 6561 6c5f   self._get_real_
-0000f770: 696d 6167 2829 0a20 2020 2020 2020 205f  imag().        _
-0000f780: 6162 7320 3d20 6e70 2e73 7172 7428 5f72  abs = np.sqrt(_r
-0000f790: 652a 2a32 202b 205f 696d 2a2a 3229 0a20  e**2 + _im**2). 
-0000f7a0: 2020 2020 2020 205f 616e 676c 6520 3d20         _angle = 
-0000f7b0: 6e70 2e61 7263 7461 6e32 285f 696d 2c20  np.arctan2(_im, 
-0000f7c0: 5f72 6529 0a20 2020 2020 2020 2072 6574  _re).        ret
-0000f7d0: 7572 6e20 782c 205f 6162 732c 205f 616e  urn x, _abs, _an
-0000f7e0: 676c 650a 0a0a 636c 6173 7320 5061 7261  gle...class Para
-0000f7f0: 6d65 7472 6963 4c69 6e65 4261 7365 5365  metricLineBaseSe
-0000f800: 7269 6573 280a 2020 2020 436f 6d6d 6f6e  ries(.    Common
-0000f810: 4164 6170 7469 7665 4576 616c 7561 7469  AdaptiveEvaluati
-0000f820: 6f6e 2c20 436f 6d6d 6f6e 556e 6966 6f72  on, CommonUnifor
-0000f830: 6d45 7661 6c75 6174 696f 6e2c 204c 696e  mEvaluation, Lin
-0000f840: 6532 4442 6173 6553 6572 6965 730a 293a  e2DBaseSeries.):
-0000f850: 0a20 2020 2069 735f 7061 7261 6d65 7472  .    is_parametr
-0000f860: 6963 203d 2054 7275 650a 0a20 2020 2064  ic = True..    d
-0000f870: 6566 205f 7365 745f 7061 7261 6d65 7472  ef _set_parametr
-0000f880: 6963 5f6c 696e 655f 6c61 6265 6c28 7365  ic_line_label(se
-0000f890: 6c66 2c20 6c61 6265 6c29 3a0a 2020 2020  lf, label):.    
-0000f8a0: 2020 2020 2222 224c 6f67 6963 2074 6f20      """Logic to 
-0000f8b0: 7365 7420 7468 6520 636f 7272 6563 7420  set the correct 
-0000f8c0: 6c61 6265 6c20 746f 2062 6520 7368 6f77  label to be show
-0000f8d0: 6e20 6f6e 2074 6865 2070 6c6f 742e 0a20  n on the plot.. 
-0000f8e0: 2020 2020 2020 2049 6620 6075 7365 5f63         If `use_c
-0000f8f0: 6d3d 5472 7565 6020 7468 6572 6520 7769  m=True` there wi
-0000f900: 6c6c 2062 6520 6120 636f 6c6f 7262 6172  ll be a colorbar
-0000f910: 2c20 736f 2077 6520 7368 6f77 2074 6865  , so we show the
-0000f920: 2070 6172 616d 6574 6572 2e0a 2020 2020   parameter..    
-0000f930: 2020 2020 4966 2060 7573 655f 636d 3d46      If `use_cm=F
-0000f940: 616c 7365 602c 2074 6865 7265 206d 6967  alse`, there mig
-0000f950: 6874 2062 6520 6120 6c65 6765 6e64 2c20  ht be a legend, 
-0000f960: 736f 2077 6520 7368 6f77 2074 6865 2065  so we show the e
-0000f970: 7870 7265 7373 696f 6e73 2e0a 0a20 2020  xpressions...   
-0000f980: 2020 2020 2050 6172 616d 6574 6572 730a       Parameters.
-0000f990: 2020 2020 2020 2020 3d3d 3d3d 3d3d 3d3d          ========
-0000f9a0: 3d3d 0a20 2020 2020 2020 206c 6162 656c  ==.        label
-0000f9b0: 203a 2073 7472 0a20 2020 2020 2020 2020   : str.         
-0000f9c0: 2020 206c 6162 656c 2070 6173 7365 6420     label passed 
-0000f9d0: 696e 2062 7920 7468 6520 7072 652d 7072  in by the pre-pr
-0000f9e0: 6f63 6573 736f 7220 6f72 2074 6865 2075  ocessor or the u
-0000f9f0: 7365 720a 2020 2020 2020 2020 2222 220a  ser.        """.
-0000fa00: 2020 2020 2020 2020 7365 6c66 2e5f 6c61          self._la
-0000fa10: 6265 6c20 3d20 7374 7228 7365 6c66 2e76  bel = str(self.v
-0000fa20: 6172 2920 6966 206c 6162 656c 2069 7320  ar) if label is 
-0000fa30: 4e6f 6e65 2065 6c73 6520 6c61 6265 6c0a  None else label.
-0000fa40: 2020 2020 2020 2020 7365 6c66 2e5f 6c61          self._la
-0000fa50: 7465 785f 6c61 6265 6c20 3d20 6c61 7465  tex_label = late
-0000fa60: 7828 7365 6c66 2e76 6172 2920 6966 206c  x(self.var) if l
-0000fa70: 6162 656c 2069 7320 4e6f 6e65 2065 6c73  abel is None els
-0000fa80: 6520 6c61 6265 6c0a 2020 2020 2020 2020  e label.        
-0000fa90: 6966 2028 7365 6c66 2e75 7365 5f63 6d20  if (self.use_cm 
-0000faa0: 6973 2046 616c 7365 2920 616e 6420 2873  is False) and (s
-0000fab0: 656c 662e 5f6c 6162 656c 203d 3d20 7374  elf._label == st
-0000fac0: 7228 7365 6c66 2e76 6172 2929 3a0a 2020  r(self.var)):.  
-0000fad0: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
-0000fae0: 6c61 6265 6c20 3d20 7374 7228 7365 6c66  label = str(self
-0000faf0: 2e65 7870 7229 0a20 2020 2020 2020 2020  .expr).         
-0000fb00: 2020 2073 656c 662e 5f6c 6174 6578 5f6c     self._latex_l
-0000fb10: 6162 656c 203d 206c 6174 6578 2873 656c  abel = latex(sel
-0000fb20: 662e 6578 7072 290a 2020 2020 2020 2020  f.expr).        
-0000fb30: 2320 6966 2074 6865 2065 7870 7265 7373  # if the express
-0000fb40: 696f 6e73 2069 7320 6120 6c61 6d62 6461  ions is a lambda
-0000fb50: 2066 756e 6374 696f 6e20 616e 6420 7573   function and us
-0000fb60: 655f 636d 3d46 616c 7365 2061 6e64 206e  e_cm=False and n
-0000fb70: 6f20 6c61 6265 6c0a 2020 2020 2020 2020  o label.        
-0000fb80: 2320 6861 7320 6265 656e 2070 726f 7669  # has been provi
-0000fb90: 6465 642c 2074 6865 6e20 6974 7320 6265  ded, then its be
-0000fba0: 7474 6572 2074 6f20 646f 2074 6865 2066  tter to do the f
-0000fbb0: 6f6c 6c6f 7769 6e67 2069 6e20 6f72 6465  ollowing in orde
-0000fbc0: 7220 746f 0a20 2020 2020 2020 2023 2061  r to.        # a
-0000fbd0: 766f 6964 2073 7570 7269 7365 7320 6f6e  void suprises on
-0000fbe0: 2074 6865 2062 6163 6b65 6e64 0a20 2020   the backend.   
-0000fbf0: 2020 2020 2069 6620 616e 7928 6361 6c6c       if any(call
-0000fc00: 6162 6c65 2865 2920 666f 7220 6520 696e  able(e) for e in
-0000fc10: 2073 656c 662e 6578 7072 2920 616e 6420   self.expr) and 
-0000fc20: 286e 6f74 2073 656c 662e 7573 655f 636d  (not self.use_cm
-0000fc30: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
-0000fc40: 6620 7365 6c66 2e5f 6c61 6265 6c20 3d3d  f self._label ==
-0000fc50: 2073 7472 2873 656c 662e 6578 7072 293a   str(self.expr):
-0000fc60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000fc70: 2073 656c 662e 5f6c 6162 656c 203d 2022   self._label = "
-0000fc80: 220a 0a20 2020 2064 6566 205f 6164 6170  "..    def _adap
-0000fc90: 7469 7665 5f73 616d 706c 696e 6728 7365  tive_sampling(se
-0000fca0: 6c66 293a 0a20 2020 2020 2020 206e 7020  lf):.        np 
-0000fcb0: 3d20 696d 706f 7274 5f6d 6f64 756c 6528  = import_module(
-0000fcc0: 276e 756d 7079 2729 0a0a 2020 2020 2020  'numpy')..      
-0000fcd0: 2020 6465 6620 6675 6e63 2866 2c20 6973    def func(f, is
-0000fce0: 5f32 446c 696e 652c 2078 293a 0a20 2020  _2Dline, x):.   
-0000fcf0: 2020 2020 2020 2020 2074 7279 3a0a 2020           try:.  
-0000fd00: 2020 2020 2020 2020 2020 2020 2020 7720                w 
-0000fd10: 3d20 5b63 6f6d 706c 6578 2874 2920 666f  = [complex(t) fo
-0000fd20: 7220 7420 696e 2066 2863 6f6d 706c 6578  r t in f(complex
-0000fd30: 2878 2929 5d0a 2020 2020 2020 2020 2020  (x))].          
-0000fd40: 2020 2020 2020 7265 7475 726e 205b 742e        return [t.
-0000fd50: 7265 616c 2069 6620 6e70 2e69 7363 6c6f  real if np.isclo
-0000fd60: 7365 2874 2e69 6d61 672c 2030 2920 656c  se(t.imag, 0) el
-0000fd70: 7365 206e 702e 6e61 6e20 666f 7220 7420  se np.nan for t 
-0000fd80: 696e 2077 5d0a 2020 2020 2020 2020 2020  in w].          
-0000fd90: 2020 6578 6365 7074 2028 5a65 726f 4469    except (ZeroDi
-0000fda0: 7669 7369 6f6e 4572 726f 722c 204f 7665  visionError, Ove
-0000fdb0: 7266 6c6f 7745 7272 6f72 293a 0a20 2020  rflowError):.   
-0000fdc0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0000fdd0: 7572 6e20 5b6e 702e 6e61 6e20 666f 7220  urn [np.nan for 
-0000fde0: 7420 696e 2072 616e 6765 2832 2069 6620  t in range(2 if 
-0000fdf0: 6973 5f32 446c 696e 6520 656c 7365 2033  is_2Dline else 3
-0000fe00: 295d 0a0a 2020 2020 2020 2020 6966 2061  )]..        if a
-0000fe10: 6c6c 286e 6f74 2063 616c 6c61 626c 6528  ll(not callable(
-0000fe20: 6529 2066 6f72 2065 2069 6e20 7365 6c66  e) for e in self
-0000fe30: 2e65 7870 7229 3a0a 2020 2020 2020 2020  .expr):.        
-0000fe40: 2020 2020 6578 7072 203d 2054 7570 6c65      expr = Tuple
-0000fe50: 2873 656c 662e 6578 7072 5f78 2c20 7365  (self.expr_x, se
-0000fe60: 6c66 2e65 7870 725f 7929 0a20 2020 2020  lf.expr_y).     
-0000fe70: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
-0000fe80: 6c66 2e69 735f 3244 6c69 6e65 3a0a 2020  lf.is_2Dline:.  
-0000fe90: 2020 2020 2020 2020 2020 2020 2020 6578                ex
-0000fea0: 7072 203d 2054 7570 6c65 2873 656c 662e  pr = Tuple(self.
-0000feb0: 6578 7072 5f78 2c20 7365 6c66 2e65 7870  expr_x, self.exp
-0000fec0: 725f 792c 2073 656c 662e 6578 7072 5f7a  r_y, self.expr_z
-0000fed0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-0000fee0: 2020 2020 2020 2020 2020 2020 2320 6578              # ex
-0000fef0: 7072 2069 7320 7573 6572 2d70 726f 7669  pr is user-provi
-0000ff00: 6465 6420 6c61 6d62 6461 2066 756e 6374  ded lambda funct
-0000ff10: 696f 6e73 0a20 2020 2020 2020 2020 2020  ions.           
-0000ff20: 2065 7870 7220 3d20 6c61 6d62 6461 2078   expr = lambda x
-0000ff30: 3a20 2873 656c 662e 6578 7072 5f78 2878  : (self.expr_x(x
-0000ff40: 292c 2073 656c 662e 6578 7072 5f79 2878  ), self.expr_y(x
-0000ff50: 2929 0a20 2020 2020 2020 2020 2020 2069  )).            i
-0000ff60: 6620 6e6f 7420 7365 6c66 2e69 735f 3244  f not self.is_2D
-0000ff70: 6c69 6e65 3a0a 2020 2020 2020 2020 2020  line:.          
-0000ff80: 2020 2020 2020 6578 7072 203d 206c 616d        expr = lam
-0000ff90: 6264 6120 783a 2028 0a20 2020 2020 2020  bda x: (.       
-0000ffa0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000ffb0: 662e 6578 7072 5f78 2878 292c 2073 656c  f.expr_x(x), sel
-0000ffc0: 662e 6578 7072 5f79 2878 292c 2073 656c  f.expr_y(x), sel
-0000ffd0: 662e 6578 7072 5f7a 2878 2929 0a0a 2020  f.expr_z(x))..  
-0000ffe0: 2020 2020 2020 6461 7461 203d 205f 6164        data = _ad
-0000fff0: 6170 7469 7665 5f65 7661 6c28 0a20 2020  aptive_eval(.   
-00010000: 2020 2020 2020 2020 2066 756e 632c 205b           func, [
-00010010: 7365 6c66 2e76 6172 5d2c 2065 7870 722c  self.var], expr,
-00010020: 0a20 2020 2020 2020 2020 2020 205b 666c  .            [fl
-00010030: 6f61 7428 7365 6c66 2e73 7461 7274 292c  oat(self.start),
-00010040: 2066 6c6f 6174 2873 656c 662e 656e 6429   float(self.end)
-00010050: 5d2c 0a20 2020 2020 2020 2020 2020 2073  ],.            s
-00010060: 656c 662e 6973 5f32 446c 696e 652c 0a20  elf.is_2Dline,. 
-00010070: 2020 2020 2020 2020 2020 206d 6f64 756c             modul
-00010080: 6573 3d73 656c 662e 6d6f 6475 6c65 732c  es=self.modules,
-00010090: 0a20 2020 2020 2020 2020 2020 2061 6461  .            ada
-000100a0: 7074 6976 655f 676f 616c 3d73 656c 662e  ptive_goal=self.
-000100b0: 6164 6170 7469 7665 5f67 6f61 6c2c 0a20  adaptive_goal,. 
-000100c0: 2020 2020 2020 2020 2020 206c 6f73 735f             loss_
-000100d0: 666e 3d73 656c 662e 6c6f 7373 5f66 6e29  fn=self.loss_fn)
-000100e0: 0a0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
-000100f0: 662e 6973 5f32 446c 696e 653a 0a20 2020  f.is_2Dline:.   
-00010100: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00010110: 6461 7461 5b3a 2c20 315d 2c20 6461 7461  data[:, 1], data
-00010120: 5b3a 2c20 325d 2c20 6461 7461 5b3a 2c20  [:, 2], data[:, 
-00010130: 305d 0a20 2020 2020 2020 2072 6574 7572  0].        retur
-00010140: 6e20 6461 7461 5b3a 2c20 315d 2c20 6461  n data[:, 1], da
-00010150: 7461 5b3a 2c20 325d 2c20 6461 7461 5b3a  ta[:, 2], data[:
-00010160: 2c20 335d 2c20 6461 7461 5b3a 2c20 305d  , 3], data[:, 0]
-00010170: 0a0a 2020 2020 6465 6620 6765 745f 6c61  ..    def get_la
-00010180: 6265 6c28 7365 6c66 2c20 7573 655f 6c61  bel(self, use_la
-00010190: 7465 783d 4661 6c73 652c 2077 7261 7070  tex=False, wrapp
-000101a0: 6572 3d22 2425 7324 2229 3a0a 2020 2020  er="$%s$"):.    
-000101b0: 2020 2020 2320 7061 7261 6d65 7472 6963      # parametric
-000101c0: 206c 696e 6573 2072 6574 7572 6e73 2074   lines returns t
-000101d0: 6865 2072 6570 7265 7365 6e74 6174 696f  he representatio
-000101e0: 6e20 6f66 2074 6865 2070 6172 616d 6574  n of the paramet
-000101f0: 6572 2074 6f20 6265 0a20 2020 2020 2020  er to be.       
-00010200: 2023 2073 686f 776e 206f 6e20 7468 6520   # shown on the 
-00010210: 636f 6c6f 7262 6172 2069 6620 6075 7365  colorbar if `use
-00010220: 5f63 6d3d 5472 7565 602c 206f 7468 6572  _cm=True`, other
-00010230: 7769 7365 2069 7420 7265 7475 726e 7320  wise it returns 
-00010240: 7468 650a 2020 2020 2020 2020 2320 7265  the.        # re
-00010250: 7072 6573 656e 7461 7469 6f6e 206f 6620  presentation of 
-00010260: 7468 6520 6578 7072 6573 7369 6f6e 2074  the expression t
-00010270: 6f20 6265 2070 6c61 6365 6420 6f6e 2074  o be placed on t
-00010280: 6865 206c 6567 656e 642e 0a20 2020 2020  he legend..     
-00010290: 2020 2069 6620 7365 6c66 2e75 7365 5f63     if self.use_c
-000102a0: 6d3a 0a20 2020 2020 2020 2020 2020 2069  m:.            i
-000102b0: 6620 7374 7228 7365 6c66 2e76 6172 2920  f str(self.var) 
-000102c0: 3d3d 2073 656c 662e 5f6c 6162 656c 3a0a  == self._label:.
-000102d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000102e0: 6966 2075 7365 5f6c 6174 6578 3a0a 2020  if use_latex:.  
-000102f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010300: 2020 7265 7475 726e 2073 656c 662e 5f67    return self._g
-00010310: 6574 5f77 7261 7070 6564 5f6c 6162 656c  et_wrapped_label
-00010320: 286c 6174 6578 2873 656c 662e 7661 7229  (latex(self.var)
-00010330: 2c20 7772 6170 7065 7229 0a20 2020 2020  , wrapper).     
-00010340: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00010350: 6e20 7374 7228 7365 6c66 2e76 6172 290a  n str(self.var).
-00010360: 2020 2020 2020 2020 2020 2020 2320 6865              # he
-00010370: 7265 2074 6865 2075 7365 7220 6861 7320  re the user has 
-00010380: 7072 6f76 6964 6564 2061 2063 7573 746f  provided a custo
-00010390: 6d20 6c61 6265 6c0a 2020 2020 2020 2020  m label.        
-000103a0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000103b0: 5f6c 6162 656c 0a20 2020 2020 2020 2069  _label.        i
-000103c0: 6620 7573 655f 6c61 7465 783a 0a20 2020  f use_latex:.   
-000103d0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-000103e0: 2e5f 6c61 6265 6c20 213d 2073 7472 2873  ._label != str(s
-000103f0: 656c 662e 6578 7072 293a 0a20 2020 2020  elf.expr):.     
-00010400: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00010410: 6e20 7365 6c66 2e5f 6c61 7465 785f 6c61  n self._latex_la
-00010420: 6265 6c0a 2020 2020 2020 2020 2020 2020  bel.            
-00010430: 7265 7475 726e 2073 656c 662e 5f67 6574  return self._get
-00010440: 5f77 7261 7070 6564 5f6c 6162 656c 2873  _wrapped_label(s
-00010450: 656c 662e 5f6c 6174 6578 5f6c 6162 656c  elf._latex_label
-00010460: 2c20 7772 6170 7065 7229 0a20 2020 2020  , wrapper).     
-00010470: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00010480: 6c61 6265 6c0a 0a20 2020 2064 6566 205f  label..    def _
-00010490: 6765 745f 6461 7461 5f68 656c 7065 7228  get_data_helper(
-000104a0: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
-000104b0: 2222 5265 7475 726e 7320 636f 6f72 6469  ""Returns coordi
-000104c0: 6e61 7465 7320 7468 6174 206e 6565 6473  nates that needs
-000104d0: 2074 6f20 6265 2070 6f73 7470 726f 6365   to be postproce
-000104e0: 7373 6564 2e0a 2020 2020 2020 2020 4465  ssed..        De
-000104f0: 7065 6e64 696e 6720 6f6e 2074 6865 2060  pending on the `
-00010500: 6164 6170 7469 7665 6020 6f70 7469 6f6e  adaptive` option
-00010510: 2c20 7468 6973 2066 756e 6374 696f 6e20  , this function 
-00010520: 7769 6c6c 2065 6974 6865 7220 7573 6520  will either use 
-00010530: 616e 0a20 2020 2020 2020 2061 6461 7074  an.        adapt
-00010540: 6976 6520 616c 676f 7269 7468 6d20 6f72  ive algorithm or
-00010550: 2069 7420 7769 6c6c 2075 6e69 666f 726d   it will uniform
-00010560: 6c79 2073 616d 706c 6520 7468 6520 6578  ly sample the ex
-00010570: 7072 6573 7369 6f6e 206f 7665 7220 7468  pression over th
-00010580: 650a 2020 2020 2020 2020 7072 6f76 6964  e.        provid
-00010590: 6564 2072 616e 6765 2e0a 2020 2020 2020  ed range..      
-000105a0: 2020 2222 220a 2020 2020 2020 2020 6966    """.        if
-000105b0: 2073 656c 662e 6164 6170 7469 7665 3a0a   self.adaptive:.
-000105c0: 2020 2020 2020 2020 2020 2020 636f 6f72              coor
-000105d0: 6473 203d 2073 656c 662e 5f61 6461 7074  ds = self._adapt
-000105e0: 6976 655f 7361 6d70 6c69 6e67 2829 0a20  ive_sampling(). 
-000105f0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00010600: 2020 2020 2020 2020 2063 6f6f 7264 7320           coords 
-00010610: 3d20 7365 6c66 2e5f 756e 6966 6f72 6d5f  = self._uniform_
-00010620: 7361 6d70 6c69 6e67 2829 0a0a 2020 2020  sampling()..    
-00010630: 2020 2020 6966 2073 656c 662e 6973 5f32      if self.is_2
-00010640: 446c 696e 6520 616e 6420 7365 6c66 2e69  Dline and self.i
-00010650: 735f 706f 6c61 723a 0a20 2020 2020 2020  s_polar:.       
-00010660: 2020 2020 2023 2077 6865 6e20 706c 6f74       # when plot
-00010670: 5f70 6f6c 6172 2069 7320 6578 6563 7574  _polar is execut
-00010680: 6564 2077 6974 6820 706f 6c61 725f 6178  ed with polar_ax
-00010690: 6973 3d54 7275 650a 2020 2020 2020 2020  is=True.        
-000106a0: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
-000106b0: 6d6f 6475 6c65 2827 6e75 6d70 7927 290a  module('numpy').
-000106c0: 2020 2020 2020 2020 2020 2020 782c 2079              x, y
-000106d0: 2c20 5f20 3d20 636f 6f72 6473 0a20 2020  , _ = coords.   
-000106e0: 2020 2020 2020 2020 2072 203d 206e 702e           r = np.
-000106f0: 7371 7274 2878 2a2a 3220 2b20 792a 2a32  sqrt(x**2 + y**2
-00010700: 290a 2020 2020 2020 2020 2020 2020 7420  ).            t 
-00010710: 3d20 6e70 2e61 7263 7461 6e32 2879 2c20  = np.arctan2(y, 
-00010720: 7829 0a20 2020 2020 2020 2020 2020 2063  x).            c
-00010730: 6f6f 7264 7320 3d20 5b74 2c20 722c 2063  oords = [t, r, c
-00010740: 6f6f 7264 735b 2d31 5d5d 0a0a 2020 2020  oords[-1]]..    
-00010750: 2020 2020 6966 2063 616c 6c61 626c 6528      if callable(
-00010760: 7365 6c66 2e63 6f6c 6f72 5f66 756e 6329  self.color_func)
-00010770: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
-00010780: 6f72 6473 203d 206c 6973 7428 636f 6f72  ords = list(coor
-00010790: 6473 290a 2020 2020 2020 2020 2020 2020  ds).            
-000107a0: 636f 6f72 6473 5b2d 315d 203d 2073 656c  coords[-1] = sel
-000107b0: 662e 6576 616c 5f63 6f6c 6f72 5f66 756e  f.eval_color_fun
-000107c0: 6328 2a63 6f6f 7264 7329 0a0a 2020 2020  c(*coords)..    
-000107d0: 2020 2020 7265 7475 726e 2063 6f6f 7264      return coord
-000107e0: 730a 0a20 2020 2064 6566 205f 756e 6966  s..    def _unif
-000107f0: 6f72 6d5f 7361 6d70 6c69 6e67 2873 656c  orm_sampling(sel
-00010800: 6629 3a0a 2020 2020 2020 2020 2222 2252  f):.        """R
-00010810: 6574 7572 6e73 2063 6f6f 7264 696e 6174  eturns coordinat
-00010820: 6573 2074 6861 7420 6e65 6564 7320 746f  es that needs to
-00010830: 2062 6520 706f 7374 7072 6f63 6573 7365   be postprocesse
-00010840: 642e 2222 220a 2020 2020 2020 2020 6e70  d.""".        np
-00010850: 203d 2069 6d70 6f72 745f 6d6f 6475 6c65   = import_module
-00010860: 2827 6e75 6d70 7927 290a 0a20 2020 2020  ('numpy')..     
-00010870: 2020 2072 6573 756c 7473 203d 2073 656c     results = sel
-00010880: 662e 5f65 7661 6c75 6174 6528 290a 2020  f._evaluate().  
-00010890: 2020 2020 2020 666f 7220 692c 2072 2069        for i, r i
-000108a0: 6e20 656e 756d 6572 6174 6528 7265 7375  n enumerate(resu
-000108b0: 6c74 7329 3a0a 2020 2020 2020 2020 2020  lts):.          
-000108c0: 2020 5f72 652c 205f 696d 203d 206e 702e    _re, _im = np.
-000108d0: 7265 616c 2872 292c 206e 702e 696d 6167  real(r), np.imag
-000108e0: 2872 290a 2020 2020 2020 2020 2020 2020  (r).            
-000108f0: 5f72 655b 6e70 2e69 6e76 6572 7428 6e70  _re[np.invert(np
-00010900: 2e69 7363 6c6f 7365 285f 696d 2c20 6e70  .isclose(_im, np
-00010910: 2e7a 6572 6f73 5f6c 696b 6528 5f69 6d29  .zeros_like(_im)
-00010920: 2929 5d20 3d20 6e70 2e6e 616e 0a20 2020  ))] = np.nan.   
-00010930: 2020 2020 2020 2020 2072 6573 756c 7473           results
-00010940: 5b69 5d20 3d20 5f72 650a 0a20 2020 2020  [i] = _re..     
-00010950: 2020 2072 6574 7572 6e20 5b2a 7265 7375     return [*resu
-00010960: 6c74 735b 313a 5d2c 2072 6573 756c 7473  lts[1:], results
-00010970: 5b30 5d5d 0a0a 0a63 6c61 7373 2050 6172  [0]]...class Par
-00010980: 616d 6574 7269 6332 444c 696e 6553 6572  ametric2DLineSer
-00010990: 6965 7328 5061 7261 6d65 7472 6963 4c69  ies(ParametricLi
-000109a0: 6e65 4261 7365 5365 7269 6573 293a 0a20  neBaseSeries):. 
-000109b0: 2020 2022 2222 5265 7072 6573 656e 7461     """Representa
-000109c0: 7469 6f6e 2066 6f72 2061 206c 696e 6520  tion for a line 
-000109d0: 636f 6e73 6973 7469 6e67 206f 6620 7477  consisting of tw
-000109e0: 6f20 7061 7261 6d65 7472 6963 2073 796d  o parametric sym
-000109f0: 7079 2065 7870 7265 7373 696f 6e73 0a20  py expressions. 
-00010a00: 2020 206f 7665 7220 6120 7261 6e67 652e     over a range.
-00010a10: 2222 220a 0a20 2020 2069 735f 7061 7261  """..    is_para
-00010a20: 6d65 7472 6963 203d 2054 7275 650a 0a20  metric = True.. 
-00010a30: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
-00010a40: 7365 6c66 2c20 6578 7072 5f78 2c20 6578  self, expr_x, ex
-00010a50: 7072 5f79 2c20 7661 725f 7374 6172 745f  pr_y, var_start_
-00010a60: 656e 642c 206c 6162 656c 3d22 222c 202a  end, label="", *
-00010a70: 2a6b 7761 7267 7329 3a0a 2020 2020 2020  *kwargs):.      
-00010a80: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-00010a90: 5f5f 282a 2a6b 7761 7267 7329 0a20 2020  __(**kwargs).   
-00010aa0: 2020 2020 2073 656c 662e 6578 7072 5f78       self.expr_x
-00010ab0: 203d 2065 7870 725f 7820 6966 2063 616c   = expr_x if cal
-00010ac0: 6c61 626c 6528 6578 7072 5f78 2920 656c  lable(expr_x) el
-00010ad0: 7365 2073 796d 7069 6679 2865 7870 725f  se sympify(expr_
-00010ae0: 7829 0a20 2020 2020 2020 2073 656c 662e  x).        self.
-00010af0: 6578 7072 5f79 203d 2065 7870 725f 7920  expr_y = expr_y 
-00010b00: 6966 2063 616c 6c61 626c 6528 6578 7072  if callable(expr
-00010b10: 5f79 2920 656c 7365 2073 796d 7069 6679  _y) else sympify
-00010b20: 2865 7870 725f 7929 0a20 2020 2020 2020  (expr_y).       
-00010b30: 2073 656c 662e 6578 7072 203d 2028 7365   self.expr = (se
-00010b40: 6c66 2e65 7870 725f 782c 2073 656c 662e  lf.expr_x, self.
-00010b50: 6578 7072 5f79 290a 2020 2020 2020 2020  expr_y).        
-00010b60: 7365 6c66 2e72 616e 6765 7320 3d20 5b76  self.ranges = [v
-00010b70: 6172 5f73 7461 7274 5f65 6e64 5d0a 2020  ar_start_end].  
-00010b80: 2020 2020 2020 7365 6c66 2e5f 6361 7374        self._cast
-00010b90: 203d 2066 6c6f 6174 0a20 2020 2020 2020   = float.       
-00010ba0: 2073 656c 662e 7573 655f 636d 203d 206b   self.use_cm = k
-00010bb0: 7761 7267 732e 6765 7428 2275 7365 5f63  wargs.get("use_c
-00010bc0: 6d22 2c20 5472 7565 290a 2020 2020 2020  m", True).      
-00010bd0: 2020 7365 6c66 2e5f 7365 745f 7061 7261    self._set_para
-00010be0: 6d65 7472 6963 5f6c 696e 655f 6c61 6265  metric_line_labe
-00010bf0: 6c28 6c61 6265 6c29 0a20 2020 2020 2020  l(label).       
-00010c00: 2073 656c 662e 5f70 6f73 745f 696e 6974   self._post_init
-00010c10: 2829 0a0a 2020 2020 6465 6620 5f5f 7374  ()..    def __st
-00010c20: 725f 5f28 7365 6c66 293a 0a20 2020 2020  r__(self):.     
-00010c30: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00010c40: 7374 725f 6865 6c70 6572 280a 2020 2020  str_helper(.    
-00010c50: 2020 2020 2020 2020 2270 6172 616d 6574          "paramet
-00010c60: 7269 6320 6361 7274 6573 6961 6e20 6c69  ric cartesian li
-00010c70: 6e65 3a20 2825 732c 2025 7329 2066 6f72  ne: (%s, %s) for
-00010c80: 2025 7320 6f76 6572 2025 7322 2025 2028   %s over %s" % (
-00010c90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010ca0: 2073 7472 2873 656c 662e 6578 7072 5f78   str(self.expr_x
-00010cb0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00010cc0: 2020 2073 7472 2873 656c 662e 6578 7072     str(self.expr
-00010cd0: 5f79 292c 0a20 2020 2020 2020 2020 2020  _y),.           
-00010ce0: 2020 2020 2073 7472 2873 656c 662e 7661       str(self.va
-00010cf0: 7229 2c0a 2020 2020 2020 2020 2020 2020  r),.            
-00010d00: 2020 2020 7374 7228 2873 656c 662e 7374      str((self.st
-00010d10: 6172 742c 2073 656c 662e 656e 6429 290a  art, self.end)).
-00010d20: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00010d30: 2020 2020 2020 290a 0a0a 636c 6173 7320        )...class 
-00010d40: 5061 7261 6d65 7472 6963 3344 4c69 6e65  Parametric3DLine
-00010d50: 5365 7269 6573 2850 6172 616d 6574 7269  Series(Parametri
-00010d60: 634c 696e 6542 6173 6553 6572 6965 7329  cLineBaseSeries)
-00010d70: 3a0a 2020 2020 2222 2252 6570 7265 7365  :.    """Represe
-00010d80: 6e74 6174 696f 6e20 666f 7220 6120 3344  ntation for a 3D
-00010d90: 206c 696e 6520 636f 6e73 6973 7469 6e67   line consisting
-00010da0: 206f 6620 7468 7265 6520 7061 7261 6d65   of three parame
-00010db0: 7472 6963 2073 796d 7079 0a20 2020 2065  tric sympy.    e
-00010dc0: 7870 7265 7373 696f 6e73 2061 6e64 2061  xpressions and a
-00010dd0: 2072 616e 6765 2e22 2222 0a0a 2020 2020   range."""..    
-00010de0: 6973 5f32 446c 696e 6520 3d20 4661 6c73  is_2Dline = Fals
-00010df0: 650a 2020 2020 6973 5f33 446c 696e 6520  e.    is_3Dline 
-00010e00: 3d20 5472 7565 0a0a 2020 2020 6465 6620  = True..    def 
-00010e10: 5f5f 696e 6974 5f5f 280a 2020 2020 2020  __init__(.      
-00010e20: 2020 7365 6c66 2c20 6578 7072 5f78 2c20    self, expr_x, 
-00010e30: 6578 7072 5f79 2c20 6578 7072 5f7a 2c20  expr_y, expr_z, 
-00010e40: 7661 725f 7374 6172 745f 656e 642c 206c  var_start_end, l
-00010e50: 6162 656c 3d22 222c 202a 2a6b 7761 7267  abel="", **kwarg
-00010e60: 730a 2020 2020 293a 0a20 2020 2020 2020  s.    ):.       
-00010e70: 2073 7570 6572 2829 2e5f 5f69 6e69 745f   super().__init_
-00010e80: 5f28 2a2a 6b77 6172 6773 290a 2020 2020  _(**kwargs).    
-00010e90: 2020 2020 7365 6c66 2e65 7870 725f 7820      self.expr_x 
-00010ea0: 3d20 6578 7072 5f78 2069 6620 6361 6c6c  = expr_x if call
-00010eb0: 6162 6c65 2865 7870 725f 7829 2065 6c73  able(expr_x) els
-00010ec0: 6520 7379 6d70 6966 7928 6578 7072 5f78  e sympify(expr_x
-00010ed0: 290a 2020 2020 2020 2020 7365 6c66 2e65  ).        self.e
-00010ee0: 7870 725f 7920 3d20 6578 7072 5f79 2069  xpr_y = expr_y i
-00010ef0: 6620 6361 6c6c 6162 6c65 2865 7870 725f  f callable(expr_
-00010f00: 7929 2065 6c73 6520 7379 6d70 6966 7928  y) else sympify(
-00010f10: 6578 7072 5f79 290a 2020 2020 2020 2020  expr_y).        
-00010f20: 7365 6c66 2e65 7870 725f 7a20 3d20 6578  self.expr_z = ex
-00010f30: 7072 5f7a 2069 6620 6361 6c6c 6162 6c65  pr_z if callable
-00010f40: 2865 7870 725f 7a29 2065 6c73 6520 7379  (expr_z) else sy
-00010f50: 6d70 6966 7928 6578 7072 5f7a 290a 2020  mpify(expr_z).  
-00010f60: 2020 2020 2020 7365 6c66 2e65 7870 7220        self.expr 
-00010f70: 3d20 2873 656c 662e 6578 7072 5f78 2c20  = (self.expr_x, 
-00010f80: 7365 6c66 2e65 7870 725f 792c 2073 656c  self.expr_y, sel
-00010f90: 662e 6578 7072 5f7a 290a 2020 2020 2020  f.expr_z).      
-00010fa0: 2020 7365 6c66 2e72 616e 6765 7320 3d20    self.ranges = 
-00010fb0: 5b76 6172 5f73 7461 7274 5f65 6e64 5d0a  [var_start_end].
-00010fc0: 2020 2020 2020 2020 7365 6c66 2e5f 6361          self._ca
-00010fd0: 7374 203d 2066 6c6f 6174 0a20 2020 2020  st = float.     
-00010fe0: 2020 2073 656c 662e 7573 655f 636d 203d     self.use_cm =
-00010ff0: 206b 7761 7267 732e 6765 7428 2275 7365   kwargs.get("use
-00011000: 5f63 6d22 2c20 5472 7565 290a 2020 2020  _cm", True).    
-00011010: 2020 2020 7365 6c66 2e5f 7365 745f 7061      self._set_pa
-00011020: 7261 6d65 7472 6963 5f6c 696e 655f 6c61  rametric_line_la
-00011030: 6265 6c28 6c61 6265 6c29 0a20 2020 2020  bel(label).     
-00011040: 2020 2073 656c 662e 5f70 6f73 745f 696e     self._post_in
-00011050: 6974 2829 0a0a 2020 2020 6465 6620 5f5f  it()..    def __
-00011060: 7374 725f 5f28 7365 6c66 293a 0a20 2020  str__(self):.   
-00011070: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00011080: 2e5f 7374 725f 6865 6c70 6572 280a 2020  ._str_helper(.  
-00011090: 2020 2020 2020 2020 2020 2233 4420 7061            "3D pa
-000110a0: 7261 6d65 7472 6963 2063 6172 7465 7369  rametric cartesi
-000110b0: 616e 206c 696e 653a 2028 2573 2c20 2573  an line: (%s, %s
-000110c0: 2c20 2573 2920 666f 7220 2573 206f 7665  , %s) for %s ove
-000110d0: 7220 2573 2220 2520 280a 2020 2020 2020  r %s" % (.      
-000110e0: 2020 2020 2020 7374 7228 7365 6c66 2e65        str(self.e
-000110f0: 7870 725f 7829 2c0a 2020 2020 2020 2020  xpr_x),.        
-00011100: 2020 2020 7374 7228 7365 6c66 2e65 7870      str(self.exp
-00011110: 725f 7929 2c0a 2020 2020 2020 2020 2020  r_y),.          
-00011120: 2020 7374 7228 7365 6c66 2e65 7870 725f    str(self.expr_
-00011130: 7a29 2c0a 2020 2020 2020 2020 2020 2020  z),.            
-00011140: 7374 7228 7365 6c66 2e76 6172 292c 0a20  str(self.var),. 
-00011150: 2020 2020 2020 2020 2020 2073 7472 2828             str((
-00011160: 7365 6c66 2e73 7461 7274 2c20 7365 6c66  self.start, self
-00011170: 2e65 6e64 2929 0a20 2020 2020 2020 2029  .end)).        )
-00011180: 290a 0a0a 636c 6173 7320 5375 7266 6163  )...class Surfac
-00011190: 6542 6173 6553 6572 6965 7328 4261 7365  eBaseSeries(Base
-000111a0: 5365 7269 6573 293a 0a20 2020 2022 2222  Series):.    """
-000111b0: 4120 6261 7365 2063 6c61 7373 2066 6f72  A base class for
-000111c0: 2033 4420 7375 7266 6163 6573 2e22 2222   3D surfaces."""
-000111d0: 0a0a 2020 2020 6973 5f33 4473 7572 6661  ..    is_3Dsurfa
-000111e0: 6365 203d 2054 7275 650a 2020 2020 5f61  ce = True.    _a
-000111f0: 6c6c 6f77 6564 5f6b 6579 7320 3d20 5b22  llowed_keys = ["
-00011200: 7375 7266 6163 655f 636f 6c6f 7222 2c20  surface_color", 
-00011210: 2269 735f 706f 6c61 7222 5d0a 0a20 2020  "is_polar"]..   
-00011220: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
-00011230: 6c66 2c20 2a61 7267 732c 202a 2a6b 7761  lf, *args, **kwa
-00011240: 7267 7329 3a0a 2020 2020 2020 2020 7375  rgs):.        su
-00011250: 7065 7228 292e 5f5f 696e 6974 5f5f 282a  per().__init__(*
-00011260: 2a6b 7761 7267 7329 0a20 2020 2020 2020  *kwargs).       
-00011270: 2023 204e 4f54 453a 2077 6879 2073 686f   # NOTE: why sho
-00011280: 756c 6420 5375 7266 6163 654f 7665 7232  uld SurfaceOver2
-00011290: 4452 616e 6765 5365 7269 6573 2073 7570  DRangeSeries sup
-000112a0: 706f 7274 2069 7320 706f 6c61 723f 0a20  port is polar?. 
-000112b0: 2020 2020 2020 2023 2041 6674 6572 2061         # After a
-000112c0: 6c6c 2c20 7468 6520 7361 6d65 2072 6573  ll, the same res
-000112d0: 756c 7420 6361 6e20 6265 2061 6368 6965  ult can be achie
-000112e0: 7665 2077 6974 680a 2020 2020 2020 2020  ve with.        
-000112f0: 2320 5061 7261 6d65 7472 6963 5375 7266  # ParametricSurf
-00011300: 6163 6553 6572 6965 732e 2046 6f72 2065  aceSeries. For e
-00011310: 7861 6d70 6c65 3a0a 2020 2020 2020 2020  xample:.        
-00011320: 2320 7369 6e28 7229 2066 6f72 2028 722c  # sin(r) for (r,
-00011330: 2030 2c20 3220 2a20 7069 2920 616e 6420   0, 2 * pi) and 
-00011340: 2874 6865 7461 2c20 302c 2070 692f 3229  (theta, 0, pi/2)
-00011350: 2063 616e 2062 6520 7061 7261 6d65 7465   can be paramete
-00011360: 7269 7a65 640a 2020 2020 2020 2020 2320  rized.        # 
-00011370: 6173 2028 7220 2a20 636f 7328 7468 6574  as (r * cos(thet
-00011380: 6129 2c20 7220 2a20 7369 6e28 7468 6574  a), r * sin(thet
-00011390: 6129 2c20 7369 6e28 7429 2920 666f 7220  a), sin(t)) for 
-000113a0: 2872 2c20 302c 2032 202a 2070 6929 2061  (r, 0, 2 * pi) a
-000113b0: 6e64 0a20 2020 2020 2020 2023 2028 7468  nd.        # (th
-000113c0: 6574 612c 2030 2c20 7069 2f32 292e 0a20  eta, 0, pi/2).. 
-000113d0: 2020 2020 2020 2023 2042 6563 6175 7365         # Because
-000113e0: 2069 7420 6973 2066 6173 7465 7220 746f   it is faster to
-000113f0: 2065 7661 6c75 6174 6520 2869 6d70 6f72   evaluate (impor
-00011400: 7461 6e74 2066 6f72 2069 6e74 6572 6163  tant for interac
-00011410: 7469 7665 2070 6c6f 7473 292e 0a20 2020  tive plots)..   
-00011420: 2020 2020 2073 656c 662e 6973 5f70 6f6c       self.is_pol
-00011430: 6172 203d 206b 7761 7267 732e 6765 7428  ar = kwargs.get(
-00011440: 2269 735f 706f 6c61 7222 2c20 4661 6c73  "is_polar", Fals
-00011450: 6529 0a20 2020 2020 2020 2073 656c 662e  e).        self.
-00011460: 7375 7266 6163 655f 636f 6c6f 7220 3d20  surface_color = 
-00011470: 6b77 6172 6773 2e67 6574 2822 7375 7266  kwargs.get("surf
-00011480: 6163 655f 636f 6c6f 7222 2c20 4e6f 6e65  ace_color", None
-00011490: 290a 2020 2020 2020 2020 7365 6c66 2e63  ).        self.c
-000114a0: 6f6c 6f72 5f66 756e 6320 3d20 6b77 6172  olor_func = kwar
-000114b0: 6773 2e67 6574 2822 636f 6c6f 725f 6675  gs.get("color_fu
-000114c0: 6e63 222c 206c 616d 6264 6120 782c 2079  nc", lambda x, y
-000114d0: 2c20 7a3a 207a 290a 2020 2020 2020 2020  , z: z).        
-000114e0: 6966 2063 616c 6c61 626c 6528 7365 6c66  if callable(self
-000114f0: 2e73 7572 6661 6365 5f63 6f6c 6f72 293a  .surface_color):
-00011500: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00011510: 662e 636f 6c6f 725f 6675 6e63 203d 2073  f.color_func = s
-00011520: 656c 662e 7375 7266 6163 655f 636f 6c6f  elf.surface_colo
-00011530: 720a 2020 2020 2020 2020 2020 2020 7365  r.            se
-00011540: 6c66 2e73 7572 6661 6365 5f63 6f6c 6f72  lf.surface_color
-00011550: 203d 204e 6f6e 650a 0a20 2020 2064 6566   = None..    def
-00011560: 205f 7365 745f 7375 7266 6163 655f 6c61   _set_surface_la
-00011570: 6265 6c28 7365 6c66 2c20 6c61 6265 6c29  bel(self, label)
-00011580: 3a0a 2020 2020 2020 2020 6578 7072 7320  :.        exprs 
-00011590: 3d20 7365 6c66 2e65 7870 720a 2020 2020  = self.expr.    
-000115a0: 2020 2020 7365 6c66 2e5f 6c61 6265 6c20      self._label 
-000115b0: 3d20 7374 7228 6578 7072 7329 2069 6620  = str(exprs) if 
-000115c0: 6c61 6265 6c20 6973 204e 6f6e 6520 656c  label is None el
-000115d0: 7365 206c 6162 656c 0a20 2020 2020 2020  se label.       
-000115e0: 2073 656c 662e 5f6c 6174 6578 5f6c 6162   self._latex_lab
-000115f0: 656c 203d 206c 6174 6578 2865 7870 7273  el = latex(exprs
-00011600: 2920 6966 206c 6162 656c 2069 7320 4e6f  ) if label is No
-00011610: 6e65 2065 6c73 6520 6c61 6265 6c0a 2020  ne else label.  
-00011620: 2020 2020 2020 2320 6966 2074 6865 2065        # if the e
-00011630: 7870 7265 7373 696f 6e73 2069 7320 6120  xpressions is a 
-00011640: 6c61 6d62 6461 2066 756e 6374 696f 6e20  lambda function 
-00011650: 616e 6420 6e6f 206c 6162 656c 0a20 2020  and no label.   
-00011660: 2020 2020 2023 2068 6173 2062 6565 6e20       # has been 
-00011670: 7072 6f76 6964 6564 2c20 7468 656e 2069  provided, then i
-00011680: 7473 2062 6574 7465 7220 746f 2064 6f20  ts better to do 
-00011690: 7468 6520 666f 6c6c 6f77 696e 6720 746f  the following to
-000116a0: 2061 766f 6964 0a20 2020 2020 2020 2023   avoid.        #
-000116b0: 2073 7570 7269 7365 7320 6f6e 2074 6865   suprises on the
-000116c0: 2062 6163 6b65 6e64 0a20 2020 2020 2020   backend.       
-000116d0: 2069 735f 6c61 6d62 6461 203d 2028 6361   is_lambda = (ca
-000116e0: 6c6c 6162 6c65 2865 7870 7273 2920 6966  llable(exprs) if
-000116f0: 206e 6f74 2068 6173 6174 7472 2865 7870   not hasattr(exp
-00011700: 7273 2c20 225f 5f69 7465 725f 5f22 290a  rs, "__iter__").
-00011710: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00011720: 2061 6e79 2863 616c 6c61 626c 6528 6529   any(callable(e)
-00011730: 2066 6f72 2065 2069 6e20 6578 7072 7329   for e in exprs)
-00011740: 290a 2020 2020 2020 2020 6966 2069 735f  ).        if is_
-00011750: 6c61 6d62 6461 2061 6e64 2028 7365 6c66  lambda and (self
-00011760: 2e5f 6c61 6265 6c20 3d3d 2073 7472 2865  ._label == str(e
-00011770: 7870 7273 2929 3a0a 2020 2020 2020 2020  xprs)):.        
-00011780: 2020 2020 7365 6c66 2e5f 6c61 6265 6c20      self._label 
-00011790: 3d20 2222 0a20 2020 2020 2020 2020 2020  = "".           
-000117a0: 2073 656c 662e 5f6c 6174 6578 5f6c 6162   self._latex_lab
-000117b0: 656c 203d 2022 220a 0a20 2020 2040 7072  el = ""..    @pr
-000117c0: 6f70 6572 7479 0a20 2020 2064 6566 2073  operty.    def s
-000117d0: 7572 6661 6365 5f63 6f6c 6f72 2873 656c  urface_color(sel
-000117e0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
-000117f0: 726e 2073 656c 662e 5f73 7572 6661 6365  rn self._surface
-00011800: 5f63 6f6c 6f72 0a0a 2020 2020 4073 7572  _color..    @sur
-00011810: 6661 6365 5f63 6f6c 6f72 2e73 6574 7465  face_color.sette
-00011820: 720a 2020 2020 6465 6620 7375 7266 6163  r.    def surfac
-00011830: 655f 636f 6c6f 7228 7365 6c66 2c20 7661  e_color(self, va
-00011840: 6c29 3a0a 2020 2020 2020 2020 7365 6c66  l):.        self
-00011850: 2e5f 6c69 6e65 5f73 7572 6661 6365 5f63  ._line_surface_c
-00011860: 6f6c 6f72 2822 5f73 7572 6661 6365 5f63  olor("_surface_c
-00011870: 6f6c 6f72 222c 2076 616c 290a 0a0a 636c  olor", val)...cl
-00011880: 6173 7320 5375 7266 6163 654f 7665 7232  ass SurfaceOver2
-00011890: 4452 616e 6765 5365 7269 6573 280a 2020  DRangeSeries(.  
-000118a0: 2020 436f 6d6d 6f6e 4164 6170 7469 7665    CommonAdaptive
-000118b0: 4576 616c 7561 7469 6f6e 2c20 436f 6d6d  Evaluation, Comm
-000118c0: 6f6e 556e 6966 6f72 6d45 7661 6c75 6174  onUniformEvaluat
-000118d0: 696f 6e2c 2053 7572 6661 6365 4261 7365  ion, SurfaceBase
-000118e0: 5365 7269 6573 0a29 3a0a 2020 2020 2222  Series.):.    ""
-000118f0: 2252 6570 7265 7365 6e74 6174 696f 6e20  "Representation 
-00011900: 666f 7220 6120 3344 2073 7572 6661 6365  for a 3D surface
-00011910: 2063 6f6e 7369 7374 696e 6720 6f66 2061   consisting of a
-00011920: 2073 796d 7079 2065 7870 7265 7373 696f   sympy expressio
-00011930: 6e20 616e 6420 3244 0a20 2020 2072 616e  n and 2D.    ran
-00011940: 6765 2e22 2222 0a0a 2020 2020 6465 6620  ge."""..    def 
-00011950: 5f5f 696e 6974 5f5f 280a 2020 2020 2020  __init__(.      
-00011960: 2020 7365 6c66 2c20 6578 7072 2c20 7661    self, expr, va
-00011970: 725f 7374 6172 745f 656e 645f 782c 2076  r_start_end_x, v
-00011980: 6172 5f73 7461 7274 5f65 6e64 5f79 2c20  ar_start_end_y, 
-00011990: 6c61 6265 6c3d 2222 2c20 2a2a 6b77 6172  label="", **kwar
-000119a0: 6773 0a20 2020 2029 3a0a 2020 2020 2020  gs.    ):.      
-000119b0: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-000119c0: 5f5f 282a 2a6b 7761 7267 7329 0a20 2020  __(**kwargs).   
-000119d0: 2020 2020 2073 656c 662e 6578 7072 203d       self.expr =
-000119e0: 2065 7870 7220 6966 2063 616c 6c61 626c   expr if callabl
-000119f0: 6528 6578 7072 2920 656c 7365 2073 796d  e(expr) else sym
-00011a00: 7069 6679 2865 7870 7229 0a20 2020 2020  pify(expr).     
-00011a10: 2020 2073 656c 662e 7261 6e67 6573 203d     self.ranges =
-00011a20: 205b 7661 725f 7374 6172 745f 656e 645f   [var_start_end_
-00011a30: 782c 2076 6172 5f73 7461 7274 5f65 6e64  x, var_start_end
-00011a40: 5f79 5d0a 2020 2020 2020 2020 7365 6c66  _y].        self
-00011a50: 2e5f 7365 745f 7375 7266 6163 655f 6c61  ._set_surface_la
-00011a60: 6265 6c28 6c61 6265 6c29 0a20 2020 2020  bel(label).     
-00011a70: 2020 2073 656c 662e 5f70 6f73 745f 696e     self._post_in
-00011a80: 6974 2829 0a0a 2020 2020 4070 726f 7065  it()..    @prope
-00011a90: 7274 790a 2020 2020 6465 6620 7661 725f  rty.    def var_
-00011aa0: 7828 7365 6c66 293a 0a20 2020 2020 2020  x(self):.       
-00011ab0: 2072 6574 7572 6e20 7365 6c66 2e72 616e   return self.ran
-00011ac0: 6765 735b 305d 5b30 5d0a 0a20 2020 2040  ges[0][0]..    @
-00011ad0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-00011ae0: 2076 6172 5f79 2873 656c 6629 3a0a 2020   var_y(self):.  
-00011af0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00011b00: 662e 7261 6e67 6573 5b31 5d5b 305d 0a0a  f.ranges[1][0]..
-00011b10: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-00011b20: 2020 6465 6620 7374 6172 745f 7828 7365    def start_x(se
-00011b30: 6c66 293a 0a20 2020 2020 2020 2074 7279  lf):.        try
-00011b40: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00011b50: 7475 726e 2066 6c6f 6174 2873 656c 662e  turn float(self.
-00011b60: 7261 6e67 6573 5b30 5d5b 315d 290a 2020  ranges[0][1]).  
-00011b70: 2020 2020 2020 6578 6365 7074 2045 7863        except Exc
-00011b80: 6570 7469 6f6e 3a0a 2020 2020 2020 2020  eption:.        
-00011b90: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00011ba0: 7261 6e67 6573 5b30 5d5b 315d 0a0a 2020  ranges[0][1]..  
-00011bb0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00011bc0: 6465 6620 656e 645f 7828 7365 6c66 293a  def end_x(self):
-00011bd0: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
-00011be0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00011bf0: 2066 6c6f 6174 2873 656c 662e 7261 6e67   float(self.rang
-00011c00: 6573 5b30 5d5b 325d 290a 2020 2020 2020  es[0][2]).      
-00011c10: 2020 6578 6365 7074 2045 7863 6570 7469    except Excepti
-00011c20: 6f6e 3a0a 2020 2020 2020 2020 2020 2020  on:.            
-00011c30: 7265 7475 726e 2073 656c 662e 7261 6e67  return self.rang
-00011c40: 6573 5b30 5d5b 325d 0a0a 2020 2020 4070  es[0][2]..    @p
-00011c50: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00011c60: 7374 6172 745f 7928 7365 6c66 293a 0a20  start_y(self):. 
-00011c70: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-00011c80: 2020 2020 2020 2020 7265 7475 726e 2066          return f
-00011c90: 6c6f 6174 2873 656c 662e 7261 6e67 6573  loat(self.ranges
-00011ca0: 5b31 5d5b 315d 290a 2020 2020 2020 2020  [1][1]).        
-00011cb0: 6578 6365 7074 2045 7863 6570 7469 6f6e  except Exception
-00011cc0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00011cd0: 7475 726e 2073 656c 662e 7261 6e67 6573  turn self.ranges
-00011ce0: 5b31 5d5b 315d 0a0a 2020 2020 4070 726f  [1][1]..    @pro
-00011cf0: 7065 7274 790a 2020 2020 6465 6620 656e  perty.    def en
-00011d00: 645f 7928 7365 6c66 293a 0a20 2020 2020  d_y(self):.     
-00011d10: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
-00011d20: 2020 2020 7265 7475 726e 2066 6c6f 6174      return float
-00011d30: 2873 656c 662e 7261 6e67 6573 5b31 5d5b  (self.ranges[1][
-00011d40: 325d 290a 2020 2020 2020 2020 6578 6365  2]).        exce
-00011d50: 7074 2045 7863 6570 7469 6f6e 3a0a 2020  pt Exception:.  
-00011d60: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00011d70: 2073 656c 662e 7261 6e67 6573 5b31 5d5b   self.ranges[1][
-00011d80: 325d 0a0a 2020 2020 6465 6620 5f5f 7374  2]..    def __st
-00011d90: 725f 5f28 7365 6c66 293a 0a20 2020 2020  r__(self):.     
-00011da0: 2020 2073 6572 6965 735f 7479 7065 203d     series_type =
-00011db0: 2022 6361 7274 6573 6961 6e20 7375 7266   "cartesian surf
-00011dc0: 6163 6522 2069 6620 7365 6c66 2e69 735f  ace" if self.is_
-00011dd0: 3344 7375 7266 6163 6520 656c 7365 2022  3Dsurface else "
-00011de0: 636f 6e74 6f75 7222 0a20 2020 2020 2020  contour".       
-00011df0: 2072 6574 7572 6e20 7365 6c66 2e5f 7374   return self._st
-00011e00: 725f 6865 6c70 6572 280a 2020 2020 2020  r_helper(.      
-00011e10: 2020 2020 2020 7365 7269 6573 5f74 7970        series_typ
-00011e20: 6520 2b20 223a 2025 7320 666f 7222 2022  e + ": %s for" "
-00011e30: 2025 7320 6f76 6572 2025 7320 616e 6420   %s over %s and 
-00011e40: 2573 206f 7665 7220 2573 2220 2520 280a  %s over %s" % (.
-00011e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011e60: 7374 7228 7365 6c66 2e65 7870 7229 2c0a  str(self.expr),.
-00011e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011e80: 7374 7228 7365 6c66 2e76 6172 5f78 292c  str(self.var_x),
-00011e90: 2073 7472 2828 7365 6c66 2e73 7461 7274   str((self.start
-00011ea0: 5f78 2c20 7365 6c66 2e65 6e64 5f78 2929  _x, self.end_x))
-00011eb0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00011ec0: 2020 7374 7228 7365 6c66 2e76 6172 5f79    str(self.var_y
-00011ed0: 292c 2073 7472 2828 7365 6c66 2e73 7461  ), str((self.sta
-00011ee0: 7274 5f79 2c20 7365 6c66 2e65 6e64 5f79  rt_y, self.end_y
-00011ef0: 2929 2c0a 2020 2020 2020 2020 2020 2020  )),.            
-00011f00: 290a 2020 2020 2020 2020 290a 0a20 2020  ).        )..   
-00011f10: 2064 6566 205f 6164 6170 7469 7665 5f73   def _adaptive_s
-00011f20: 616d 706c 696e 6728 7365 6c66 293a 0a20  ampling(self):. 
-00011f30: 2020 2020 2020 206e 7020 3d20 696d 706f         np = impo
-00011f40: 7274 5f6d 6f64 756c 6528 276e 756d 7079  rt_module('numpy
-00011f50: 2729 0a0a 2020 2020 2020 2020 6465 6620  ')..        def 
-00011f60: 6675 6e63 2866 2c20 7879 293a 0a20 2020  func(f, xy):.   
-00011f70: 2020 2020 2020 2020 2074 7279 3a0a 2020           try:.  
-00011f80: 2020 2020 2020 2020 2020 2020 2020 7720                w 
-00011f90: 3d20 6628 2a5b 636f 6d70 6c65 7828 7429  = f(*[complex(t)
-00011fa0: 2066 6f72 2074 2069 6e20 7879 5d29 0a20   for t in xy]). 
-00011fb0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00011fc0: 6574 7572 6e20 772e 7265 616c 2069 6620  eturn w.real if 
-00011fd0: 6e70 2e69 7363 6c6f 7365 2877 2e69 6d61  np.isclose(w.ima
-00011fe0: 672c 2030 2920 656c 7365 206e 702e 6e61  g, 0) else np.na
-00011ff0: 6e0a 2020 2020 2020 2020 2020 2020 6578  n.            ex
-00012000: 6365 7074 2028 5a65 726f 4469 7669 7369  cept (ZeroDivisi
-00012010: 6f6e 4572 726f 722c 204f 7665 7266 6c6f  onError, Overflo
-00012020: 7745 7272 6f72 293a 0a20 2020 2020 2020  wError):.       
-00012030: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00012040: 6e70 2e6e 616e 0a0a 2020 2020 2020 2020  np.nan..        
-00012050: 7265 7475 726e 205f 6164 6170 7469 7665  return _adaptive
-00012060: 5f65 7661 6c28 0a20 2020 2020 2020 2020  _eval(.         
-00012070: 2020 2066 756e 632c 205b 7365 6c66 2e76     func, [self.v
-00012080: 6172 5f78 2c20 7365 6c66 2e76 6172 5f79  ar_x, self.var_y
-00012090: 5d2c 2073 656c 662e 6578 7072 2c0a 2020  ], self.expr,.  
-000120a0: 2020 2020 2020 2020 2020 5b28 7365 6c66            [(self
-000120b0: 2e73 7461 7274 5f78 2c20 7365 6c66 2e65  .start_x, self.e
-000120c0: 6e64 5f78 292c 2028 7365 6c66 2e73 7461  nd_x), (self.sta
-000120d0: 7274 5f79 2c20 7365 6c66 2e65 6e64 5f79  rt_y, self.end_y
-000120e0: 295d 2c0a 2020 2020 2020 2020 2020 2020  )],.            
-000120f0: 6d6f 6475 6c65 733d 7365 6c66 2e6d 6f64  modules=self.mod
-00012100: 756c 6573 2c0a 2020 2020 2020 2020 2020  ules,.          
-00012110: 2020 6164 6170 7469 7665 5f67 6f61 6c3d    adaptive_goal=
-00012120: 7365 6c66 2e61 6461 7074 6976 655f 676f  self.adaptive_go
-00012130: 616c 2c0a 2020 2020 2020 2020 2020 2020  al,.            
-00012140: 6c6f 7373 5f66 6e3d 7365 6c66 2e6c 6f73  loss_fn=self.los
-00012150: 735f 666e 290a 0a20 2020 2064 6566 205f  s_fn)..    def _
-00012160: 756e 6966 6f72 6d5f 7361 6d70 6c69 6e67  uniform_sampling
-00012170: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00012180: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
-00012190: 6c65 2827 6e75 6d70 7927 290a 0a20 2020  le('numpy')..   
-000121a0: 2020 2020 2072 6573 756c 7473 203d 2073       results = s
-000121b0: 656c 662e 5f65 7661 6c75 6174 6528 290a  elf._evaluate().
-000121c0: 2020 2020 2020 2020 666f 7220 692c 2072          for i, r
-000121d0: 2069 6e20 656e 756d 6572 6174 6528 7265   in enumerate(re
-000121e0: 7375 6c74 7329 3a0a 2020 2020 2020 2020  sults):.        
-000121f0: 2020 2020 5f72 652c 205f 696d 203d 206e      _re, _im = n
-00012200: 702e 7265 616c 2872 292c 206e 702e 696d  p.real(r), np.im
-00012210: 6167 2872 290a 2020 2020 2020 2020 2020  ag(r).          
-00012220: 2020 5f72 655b 6e70 2e69 6e76 6572 7428    _re[np.invert(
-00012230: 6e70 2e69 7363 6c6f 7365 285f 696d 2c20  np.isclose(_im, 
-00012240: 6e70 2e7a 6572 6f73 5f6c 696b 6528 5f69  np.zeros_like(_i
-00012250: 6d29 2929 5d20 3d20 6e70 2e6e 616e 0a20  m)))] = np.nan. 
-00012260: 2020 2020 2020 2020 2020 2072 6573 756c             resul
-00012270: 7473 5b69 5d20 3d20 5f72 650a 0a20 2020  ts[i] = _re..   
-00012280: 2020 2020 2072 6574 7572 6e20 7265 7375       return resu
-00012290: 6c74 730a 0a20 2020 2064 6566 2067 6574  lts..    def get
-000122a0: 5f64 6174 6128 7365 6c66 293a 0a20 2020  _data(self):.   
-000122b0: 2020 2020 2022 2222 5265 7475 726e 2061       """Return a
-000122c0: 7272 6179 7320 6f66 2063 6f6f 7264 696e  rrays of coordin
-000122d0: 6174 6573 2066 6f72 2070 6c6f 7474 696e  ates for plottin
-000122e0: 672e 2044 6570 656e 6469 6e67 206f 6e20  g. Depending on 
-000122f0: 7468 650a 2020 2020 2020 2020 6061 6461  the.        `ada
-00012300: 7074 6976 6560 206f 7074 696f 6e2c 2074  ptive` option, t
-00012310: 6869 7320 6675 6e63 7469 6f6e 2077 696c  his function wil
-00012320: 6c20 6569 7468 6572 2075 7365 2061 6e20  l either use an 
-00012330: 6164 6170 7469 7665 2061 6c67 6f72 6974  adaptive algorit
-00012340: 686d 0a20 2020 2020 2020 206f 7220 6974  hm.        or it
-00012350: 2077 696c 6c20 756e 6966 6f72 6d6c 7920   will uniformly 
-00012360: 7361 6d70 6c65 2074 6865 2065 7870 7265  sample the expre
-00012370: 7373 696f 6e20 6f76 6572 2074 6865 2070  ssion over the p
-00012380: 726f 7669 6465 6420 7261 6e67 652e 0a0a  rovided range...
-00012390: 2020 2020 2020 2020 5265 7475 726e 730a          Returns.
-000123a0: 2020 2020 2020 2020 3d3d 3d3d 3d3d 3d0a          =======.
-000123b0: 0a20 2020 2020 2020 206d 6573 685f 7820  .        mesh_x 
-000123c0: 3a20 6e70 2e6e 6461 7272 6179 205b 6e32  : np.ndarray [n2
-000123d0: 2078 206e 315d 0a20 2020 2020 2020 2020   x n1].         
-000123e0: 2020 2052 6561 6c20 4469 7363 7265 7469     Real Discreti
-000123f0: 7a65 6420 782d 646f 6d61 696e 2e0a 0a20  zed x-domain... 
-00012400: 2020 2020 2020 206d 6573 685f 7920 3a20         mesh_y : 
-00012410: 6e70 2e6e 6461 7272 6179 205b 6e32 2078  np.ndarray [n2 x
-00012420: 206e 315d 0a20 2020 2020 2020 2020 2020   n1].           
-00012430: 2052 6561 6c20 4469 7363 7265 7469 7a65   Real Discretize
-00012440: 6420 792d 646f 6d61 696e 2e0a 0a20 2020  d y-domain...   
-00012450: 2020 2020 207a 203a 206e 702e 6e64 6172       z : np.ndar
-00012460: 7261 7920 5b6e 3220 7820 6e31 5d0a 2020  ray [n2 x n1].  
-00012470: 2020 2020 2020 2020 2020 5265 7375 6c74            Result
-00012480: 7320 6f66 2074 6865 2065 7661 6c75 6174  s of the evaluat
-00012490: 696f 6e2e 0a20 2020 2020 2020 2022 2222  ion..        """
-000124a0: 0a20 2020 2020 2020 206e 7020 3d20 696d  .        np = im
-000124b0: 706f 7274 5f6d 6f64 756c 6528 276e 756d  port_module('num
-000124c0: 7079 2729 0a0a 2020 2020 2020 2020 6966  py')..        if
-000124d0: 2073 656c 662e 6164 6170 7469 7665 3a0a   self.adaptive:.
-000124e0: 2020 2020 2020 2020 2020 2020 7265 7320              res 
-000124f0: 3d20 7365 6c66 2e5f 6164 6170 7469 7665  = self._adaptive
-00012500: 5f73 616d 706c 696e 6728 290a 2020 2020  _sampling().    
-00012510: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00012520: 2020 2020 2020 7265 7320 3d20 7365 6c66        res = self
-00012530: 2e5f 756e 6966 6f72 6d5f 7361 6d70 6c69  ._uniform_sampli
-00012540: 6e67 2829 0a0a 2020 2020 2020 2020 782c  ng()..        x,
-00012550: 2079 2c20 7a20 3d20 7265 730a 2020 2020   y, z = res.    
-00012560: 2020 2020 6966 2073 656c 662e 6973 5f70      if self.is_p
-00012570: 6f6c 6172 2061 6e64 2073 656c 662e 6973  olar and self.is
-00012580: 5f33 4473 7572 6661 6365 3a0a 2020 2020  _3Dsurface:.    
-00012590: 2020 2020 2020 2020 7220 3d20 782e 636f          r = x.co
-000125a0: 7079 2829 0a20 2020 2020 2020 2020 2020  py().           
-000125b0: 2078 203d 2072 202a 206e 702e 636f 7328   x = r * np.cos(
-000125c0: 7929 0a20 2020 2020 2020 2020 2020 2079  y).            y
-000125d0: 203d 2072 202a 206e 702e 7369 6e28 7929   = r * np.sin(y)
-000125e0: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-000125f0: 2073 656c 662e 5f61 7070 6c79 5f74 7261   self._apply_tra
-00012600: 6e73 666f 726d 2878 2c20 792c 207a 290a  nsform(x, y, z).
-00012610: 0a0a 636c 6173 7320 5061 7261 6d65 7472  ..class Parametr
-00012620: 6963 5375 7266 6163 6553 6572 6965 7328  icSurfaceSeries(
-00012630: 0a20 2020 2043 6f6d 6d6f 6e55 6e69 666f  .    CommonUnifo
-00012640: 726d 4576 616c 7561 7469 6f6e 2c20 5375  rmEvaluation, Su
-00012650: 7266 6163 6542 6173 6553 6572 6965 730a  rfaceBaseSeries.
-00012660: 293a 0a20 2020 2022 2222 5265 7072 6573  ):.    """Repres
-00012670: 656e 7461 7469 6f6e 2066 6f72 2061 2033  entation for a 3
-00012680: 4420 7375 7266 6163 6520 636f 6e73 6973  D surface consis
-00012690: 7469 6e67 206f 6620 7468 7265 6520 7061  ting of three pa
-000126a0: 7261 6d65 7472 6963 2073 796d 7079 0a20  rametric sympy. 
-000126b0: 2020 2065 7870 7265 7373 696f 6e73 2061     expressions a
-000126c0: 6e64 2061 2072 616e 6765 2e22 2222 0a0a  nd a range."""..
-000126d0: 2020 2020 6973 5f70 6172 616d 6574 7269      is_parametri
-000126e0: 6320 3d20 5472 7565 0a0a 2020 2020 6465  c = True..    de
-000126f0: 6620 5f5f 696e 6974 5f5f 280a 2020 2020  f __init__(.    
-00012700: 2020 2020 7365 6c66 2c20 6578 7072 5f78      self, expr_x
-00012710: 2c20 6578 7072 5f79 2c20 6578 7072 5f7a  , expr_y, expr_z
-00012720: 2c0a 2020 2020 2020 2020 7661 725f 7374  ,.        var_st
-00012730: 6172 745f 656e 645f 752c 2076 6172 5f73  art_end_u, var_s
-00012740: 7461 7274 5f65 6e64 5f76 2c20 6c61 6265  tart_end_v, labe
-00012750: 6c3d 2222 2c20 2a2a 6b77 6172 6773 0a20  l="", **kwargs. 
-00012760: 2020 2029 3a0a 2020 2020 2020 2020 7375     ):.        su
-00012770: 7065 7228 292e 5f5f 696e 6974 5f5f 282a  per().__init__(*
-00012780: 2a6b 7761 7267 7329 0a20 2020 2020 2020  *kwargs).       
-00012790: 2073 656c 662e 6578 7072 5f78 203d 2065   self.expr_x = e
-000127a0: 7870 725f 7820 6966 2063 616c 6c61 626c  xpr_x if callabl
-000127b0: 6528 6578 7072 5f78 2920 656c 7365 2073  e(expr_x) else s
-000127c0: 796d 7069 6679 2865 7870 725f 7829 0a20  ympify(expr_x). 
-000127d0: 2020 2020 2020 2073 656c 662e 6578 7072         self.expr
-000127e0: 5f79 203d 2065 7870 725f 7920 6966 2063  _y = expr_y if c
-000127f0: 616c 6c61 626c 6528 6578 7072 5f79 2920  allable(expr_y) 
-00012800: 656c 7365 2073 796d 7069 6679 2865 7870  else sympify(exp
-00012810: 725f 7929 0a20 2020 2020 2020 2073 656c  r_y).        sel
-00012820: 662e 6578 7072 5f7a 203d 2065 7870 725f  f.expr_z = expr_
-00012830: 7a20 6966 2063 616c 6c61 626c 6528 6578  z if callable(ex
-00012840: 7072 5f7a 2920 656c 7365 2073 796d 7069  pr_z) else sympi
-00012850: 6679 2865 7870 725f 7a29 0a20 2020 2020  fy(expr_z).     
-00012860: 2020 2073 656c 662e 6578 7072 203d 2028     self.expr = (
-00012870: 7365 6c66 2e65 7870 725f 782c 2073 656c  self.expr_x, sel
-00012880: 662e 6578 7072 5f79 2c20 7365 6c66 2e65  f.expr_y, self.e
-00012890: 7870 725f 7a29 0a20 2020 2020 2020 2073  xpr_z).        s
-000128a0: 656c 662e 7261 6e67 6573 203d 205b 7661  elf.ranges = [va
-000128b0: 725f 7374 6172 745f 656e 645f 752c 2076  r_start_end_u, v
-000128c0: 6172 5f73 7461 7274 5f65 6e64 5f76 5d0a  ar_start_end_v].
-000128d0: 2020 2020 2020 2020 7365 6c66 2e63 6f6c          self.col
-000128e0: 6f72 5f66 756e 6320 3d20 6b77 6172 6773  or_func = kwargs
-000128f0: 2e67 6574 2822 636f 6c6f 725f 6675 6e63  .get("color_func
-00012900: 222c 206c 616d 6264 6120 782c 2079 2c20  ", lambda x, y, 
-00012910: 7a2c 2075 2c20 763a 207a 290a 2020 2020  z, u, v: z).    
-00012920: 2020 2020 7365 6c66 2e5f 7365 745f 7375      self._set_su
-00012930: 7266 6163 655f 6c61 6265 6c28 6c61 6265  rface_label(labe
-00012940: 6c29 0a20 2020 2020 2020 2073 656c 662e  l).        self.
-00012950: 5f70 6f73 745f 696e 6974 2829 0a0a 2020  _post_init()..  
-00012960: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00012970: 6465 6620 7661 725f 7528 7365 6c66 293a  def var_u(self):
-00012980: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00012990: 7365 6c66 2e72 616e 6765 735b 305d 5b30  self.ranges[0][0
-000129a0: 5d0a 0a20 2020 2040 7072 6f70 6572 7479  ]..    @property
-000129b0: 0a20 2020 2064 6566 2076 6172 5f76 2873  .    def var_v(s
-000129c0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-000129d0: 7475 726e 2073 656c 662e 7261 6e67 6573  turn self.ranges
-000129e0: 5b31 5d5b 305d 0a0a 2020 2020 4070 726f  [1][0]..    @pro
-000129f0: 7065 7274 790a 2020 2020 6465 6620 7374  perty.    def st
-00012a00: 6172 745f 7528 7365 6c66 293a 0a20 2020  art_u(self):.   
-00012a10: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
-00012a20: 2020 2020 2020 7265 7475 726e 2066 6c6f        return flo
-00012a30: 6174 2873 656c 662e 7261 6e67 6573 5b30  at(self.ranges[0
-00012a40: 5d5b 315d 290a 2020 2020 2020 2020 6578  ][1]).        ex
-00012a50: 6365 7074 2045 7863 6570 7469 6f6e 3a0a  cept Exception:.
-00012a60: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00012a70: 726e 2073 656c 662e 7261 6e67 6573 5b30  rn self.ranges[0
-00012a80: 5d5b 315d 0a0a 2020 2020 4070 726f 7065  ][1]..    @prope
-00012a90: 7274 790a 2020 2020 6465 6620 656e 645f  rty.    def end_
-00012aa0: 7528 7365 6c66 293a 0a20 2020 2020 2020  u(self):.       
-00012ab0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
-00012ac0: 2020 7265 7475 726e 2066 6c6f 6174 2873    return float(s
-00012ad0: 656c 662e 7261 6e67 6573 5b30 5d5b 325d  elf.ranges[0][2]
-00012ae0: 290a 2020 2020 2020 2020 6578 6365 7074  ).        except
-00012af0: 2045 7863 6570 7469 6f6e 3a0a 2020 2020   Exception:.    
-00012b00: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00012b10: 656c 662e 7261 6e67 6573 5b30 5d5b 325d  elf.ranges[0][2]
-00012b20: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-00012b30: 2020 2020 6465 6620 7374 6172 745f 7628      def start_v(
-00012b40: 7365 6c66 293a 0a20 2020 2020 2020 2074  self):.        t
-00012b50: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-00012b60: 7265 7475 726e 2066 6c6f 6174 2873 656c  return float(sel
-00012b70: 662e 7261 6e67 6573 5b31 5d5b 315d 290a  f.ranges[1][1]).
-00012b80: 2020 2020 2020 2020 6578 6365 7074 2045          except E
-00012b90: 7863 6570 7469 6f6e 3a0a 2020 2020 2020  xception:.      
-00012ba0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00012bb0: 662e 7261 6e67 6573 5b31 5d5b 315d 0a0a  f.ranges[1][1]..
-00012bc0: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-00012bd0: 2020 6465 6620 656e 645f 7628 7365 6c66    def end_v(self
-00012be0: 293a 0a20 2020 2020 2020 2074 7279 3a0a  ):.        try:.
-00012bf0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00012c00: 726e 2066 6c6f 6174 2873 656c 662e 7261  rn float(self.ra
-00012c10: 6e67 6573 5b31 5d5b 325d 290a 2020 2020  nges[1][2]).    
-00012c20: 2020 2020 6578 6365 7074 2045 7863 6570      except Excep
-00012c30: 7469 6f6e 3a0a 2020 2020 2020 2020 2020  tion:.          
-00012c40: 2020 7265 7475 726e 2073 656c 662e 7261    return self.ra
-00012c50: 6e67 6573 5b31 5d5b 325d 0a0a 2020 2020  nges[1][2]..    
-00012c60: 6465 6620 5f5f 7374 725f 5f28 7365 6c66  def __str__(self
-00012c70: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-00012c80: 6e20 7365 6c66 2e5f 7374 725f 6865 6c70  n self._str_help
-00012c90: 6572 280a 2020 2020 2020 2020 2020 2020  er(.            
-00012ca0: 2270 6172 616d 6574 7269 6320 6361 7274  "parametric cart
-00012cb0: 6573 6961 6e20 7375 7266 6163 653a 2028  esian surface: (
-00012cc0: 2573 2c20 2573 2c20 2573 2920 666f 7222  %s, %s, %s) for"
-00012cd0: 0a20 2020 2020 2020 2020 2020 2022 2025  .            " %
-00012ce0: 7320 6f76 6572 2025 7320 616e 6420 2573  s over %s and %s
-00012cf0: 206f 7665 7220 2573 2220 2520 280a 2020   over %s" % (.  
-00012d00: 2020 2020 2020 2020 2020 2020 2020 7374                st
-00012d10: 7228 7365 6c66 2e65 7870 725f 7829 2c20  r(self.expr_x), 
-00012d20: 7374 7228 7365 6c66 2e65 7870 725f 7929  str(self.expr_y)
-00012d30: 2c20 7374 7228 7365 6c66 2e65 7870 725f  , str(self.expr_
-00012d40: 7a29 2c0a 2020 2020 2020 2020 2020 2020  z),.            
-00012d50: 2020 2020 7374 7228 7365 6c66 2e76 6172      str(self.var
-00012d60: 5f75 292c 2073 7472 2828 7365 6c66 2e73  _u), str((self.s
-00012d70: 7461 7274 5f75 2c20 7365 6c66 2e65 6e64  tart_u, self.end
-00012d80: 5f75 2929 2c0a 2020 2020 2020 2020 2020  _u)),.          
-00012d90: 2020 2020 2020 7374 7228 7365 6c66 2e76        str(self.v
-00012da0: 6172 5f76 292c 2073 7472 2828 7365 6c66  ar_v), str((self
-00012db0: 2e73 7461 7274 5f76 2c20 7365 6c66 2e65  .start_v, self.e
-00012dc0: 6e64 5f76 2929 2c0a 2020 2020 2020 2020  nd_v)),.        
-00012dd0: 2020 2020 290a 2020 2020 2020 2020 290a      ).        ).
-00012de0: 0a20 2020 2064 6566 2067 6574 5f64 6174  .    def get_dat
-00012df0: 6128 7365 6c66 293a 0a20 2020 2020 2020  a(self):.       
-00012e00: 2022 2222 5265 7475 726e 2061 7272 6179   """Return array
-00012e10: 7320 6f66 2063 6f6f 7264 696e 6174 6573  s of coordinates
-00012e20: 2066 6f72 2070 6c6f 7474 696e 672e 2044   for plotting. D
-00012e30: 6570 656e 6469 6e67 206f 6e20 7468 650a  epending on the.
-00012e40: 2020 2020 2020 2020 6061 6461 7074 6976          `adaptiv
-00012e50: 6560 206f 7074 696f 6e2c 2074 6869 7320  e` option, this 
-00012e60: 6675 6e63 7469 6f6e 2077 696c 6c20 6569  function will ei
-00012e70: 7468 6572 2075 7365 2061 6e20 6164 6170  ther use an adap
-00012e80: 7469 7665 2061 6c67 6f72 6974 686d 0a20  tive algorithm. 
-00012e90: 2020 2020 2020 206f 7220 6974 2077 696c         or it wil
-00012ea0: 6c20 756e 6966 6f72 6d6c 7920 7361 6d70  l uniformly samp
-00012eb0: 6c65 2074 6865 2065 7870 7265 7373 696f  le the expressio
-00012ec0: 6e20 6f76 6572 2074 6865 2070 726f 7669  n over the provi
-00012ed0: 6465 6420 7261 6e67 652e 0a0a 2020 2020  ded range...    
-00012ee0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-00012ef0: 2020 2020 3d3d 3d3d 3d3d 3d0a 0a20 2020      =======..   
-00012f00: 2020 2020 2078 203a 206e 702e 6e64 6172       x : np.ndar
-00012f10: 7261 7920 5b6e 3220 7820 6e31 5d0a 2020  ray [n2 x n1].  
-00012f20: 2020 2020 2020 2020 2020 782d 636f 6f72            x-coor
-00012f30: 6469 6e61 7465 732e 0a20 2020 2020 2020  dinates..       
-00012f40: 2079 203a 206e 702e 6e64 6172 7261 7920   y : np.ndarray 
-00012f50: 5b6e 3220 7820 6e31 5d0a 2020 2020 2020  [n2 x n1].      
-00012f60: 2020 2020 2020 792d 636f 6f72 6469 6e61        y-coordina
-00012f70: 7465 732e 0a20 2020 2020 2020 207a 203a  tes..        z :
-00012f80: 206e 702e 6e64 6172 7261 7920 5b6e 3220   np.ndarray [n2 
-00012f90: 7820 6e31 5d0a 2020 2020 2020 2020 2020  x n1].          
-00012fa0: 2020 7a2d 636f 6f72 6469 6e61 7465 732e    z-coordinates.
-00012fb0: 0a20 2020 2020 2020 206d 6573 685f 7520  .        mesh_u 
-00012fc0: 3a20 6e70 2e6e 6461 7272 6179 205b 6e32  : np.ndarray [n2
-00012fd0: 2078 206e 315d 0a20 2020 2020 2020 2020   x n1].         
-00012fe0: 2020 2044 6973 6372 6574 697a 6564 2075     Discretized u
-00012ff0: 2072 616e 6765 2e0a 2020 2020 2020 2020   range..        
-00013000: 6d65 7368 5f76 203a 206e 702e 6e64 6172  mesh_v : np.ndar
-00013010: 7261 7920 5b6e 3220 7820 6e31 5d0a 2020  ray [n2 x n1].  
-00013020: 2020 2020 2020 2020 2020 4469 7363 7265            Discre
-00013030: 7469 7a65 6420 7620 7261 6e67 652e 0a20  tized v range.. 
-00013040: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00013050: 2020 206e 7020 3d20 696d 706f 7274 5f6d     np = import_m
-00013060: 6f64 756c 6528 276e 756d 7079 2729 0a0a  odule('numpy')..
-00013070: 2020 2020 2020 2020 7265 7375 6c74 7320          results 
-00013080: 3d20 7365 6c66 2e5f 6576 616c 7561 7465  = self._evaluate
-00013090: 2829 0a20 2020 2020 2020 2066 6f72 2069  ().        for i
-000130a0: 2c20 7220 696e 2065 6e75 6d65 7261 7465  , r in enumerate
-000130b0: 2872 6573 756c 7473 293a 0a20 2020 2020  (results):.     
-000130c0: 2020 2020 2020 205f 7265 2c20 5f69 6d20         _re, _im 
-000130d0: 3d20 6e70 2e72 6561 6c28 7229 2c20 6e70  = np.real(r), np
-000130e0: 2e69 6d61 6728 7229 0a20 2020 2020 2020  .imag(r).       
-000130f0: 2020 2020 205f 7265 5b6e 702e 696e 7665       _re[np.inve
-00013100: 7274 286e 702e 6973 636c 6f73 6528 5f69  rt(np.isclose(_i
-00013110: 6d2c 206e 702e 7a65 726f 735f 6c69 6b65  m, np.zeros_like
-00013120: 285f 696d 2929 295d 203d 206e 702e 6e61  (_im)))] = np.na
-00013130: 6e0a 2020 2020 2020 2020 2020 2020 7265  n.            re
-00013140: 7375 6c74 735b 695d 203d 205f 7265 0a0a  sults[i] = _re..
-00013150: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00013160: 656c 662e 5f61 7070 6c79 5f74 7261 6e73  elf._apply_trans
-00013170: 666f 726d 282a 7265 7375 6c74 735b 323a  form(*results[2:
-00013180: 5d2c 202a 7265 7375 6c74 735b 3a32 5d29  ], *results[:2])
-00013190: 0a0a 0a63 6c61 7373 2043 6f6e 746f 7572  ...class Contour
-000131a0: 5365 7269 6573 2853 7572 6661 6365 4f76  Series(SurfaceOv
-000131b0: 6572 3244 5261 6e67 6553 6572 6965 7329  er2DRangeSeries)
-000131c0: 3a0a 2020 2020 2222 2252 6570 7265 7365  :.    """Represe
-000131d0: 6e74 6174 696f 6e20 666f 7220 6120 636f  ntation for a co
-000131e0: 6e74 6f75 7220 706c 6f74 2e22 2222 0a0a  ntour plot."""..
-000131f0: 2020 2020 6973 5f33 4473 7572 6661 6365      is_3Dsurface
-00013200: 203d 2046 616c 7365 0a20 2020 2069 735f   = False.    is_
-00013210: 636f 6e74 6f75 7220 3d20 5472 7565 0a20  contour = True. 
-00013220: 2020 205f 616c 6c6f 7765 645f 6b65 7973     _allowed_keys
-00013230: 203d 205b 0a20 2020 2020 2020 2022 636f   = [.        "co
-00013240: 6e74 6f75 725f 6b77 222c 2022 6973 5f66  ntour_kw", "is_f
-00013250: 696c 6c65 6422 2c20 2266 696c 6c22 2c20  illed", "fill", 
-00013260: 2263 6c61 6265 6c73 225d 0a0a 2020 2020  "clabels"]..    
-00013270: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00013280: 662c 202a 6172 6773 2c20 2a2a 6b77 6172  f, *args, **kwar
-00013290: 6773 293a 0a20 2020 2020 2020 2073 7570  gs):.        sup
-000132a0: 6572 2829 2e5f 5f69 6e69 745f 5f28 2a61  er().__init__(*a
-000132b0: 7267 732c 202a 2a6b 7761 7267 7329 0a20  rgs, **kwargs). 
-000132c0: 2020 2020 2020 2073 656c 662e 6973 5f66         self.is_f
-000132d0: 696c 6c65 6420 3d20 6b77 6172 6773 2e67  illed = kwargs.g
-000132e0: 6574 2822 6973 5f66 696c 6c65 6422 2c20  et("is_filled", 
-000132f0: 6b77 6172 6773 2e67 6574 2822 6669 6c6c  kwargs.get("fill
-00013300: 222c 2054 7275 6529 290a 2020 2020 2020  ", True)).      
-00013310: 2020 7365 6c66 2e73 686f 775f 636c 6162    self.show_clab
-00013320: 656c 7320 3d20 6b77 6172 6773 2e67 6574  els = kwargs.get
-00013330: 2822 636c 6162 656c 7322 2c20 5472 7565  ("clabels", True
-00013340: 290a 0a20 2020 2020 2020 2023 204e 4f54  )..        # NOT
-00013350: 453a 2063 6f6e 746f 7572 2070 6c6f 7473  E: contour plots
-00013360: 2061 7265 2075 7365 6420 6279 2070 6c6f   are used by plo
-00013370: 745f 636f 6e74 6f75 722c 2070 6c6f 745f  t_contour, plot_
-00013380: 7665 6374 6f72 2061 6e64 0a20 2020 2020  vector and.     
-00013390: 2020 2023 2070 6c6f 745f 636f 6d70 6c65     # plot_comple
-000133a0: 785f 7665 6374 6f72 2e20 4279 2069 6d70  x_vector. By imp
-000133b0: 6c65 6d65 6e74 696e 6720 636f 6e74 6f75  lementing contou
-000133c0: 725f 6b77 2077 6520 6172 6520 6162 6c65  r_kw we are able
-000133d0: 2074 6f0a 2020 2020 2020 2020 2320 7175   to.        # qu
-000133e0: 6963 6b6c 7920 7461 7267 6574 2074 6865  ickly target the
-000133f0: 2063 6f6e 746f 7572 2070 6c6f 742e 0a20   contour plot.. 
-00013400: 2020 2020 2020 2073 656c 662e 7265 6e64         self.rend
-00013410: 6572 696e 675f 6b77 203d 206b 7761 7267  ering_kw = kwarg
-00013420: 732e 6765 7428 0a20 2020 2020 2020 2020  s.get(.         
-00013430: 2020 2022 636f 6e74 6f75 725f 6b77 222c     "contour_kw",
-00013440: 206b 7761 7267 732e 6765 7428 2272 656e   kwargs.get("ren
-00013450: 6465 7269 6e67 5f6b 7722 2c20 6469 6374  dering_kw", dict
-00013460: 2829 2929 0a0a 0a63 6c61 7373 2049 6d70  ()))...class Imp
-00013470: 6c69 6369 7453 6572 6965 7328 0a20 2020  licitSeries(.   
-00013480: 2043 6f6d 6d6f 6e55 6e69 666f 726d 4576   CommonUniformEv
-00013490: 616c 7561 7469 6f6e 2c20 4261 7365 5365  aluation, BaseSe
-000134a0: 7269 6573 0a29 3a0a 2020 2020 2222 2252  ries.):.    """R
-000134b0: 6570 7265 7365 6e74 6174 696f 6e20 666f  epresentation fo
-000134c0: 7220 496d 706c 6963 6974 2070 6c6f 740a  r Implicit plot.
-000134d0: 0a20 2020 2052 6566 6572 656e 6365 730a  .    References.
-000134e0: 2020 2020 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a      ==========..
-000134f0: 2020 2020 2e2e 205b 315d 204a 6566 6672      .. [1] Jeffr
-00013500: 6579 2041 6c6c 656e 2054 7570 7065 722e  ey Allen Tupper.
-00013510: 2052 656c 6961 626c 6520 5477 6f2d 4469   Reliable Two-Di
-00013520: 6d65 6e73 696f 6e61 6c20 4772 6170 6869  mensional Graphi
-00013530: 6e67 204d 6574 686f 6473 2066 6f72 0a20  ng Methods for. 
-00013540: 2020 204d 6174 6865 6d61 7469 6361 6c20     Mathematical 
-00013550: 466f 726d 756c 6165 2077 6974 6820 5477  Formulae with Tw
-00013560: 6f20 4672 6565 2056 6172 6961 626c 6573  o Free Variables
-00013570: 2e0a 0a20 2020 202e 2e20 5b32 5d20 4a65  ...    .. [2] Je
-00013580: 6666 7265 7920 416c 6c65 6e20 5475 7070  ffrey Allen Tupp
-00013590: 6572 2e20 4772 6170 6869 6e67 2045 7175  er. Graphing Equ
-000135a0: 6174 696f 6e73 2077 6974 6820 4765 6e65  ations with Gene
-000135b0: 7261 6c69 7a65 6420 496e 7465 7276 616c  ralized Interval
-000135c0: 0a20 2020 2041 7269 7468 6d65 7469 632e  .    Arithmetic.
-000135d0: 204d 6173 7465 7227 7320 7468 6573 6973   Master's thesis
-000135e0: 2e20 556e 6976 6572 7369 7479 206f 6620  . University of 
-000135f0: 546f 726f 6e74 6f2c 2031 3939 360a 2020  Toronto, 1996.  
-00013600: 2020 2222 220a 0a20 2020 2069 735f 696d    """..    is_im
-00013610: 706c 6963 6974 203d 2054 7275 650a 2020  plicit = True.  
-00013620: 2020 7573 655f 636d 203d 2046 616c 7365    use_cm = False
-00013630: 0a20 2020 205f 616c 6c6f 7765 645f 6b65  .    _allowed_ke
-00013640: 7973 203d 205b 2261 6461 7074 6976 6522  ys = ["adaptive"
-00013650: 2c20 2264 6570 7468 222c 2022 636f 6c6f  , "depth", "colo
-00013660: 7222 5d0a 2020 2020 5f4e 203d 2031 3030  r"].    _N = 100
-00013670: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
-00013680: 5f5f 2873 656c 662c 2065 7870 722c 2076  __(self, expr, v
-00013690: 6172 5f73 7461 7274 5f65 6e64 5f78 2c20  ar_start_end_x, 
-000136a0: 7661 725f 7374 6172 745f 656e 645f 792c  var_start_end_y,
-000136b0: 206c 6162 656c 3d22 222c 202a 2a6b 7761   label="", **kwa
-000136c0: 7267 7329 3a0a 2020 2020 2020 2020 7375  rgs):.        su
-000136d0: 7065 7228 292e 5f5f 696e 6974 5f5f 282a  per().__init__(*
-000136e0: 2a6b 7761 7267 7329 0a20 2020 2020 2020  *kwargs).       
-000136f0: 2073 656c 662e 6164 6170 7469 7665 203d   self.adaptive =
-00013700: 206b 7761 7267 732e 6765 7428 2261 6461   kwargs.get("ada
-00013710: 7074 6976 6522 2c20 4661 6c73 6529 0a20  ptive", False). 
-00013720: 2020 2020 2020 2073 656c 662e 6578 7072         self.expr
-00013730: 203d 2065 7870 720a 2020 2020 2020 2020   = expr.        
-00013740: 7365 6c66 2e5f 6c61 6265 6c20 3d20 7374  self._label = st
-00013750: 7228 6578 7072 2920 6966 206c 6162 656c  r(expr) if label
-00013760: 2069 7320 4e6f 6e65 2065 6c73 6520 6c61   is None else la
-00013770: 6265 6c0a 2020 2020 2020 2020 7365 6c66  bel.        self
-00013780: 2e5f 6c61 7465 785f 6c61 6265 6c20 3d20  ._latex_label = 
-00013790: 6c61 7465 7828 6578 7072 2920 6966 206c  latex(expr) if l
-000137a0: 6162 656c 2069 7320 4e6f 6e65 2065 6c73  abel is None els
-000137b0: 6520 6c61 6265 6c0a 2020 2020 2020 2020  e label.        
-000137c0: 7365 6c66 2e72 616e 6765 7320 3d20 5b76  self.ranges = [v
-000137d0: 6172 5f73 7461 7274 5f65 6e64 5f78 2c20  ar_start_end_x, 
-000137e0: 7661 725f 7374 6172 745f 656e 645f 795d  var_start_end_y]
-000137f0: 0a20 2020 2020 2020 2073 656c 662e 7661  .        self.va
-00013800: 725f 782c 2073 656c 662e 7374 6172 745f  r_x, self.start_
-00013810: 782c 2073 656c 662e 656e 645f 7820 3d20  x, self.end_x = 
-00013820: 7365 6c66 2e72 616e 6765 735b 305d 0a20  self.ranges[0]. 
-00013830: 2020 2020 2020 2073 656c 662e 7661 725f         self.var_
-00013840: 792c 2073 656c 662e 7374 6172 745f 792c  y, self.start_y,
-00013850: 2073 656c 662e 656e 645f 7920 3d20 7365   self.end_y = se
-00013860: 6c66 2e72 616e 6765 735b 315d 0a20 2020  lf.ranges[1].   
-00013870: 2020 2020 2073 656c 662e 5f63 6f6c 6f72       self._color
-00013880: 203d 206b 7761 7267 732e 6765 7428 2263   = kwargs.get("c
-00013890: 6f6c 6f72 222c 206b 7761 7267 732e 6765  olor", kwargs.ge
-000138a0: 7428 226c 696e 655f 636f 6c6f 7222 2c20  t("line_color", 
-000138b0: 4e6f 6e65 2929 0a0a 2020 2020 2020 2020  None))..        
-000138c0: 6966 2073 656c 662e 6973 5f69 6e74 6572  if self.is_inter
-000138d0: 6163 7469 7665 2061 6e64 2073 656c 662e  active and self.
-000138e0: 6164 6170 7469 7665 3a0a 2020 2020 2020  adaptive:.      
-000138f0: 2020 2020 2020 7261 6973 6520 4e6f 7449        raise NotI
-00013900: 6d70 6c65 6d65 6e74 6564 4572 726f 7228  mplementedError(
-00013910: 2249 6e74 6572 6163 7469 7665 2070 6c6f  "Interactive plo
-00013920: 7420 7769 7468 2060 6164 6170 7469 7665  t with `adaptive
-00013930: 3d54 7275 6560 2022 0a20 2020 2020 2020  =True` ".       
-00013940: 2020 2020 2020 2020 2022 6973 206e 6f74           "is not
-00013950: 2073 7570 706f 7274 6564 2e22 290a 0a20   supported.").. 
-00013960: 2020 2020 2020 2023 2043 6865 636b 2077         # Check w
-00013970: 6865 7468 6572 2074 6865 2064 6570 7468  hether the depth
-00013980: 2069 7320 6772 6561 7465 7220 7468 616e   is greater than
-00013990: 2034 206f 7220 6c65 7373 2074 6861 6e20   4 or less than 
-000139a0: 302e 0a20 2020 2020 2020 2064 6570 7468  0..        depth
-000139b0: 203d 206b 7761 7267 732e 6765 7428 2264   = kwargs.get("d
-000139c0: 6570 7468 222c 2030 290a 2020 2020 2020  epth", 0).      
-000139d0: 2020 6966 2064 6570 7468 203e 2034 3a0a    if depth > 4:.
-000139e0: 2020 2020 2020 2020 2020 2020 6465 7074              dept
-000139f0: 6820 3d20 340a 2020 2020 2020 2020 656c  h = 4.        el
-00013a00: 6966 2064 6570 7468 203c 2030 3a0a 2020  if depth < 0:.  
-00013a10: 2020 2020 2020 2020 2020 6465 7074 6820            depth 
-00013a20: 3d20 300a 2020 2020 2020 2020 7365 6c66  = 0.        self
-00013a30: 2e64 6570 7468 203d 2034 202b 2064 6570  .depth = 4 + dep
-00013a40: 7468 0a20 2020 2020 2020 2073 656c 662e  th.        self.
-00013a50: 5f70 6f73 745f 696e 6974 2829 0a0a 2020  _post_init()..  
-00013a60: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00013a70: 6465 6620 6578 7072 2873 656c 6629 3a0a  def expr(self):.
-00013a80: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00013a90: 6164 6170 7469 7665 3a0a 2020 2020 2020  adaptive:.      
-00013aa0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00013ab0: 662e 5f61 6461 7074 6976 655f 6578 7072  f._adaptive_expr
-00013ac0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00013ad0: 7365 6c66 2e5f 6e6f 6e5f 6164 6170 7469  self._non_adapti
-00013ae0: 7665 5f65 7870 720a 0a20 2020 2040 6578  ve_expr..    @ex
-00013af0: 7072 2e73 6574 7465 720a 2020 2020 6465  pr.setter.    de
-00013b00: 6620 6578 7072 2873 656c 662c 2065 7870  f expr(self, exp
-00013b10: 7229 3a0a 2020 2020 2020 2020 7365 6c66  r):.        self
-00013b20: 2e5f 626c 6f63 6b5f 6c61 6d62 6461 5f66  ._block_lambda_f
-00013b30: 756e 6374 696f 6e73 2865 7870 7229 0a20  unctions(expr). 
-00013b40: 2020 2020 2020 2023 2074 6865 7365 2061         # these a
-00013b50: 7265 206e 6565 6465 6420 666f 7220 6164  re needed for ad
-00013b60: 6170 7469 7665 2065 7661 6c75 6174 696f  aptive evaluatio
-00013b70: 6e0a 2020 2020 2020 2020 6578 7072 2c20  n.        expr, 
-00013b80: 6861 735f 6571 7561 6c69 7479 203d 2073  has_equality = s
-00013b90: 656c 662e 5f68 6173 5f65 7175 616c 6974  elf._has_equalit
-00013ba0: 7928 7379 6d70 6966 7928 6578 7072 2929  y(sympify(expr))
-00013bb0: 0a20 2020 2020 2020 2073 656c 662e 5f61  .        self._a
-00013bc0: 6461 7074 6976 655f 6578 7072 203d 2065  daptive_expr = e
-00013bd0: 7870 720a 2020 2020 2020 2020 7365 6c66  xpr.        self
-00013be0: 2e68 6173 5f65 7175 616c 6974 7920 3d20  .has_equality = 
-00013bf0: 6861 735f 6571 7561 6c69 7479 0a20 2020  has_equality.   
-00013c00: 2020 2020 2073 656c 662e 5f6c 6162 656c       self._label
-00013c10: 203d 2073 7472 2865 7870 7229 0a20 2020   = str(expr).   
-00013c20: 2020 2020 2073 656c 662e 5f6c 6174 6578       self._latex
-00013c30: 5f6c 6162 656c 203d 206c 6174 6578 2865  _label = latex(e
-00013c40: 7870 7229 0a0a 2020 2020 2020 2020 6966  xpr)..        if
-00013c50: 2069 7369 6e73 7461 6e63 6528 6578 7072   isinstance(expr
-00013c60: 2c20 2842 6f6f 6c65 616e 4675 6e63 7469  , (BooleanFuncti
-00013c70: 6f6e 2c20 4e65 2929 2061 6e64 2028 6e6f  on, Ne)) and (no
-00013c80: 7420 7365 6c66 2e61 6461 7074 6976 6529  t self.adaptive)
-00013c90: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-00013ca0: 6c66 2e61 6461 7074 6976 6520 3d20 5472  lf.adaptive = Tr
-00013cb0: 7565 0a20 2020 2020 2020 2020 2020 206d  ue.            m
-00013cc0: 7367 203d 2022 636f 6e74 6169 6e73 2042  sg = "contains B
-00013cd0: 6f6f 6c65 616e 2066 756e 6374 696f 6e73  oolean functions
-00013ce0: 2e20 220a 2020 2020 2020 2020 2020 2020  . ".            
-00013cf0: 6966 2069 7369 6e73 7461 6e63 6528 6578  if isinstance(ex
-00013d00: 7072 2c20 4e65 293a 0a20 2020 2020 2020  pr, Ne):.       
-00013d10: 2020 2020 2020 2020 206d 7367 203d 2022           msg = "
-00013d20: 6973 2061 6e20 756e 6571 7561 6c69 7479  is an unequality
-00013d30: 2e20 220a 2020 2020 2020 2020 2020 2020  . ".            
-00013d40: 7761 726e 696e 6773 2e77 6172 6e28 6622  warnings.warn(f"
-00013d50: 5468 6520 7072 6f76 6964 6564 2065 7870  The provided exp
-00013d60: 7265 7373 696f 6e20 7b6d 7367 7d22 0a20  ression {msg}". 
-00013d70: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00013d80: 496e 206f 7264 6572 2074 6f20 706c 6f74  In order to plot
-00013d90: 2074 6865 2065 7870 7265 7373 696f 6e2c   the expression,
-00013da0: 2074 6865 2061 6c67 6f72 6974 686d 2022   the algorithm "
-00013db0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013dc0: 2022 6175 746f 6d61 7469 6361 6c6c 7920   "automatically 
-00013dd0: 7377 6974 6368 6564 2074 6f20 616e 2061  switched to an a
-00013de0: 6461 7074 6976 6520 7361 6d70 6c69 6e67  daptive sampling
-00013df0: 2e22 2c0a 2020 2020 2020 2020 2020 2020  .",.            
-00013e00: 2020 2020 7374 6163 6b6c 6576 656c 3d31      stacklevel=1
-00013e10: 290a 0a20 2020 2020 2020 2069 6620 6973  )..        if is
-00013e20: 696e 7374 616e 6365 2865 7870 722c 2042  instance(expr, B
-00013e30: 6f6f 6c65 616e 4675 6e63 7469 6f6e 293a  ooleanFunction):
-00013e40: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00013e50: 662e 5f6e 6f6e 5f61 6461 7074 6976 655f  f._non_adaptive_
-00013e60: 6578 7072 203d 204e 6f6e 650a 2020 2020  expr = None.    
-00013e70: 2020 2020 2020 2020 7365 6c66 2e5f 6973          self._is
-00013e80: 5f65 7175 616c 6974 7920 3d20 4661 6c73  _equality = Fals
-00013e90: 650a 2020 2020 2020 2020 656c 7365 3a0a  e.        else:.
-00013ea0: 2020 2020 2020 2020 2020 2020 2320 7468              # th
-00013eb0: 6573 6520 6172 6520 6e65 6564 6564 2066  ese are needed f
-00013ec0: 6f72 2075 6e69 666f 726d 206d 6573 6869  or uniform meshi
-00013ed0: 6e67 2065 7661 6c75 6174 696f 6e0a 2020  ng evaluation.  
-00013ee0: 2020 2020 2020 2020 2020 6578 7072 2c20            expr, 
-00013ef0: 6973 5f65 7175 616c 6974 7920 3d20 7365  is_equality = se
-00013f00: 6c66 2e5f 7072 6570 726f 6365 7373 5f6d  lf._preprocess_m
-00013f10: 6573 6867 7269 645f 6578 7072 6573 7369  eshgrid_expressi
-00013f20: 6f6e 280a 2020 2020 2020 2020 2020 2020  on(.            
-00013f30: 2020 2020 6578 7072 2c20 7365 6c66 2e61      expr, self.a
-00013f40: 6461 7074 6976 6529 0a20 2020 2020 2020  daptive).       
-00013f50: 2020 2020 2073 656c 662e 5f6e 6f6e 5f61       self._non_a
-00013f60: 6461 7074 6976 655f 6578 7072 203d 2065  daptive_expr = e
-00013f70: 7870 720a 2020 2020 2020 2020 2020 2020  xpr.            
-00013f80: 7365 6c66 2e5f 6973 5f65 7175 616c 6974  self._is_equalit
-00013f90: 7920 3d20 6973 5f65 7175 616c 6974 790a  y = is_equality.
-00013fa0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00013fb0: 2020 2064 6566 206c 696e 655f 636f 6c6f     def line_colo
-00013fc0: 7228 7365 6c66 293a 0a20 2020 2020 2020  r(self):.       
-00013fd0: 2072 6574 7572 6e20 7365 6c66 2e5f 636f   return self._co
-00013fe0: 6c6f 720a 0a20 2020 2040 6c69 6e65 5f63  lor..    @line_c
-00013ff0: 6f6c 6f72 2e73 6574 7465 720a 2020 2020  olor.setter.    
-00014000: 6465 6620 6c69 6e65 5f63 6f6c 6f72 2873  def line_color(s
-00014010: 656c 662c 2076 293a 0a20 2020 2020 2020  elf, v):.       
-00014020: 2073 656c 662e 5f63 6f6c 6f72 203d 2076   self._color = v
-00014030: 0a0a 2020 2020 636f 6c6f 7220 3d20 6c69  ..    color = li
-00014040: 6e65 5f63 6f6c 6f72 0a0a 2020 2020 6465  ne_color..    de
-00014050: 6620 5f68 6173 5f65 7175 616c 6974 7928  f _has_equality(
-00014060: 7365 6c66 2c20 6578 7072 293a 0a20 2020  self, expr):.   
-00014070: 2020 2020 2023 2052 6570 7265 7365 6e74       # Represent
-00014080: 7320 7768 6574 6865 7220 7468 6520 6578  s whether the ex
-00014090: 7072 6573 7369 6f6e 2063 6f6e 7461 696e  pression contain
-000140a0: 7320 616e 2045 7175 616c 6974 792c 2047  s an Equality, G
-000140b0: 7265 6174 6572 5468 616e 0a20 2020 2020  reaterThan.     
-000140c0: 2020 2023 206f 7220 4c65 7373 5468 616e     # or LessThan
-000140d0: 0a20 2020 2020 2020 2068 6173 5f65 7175  .        has_equ
-000140e0: 616c 6974 7920 3d20 4661 6c73 650a 0a20  ality = False.. 
-000140f0: 2020 2020 2020 2064 6566 2061 7267 5f65         def arg_e
-00014100: 7870 616e 6428 626f 6f6c 5f65 7870 7229  xpand(bool_expr)
-00014110: 3a0a 2020 2020 2020 2020 2020 2020 2222  :.            ""
-00014120: 2252 6563 7572 7369 7665 6c79 2065 7870  "Recursively exp
-00014130: 616e 6473 2074 6865 2061 7267 756d 656e  ands the argumen
-00014140: 7473 206f 6620 616e 2042 6f6f 6c65 616e  ts of an Boolean
-00014150: 2046 756e 6374 696f 6e22 2222 0a20 2020   Function""".   
-00014160: 2020 2020 2020 2020 2066 6f72 2061 7267           for arg
-00014170: 2069 6e20 626f 6f6c 5f65 7870 722e 6172   in bool_expr.ar
-00014180: 6773 3a0a 2020 2020 2020 2020 2020 2020  gs:.            
-00014190: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
-000141a0: 6528 6172 672c 2042 6f6f 6c65 616e 4675  e(arg, BooleanFu
-000141b0: 6e63 7469 6f6e 293a 0a20 2020 2020 2020  nction):.       
-000141c0: 2020 2020 2020 2020 2020 2020 2061 7267               arg
-000141d0: 5f65 7870 616e 6428 6172 6729 0a20 2020  _expand(arg).   
-000141e0: 2020 2020 2020 2020 2020 2020 2065 6c69               eli
-000141f0: 6620 6973 696e 7374 616e 6365 2861 7267  f isinstance(arg
-00014200: 2c20 5265 6c61 7469 6f6e 616c 293a 0a20  , Relational):. 
-00014210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014220: 2020 2061 7267 5f6c 6973 742e 6170 7065     arg_list.appe
-00014230: 6e64 2861 7267 290a 0a20 2020 2020 2020  nd(arg)..       
-00014240: 2061 7267 5f6c 6973 7420 3d20 5b5d 0a20   arg_list = []. 
-00014250: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-00014260: 616e 6365 2865 7870 722c 2042 6f6f 6c65  ance(expr, Boole
-00014270: 616e 4675 6e63 7469 6f6e 293a 0a20 2020  anFunction):.   
-00014280: 2020 2020 2020 2020 2061 7267 5f65 7870           arg_exp
-00014290: 616e 6428 6578 7072 290a 2020 2020 2020  and(expr).      
-000142a0: 2020 2020 2020 2320 4368 6563 6b20 7768        # Check wh
-000142b0: 6574 6865 7220 7468 6572 6520 6973 2061  ether there is a
-000142c0: 6e20 6571 7561 6c69 7479 2069 6e20 7468  n equality in th
-000142d0: 6520 6578 7072 6573 7369 6f6e 2070 726f  e expression pro
-000142e0: 7669 6465 642e 0a20 2020 2020 2020 2020  vided..         
-000142f0: 2020 2069 6620 616e 7928 6973 696e 7374     if any(isinst
-00014300: 616e 6365 2865 2c20 2845 7175 616c 6974  ance(e, (Equalit
-00014310: 792c 2047 7265 6174 6572 5468 616e 2c20  y, GreaterThan, 
-00014320: 4c65 7373 5468 616e 2929 2066 6f72 2065  LessThan)) for e
-00014330: 2069 6e20 6172 675f 6c69 7374 293a 0a20   in arg_list):. 
-00014340: 2020 2020 2020 2020 2020 2020 2020 2068                 h
-00014350: 6173 5f65 7175 616c 6974 7920 3d20 5472  as_equality = Tr
-00014360: 7565 0a20 2020 2020 2020 2065 6c69 6620  ue.        elif 
-00014370: 6e6f 7420 6973 696e 7374 616e 6365 2865  not isinstance(e
-00014380: 7870 722c 2052 656c 6174 696f 6e61 6c29  xpr, Relational)
-00014390: 3a0a 2020 2020 2020 2020 2020 2020 6578  :.            ex
-000143a0: 7072 203d 2045 7175 616c 6974 7928 6578  pr = Equality(ex
-000143b0: 7072 2c20 3029 0a20 2020 2020 2020 2020  pr, 0).         
-000143c0: 2020 2068 6173 5f65 7175 616c 6974 7920     has_equality 
-000143d0: 3d20 5472 7565 0a20 2020 2020 2020 2065  = True.        e
-000143e0: 6c69 6620 6973 696e 7374 616e 6365 2865  lif isinstance(e
-000143f0: 7870 722c 2028 4571 7561 6c69 7479 2c20  xpr, (Equality, 
-00014400: 4772 6561 7465 7254 6861 6e2c 204c 6573  GreaterThan, Les
-00014410: 7354 6861 6e29 293a 0a20 2020 2020 2020  sThan)):.       
-00014420: 2020 2020 2068 6173 5f65 7175 616c 6974       has_equalit
-00014430: 7920 3d20 5472 7565 0a0a 2020 2020 2020  y = True..      
-00014440: 2020 7265 7475 726e 2065 7870 722c 2068    return expr, h
-00014450: 6173 5f65 7175 616c 6974 790a 0a20 2020  as_equality..   
-00014460: 2064 6566 205f 5f73 7472 5f5f 2873 656c   def __str__(sel
-00014470: 6629 3a0a 2020 2020 2020 2020 6620 3d20  f):.        f = 
-00014480: 6c61 6d62 6461 2074 3a20 666c 6f61 7428  lambda t: float(
-00014490: 7429 2069 6620 6c65 6e28 742e 6672 6565  t) if len(t.free
-000144a0: 5f73 796d 626f 6c73 2920 3d3d 2030 2065  _symbols) == 0 e
-000144b0: 6c73 6520 740a 0a20 2020 2020 2020 2072  lse t..        r
-000144c0: 6574 7572 6e20 7365 6c66 2e5f 7374 725f  eturn self._str_
-000144d0: 6865 6c70 6572 280a 2020 2020 2020 2020  helper(.        
-000144e0: 2020 2020 2249 6d70 6c69 6369 7420 6578      "Implicit ex
-000144f0: 7072 6573 7369 6f6e 3a20 2573 2066 6f72  pression: %s for
-00014500: 2025 7320 6f76 6572 2025 7320 616e 6420   %s over %s and 
-00014510: 2573 206f 7665 7220 2573 2229 2025 2028  %s over %s") % (
-00014520: 0a20 2020 2020 2020 2020 2020 2073 7472  .            str
-00014530: 2873 656c 662e 5f61 6461 7074 6976 655f  (self._adaptive_
-00014540: 6578 7072 292c 0a20 2020 2020 2020 2020  expr),.         
-00014550: 2020 2073 7472 2873 656c 662e 7661 725f     str(self.var_
-00014560: 7829 2c0a 2020 2020 2020 2020 2020 2020  x),.            
-00014570: 7374 7228 2866 2873 656c 662e 7374 6172  str((f(self.star
-00014580: 745f 7829 2c20 6628 7365 6c66 2e65 6e64  t_x), f(self.end
-00014590: 5f78 2929 292c 0a20 2020 2020 2020 2020  _x))),.         
-000145a0: 2020 2073 7472 2873 656c 662e 7661 725f     str(self.var_
-000145b0: 7929 2c0a 2020 2020 2020 2020 2020 2020  y),.            
-000145c0: 7374 7228 2866 2873 656c 662e 7374 6172  str((f(self.star
-000145d0: 745f 7929 2c20 6628 7365 6c66 2e65 6e64  t_y), f(self.end
-000145e0: 5f79 2929 292c 0a20 2020 2020 2020 2029  _y))),.        )
-000145f0: 0a0a 2020 2020 6465 6620 6765 745f 6461  ..    def get_da
-00014600: 7461 2873 656c 6629 3a0a 2020 2020 2020  ta(self):.      
-00014610: 2020 2222 2252 6574 7572 6e73 206e 756d    """Returns num
-00014620: 6572 6963 616c 2064 6174 612e 0a0a 2020  erical data...  
-00014630: 2020 2020 2020 5265 7475 726e 730a 2020        Returns.  
-00014640: 2020 2020 2020 3d3d 3d3d 3d3d 3d0a 0a20        =======.. 
-00014650: 2020 2020 2020 2049 6620 7468 6520 7365         If the se
-00014660: 7269 6573 2069 7320 6576 616c 7561 7465  ries is evaluate
-00014670: 6420 7769 7468 2074 6865 2060 6164 6170  d with the `adap
-00014680: 7469 7665 3d54 7275 6560 2069 7420 7265  tive=True` it re
-00014690: 7475 726e 733a 0a0a 2020 2020 2020 2020  turns:..        
-000146a0: 696e 7465 7276 616c 5f6c 6973 7420 3a20  interval_list : 
-000146b0: 6c69 7374 0a20 2020 2020 2020 2020 2020  list.           
-000146c0: 204c 6973 7420 6f66 2062 6f75 6e64 696e   List of boundin
-000146d0: 6720 7265 6374 616e 6775 6c61 7220 696e  g rectangular in
-000146e0: 7465 7276 616c 7320 746f 2062 6520 706f  tervals to be po
-000146f0: 7374 7072 6f63 6573 7365 6420 616e 640a  stprocessed and.
-00014700: 2020 2020 2020 2020 2020 2020 6576 656e              even
-00014710: 7475 616c 6c79 2075 7365 6420 7769 7468  tually used with
-00014720: 204d 6174 706c 6f74 6c69 6227 7320 6060   Matplotlib's ``
-00014730: 6669 6c6c 6060 2063 6f6d 6d61 6e64 2e0a  fill`` command..
-00014740: 2020 2020 2020 2020 6475 6d6d 7920 3a20          dummy : 
-00014750: 7374 720a 2020 2020 2020 2020 2020 2020  str.            
-00014760: 4120 7374 7269 6e67 2063 6f6e 7461 696e  A string contain
-00014770: 696e 6720 6060 2266 696c 6c22 6060 2e0a  ing ``"fill"``..
-00014780: 0a20 2020 2020 2020 204f 7468 6572 7769  .        Otherwi
-00014790: 7365 2c20 6974 2072 6574 7572 6e73 2032  se, it returns 2
-000147a0: 4420 6e75 6d70 7920 6172 7261 7973 2074  D numpy arrays t
-000147b0: 6f20 6265 2075 7365 6420 7769 7468 204d  o be used with M
-000147c0: 6174 706c 6f74 6c69 6227 730a 2020 2020  atplotlib's.    
-000147d0: 2020 2020 6060 636f 6e74 6f75 7260 6020      ``contour`` 
-000147e0: 6f72 2060 6063 6f6e 746f 7572 6660 6020  or ``contourf`` 
-000147f0: 636f 6d6d 616e 6473 3a0a 0a20 2020 2020  commands:..     
-00014800: 2020 2078 5f61 7272 6179 203a 206e 702e     x_array : np.
-00014810: 6e64 6172 7261 790a 2020 2020 2020 2020  ndarray.        
-00014820: 795f 6172 7261 7920 3a20 6e70 2e6e 6461  y_array : np.nda
-00014830: 7272 6179 0a20 2020 2020 2020 207a 5f61  rray.        z_a
-00014840: 7272 6179 203a 206e 702e 6e64 6172 7261  rray : np.ndarra
-00014850: 790a 2020 2020 2020 2020 706c 6f74 5f74  y.        plot_t
-00014860: 7970 6520 3a20 7374 720a 2020 2020 2020  ype : str.      
-00014870: 2020 2020 2020 4120 7374 7269 6e67 2073        A string s
-00014880: 7065 6369 6679 696e 6720 7768 6963 6820  pecifying which 
-00014890: 706c 6f74 2063 6f6d 6d61 6e64 2074 6f20  plot command to 
-000148a0: 7573 652c 2060 6022 636f 6e74 6f75 7222  use, ``"contour"
-000148b0: 6060 0a20 2020 2020 2020 2020 2020 206f  ``.            o
-000148c0: 7220 6060 2263 6f6e 746f 7572 6622 6060  r ``"contourf"``
-000148d0: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-000148e0: 2020 2020 2020 6966 2073 656c 662e 6164        if self.ad
-000148f0: 6170 7469 7665 3a0a 2020 2020 2020 2020  aptive:.        
-00014900: 2020 2020 6461 7461 203d 2073 656c 662e      data = self.
-00014910: 5f61 6461 7074 6976 655f 6576 616c 2829  _adaptive_eval()
-00014920: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00014930: 6461 7461 2069 7320 6e6f 7420 4e6f 6e65  data is not None
-00014940: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00014950: 2020 7265 7475 726e 2064 6174 610a 2020    return data.  
-00014960: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00014970: 662e 5f67 6574 5f6d 6573 6865 735f 6772  f._get_meshes_gr
-00014980: 6964 2829 0a0a 2020 2020 6465 6620 5f61  id()..    def _a
-00014990: 6461 7074 6976 655f 6576 616c 2873 656c  daptive_eval(sel
-000149a0: 6629 3a0a 2020 2020 2020 2020 696d 706f  f):.        impo
-000149b0: 7274 2073 796d 7079 2e70 6c6f 7474 696e  rt sympy.plottin
-000149c0: 672e 696e 7465 7276 616c 6d61 7468 2e6c  g.intervalmath.l
-000149d0: 6962 5f69 6e74 6572 7661 6c20 6173 206c  ib_interval as l
-000149e0: 690a 0a20 2020 2020 2020 2075 7365 725f  i..        user_
-000149f0: 6675 6e63 7469 6f6e 7320 3d20 7b7d 0a20  functions = {}. 
-00014a00: 2020 2020 2020 2070 7269 6e74 6572 203d         printer =
-00014a10: 2049 6e74 6572 7661 6c4d 6174 6850 7269   IntervalMathPri
-00014a20: 6e74 6572 287b 0a20 2020 2020 2020 2020  nter({.         
-00014a30: 2020 2027 6675 6c6c 795f 7175 616c 6966     'fully_qualif
-00014a40: 6965 645f 6d6f 6475 6c65 7327 3a20 4661  ied_modules': Fa
-00014a50: 6c73 652c 2027 696e 6c69 6e65 273a 2054  lse, 'inline': T
-00014a60: 7275 652c 0a20 2020 2020 2020 2020 2020  rue,.           
-00014a70: 2027 616c 6c6f 775f 756e 6b6e 6f77 6e5f   'allow_unknown_
-00014a80: 6675 6e63 7469 6f6e 7327 3a20 5472 7565  functions': True
-00014a90: 2c0a 2020 2020 2020 2020 2020 2020 2775  ,.            'u
-00014aa0: 7365 725f 6675 6e63 7469 6f6e 7327 3a20  ser_functions': 
-00014ab0: 7573 6572 5f66 756e 6374 696f 6e73 7d29  user_functions})
-00014ac0: 0a0a 2020 2020 2020 2020 6b65 7973 203d  ..        keys =
-00014ad0: 205b 7420 666f 7220 7420 696e 2064 6972   [t for t in dir
-00014ae0: 286c 6929 2069 6620 2822 5f5f 2220 6e6f  (li) if ("__" no
-00014af0: 7420 696e 2074 2920 616e 6420 2874 206e  t in t) and (t n
-00014b00: 6f74 2069 6e20 5b22 696d 706f 7274 5f6d  ot in ["import_m
-00014b10: 6f64 756c 6522 2c20 2269 6e74 6572 7661  odule", "interva
-00014b20: 6c22 5d29 5d0a 2020 2020 2020 2020 7661  l"])].        va
-00014b30: 6c73 203d 205b 6765 7461 7474 7228 6c69  ls = [getattr(li
-00014b40: 2c20 6b29 2066 6f72 206b 2069 6e20 6b65  , k) for k in ke
-00014b50: 7973 5d0a 2020 2020 2020 2020 6420 3d20  ys].        d = 
-00014b60: 7b6b 3a20 7620 666f 7220 6b2c 2076 2069  {k: v for k, v i
-00014b70: 6e20 7a69 7028 6b65 7973 2c20 7661 6c73  n zip(keys, vals
-00014b80: 297d 0a20 2020 2020 2020 2066 756e 6320  )}.        func 
-00014b90: 3d20 6c61 6d62 6469 6679 2828 7365 6c66  = lambdify((self
-00014ba0: 2e76 6172 5f78 2c20 7365 6c66 2e76 6172  .var_x, self.var
-00014bb0: 5f79 292c 2073 656c 662e 6578 7072 2c20  _y), self.expr, 
-00014bc0: 6d6f 6475 6c65 733d 5b64 5d2c 2070 7269  modules=[d], pri
-00014bd0: 6e74 6572 3d70 7269 6e74 6572 290a 2020  nter=printer).  
-00014be0: 2020 2020 2020 6461 7461 203d 204e 6f6e        data = Non
-00014bf0: 650a 0a20 2020 2020 2020 2074 7279 3a0a  e..        try:.
-00014c00: 2020 2020 2020 2020 2020 2020 6461 7461              data
-00014c10: 203d 2073 656c 662e 5f67 6574 5f72 6173   = self._get_ras
-00014c20: 7465 725f 696e 7465 7276 616c 2866 756e  ter_interval(fun
-00014c30: 6329 0a20 2020 2020 2020 2065 7863 6570  c).        excep
-00014c40: 7420 4e61 6d65 4572 726f 7220 6173 2065  t NameError as e
-00014c50: 7272 3a0a 2020 2020 2020 2020 2020 2020  rr:.            
-00014c60: 7761 726e 696e 6773 2e77 6172 6e28 0a20  warnings.warn(. 
-00014c70: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00014c80: 4164 6170 7469 7665 206d 6573 6869 6e67  Adaptive meshing
-00014c90: 2063 6f75 6c64 206e 6f74 2062 6520 6170   could not be ap
-00014ca0: 706c 6965 6420 746f 2074 6865 220a 2020  plied to the".  
-00014cb0: 2020 2020 2020 2020 2020 2020 2020 2220                " 
-00014cc0: 6578 7072 6573 7369 6f6e 2c20 6173 2073  expression, as s
-00014cd0: 6f6d 6520 6675 6e63 7469 6f6e 7320 6172  ome functions ar
-00014ce0: 6520 6e6f 7420 7965 7420 696d 706c 656d  e not yet implem
-00014cf0: 656e 7465 6422 0a20 2020 2020 2020 2020  ented".         
-00014d00: 2020 2020 2020 2022 2069 6e20 7468 6520         " in the 
-00014d10: 696e 7465 7276 616c 206d 6174 6820 6d6f  interval math mo
-00014d20: 6475 6c65 3a5c 6e5c 6e22 0a20 2020 2020  dule:\n\n".     
-00014d30: 2020 2020 2020 2020 2020 2022 4e61 6d65             "Name
-00014d40: 4572 726f 723a 2025 735c 6e5c 6e22 2025  Error: %s\n\n" %
-00014d50: 2065 7272 202b 0a20 2020 2020 2020 2020   err +.         
-00014d60: 2020 2020 2020 2022 5072 6f63 6565 6469         "Proceedi
-00014d70: 6e67 2077 6974 6820 756e 6966 6f72 6d20  ng with uniform 
-00014d80: 6d65 7368 696e 672e 220a 2020 2020 2020  meshing.".      
-00014d90: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00014da0: 2020 2020 2020 2020 7365 6c66 2e61 6461          self.ada
-00014db0: 7074 6976 6520 3d20 4661 6c73 650a 2020  ptive = False.  
-00014dc0: 2020 2020 2020 6578 6365 7074 2028 4174        except (At
-00014dd0: 7472 6962 7574 6545 7272 6f72 2c20 5479  tributeError, Ty
-00014de0: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
-00014df0: 2020 2020 2020 2320 5858 583a 2041 7474        # XXX: Att
-00014e00: 7269 6275 7465 4572 726f 7228 2227 6c69  ributeError("'li
-00014e10: 7374 2720 6f62 6a65 6374 2068 6173 206e  st' object has n
-00014e20: 6f20 6174 7472 6962 7574 6520 2769 735f  o attribute 'is_
-00014e30: 7265 616c 2722 290a 2020 2020 2020 2020  real'").        
-00014e40: 2020 2020 2320 5468 6174 206e 6565 6473      # That needs
-00014e50: 2066 6978 696e 6720 736f 6d65 686f 7720   fixing somehow 
-00014e60: 2d20 7765 2073 686f 756c 646e 2774 2062  - we shouldn't b
-00014e70: 6520 6361 7463 6869 6e67 0a20 2020 2020  e catching.     
-00014e80: 2020 2020 2020 2023 2041 7474 7269 6275         # Attribu
-00014e90: 7465 4572 726f 7220 6865 7265 2e0a 2020  teError here..  
-00014ea0: 2020 2020 2020 2020 2020 7761 726e 696e            warnin
-00014eb0: 6773 2e77 6172 6e28 0a20 2020 2020 2020  gs.warn(.       
-00014ec0: 2020 2020 2020 2020 2022 4164 6170 7469           "Adapti
-00014ed0: 7665 206d 6573 6869 6e67 2063 6f75 6c64  ve meshing could
-00014ee0: 206e 6f74 2062 6520 6170 706c 6965 6420   not be applied 
-00014ef0: 746f 2074 6865 220a 2020 2020 2020 2020  to the".        
-00014f00: 2020 2020 2020 2020 2220 6578 7072 6573          " expres
-00014f10: 7369 6f6e 2e20 5573 696e 6720 756e 6966  sion. Using unif
-00014f20: 6f72 6d20 6d65 7368 696e 672e 2229 0a20  orm meshing."). 
-00014f30: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00014f40: 6164 6170 7469 7665 203d 2046 616c 7365  adaptive = False
-00014f50: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00014f60: 2064 6174 610a 0a20 2020 2064 6566 205f   data..    def _
-00014f70: 6765 745f 7261 7374 6572 5f69 6e74 6572  get_raster_inter
-00014f80: 7661 6c28 7365 6c66 2c20 6675 6e63 293a  val(self, func):
-00014f90: 0a20 2020 2020 2020 2022 2222 5573 6573  .        """Uses
-00014fa0: 2069 6e74 6572 7661 6c20 6d61 7468 2074   interval math t
-00014fb0: 6f20 6164 6170 7469 7665 6c79 206d 6573  o adaptively mes
-00014fc0: 6820 616e 6420 6f62 7461 696e 2074 6865  h and obtain the
-00014fd0: 2070 6c6f 7422 2222 0a20 2020 2020 2020   plot""".       
-00014fe0: 206e 7020 3d20 696d 706f 7274 5f6d 6f64   np = import_mod
-00014ff0: 756c 6528 276e 756d 7079 2729 0a0a 2020  ule('numpy')..  
-00015000: 2020 2020 2020 6b20 3d20 7365 6c66 2e64        k = self.d
-00015010: 6570 7468 0a20 2020 2020 2020 2069 6e74  epth.        int
-00015020: 6572 7661 6c5f 6c69 7374 203d 205b 5d0a  erval_list = [].
-00015030: 2020 2020 2020 2020 7378 2c20 7379 203d          sx, sy =
-00015040: 205b 666c 6f61 7428 7429 2066 6f72 2074   [float(t) for t
-00015050: 2069 6e20 5b73 656c 662e 7374 6172 745f   in [self.start_
-00015060: 782c 2073 656c 662e 7374 6172 745f 795d  x, self.start_y]
-00015070: 5d0a 2020 2020 2020 2020 6578 2c20 6579  ].        ex, ey
-00015080: 203d 205b 666c 6f61 7428 7429 2066 6f72   = [float(t) for
-00015090: 2074 2069 6e20 5b73 656c 662e 656e 645f   t in [self.end_
-000150a0: 782c 2073 656c 662e 656e 645f 795d 5d0a  x, self.end_y]].
-000150b0: 2020 2020 2020 2020 2320 4372 6561 7465          # Create
-000150c0: 2069 6e69 7469 616c 2033 3220 6469 7669   initial 32 divi
-000150d0: 7369 6f6e 730a 2020 2020 2020 2020 7873  sions.        xs
-000150e0: 616d 706c 6520 3d20 6e70 2e6c 696e 7370  ample = np.linsp
-000150f0: 6163 6528 7378 2c20 6578 2c20 3333 290a  ace(sx, ex, 33).
-00015100: 2020 2020 2020 2020 7973 616d 706c 6520          ysample 
-00015110: 3d20 6e70 2e6c 696e 7370 6163 6528 7379  = np.linspace(sy
-00015120: 2c20 6579 2c20 3333 290a 0a20 2020 2020  , ey, 33)..     
-00015130: 2020 2023 2041 6464 2061 2073 6d61 6c6c     # Add a small
-00015140: 206a 6974 7465 7220 736f 2074 6861 7420   jitter so that 
-00015150: 7468 6572 6520 6172 6520 6e6f 2066 616c  there are no fal
-00015160: 7365 2070 6f73 6974 6976 6573 2066 6f72  se positives for
-00015170: 2065 7175 616c 6974 792e 0a20 2020 2020   equality..     
-00015180: 2020 2023 2045 783a 2079 3d3d 7820 6265     # Ex: y==x be
-00015190: 636f 6d65 7320 5472 7565 2066 6f72 2078  comes True for x
-000151a0: 2069 6e74 6572 7661 6c28 312c 2032 2920   interval(1, 2) 
-000151b0: 616e 6420 7920 696e 7465 7276 616c 2831  and y interval(1
-000151c0: 2c20 3229 0a20 2020 2020 2020 2023 2077  , 2).        # w
-000151d0: 6869 6368 2077 696c 6c20 6472 6177 2061  hich will draw a
-000151e0: 2072 6563 7461 6e67 6c65 2e0a 2020 2020   rectangle..    
-000151f0: 2020 2020 6a69 7474 6572 7820 3d20 280a      jitterx = (.
-00015200: 2020 2020 2020 2020 2020 2020 286e 702e              (np.
-00015210: 7261 6e64 6f6d 2e72 616e 6428 6c65 6e28  random.rand(len(
-00015220: 7873 616d 706c 6529 2920 2a20 3220 2d20  xsample)) * 2 - 
-00015230: 3129 0a20 2020 2020 2020 2020 2020 202a  1).            *
-00015240: 2028 6578 202d 2073 7829 0a20 2020 2020   (ex - sx).     
-00015250: 2020 2020 2020 202f 2032 202a 2a20 3230         / 2 ** 20
-00015260: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
-00015270: 2020 206a 6974 7465 7279 203d 2028 0a20     jittery = (. 
-00015280: 2020 2020 2020 2020 2020 2028 6e70 2e72             (np.r
-00015290: 616e 646f 6d2e 7261 6e64 286c 656e 2879  andom.rand(len(y
-000152a0: 7361 6d70 6c65 2929 202a 2032 202d 2031  sample)) * 2 - 1
-000152b0: 290a 2020 2020 2020 2020 2020 2020 2a20  ).            * 
-000152c0: 2865 7920 2d20 7379 290a 2020 2020 2020  (ey - sy).      
-000152d0: 2020 2020 2020 2f20 3220 2a2a 2032 300a        / 2 ** 20.
-000152e0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-000152f0: 2020 7873 616d 706c 6520 2b3d 206a 6974    xsample += jit
-00015300: 7465 7278 0a20 2020 2020 2020 2079 7361  terx.        ysa
-00015310: 6d70 6c65 202b 3d20 6a69 7474 6572 790a  mple += jittery.
-00015320: 0a20 2020 2020 2020 2078 696e 7465 7220  .        xinter 
-00015330: 3d20 5b69 6e74 6572 7661 6c28 7831 2c20  = [interval(x1, 
-00015340: 7832 2920 666f 7220 7831 2c20 7832 2069  x2) for x1, x2 i
-00015350: 6e20 7a69 7028 7873 616d 706c 655b 3a2d  n zip(xsample[:-
-00015360: 315d 2c20 7873 616d 706c 655b 313a 5d29  1], xsample[1:])
-00015370: 5d0a 2020 2020 2020 2020 7969 6e74 6572  ].        yinter
-00015380: 203d 205b 696e 7465 7276 616c 2879 312c   = [interval(y1,
-00015390: 2079 3229 2066 6f72 2079 312c 2079 3220   y2) for y1, y2 
-000153a0: 696e 207a 6970 2879 7361 6d70 6c65 5b3a  in zip(ysample[:
-000153b0: 2d31 5d2c 2079 7361 6d70 6c65 5b31 3a5d  -1], ysample[1:]
-000153c0: 295d 0a20 2020 2020 2020 2069 6e74 6572  )].        inter
-000153d0: 7661 6c5f 6c69 7374 203d 205b 5b78 2c20  val_list = [[x, 
-000153e0: 795d 2066 6f72 2078 2069 6e20 7869 6e74  y] for x in xint
-000153f0: 6572 2066 6f72 2079 2069 6e20 7969 6e74  er for y in yint
-00015400: 6572 5d0a 2020 2020 2020 2020 706c 6f74  er].        plot
-00015410: 5f6c 6973 7420 3d20 5b5d 0a0a 2020 2020  _list = []..    
-00015420: 2020 2020 2320 7265 6375 7273 6976 6520      # recursive 
-00015430: 6361 6c6c 2072 6566 696e 6570 6978 656c  call refinepixel
-00015440: 7320 7768 6963 6820 7375 6264 6976 6964  s which subdivid
-00015450: 6573 2074 6865 2069 6e74 6572 7661 6c73  es the intervals
-00015460: 2077 6869 6368 2061 7265 0a20 2020 2020   which are.     
-00015470: 2020 2023 206e 6569 7468 6572 2054 7275     # neither Tru
-00015480: 6520 6e6f 7220 4661 6c73 6520 6163 636f  e nor False acco
-00015490: 7264 696e 6720 746f 2074 6865 2065 7870  rding to the exp
-000154a0: 7265 7373 696f 6e2e 0a20 2020 2020 2020  ression..       
-000154b0: 2064 6566 2072 6566 696e 655f 7069 7865   def refine_pixe
-000154c0: 6c73 2869 6e74 6572 7661 6c5f 6c69 7374  ls(interval_list
-000154d0: 293a 0a20 2020 2020 2020 2020 2020 2022  ):.            "
-000154e0: 2222 4576 616c 7561 7465 7320 7468 6520  ""Evaluates the 
-000154f0: 696e 7465 7276 616c 7320 616e 6420 7375  intervals and su
-00015500: 6264 6976 6964 6573 2074 6865 2069 6e74  bdivides the int
-00015510: 6572 7661 6c20 6966 2074 6865 0a20 2020  erval if the.   
-00015520: 2020 2020 2020 2020 2065 7870 7265 7373           express
-00015530: 696f 6e20 6973 2070 6172 7469 616c 6c79  ion is partially
-00015540: 2073 6174 6973 6669 6564 2e22 2222 0a20   satisfied.""". 
-00015550: 2020 2020 2020 2020 2020 2074 656d 705f             temp_
-00015560: 696e 7465 7276 616c 5f6c 6973 7420 3d20  interval_list = 
-00015570: 5b5d 0a20 2020 2020 2020 2020 2020 2070  [].            p
-00015580: 6c6f 745f 6c69 7374 203d 205b 5d0a 2020  lot_list = [].  
-00015590: 2020 2020 2020 2020 2020 666f 7220 696e            for in
-000155a0: 7465 7276 616c 7320 696e 2069 6e74 6572  tervals in inter
-000155b0: 7661 6c5f 6c69 7374 3a0a 0a20 2020 2020  val_list:..     
-000155c0: 2020 2020 2020 2020 2020 2023 2043 6f6e             # Con
-000155d0: 7665 7274 2074 6865 2061 7272 6179 2069  vert the array i
-000155e0: 6e64 6963 6573 2074 6f20 7820 616e 6420  ndices to x and 
-000155f0: 7920 7661 6c75 6573 0a20 2020 2020 2020  y values.       
-00015600: 2020 2020 2020 2020 2069 6e74 6572 7661           interva
-00015610: 6c78 203d 2069 6e74 6572 7661 6c73 5b30  lx = intervals[0
-00015620: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00015630: 2020 696e 7465 7276 616c 7920 3d20 696e    intervaly = in
-00015640: 7465 7276 616c 735b 315d 0a20 2020 2020  tervals[1].     
-00015650: 2020 2020 2020 2020 2020 2066 756e 635f             func_
-00015660: 6576 616c 203d 2066 756e 6328 696e 7465  eval = func(inte
-00015670: 7276 616c 782c 2069 6e74 6572 7661 6c79  rvalx, intervaly
-00015680: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00015690: 2020 2320 5468 6520 6578 7072 6573 7369    # The expressi
-000156a0: 6f6e 2069 7320 7661 6c69 6420 696e 2074  on is valid in t
-000156b0: 6865 2069 6e74 6572 7661 6c2e 2043 6861  he interval. Cha
-000156c0: 6e67 6520 7468 6520 636f 6e74 6f75 720a  nge the contour.
-000156d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000156e0: 2320 6172 7261 7920 7661 6c75 6573 2074  # array values t
-000156f0: 6f20 312e 0a20 2020 2020 2020 2020 2020  o 1..           
-00015700: 2020 2020 2069 6620 6675 6e63 5f65 7661       if func_eva
-00015710: 6c5b 315d 2069 7320 4661 6c73 6520 6f72  l[1] is False or
-00015720: 2066 756e 635f 6576 616c 5b30 5d20 6973   func_eval[0] is
-00015730: 2046 616c 7365 3a0a 2020 2020 2020 2020   False:.        
-00015740: 2020 2020 2020 2020 2020 2020 7061 7373              pass
-00015750: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015760: 2065 6c69 6620 6675 6e63 5f65 7661 6c20   elif func_eval 
-00015770: 3d3d 2028 5472 7565 2c20 5472 7565 293a  == (True, True):
-00015780: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015790: 2020 2020 2070 6c6f 745f 6c69 7374 2e61       plot_list.a
-000157a0: 7070 656e 6428 5b69 6e74 6572 7661 6c78  ppend([intervalx
-000157b0: 2c20 696e 7465 7276 616c 795d 290a 2020  , intervaly]).  
-000157c0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-000157d0: 6966 2066 756e 635f 6576 616c 5b31 5d20  if func_eval[1] 
-000157e0: 6973 204e 6f6e 6520 6f72 2066 756e 635f  is None or func_
-000157f0: 6576 616c 5b30 5d20 6973 204e 6f6e 653a  eval[0] is None:
-00015800: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015810: 2020 2020 2023 2053 7562 6469 7669 6465       # Subdivide
-00015820: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015830: 2020 2020 2061 7667 7820 3d20 696e 7465       avgx = inte
-00015840: 7276 616c 782e 6d69 640a 2020 2020 2020  rvalx.mid.      
-00015850: 2020 2020 2020 2020 2020 2020 2020 6176                av
-00015860: 6779 203d 2069 6e74 6572 7661 6c79 2e6d  gy = intervaly.m
-00015870: 6964 0a20 2020 2020 2020 2020 2020 2020  id.             
-00015880: 2020 2020 2020 2061 203d 2069 6e74 6572         a = inter
-00015890: 7661 6c28 696e 7465 7276 616c 782e 7374  val(intervalx.st
-000158a0: 6172 742c 2061 7667 7829 0a20 2020 2020  art, avgx).     
-000158b0: 2020 2020 2020 2020 2020 2020 2020 2062                 b
-000158c0: 203d 2069 6e74 6572 7661 6c28 6176 6778   = interval(avgx
-000158d0: 2c20 696e 7465 7276 616c 782e 656e 6429  , intervalx.end)
-000158e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000158f0: 2020 2020 2063 203d 2069 6e74 6572 7661       c = interva
-00015900: 6c28 696e 7465 7276 616c 792e 7374 6172  l(intervaly.star
-00015910: 742c 2061 7667 7929 0a20 2020 2020 2020  t, avgy).       
-00015920: 2020 2020 2020 2020 2020 2020 2064 203d               d =
-00015930: 2069 6e74 6572 7661 6c28 6176 6779 2c20   interval(avgy, 
-00015940: 696e 7465 7276 616c 792e 656e 6429 0a20  intervaly.end). 
-00015950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015960: 2020 2074 656d 705f 696e 7465 7276 616c     temp_interval
-00015970: 5f6c 6973 742e 6170 7065 6e64 285b 612c  _list.append([a,
-00015980: 2063 5d29 0a20 2020 2020 2020 2020 2020   c]).           
-00015990: 2020 2020 2020 2020 2074 656d 705f 696e           temp_in
-000159a0: 7465 7276 616c 5f6c 6973 742e 6170 7065  terval_list.appe
-000159b0: 6e64 285b 612c 2064 5d29 0a20 2020 2020  nd([a, d]).     
-000159c0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-000159d0: 656d 705f 696e 7465 7276 616c 5f6c 6973  emp_interval_lis
-000159e0: 742e 6170 7065 6e64 285b 622c 2063 5d29  t.append([b, c])
-000159f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015a00: 2020 2020 2074 656d 705f 696e 7465 7276       temp_interv
-00015a10: 616c 5f6c 6973 742e 6170 7065 6e64 285b  al_list.append([
-00015a20: 622c 2064 5d29 0a20 2020 2020 2020 2020  b, d]).         
-00015a30: 2020 2072 6574 7572 6e20 7465 6d70 5f69     return temp_i
-00015a40: 6e74 6572 7661 6c5f 6c69 7374 2c20 706c  nterval_list, pl
-00015a50: 6f74 5f6c 6973 740a 0a20 2020 2020 2020  ot_list..       
-00015a60: 2077 6869 6c65 206b 203e 3d20 3020 616e   while k >= 0 an
-00015a70: 6420 6c65 6e28 696e 7465 7276 616c 5f6c  d len(interval_l
-00015a80: 6973 7429 3a0a 2020 2020 2020 2020 2020  ist):.          
-00015a90: 2020 696e 7465 7276 616c 5f6c 6973 742c    interval_list,
-00015aa0: 2070 6c6f 745f 6c69 7374 5f74 656d 7020   plot_list_temp 
-00015ab0: 3d20 7265 6669 6e65 5f70 6978 656c 7328  = refine_pixels(
-00015ac0: 696e 7465 7276 616c 5f6c 6973 7429 0a20  interval_list). 
-00015ad0: 2020 2020 2020 2020 2020 2070 6c6f 745f             plot_
-00015ae0: 6c69 7374 2e65 7874 656e 6428 706c 6f74  list.extend(plot
-00015af0: 5f6c 6973 745f 7465 6d70 290a 2020 2020  _list_temp).    
-00015b00: 2020 2020 2020 2020 6b20 3d20 6b20 2d20          k = k - 
-00015b10: 310a 2020 2020 2020 2020 2320 4368 6563  1.        # Chec
-00015b20: 6b20 7768 6574 6865 7220 7468 6520 6578  k whether the ex
-00015b30: 7072 6573 7369 6f6e 2072 6570 7265 7365  pression represe
-00015b40: 6e74 7320 616e 2065 7175 616c 6974 790a  nts an equality.
-00015b50: 2020 2020 2020 2020 2320 4966 2069 7420          # If it 
-00015b60: 7265 7072 6573 656e 7473 2061 6e20 6571  represents an eq
-00015b70: 7561 6c69 7479 2c20 7468 656e 206e 6f6e  uality, then non
-00015b80: 6520 6f66 2074 6865 2069 6e74 6572 7661  e of the interva
-00015b90: 6c73 0a20 2020 2020 2020 2023 2077 6f75  ls.        # wou
-00015ba0: 6c64 2068 6176 6520 7361 7469 7366 6965  ld have satisfie
-00015bb0: 6420 7468 6520 6578 7072 6573 7369 6f6e  d the expression
-00015bc0: 2064 7565 2074 6f20 666c 6f61 7469 6e67   due to floating
-00015bd0: 2070 6f69 6e74 0a20 2020 2020 2020 2023   point.        #
-00015be0: 2064 6966 6665 7265 6e63 6573 2e20 4164   differences. Ad
-00015bf0: 6420 616c 6c20 7468 6520 756e 6465 6369  d all the undeci
-00015c00: 6465 6420 7661 6c75 6573 2074 6f20 7468  ded values to th
-00015c10: 6520 706c 6f74 2e0a 2020 2020 2020 2020  e plot..        
-00015c20: 6966 2073 656c 662e 6861 735f 6571 7561  if self.has_equa
-00015c30: 6c69 7479 3a0a 2020 2020 2020 2020 2020  lity:.          
-00015c40: 2020 666f 7220 696e 7465 7276 616c 7320    for intervals 
-00015c50: 696e 2069 6e74 6572 7661 6c5f 6c69 7374  in interval_list
-00015c60: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00015c70: 2020 696e 7465 7276 616c 7820 3d20 696e    intervalx = in
-00015c80: 7465 7276 616c 735b 305d 0a20 2020 2020  tervals[0].     
-00015c90: 2020 2020 2020 2020 2020 2069 6e74 6572             inter
-00015ca0: 7661 6c79 203d 2069 6e74 6572 7661 6c73  valy = intervals
-00015cb0: 5b31 5d0a 2020 2020 2020 2020 2020 2020  [1].            
-00015cc0: 2020 2020 6675 6e63 5f65 7661 6c20 3d20      func_eval = 
-00015cd0: 6675 6e63 2869 6e74 6572 7661 6c78 2c20  func(intervalx, 
-00015ce0: 696e 7465 7276 616c 7929 0a20 2020 2020  intervaly).     
-00015cf0: 2020 2020 2020 2020 2020 2069 6620 6675             if fu
-00015d00: 6e63 5f65 7661 6c5b 315d 2061 6e64 2066  nc_eval[1] and f
-00015d10: 756e 635f 6576 616c 5b30 5d20 6973 206e  unc_eval[0] is n
-00015d20: 6f74 2046 616c 7365 3a0a 2020 2020 2020  ot False:.      
-00015d30: 2020 2020 2020 2020 2020 2020 2020 706c                pl
-00015d40: 6f74 5f6c 6973 742e 6170 7065 6e64 285b  ot_list.append([
-00015d50: 696e 7465 7276 616c 782c 2069 6e74 6572  intervalx, inter
-00015d60: 7661 6c79 5d29 0a20 2020 2020 2020 2072  valy]).        r
-00015d70: 6574 7572 6e20 706c 6f74 5f6c 6973 742c  eturn plot_list,
-00015d80: 2022 6669 6c6c 220a 0a20 2020 2064 6566   "fill"..    def
-00015d90: 205f 6765 745f 6d65 7368 6573 5f67 7269   _get_meshes_gri
-00015da0: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
-00015db0: 2022 2222 4765 6e65 7261 7465 7320 7468   """Generates th
-00015dc0: 6520 6d65 7368 2066 6f72 2067 656e 6572  e mesh for gener
-00015dd0: 6174 696e 6720 6120 636f 6e74 6f75 722e  ating a contour.
-00015de0: 0a0a 2020 2020 2020 2020 496e 2074 6865  ..        In the
-00015df0: 2063 6173 6520 6f66 2065 7175 616c 6974   case of equalit
-00015e00: 792c 2060 6063 6f6e 746f 7572 6060 2066  y, ``contour`` f
-00015e10: 756e 6374 696f 6e20 6f66 206d 6174 706c  unction of matpl
-00015e20: 6f74 6c69 6220 6361 6e0a 2020 2020 2020  otlib can.      
-00015e30: 2020 6265 2075 7365 642e 2049 6e20 6f74    be used. In ot
-00015e40: 6865 7220 6361 7365 732c 206d 6174 706c  her cases, matpl
-00015e50: 6f74 6c69 6227 7320 6060 636f 6e74 6f75  otlib's ``contou
-00015e60: 7266 6060 2069 7320 7573 6564 2e0a 2020  rf`` is used..  
-00015e70: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00015e80: 2020 6e70 203d 2069 6d70 6f72 745f 6d6f    np = import_mo
-00015e90: 6475 6c65 2827 6e75 6d70 7927 290a 0a20  dule('numpy').. 
-00015ea0: 2020 2020 2020 2078 6172 7261 792c 2079         xarray, y
-00015eb0: 6172 7261 792c 207a 5f67 7269 6420 3d20  array, z_grid = 
-00015ec0: 7365 6c66 2e5f 6576 616c 7561 7465 2829  self._evaluate()
-00015ed0: 0a20 2020 2020 2020 205f 7265 2c20 5f69  .        _re, _i
-00015ee0: 6d20 3d20 6e70 2e72 6561 6c28 7a5f 6772  m = np.real(z_gr
-00015ef0: 6964 292c 206e 702e 696d 6167 287a 5f67  id), np.imag(z_g
-00015f00: 7269 6429 0a20 2020 2020 2020 205f 7265  rid).        _re
-00015f10: 5b6e 702e 696e 7665 7274 286e 702e 6973  [np.invert(np.is
-00015f20: 636c 6f73 6528 5f69 6d2c 206e 702e 7a65  close(_im, np.ze
-00015f30: 726f 735f 6c69 6b65 285f 696d 2929 295d  ros_like(_im)))]
-00015f40: 203d 206e 702e 6e61 6e0a 2020 2020 2020   = np.nan.      
-00015f50: 2020 6966 2073 656c 662e 5f69 735f 6571    if self._is_eq
-00015f60: 7561 6c69 7479 3a0a 2020 2020 2020 2020  uality:.        
-00015f70: 2020 2020 7265 7475 726e 2078 6172 7261      return xarra
-00015f80: 792c 2079 6172 7261 792c 205f 7265 2c20  y, yarray, _re, 
-00015f90: 2763 6f6e 746f 7572 270a 2020 2020 2020  'contour'.      
-00015fa0: 2020 7265 7475 726e 2078 6172 7261 792c    return xarray,
-00015fb0: 2079 6172 7261 792c 205f 7265 2c20 2763   yarray, _re, 'c
-00015fc0: 6f6e 746f 7572 6627 0a0a 2020 2020 4073  ontourf'..    @s
-00015fd0: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
-00015fe0: 6465 6620 5f70 7265 7072 6f63 6573 735f  def _preprocess_
-00015ff0: 6d65 7368 6772 6964 5f65 7870 7265 7373  meshgrid_express
-00016000: 696f 6e28 6578 7072 2c20 6164 6170 7469  ion(expr, adapti
-00016010: 7665 293a 0a20 2020 2020 2020 2022 2222  ve):.        """
-00016020: 4966 2074 6865 2065 7870 7265 7373 696f  If the expressio
-00016030: 6e20 6973 2061 2052 656c 6174 696f 6e61  n is a Relationa
-00016040: 6c2c 2072 6577 7269 7465 2069 7420 6173  l, rewrite it as
-00016050: 2061 2073 696e 676c 650a 2020 2020 2020   a single.      
-00016060: 2020 6578 7072 6573 7369 6f6e 2e0a 0a20    expression... 
-00016070: 2020 2020 2020 2052 6574 7572 6e73 0a20         Returns. 
-00016080: 2020 2020 2020 203d 3d3d 3d3d 3d3d 0a0a         =======..
-00016090: 2020 2020 2020 2020 6578 7072 203a 2045          expr : E
-000160a0: 7870 720a 2020 2020 2020 2020 2020 2020  xpr.            
-000160b0: 5468 6520 7265 7772 6974 7465 6e20 6578  The rewritten ex
-000160c0: 7072 6573 7369 6f6e 0a0a 2020 2020 2020  pression..      
-000160d0: 2020 6571 7561 6c69 7479 203a 2042 6f6f    equality : Boo
-000160e0: 6c65 616e 0a20 2020 2020 2020 2020 2020  lean.           
-000160f0: 2057 6865 7465 7220 7468 6520 6f72 6967   Wheter the orig
-00016100: 696e 616c 2065 7870 7265 7373 696f 6e20  inal expression 
-00016110: 7761 7320 616e 2045 7175 616c 6974 7920  was an Equality 
-00016120: 6f72 206e 6f74 2e0a 2020 2020 2020 2020  or not..        
-00016130: 2222 220a 2020 2020 2020 2020 6571 7561  """.        equa
-00016140: 6c69 7479 203d 2046 616c 7365 0a20 2020  lity = False.   
-00016150: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
-00016160: 6365 2865 7870 722c 2045 7175 616c 6974  ce(expr, Equalit
-00016170: 7929 3a0a 2020 2020 2020 2020 2020 2020  y):.            
-00016180: 6578 7072 203d 2065 7870 722e 6c68 7320  expr = expr.lhs 
-00016190: 2d20 6578 7072 2e72 6873 0a20 2020 2020  - expr.rhs.     
-000161a0: 2020 2020 2020 2065 7175 616c 6974 7920         equality 
-000161b0: 3d20 5472 7565 0a20 2020 2020 2020 2065  = True.        e
-000161c0: 6c69 6620 6973 696e 7374 616e 6365 2865  lif isinstance(e
-000161d0: 7870 722c 2028 4772 6561 7465 7254 6861  xpr, (GreaterTha
-000161e0: 6e2c 2053 7472 6963 7447 7265 6174 6572  n, StrictGreater
-000161f0: 5468 616e 2929 3a0a 2020 2020 2020 2020  Than)):.        
-00016200: 2020 2020 6578 7072 203d 2065 7870 722e      expr = expr.
-00016210: 6c68 7320 2d20 6578 7072 2e72 6873 0a20  lhs - expr.rhs. 
-00016220: 2020 2020 2020 2065 6c69 6620 6973 696e         elif isin
-00016230: 7374 616e 6365 2865 7870 722c 2028 4c65  stance(expr, (Le
-00016240: 7373 5468 616e 2c20 5374 7269 6374 4c65  ssThan, StrictLe
-00016250: 7373 5468 616e 2929 3a0a 2020 2020 2020  ssThan)):.      
-00016260: 2020 2020 2020 6578 7072 203d 2065 7870        expr = exp
-00016270: 722e 7268 7320 2d20 6578 7072 2e6c 6873  r.rhs - expr.lhs
-00016280: 0a20 2020 2020 2020 2065 6c69 6620 6e6f  .        elif no
-00016290: 7420 6164 6170 7469 7665 3a0a 2020 2020  t adaptive:.    
-000162a0: 2020 2020 2020 2020 7261 6973 6520 4e6f          raise No
-000162b0: 7449 6d70 6c65 6d65 6e74 6564 4572 726f  tImplementedErro
-000162c0: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
-000162d0: 2020 2022 5468 6520 6578 7072 6573 7369     "The expressi
-000162e0: 6f6e 2069 7320 6e6f 7420 7375 7070 6f72  on is not suppor
-000162f0: 7465 6420 666f 7220 220a 2020 2020 2020  ted for ".      
-00016300: 2020 2020 2020 2020 2020 2270 6c6f 7474            "plott
-00016310: 696e 6720 696e 2075 6e69 666f 726d 206d  ing in uniform m
-00016320: 6573 6865 6420 706c 6f74 2e22 0a20 2020  eshed plot.".   
-00016330: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-00016340: 2020 2072 6574 7572 6e20 6578 7072 2c20     return expr, 
-00016350: 6571 7561 6c69 7479 0a0a 2020 2020 6465  equality..    de
-00016360: 6620 6765 745f 6c61 6265 6c28 7365 6c66  f get_label(self
-00016370: 2c20 7573 655f 6c61 7465 783d 4661 6c73  , use_latex=Fals
-00016380: 652c 2077 7261 7070 6572 3d22 2425 7324  e, wrapper="$%s$
-00016390: 2229 3a0a 2020 2020 2020 2020 2222 2252  "):.        """R
-000163a0: 6574 7572 6e20 7468 6520 6c61 6265 6c20  eturn the label 
-000163b0: 746f 2062 6520 7573 6564 2074 6f20 6469  to be used to di
-000163c0: 7370 6c61 7920 7468 6520 6578 7072 6573  splay the expres
-000163d0: 7369 6f6e 2e0a 0a20 2020 2020 2020 2050  sion...        P
-000163e0: 6172 616d 6574 6572 730a 2020 2020 2020  arameters.      
-000163f0: 2020 3d3d 3d3d 3d3d 3d3d 3d3d 0a20 2020    ==========.   
-00016400: 2020 2020 2075 7365 5f6c 6174 6578 203a       use_latex :
-00016410: 2062 6f6f 6c0a 2020 2020 2020 2020 2020   bool.          
-00016420: 2020 4966 2046 616c 7365 2c20 7468 6520    If False, the 
-00016430: 7374 7269 6e67 2072 6570 7265 7365 6e74  string represent
-00016440: 6174 696f 6e20 6f66 2074 6865 2065 7870  ation of the exp
-00016450: 7265 7373 696f 6e20 6973 2072 6574 7572  ression is retur
-00016460: 6e65 642e 0a20 2020 2020 2020 2020 2020  ned..           
-00016470: 2049 6620 5472 7565 2c20 7468 6520 6c61   If True, the la
-00016480: 7465 7820 7265 7072 6573 656e 7461 7469  tex representati
-00016490: 6f6e 2069 7320 7265 7475 726e 6564 2e0a  on is returned..
-000164a0: 2020 2020 2020 2020 7772 6170 7065 7220          wrapper 
-000164b0: 3a20 7374 720a 2020 2020 2020 2020 2020  : str.          
-000164c0: 2020 5468 6520 6261 636b 656e 6420 6d69    The backend mi
-000164d0: 6768 7420 6e65 6564 2074 6865 206c 6174  ght need the lat
-000164e0: 6578 2072 6570 7265 7365 6e74 6174 696f  ex representatio
-000164f0: 6e20 746f 2062 6520 7772 6170 7065 6420  n to be wrapped 
-00016500: 6279 0a20 2020 2020 2020 2020 2020 2073  by.            s
-00016510: 6f6d 6520 6368 6172 6163 7465 7273 2e20  ome characters. 
-00016520: 4465 6661 756c 7420 746f 2060 6022 2425  Default to ``"$%
-00016530: 7324 2260 602e 0a0a 2020 2020 2020 2020  s$"``...        
-00016540: 5265 7475 726e 730a 2020 2020 2020 2020  Returns.        
-00016550: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
-00016560: 6c61 6265 6c20 3a20 7374 720a 2020 2020  label : str.    
-00016570: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00016580: 6966 2075 7365 5f6c 6174 6578 2069 7320  if use_latex is 
-00016590: 4661 6c73 653a 0a20 2020 2020 2020 2020  False:.         
-000165a0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-000165b0: 6c61 6265 6c0a 2020 2020 2020 2020 6966  label.        if
-000165c0: 2028 0a20 2020 2020 2020 2020 2020 2028   (.            (
-000165d0: 7365 6c66 2e5f 6c61 6265 6c20 3d3d 2073  self._label == s
-000165e0: 7472 2873 656c 662e 5f61 6461 7074 6976  tr(self._adaptiv
-000165f0: 655f 6578 7072 2929 206f 720a 2020 2020  e_expr)) or.    
-00016600: 2020 2020 2020 2020 2822 4571 2825 732c          ("Eq(%s,
-00016610: 2030 2922 2025 2073 656c 662e 5f6c 6162   0)" % self._lab
-00016620: 656c 203d 3d20 7374 7228 7365 6c66 2e5f  el == str(self._
-00016630: 6164 6170 7469 7665 5f65 7870 7229 290a  adaptive_expr)).
-00016640: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
-00016650: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00016660: 6c66 2e5f 6765 745f 7772 6170 7065 645f  lf._get_wrapped_
-00016670: 6c61 6265 6c28 7365 6c66 2e5f 6c61 7465  label(self._late
-00016680: 785f 6c61 6265 6c2c 2077 7261 7070 6572  x_label, wrapper
-00016690: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-000166a0: 2073 656c 662e 5f6c 6174 6578 5f6c 6162   self._latex_lab
-000166b0: 656c 0a0a 0a63 6c61 7373 2049 6d70 6c69  el...class Impli
-000166c0: 6369 7433 4453 6572 6965 7328 0a20 2020  cit3DSeries(.   
-000166d0: 2043 6f6d 6d6f 6e55 6e69 666f 726d 4576   CommonUniformEv
-000166e0: 616c 7561 7469 6f6e 2c20 5375 7266 6163  aluation, Surfac
-000166f0: 6542 6173 6553 6572 6965 730a 293a 0a20  eBaseSeries.):. 
-00016700: 2020 2069 735f 696d 706c 6963 6974 203d     is_implicit =
-00016710: 2054 7275 650a 2020 2020 5f4e 203d 2036   True.    _N = 6
-00016720: 300a 0a20 2020 2064 6566 205f 5f69 6e69  0..    def __ini
-00016730: 745f 5f28 7365 6c66 2c20 6578 7072 2c20  t__(self, expr, 
-00016740: 7261 6e67 655f 782c 2072 616e 6765 5f79  range_x, range_y
-00016750: 2c20 7261 6e67 655f 7a2c 206c 6162 656c  , range_z, label
-00016760: 3d22 222c 202a 2a6b 7761 7267 7329 3a0a  ="", **kwargs):.
-00016770: 2020 2020 2020 2020 7375 7065 7228 292e          super().
-00016780: 5f5f 696e 6974 5f5f 282a 2a6b 7761 7267  __init__(**kwarg
-00016790: 7329 0a20 2020 2020 2020 2073 656c 662e  s).        self.
-000167a0: 6578 7072 203d 2065 7870 7220 6966 2063  expr = expr if c
-000167b0: 616c 6c61 626c 6528 6578 7072 2920 656c  allable(expr) el
-000167c0: 7365 2073 796d 7069 6679 2865 7870 7229  se sympify(expr)
-000167d0: 0a20 2020 2020 2020 2073 656c 662e 7261  .        self.ra
-000167e0: 6e67 6573 203d 205b 7261 6e67 655f 782c  nges = [range_x,
-000167f0: 2072 616e 6765 5f79 2c20 7261 6e67 655f   range_y, range_
-00016800: 7a5d 0a20 2020 2020 2020 2073 656c 662e  z].        self.
-00016810: 7661 725f 782c 2073 656c 662e 7374 6172  var_x, self.star
-00016820: 745f 782c 2073 656c 662e 656e 645f 7820  t_x, self.end_x 
-00016830: 3d20 7365 6c66 2e72 616e 6765 735b 305d  = self.ranges[0]
-00016840: 0a20 2020 2020 2020 2073 656c 662e 7661  .        self.va
-00016850: 725f 792c 2073 656c 662e 7374 6172 745f  r_y, self.start_
-00016860: 792c 2073 656c 662e 656e 645f 7920 3d20  y, self.end_y = 
-00016870: 7365 6c66 2e72 616e 6765 735b 315d 0a20  self.ranges[1]. 
-00016880: 2020 2020 2020 2073 656c 662e 7661 725f         self.var_
-00016890: 7a2c 2073 656c 662e 7374 6172 745f 7a2c  z, self.start_z,
-000168a0: 2073 656c 662e 656e 645f 7a20 3d20 7365   self.end_z = se
-000168b0: 6c66 2e72 616e 6765 735b 325d 0a20 2020  lf.ranges[2].   
-000168c0: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
-000168d0: 6365 2873 656c 662e 6578 7072 2c20 506c  ce(self.expr, Pl
-000168e0: 616e 6529 3a0a 2020 2020 2020 2020 2020  ane):.          
-000168f0: 2020 7365 6c66 2e65 7870 7220 3d20 7365    self.expr = se
-00016900: 6c66 2e65 7870 722e 6571 7561 7469 6f6e  lf.expr.equation
-00016910: 2873 656c 662e 7661 725f 782c 2073 656c  (self.var_x, sel
-00016920: 662e 7661 725f 792c 2073 656c 662e 7661  f.var_y, self.va
-00016930: 725f 7a29 0a20 2020 2020 2020 2073 656c  r_z).        sel
-00016940: 662e 5f73 6574 5f73 7572 6661 6365 5f6c  f._set_surface_l
-00016950: 6162 656c 286c 6162 656c 290a 0a20 2020  abel(label)..   
-00016960: 2064 6566 205f 5f73 7472 5f5f 2873 656c   def __str__(sel
-00016970: 6629 3a0a 2020 2020 2020 2020 7661 725f  f):.        var_
-00016980: 782c 2073 7461 7274 5f78 2c20 656e 645f  x, start_x, end_
-00016990: 7820 3d20 7365 6c66 2e72 616e 6765 735b  x = self.ranges[
-000169a0: 305d 0a20 2020 2020 2020 2076 6172 5f79  0].        var_y
-000169b0: 2c20 7374 6172 745f 792c 2065 6e64 5f79  , start_y, end_y
-000169c0: 203d 2073 656c 662e 7261 6e67 6573 5b31   = self.ranges[1
-000169d0: 5d0a 2020 2020 2020 2020 7661 725f 7a2c  ].        var_z,
-000169e0: 2073 7461 7274 5f7a 2c20 656e 645f 7a20   start_z, end_z 
-000169f0: 3d20 7365 6c66 2e72 616e 6765 735b 325d  = self.ranges[2]
-00016a00: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00016a10: 280a 2020 2020 2020 2020 2020 2020 2269  (.            "i
-00016a20: 6d70 6c69 6369 7420 7375 7266 6163 6520  mplicit surface 
-00016a30: 7365 7269 6573 3a20 2573 2066 6f72 2025  series: %s for %
-00016a40: 7320 6f76 6572 2025 7320 616e 6420 2573  s over %s and %s
-00016a50: 206f 7665 7220 2573 220a 2020 2020 2020   over %s".      
-00016a60: 2020 2020 2020 2220 616e 6420 2573 206f        " and %s o
-00016a70: 7665 7220 2573 2229 2025 2028 0a20 2020  ver %s") % (.   
-00016a80: 2020 2020 2020 2020 2020 2020 2073 7472               str
-00016a90: 2873 656c 662e 6578 7072 292c 0a20 2020  (self.expr),.   
-00016aa0: 2020 2020 2020 2020 2020 2020 2073 7472               str
-00016ab0: 2876 6172 5f78 292c 2073 7472 2828 666c  (var_x), str((fl
-00016ac0: 6f61 7428 7374 6172 745f 7829 2c20 666c  oat(start_x), fl
-00016ad0: 6f61 7428 656e 645f 7829 2929 2c0a 2020  oat(end_x))),.  
-00016ae0: 2020 2020 2020 2020 2020 2020 2020 7374                st
-00016af0: 7228 7661 725f 7929 2c20 7374 7228 2866  r(var_y), str((f
-00016b00: 6c6f 6174 2873 7461 7274 5f79 292c 2066  loat(start_y), f
-00016b10: 6c6f 6174 2865 6e64 5f79 2929 292c 0a20  loat(end_y))),. 
-00016b20: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00016b30: 7472 2876 6172 5f7a 292c 2073 7472 2828  tr(var_z), str((
-00016b40: 666c 6f61 7428 7374 6172 745f 7a29 2c20  float(start_z), 
-00016b50: 666c 6f61 7428 656e 645f 7a29 2929 0a20  float(end_z))). 
-00016b60: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
-00016b70: 2020 6465 6620 6765 745f 6461 7461 2873    def get_data(s
-00016b80: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-00016b90: 2245 7661 6c75 6174 6520 7468 6520 6578  "Evaluate the ex
-00016ba0: 7072 6573 7369 6f6e 206f 7665 7220 7468  pression over th
-00016bb0: 6520 7072 6f76 6964 6564 2064 6f6d 6169  e provided domai
-00016bc0: 6e2e 2054 6865 2062 6163 6b65 6e64 2077  n. The backend w
-00016bd0: 696c 6c0a 2020 2020 2020 2020 7468 656e  ill.        then
-00016be0: 2074 7279 2074 6f20 636f 6d70 7574 6520   try to compute 
-00016bf0: 616e 6420 7669 7375 616c 697a 6520 7468  and visualize th
-00016c00: 6520 6669 6e61 6c20 7265 7375 6c74 2c20  e final result, 
-00016c10: 6966 2069 7420 7375 7070 6f72 7420 7468  if it support th
-00016c20: 6973 0a20 2020 2020 2020 2064 6174 6120  is.        data 
-00016c30: 7365 7269 6573 2e0a 0a20 2020 2020 2020  series...       
-00016c40: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
-00016c50: 203d 3d3d 3d3d 3d3d 0a20 2020 2020 2020   =======.       
-00016c60: 206d 6573 685f 7820 3a20 6e70 2e6e 6461   mesh_x : np.nda
-00016c70: 7272 6179 205b 6e31 2078 206e 3220 7820  rray [n1 x n2 x 
-00016c80: 6e33 5d0a 2020 2020 2020 2020 6d65 7368  n3].        mesh
-00016c90: 5f79 203a 206e 702e 6e64 6172 7261 7920  _y : np.ndarray 
-00016ca0: 5b6e 3120 7820 6e32 2078 206e 335d 0a20  [n1 x n2 x n3]. 
-00016cb0: 2020 2020 2020 206d 6573 685f 7a20 3a20         mesh_z : 
-00016cc0: 6e70 2e6e 6461 7272 6179 205b 6e31 2078  np.ndarray [n1 x
-00016cd0: 206e 3220 7820 6e33 5d0a 2020 2020 2020   n2 x n3].      
-00016ce0: 2020 6620 3a20 6e70 2e6e 6461 7272 6179    f : np.ndarray
-00016cf0: 205b 6e31 2078 206e 3220 7820 6e33 5d0a   [n1 x n2 x n3].
-00016d00: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00016d10: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
-00016d20: 6d6f 6475 6c65 2827 6e75 6d70 7927 290a  module('numpy').
-00016d30: 0a20 2020 2020 2020 2072 6573 756c 7473  .        results
-00016d40: 203d 2073 656c 662e 5f65 7661 6c75 6174   = self._evaluat
-00016d50: 6528 290a 2020 2020 2020 2020 666f 7220  e().        for 
-00016d60: 692c 2072 2069 6e20 656e 756d 6572 6174  i, r in enumerat
-00016d70: 6528 7265 7375 6c74 7329 3a0a 2020 2020  e(results):.    
-00016d80: 2020 2020 2020 2020 7265 5f76 2c20 696d          re_v, im
-00016d90: 5f76 203d 206e 702e 7265 616c 2872 292c  _v = np.real(r),
-00016da0: 206e 702e 696d 6167 2872 290a 2020 2020   np.imag(r).    
-00016db0: 2020 2020 2020 2020 7265 5f76 5b6e 702e          re_v[np.
-00016dc0: 696e 7665 7274 286e 702e 6973 636c 6f73  invert(np.isclos
-00016dd0: 6528 696d 5f76 2c20 6e70 2e7a 6572 6f73  e(im_v, np.zeros
-00016de0: 5f6c 696b 6528 696d 5f76 2929 295d 203d  _like(im_v)))] =
-00016df0: 206e 702e 6e61 6e0a 2020 2020 2020 2020   np.nan.        
-00016e00: 2020 2020 7265 7375 6c74 735b 695d 203d      results[i] =
-00016e10: 2072 655f 760a 0a20 2020 2020 2020 2072   re_v..        r
-00016e20: 6574 7572 6e20 7365 6c66 2e5f 6170 706c  eturn self._appl
-00016e30: 795f 7472 616e 7366 6f72 6d28 2a72 6573  y_transform(*res
-00016e40: 756c 7473 290a 0a0a 636c 6173 7320 436f  ults)...class Co
-00016e50: 6d70 6c65 7850 6f69 6e74 5365 7269 6573  mplexPointSeries
-00016e60: 284c 696e 6532 4442 6173 6553 6572 6965  (Line2DBaseSerie
-00016e70: 7329 3a0a 2020 2020 2222 2252 6570 7265  s):.    """Repre
-00016e80: 7365 6e74 6174 696f 6e20 666f 7220 6120  sentation for a 
-00016e90: 6c69 6e65 2069 6e20 7468 6520 636f 6d70  line in the comp
-00016ea0: 6c65 7820 706c 616e 6520 636f 6e73 6973  lex plane consis
-00016eb0: 7469 6e67 206f 660a 2020 2020 6c69 7374  ting of.    list
-00016ec0: 206f 6620 706f 696e 7473 2e22 2222 0a0a   of points."""..
-00016ed0: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
-00016ee0: 2873 656c 662c 2065 7870 722c 206c 6162  (self, expr, lab
-00016ef0: 656c 3d22 222c 202a 2a6b 7761 7267 7329  el="", **kwargs)
-00016f00: 3a0a 2020 2020 2020 2020 7375 7065 7228  :.        super(
-00016f10: 292e 5f5f 696e 6974 5f5f 286c 6162 656c  ).__init__(label
-00016f20: 3d6c 6162 656c 2c20 2a2a 6b77 6172 6773  =label, **kwargs
-00016f30: 290a 2020 2020 2020 2020 6966 2069 7369  ).        if isi
-00016f40: 6e73 7461 6e63 6528 6578 7072 2c20 286c  nstance(expr, (l
-00016f50: 6973 742c 2074 7570 6c65 2929 3a0a 2020  ist, tuple)):.  
-00016f60: 2020 2020 2020 2020 2020 7365 6c66 2e65            self.e
-00016f70: 7870 7220 3d20 5475 706c 6528 2a65 7870  xpr = Tuple(*exp
-00016f80: 7229 0a20 2020 2020 2020 2065 6c69 6620  r).        elif 
-00016f90: 6973 696e 7374 616e 6365 2865 7870 722c  isinstance(expr,
-00016fa0: 2045 7870 7229 3a0a 2020 2020 2020 2020   Expr):.        
-00016fb0: 2020 2020 7365 6c66 2e65 7870 7220 3d20      self.expr = 
-00016fc0: 5475 706c 6528 6578 7072 290a 2020 2020  Tuple(expr).    
-00016fd0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00016fe0: 2020 2020 2020 7365 6c66 2e65 7870 7220        self.expr 
-00016ff0: 3d20 6578 7072 0a0a 2020 2020 2020 2020  = expr..        
-00017000: 7365 6c66 2e5f 626c 6f63 6b5f 6c61 6d62  self._block_lamb
-00017010: 6461 5f66 756e 6374 696f 6e73 282a 7365  da_functions(*se
-00017020: 6c66 2e65 7870 7229 0a0a 2020 2020 2020  lf.expr)..      
-00017030: 2020 7365 6c66 2e69 735f 706f 696e 7420    self.is_point 
-00017040: 3d20 6b77 6172 6773 2e67 6574 2822 7363  = kwargs.get("sc
-00017050: 6174 7465 7222 2c20 6b77 6172 6773 2e67  atter", kwargs.g
-00017060: 6574 2822 6973 5f70 6f69 6e74 222c 2054  et("is_point", T
-00017070: 7275 6529 290a 2020 2020 2020 2020 6966  rue)).        if
-00017080: 2073 656c 662e 7573 655f 636d 2061 6e64   self.use_cm and
-00017090: 2073 656c 662e 636f 6c6f 725f 6675 6e63   self.color_func
-000170a0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-000170b0: 6c66 2e69 735f 7061 7261 6d65 7472 6963  lf.is_parametric
-000170c0: 203d 2054 7275 650a 0a20 2020 2064 6566   = True..    def
-000170d0: 205f 6765 745f 6461 7461 5f68 656c 7065   _get_data_helpe
-000170e0: 7228 7365 6c66 293a 0a20 2020 2020 2020  r(self):.       
-000170f0: 2022 2222 5265 7475 726e 7320 636f 6f72   """Returns coor
-00017100: 6469 6e61 7465 7320 7468 6174 206e 6565  dinates that nee
-00017110: 6473 2074 6f20 6265 2070 6f73 7470 726f  ds to be postpro
-00017120: 6365 7373 6564 2e22 2222 0a20 2020 2020  cessed.""".     
-00017130: 2020 206e 7020 3d20 696d 706f 7274 5f6d     np = import_m
-00017140: 6f64 756c 6528 276e 756d 7079 2729 0a20  odule('numpy'). 
-00017150: 2020 2020 2020 2070 6f69 6e74 7320 3d20         points = 
-00017160: 5b63 6f6d 706c 6578 2870 2e65 7661 6c66  [complex(p.evalf
-00017170: 2873 7562 733d 7365 6c66 2e70 6172 616d  (subs=self.param
-00017180: 7329 2920 666f 7220 7020 696e 2073 656c  s)) for p in sel
-00017190: 662e 6578 7072 5d0a 2020 2020 2020 2020  f.expr].        
-000171a0: 706f 696e 7473 203d 206e 702e 6172 7261  points = np.arra
-000171b0: 7928 706f 696e 7473 290a 2020 2020 2020  y(points).      
-000171c0: 2020 722c 2069 203d 206e 702e 7265 616c    r, i = np.real
-000171d0: 2870 6f69 6e74 7329 2c20 6e70 2e69 6d61  (points), np.ima
-000171e0: 6728 706f 696e 7473 290a 2020 2020 2020  g(points).      
-000171f0: 2020 6966 2073 656c 662e 7573 655f 636d    if self.use_cm
-00017200: 2061 6e64 2063 616c 6c61 626c 6528 7365   and callable(se
-00017210: 6c66 2e63 6f6c 6f72 5f66 756e 6329 3a0a  lf.color_func):.
-00017220: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00017230: 726e 2072 2c20 692c 2073 656c 662e 6576  rn r, i, self.ev
-00017240: 616c 5f63 6f6c 6f72 5f66 756e 6328 722c  al_color_func(r,
-00017250: 2069 290a 2020 2020 2020 2020 7265 7475   i).        retu
-00017260: 726e 2072 2c20 690a 0a20 2020 2064 6566  rn r, i..    def
-00017270: 205f 5f73 7472 5f5f 2873 656c 6629 3a0a   __str__(self):.
-00017280: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00017290: 656c 662e 5f73 7472 5f68 656c 7065 7228  elf._str_helper(
-000172a0: 2263 6f6d 706c 6578 2070 6f69 6e74 733a  "complex points:
-000172b0: 2025 7322 2025 2073 656c 662e 6578 7072   %s" % self.expr
-000172c0: 290a 0a0a 636c 6173 7320 436f 6d70 6c65  )...class Comple
-000172d0: 7853 7572 6661 6365 4261 7365 5365 7269  xSurfaceBaseSeri
-000172e0: 6573 2853 7572 6661 6365 4261 7365 5365  es(SurfaceBaseSe
-000172f0: 7269 6573 293a 0a20 2020 2022 2222 5265  ries):.    """Re
-00017300: 7072 6573 656e 7420 6120 636f 6d70 6c65  present a comple
-00017310: 7820 6675 6e63 7469 6f6e 2e22 2222 0a20  x function.""". 
-00017320: 2020 2069 735f 636f 6d70 6c65 7820 3d20     is_complex = 
-00017330: 5472 7565 0a20 2020 205f 4e20 3d20 3330  True.    _N = 30
-00017340: 300a 0a20 2020 2064 6566 205f 5f69 6e69  0..    def __ini
-00017350: 745f 5f28 7365 6c66 2c20 6578 7072 2c20  t__(self, expr, 
-00017360: 722c 206c 6162 656c 3d22 222c 202a 2a6b  r, label="", **k
-00017370: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
-00017380: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-00017390: 282a 2a6b 7761 7267 7329 0a20 2020 2020  (**kwargs).     
-000173a0: 2020 2073 656c 662e 7261 6e67 6573 203d     self.ranges =
-000173b0: 205b 725d 0a20 2020 2020 2020 2073 656c   [r].        sel
-000173c0: 662e 5f6c 6162 656c 203d 2073 7472 2865  f._label = str(e
-000173d0: 7870 7229 2069 6620 6c61 6265 6c20 6973  xpr) if label is
-000173e0: 204e 6f6e 6520 656c 7365 206c 6162 656c   None else label
-000173f0: 0a20 2020 2020 2020 2073 656c 662e 5f6c  .        self._l
-00017400: 6174 6578 5f6c 6162 656c 203d 206c 6174  atex_label = lat
-00017410: 6578 2865 7870 7229 2069 6620 6c61 6265  ex(expr) if labe
-00017420: 6c20 6973 204e 6f6e 6520 656c 7365 206c  l is None else l
-00017430: 6162 656c 0a20 2020 2020 2020 2023 2064  abel.        # d
-00017440: 6574 6572 6d69 6e65 7320 7768 6174 2064  etermines what d
-00017450: 6174 6120 746f 2072 6574 7572 6e20 6f6e  ata to return on
-00017460: 2074 6865 207a 2d61 7869 730a 2020 2020   the z-axis.    
-00017470: 2020 2020 7365 6c66 2e5f 7265 7475 726e      self._return
-00017480: 203d 206b 7761 7267 732e 6765 7428 2272   = kwargs.get("r
-00017490: 6574 7572 6e22 2c20 4e6f 6e65 290a 0a20  eturn", None).. 
-000174a0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-000174b0: 2064 6566 2076 6172 2873 656c 6629 3a0a   def var(self):.
-000174c0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-000174d0: 656c 662e 7261 6e67 6573 5b30 5d5b 305d  elf.ranges[0][0]
-000174e0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-000174f0: 2020 2020 6465 6620 7374 6172 7428 7365      def start(se
-00017500: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-00017510: 7572 6e20 7365 6c66 2e72 616e 6765 735b  urn self.ranges[
-00017520: 305d 5b31 5d0a 0a20 2020 2040 7072 6f70  0][1]..    @prop
-00017530: 6572 7479 0a20 2020 2064 6566 2065 6e64  erty.    def end
-00017540: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00017550: 7265 7475 726e 2073 656c 662e 7261 6e67  return self.rang
-00017560: 6573 5b30 5d5b 325d 0a0a 2020 2020 6465  es[0][2]..    de
-00017570: 6620 5f5f 7374 725f 5f28 7365 6c66 293a  f __str__(self):
-00017580: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00017590: 2e69 735f 646f 6d61 696e 5f63 6f6c 6f72  .is_domain_color
-000175a0: 696e 673a 0a20 2020 2020 2020 2020 2020  ing:.           
-000175b0: 2070 7265 6669 7820 3d20 2263 6f6d 706c   prefix = "compl
-000175c0: 6578 2064 6f6d 6169 6e20 636f 6c6f 7269  ex domain colori
-000175d0: 6e67 220a 2020 2020 2020 2020 2020 2020  ng".            
-000175e0: 6966 2073 656c 662e 6973 5f33 4473 7572  if self.is_3Dsur
-000175f0: 6661 6365 3a0a 2020 2020 2020 2020 2020  face:.          
-00017600: 2020 2020 2020 7072 6566 6978 203d 2022        prefix = "
-00017610: 636f 6d70 6c65 7820 3344 2064 6f6d 6169  complex 3D domai
-00017620: 6e20 636f 6c6f 7269 6e67 220a 2020 2020  n coloring".    
-00017630: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00017640: 2020 2020 2020 7072 6566 6978 203d 2022        prefix = "
-00017650: 636f 6d70 6c65 7820 6361 7274 6573 6961  complex cartesia
-00017660: 6e20 7375 7266 6163 6522 0a20 2020 2020  n surface".     
-00017670: 2020 2020 2020 2069 6620 7365 6c66 2e69         if self.i
-00017680: 735f 636f 6e74 6f75 723a 0a20 2020 2020  s_contour:.     
-00017690: 2020 2020 2020 2020 2020 2070 7265 6669             prefi
-000176a0: 7820 3d20 2263 6f6d 706c 6578 2063 6f6e  x = "complex con
-000176b0: 746f 7572 220a 0a20 2020 2020 2020 2077  tour"..        w
-000176c0: 7261 7070 6572 203d 205f 6765 745f 7772  rapper = _get_wr
-000176d0: 6170 7065 725f 666f 725f 6578 7072 2873  apper_for_expr(s
-000176e0: 656c 662e 5f72 6574 7572 6e29 0a20 2020  elf._return).   
-000176f0: 2020 2020 2072 6573 2c20 7265 6520 3d20       res, ree = 
-00017700: 7265 2873 656c 662e 7374 6172 7429 2c20  re(self.start), 
-00017710: 7265 2873 656c 662e 656e 6429 0a20 2020  re(self.end).   
-00017720: 2020 2020 2069 6d73 2c20 696d 6520 3d20       ims, ime = 
-00017730: 696d 2873 656c 662e 7374 6172 7429 2c20  im(self.start), 
-00017740: 696d 2873 656c 662e 656e 6429 0a20 2020  im(self.end).   
-00017750: 2020 2020 2066 203d 206c 616d 6264 6120       f = lambda 
-00017760: 743a 2066 6c6f 6174 2874 2920 6966 206c  t: float(t) if l
-00017770: 656e 2874 2e66 7265 655f 7379 6d62 6f6c  en(t.free_symbol
-00017780: 7329 203d 3d20 3020 656c 7365 2074 0a0a  s) == 0 else t..
-00017790: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-000177a0: 656c 662e 5f73 7472 5f68 656c 7065 7228  elf._str_helper(
-000177b0: 0a20 2020 2020 2020 2020 2020 2070 7265  .            pre
-000177c0: 6669 7820 2b20 223a 2025 7320 666f 7222  fix + ": %s for"
-000177d0: 2022 2072 6528 2573 2920 6f76 6572 2025   " re(%s) over %
-000177e0: 7320 616e 6420 696d 2825 7329 206f 7665  s and im(%s) ove
-000177f0: 7220 2573 2220 2520 280a 2020 2020 2020  r %s" % (.      
-00017800: 2020 2020 2020 2020 2020 7772 6170 7065            wrappe
-00017810: 7220 2520 7365 6c66 2e65 7870 722c 0a20  r % self.expr,. 
-00017820: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00017830: 7472 2873 656c 662e 7661 7229 2c0a 2020  tr(self.var),.  
-00017840: 2020 2020 2020 2020 2020 2020 2020 7374                st
-00017850: 7228 2866 2872 6573 292c 2066 2872 6565  r((f(res), f(ree
-00017860: 2929 292c 0a20 2020 2020 2020 2020 2020  ))),.           
-00017870: 2020 2020 2073 7472 2873 656c 662e 7661       str(self.va
-00017880: 7229 2c0a 2020 2020 2020 2020 2020 2020  r),.            
-00017890: 2020 2020 7374 7228 2866 2869 6d73 292c      str((f(ims),
-000178a0: 2066 2869 6d65 2929 292c 0a20 2020 2020   f(ime))),.     
-000178b0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-000178c0: 2029 0a0a 2020 2020 6465 6620 5f63 7265   )..    def _cre
-000178d0: 6174 655f 6469 7363 7265 7469 7a65 645f  ate_discretized_
-000178e0: 646f 6d61 696e 2873 656c 6629 3a0a 2020  domain(self):.  
-000178f0: 2020 2020 2020 2222 2244 6973 6372 6574        """Discret
-00017900: 697a 6520 7468 6520 7261 6e67 6573 2069  ize the ranges i
-00017910: 6e20 6361 7365 206f 6620 756e 6966 6f72  n case of unifor
-00017920: 6d20 6d65 7368 696e 6720 7374 7261 7465  m meshing strate
-00017930: 6779 2e0a 2020 2020 2020 2020 2222 220a  gy..        """.
-00017940: 2020 2020 2020 2020 6e70 203d 2069 6d70          np = imp
-00017950: 6f72 745f 6d6f 6475 6c65 2827 6e75 6d70  ort_module('nump
-00017960: 7927 290a 2020 2020 2020 2020 7374 6172  y').        star
-00017970: 745f 7820 3d20 7365 6c66 2e5f 7570 6461  t_x = self._upda
-00017980: 7465 5f72 616e 6765 5f76 616c 7565 2873  te_range_value(s
-00017990: 656c 662e 7374 6172 7429 2e72 6561 6c0a  elf.start).real.
-000179a0: 2020 2020 2020 2020 656e 645f 7820 3d20          end_x = 
-000179b0: 7365 6c66 2e5f 7570 6461 7465 5f72 616e  self._update_ran
-000179c0: 6765 5f76 616c 7565 2873 656c 662e 656e  ge_value(self.en
-000179d0: 6429 2e72 6561 6c0a 2020 2020 2020 2020  d).real.        
-000179e0: 7374 6172 745f 7920 3d20 7365 6c66 2e5f  start_y = self._
-000179f0: 7570 6461 7465 5f72 616e 6765 5f76 616c  update_range_val
-00017a00: 7565 2873 656c 662e 7374 6172 7429 2e69  ue(self.start).i
-00017a10: 6d61 670a 2020 2020 2020 2020 656e 645f  mag.        end_
-00017a20: 7920 3d20 7365 6c66 2e5f 7570 6461 7465  y = self._update
-00017a30: 5f72 616e 6765 5f76 616c 7565 2873 656c  _range_value(sel
-00017a40: 662e 656e 6429 2e69 6d61 670a 2020 2020  f.end).imag.    
-00017a50: 2020 2020 7820 3d20 7365 6c66 2e5f 6469      x = self._di
-00017a60: 7363 7265 7469 7a65 280a 2020 2020 2020  scretize(.      
-00017a70: 2020 2020 2020 7374 6172 745f 782c 2065        start_x, e
-00017a80: 6e64 5f78 2c20 7365 6c66 2e6e 5b30 5d2c  nd_x, self.n[0],
-00017a90: 2073 656c 662e 7363 616c 6573 5b30 5d2c   self.scales[0],
-00017aa0: 2073 656c 662e 6f6e 6c79 5f69 6e74 6567   self.only_integ
-00017ab0: 6572 7329 0a20 2020 2020 2020 2079 203d  ers).        y =
-00017ac0: 2073 656c 662e 5f64 6973 6372 6574 697a   self._discretiz
-00017ad0: 6528 0a20 2020 2020 2020 2020 2020 2073  e(.            s
-00017ae0: 7461 7274 5f79 2c20 656e 645f 792c 2073  tart_y, end_y, s
-00017af0: 656c 662e 6e5b 315d 2c20 7365 6c66 2e73  elf.n[1], self.s
-00017b00: 6361 6c65 735b 315d 2c20 7365 6c66 2e6f  cales[1], self.o
-00017b10: 6e6c 795f 696e 7465 6765 7273 290a 2020  nly_integers).  
-00017b20: 2020 2020 2020 7878 2c20 7979 203d 206e        xx, yy = n
-00017b30: 702e 6d65 7368 6772 6964 2878 2c20 7929  p.meshgrid(x, y)
-00017b40: 0a20 2020 2020 2020 2064 6f6d 6169 6e20  .        domain 
-00017b50: 3d20 7878 202b 2031 6a20 2a20 7979 0a20  = xx + 1j * yy. 
-00017b60: 2020 2020 2020 2073 656c 662e 5f64 6973         self._dis
-00017b70: 6372 6574 697a 6564 5f64 6f6d 6169 6e20  cretized_domain 
-00017b80: 3d20 7b73 656c 662e 7661 723a 2064 6f6d  = {self.var: dom
-00017b90: 6169 6e7d 0a0a 0a63 6c61 7373 2043 6f6d  ain}...class Com
-00017ba0: 706c 6578 5375 7266 6163 6553 6572 6965  plexSurfaceSerie
-00017bb0: 7328 0a20 2020 2043 6f6d 6d6f 6e55 6e69  s(.    CommonUni
-00017bc0: 666f 726d 4576 616c 7561 7469 6f6e 2c20  formEvaluation, 
-00017bd0: 436f 6d70 6c65 7853 7572 6661 6365 4261  ComplexSurfaceBa
-00017be0: 7365 5365 7269 6573 0a29 3a0a 2020 2020  seSeries.):.    
-00017bf0: 2222 2252 6570 7265 7365 6e74 7320 6120  """Represents a 
-00017c00: 3344 2073 7572 6661 6365 206f 7220 636f  3D surface or co
-00017c10: 6e74 6f75 7220 706c 6f74 206f 6620 6120  ntour plot of a 
-00017c20: 636f 6d70 6c65 7820 6675 6e63 7469 6f6e  complex function
-00017c30: 206f 7665 720a 2020 2020 7468 6520 636f   over.    the co
-00017c40: 6d70 6c65 7820 706c 616e 652e 0a20 2020  mplex plane..   
-00017c50: 2022 2222 0a20 2020 2069 735f 3344 7375   """.    is_3Dsu
-00017c60: 7266 6163 6520 3d20 5472 7565 0a20 2020  rface = True.   
-00017c70: 2069 735f 636f 6e74 6f75 7220 3d20 4661   is_contour = Fa
-00017c80: 6c73 650a 2020 2020 6973 5f64 6f6d 6169  lse.    is_domai
-00017c90: 6e5f 636f 6c6f 7269 6e67 203d 2046 616c  n_coloring = Fal
-00017ca0: 7365 0a20 2020 205f 616c 6c6f 7765 645f  se.    _allowed_
-00017cb0: 6b65 7973 203d 205b 2274 6872 6565 6422  keys = ["threed"
-00017cc0: 2c20 2269 735f 6669 6c6c 6564 222c 2022  , "is_filled", "
-00017cd0: 636c 6162 656c 7322 5d0a 0a20 2020 2064  clabels"]..    d
-00017ce0: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
-00017cf0: 2c20 6578 7072 2c20 722c 206c 6162 656c  , expr, r, label
-00017d00: 3d22 222c 202a 2a6b 7761 7267 7329 3a0a  ="", **kwargs):.
-00017d10: 2020 2020 2020 2020 7375 7065 7228 292e          super().
-00017d20: 5f5f 696e 6974 5f5f 2865 7870 722c 2072  __init__(expr, r
-00017d30: 2c20 6c61 6265 6c2c 202a 2a6b 7761 7267  , label, **kwarg
-00017d40: 7329 0a0a 2020 2020 2020 2020 7365 6c66  s)..        self
-00017d50: 2e65 7870 7220 3d20 6578 7072 2069 6620  .expr = expr if 
-00017d60: 6361 6c6c 6162 6c65 2865 7870 7229 2065  callable(expr) e
-00017d70: 6c73 6520 7379 6d70 6966 7928 6578 7072  lse sympify(expr
-00017d80: 290a 2020 2020 2020 2020 6966 2069 7369  ).        if isi
-00017d90: 6e73 7461 6e63 6528 7365 6c66 2c20 436f  nstance(self, Co
-00017da0: 6d70 6c65 7853 7572 6661 6365 5365 7269  mplexSurfaceSeri
-00017db0: 6573 293a 0a20 2020 2020 2020 2020 2020  es):.           
-00017dc0: 2073 656c 662e 5f62 6c6f 636b 5f6c 616d   self._block_lam
-00017dd0: 6264 615f 6675 6e63 7469 6f6e 7328 7365  bda_functions(se
-00017de0: 6c66 2e65 7870 7229 0a0a 2020 2020 2020  lf.expr)..      
-00017df0: 2020 6966 206e 6f74 206b 7761 7267 732e    if not kwargs.
-00017e00: 6765 7428 2274 6872 6565 6422 2c20 4661  get("threed", Fa
-00017e10: 6c73 6529 3a0a 2020 2020 2020 2020 2020  lse):.          
-00017e20: 2020 7365 6c66 2e69 735f 636f 6e74 6f75    self.is_contou
-00017e30: 7220 3d20 5472 7565 0a20 2020 2020 2020  r = True.       
-00017e40: 2020 2020 2073 656c 662e 6973 5f33 4473       self.is_3Ds
-00017e50: 7572 6661 6365 203d 2046 616c 7365 0a20  urface = False. 
-00017e60: 2020 2020 2020 2073 656c 662e 6973 5f66         self.is_f
-00017e70: 696c 6c65 6420 3d20 6b77 6172 6773 2e67  illed = kwargs.g
-00017e80: 6574 2822 6973 5f66 696c 6c65 6422 2c20  et("is_filled", 
-00017e90: 6b77 6172 6773 2e67 6574 2822 6669 6c6c  kwargs.get("fill
-00017ea0: 222c 2054 7275 6529 290a 2020 2020 2020  ", True)).      
-00017eb0: 2020 7365 6c66 2e73 686f 775f 636c 6162    self.show_clab
-00017ec0: 656c 7320 3d20 6b77 6172 6773 2e67 6574  els = kwargs.get
-00017ed0: 2822 636c 6162 656c 7322 2c20 5472 7565  ("clabels", True
-00017ee0: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
-00017ef0: 706f 7374 5f69 6e69 7428 290a 0a20 2020  post_init()..   
-00017f00: 2064 6566 205f 6372 6561 7465 5f64 6973   def _create_dis
-00017f10: 6372 6574 697a 6564 5f64 6f6d 6169 6e28  cretized_domain(
-00017f20: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-00017f30: 6574 7572 6e20 436f 6d70 6c65 7853 7572  eturn ComplexSur
-00017f40: 6661 6365 4261 7365 5365 7269 6573 2e5f  faceBaseSeries._
-00017f50: 6372 6561 7465 5f64 6973 6372 6574 697a  create_discretiz
-00017f60: 6564 5f64 6f6d 6169 6e28 7365 6c66 290a  ed_domain(self).
-00017f70: 0a20 2020 2064 6566 2067 6574 5f64 6174  .    def get_dat
-00017f80: 6128 7365 6c66 293a 0a20 2020 2020 2020  a(self):.       
-00017f90: 2022 2222 5265 7475 726e 2061 7272 6179   """Return array
-00017fa0: 7320 6f66 2063 6f6f 7264 696e 6174 6573  s of coordinates
-00017fb0: 2066 6f72 2070 6c6f 7474 696e 672e 0a0a   for plotting...
-00017fc0: 2020 2020 2020 2020 5265 7475 726e 730a          Returns.
-00017fd0: 2020 2020 2020 2020 3d3d 3d3d 3d3d 3d0a          =======.
-00017fe0: 0a20 2020 2020 2020 206d 6573 685f 7820  .        mesh_x 
-00017ff0: 3a20 6e70 2e6e 6461 7272 6179 205b 6e32  : np.ndarray [n2
-00018000: 2078 206e 315d 0a20 2020 2020 2020 2020   x n1].         
-00018010: 2020 2052 6561 6c20 6469 7363 7265 7469     Real discreti
-00018020: 7a65 6420 646f 6d61 696e 2e0a 0a20 2020  zed domain...   
-00018030: 2020 2020 206d 6573 685f 7920 3a20 6e70       mesh_y : np
-00018040: 2e6e 6461 7272 6179 205b 6e32 2078 206e  .ndarray [n2 x n
-00018050: 315d 0a20 2020 2020 2020 2020 2020 2049  1].            I
-00018060: 6d61 6769 6e61 7279 2064 6973 6372 6574  maginary discret
-00018070: 697a 6564 2064 6f6d 6169 6e2e 0a0a 2020  ized domain...  
-00018080: 2020 2020 2020 7a20 3a20 6e70 2e6e 6461        z : np.nda
-00018090: 7272 6179 205b 6e32 2078 206e 315d 0a20  rray [n2 x n1]. 
-000180a0: 2020 2020 2020 2020 2020 2052 6573 756c             Resul
-000180b0: 7473 206f 6620 7468 6520 6576 616c 7561  ts of the evalua
-000180c0: 7469 6f6e 2e0a 2020 2020 2020 2020 2222  tion..        ""
-000180d0: 220a 2020 2020 2020 2020 6e70 203d 2069  ".        np = i
-000180e0: 6d70 6f72 745f 6d6f 6475 6c65 2827 6e75  mport_module('nu
-000180f0: 6d70 7927 290a 0a20 2020 2020 2020 2064  mpy')..        d
-00018100: 6f6d 6169 6e2c 207a 203d 2073 656c 662e  omain, z = self.
-00018110: 5f65 7661 6c75 6174 6528 4661 6c73 6529  _evaluate(False)
-00018120: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00018130: 2e5f 7265 7475 726e 2069 7320 4e6f 6e65  ._return is None
-00018140: 3a0a 2020 2020 2020 2020 2020 2020 7061  :.            pa
-00018150: 7373 0a20 2020 2020 2020 2065 6c69 6620  ss.        elif 
-00018160: 7365 6c66 2e5f 7265 7475 726e 203d 3d20  self._return == 
-00018170: 2272 6561 6c22 3a0a 2020 2020 2020 2020  "real":.        
-00018180: 2020 2020 7a20 3d20 6e70 2e72 6561 6c28      z = np.real(
-00018190: 7a29 0a20 2020 2020 2020 2065 6c69 6620  z).        elif 
-000181a0: 7365 6c66 2e5f 7265 7475 726e 203d 3d20  self._return == 
-000181b0: 2269 6d61 6722 3a0a 2020 2020 2020 2020  "imag":.        
-000181c0: 2020 2020 7a20 3d20 6e70 2e69 6d61 6728      z = np.imag(
-000181d0: 7a29 0a20 2020 2020 2020 2065 6c69 6620  z).        elif 
-000181e0: 7365 6c66 2e5f 7265 7475 726e 203d 3d20  self._return == 
-000181f0: 2261 6273 223a 0a20 2020 2020 2020 2020  "abs":.         
-00018200: 2020 207a 203d 206e 702e 6162 736f 6c75     z = np.absolu
-00018210: 7465 287a 290a 2020 2020 2020 2020 656c  te(z).        el
-00018220: 6966 2073 656c 662e 5f72 6574 7572 6e20  if self._return 
-00018230: 3d3d 2022 6172 6722 3a0a 2020 2020 2020  == "arg":.      
-00018240: 2020 2020 2020 7a20 3d20 6e70 2e61 6e67        z = np.ang
-00018250: 6c65 287a 290a 2020 2020 2020 2020 656c  le(z).        el
-00018260: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00018270: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00018280: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00018290: 2020 2260 5f72 6574 7572 6e60 206e 6f74    "`_return` not
-000182a0: 2072 6563 6f67 6e69 7a65 642e 2052 6563   recognized. Rec
-000182b0: 6569 7665 643a 2025 7322 2025 2073 656c  eived: %s" % sel
-000182c0: 662e 5f72 6574 7572 6e29 0a0a 2020 2020  f._return)..    
-000182d0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000182e0: 5f61 7070 6c79 5f74 7261 6e73 666f 726d  _apply_transform
-000182f0: 286e 702e 7265 616c 2864 6f6d 6169 6e29  (np.real(domain)
-00018300: 2c20 6e70 2e69 6d61 6728 646f 6d61 696e  , np.imag(domain
-00018310: 292c 207a 290a 0a0a 636c 6173 7320 436f  ), z)...class Co
-00018320: 6d70 6c65 7844 6f6d 6169 6e43 6f6c 6f72  mplexDomainColor
-00018330: 696e 6753 6572 6965 7328 0a20 2020 2043  ingSeries(.    C
-00018340: 6f6d 6d6f 6e55 6e69 666f 726d 4576 616c  ommonUniformEval
-00018350: 7561 7469 6f6e 2c20 436f 6d70 6c65 7853  uation, ComplexS
-00018360: 7572 6661 6365 4261 7365 5365 7269 6573  urfaceBaseSeries
-00018370: 0a29 3a0a 2020 2020 2222 2252 6570 7265  .):.    """Repre
-00018380: 7365 6e74 7320 6120 3244 2f33 4420 646f  sents a 2D/3D do
-00018390: 6d61 696e 2063 6f6c 6f72 696e 6720 706c  main coloring pl
-000183a0: 6f74 206f 6620 6120 636f 6d70 6c65 7820  ot of a complex 
-000183b0: 6675 6e63 7469 6f6e 206f 7665 720a 2020  function over.  
-000183c0: 2020 7468 6520 636f 6d70 6c65 7820 706c    the complex pl
-000183d0: 616e 652e 0a20 2020 2022 2222 0a20 2020  ane..    """.   
-000183e0: 2069 735f 3344 7375 7266 6163 6520 3d20   is_3Dsurface = 
-000183f0: 4661 6c73 650a 2020 2020 6973 5f64 6f6d  False.    is_dom
-00018400: 6169 6e5f 636f 6c6f 7269 6e67 203d 2054  ain_coloring = T
-00018410: 7275 650a 2020 2020 5f61 6c6c 6f77 6564  rue.    _allowed
-00018420: 5f6b 6579 7320 3d20 5b0a 2020 2020 2020  _keys = [.      
-00018430: 2020 2274 6872 6565 6422 2c20 2263 6f6c    "threed", "col
-00018440: 6f72 696e 6722 2c20 2270 6861 7365 7265  oring", "phasere
-00018450: 7322 2c20 2263 6d61 7022 2c20 2262 6c65  s", "cmap", "ble
-00018460: 7665 6c22 2c20 2270 6861 7365 6f66 6673  vel", "phaseoffs
-00018470: 6574 222c 0a20 2020 2020 2020 2022 636f  et",.        "co
-00018480: 6c6f 7262 6172 222c 2022 6174 5f69 6e66  lorbar", "at_inf
-00018490: 696e 6974 7922 2c20 2272 6965 6d61 6e6e  inity", "riemann
-000184a0: 5f6d 6173 6b22 2c20 2261 6e6e 6f74 6174  _mask", "annotat
-000184b0: 6522 0a20 2020 205d 0a0a 2020 2020 6465  e".    ]..    de
-000184c0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
-000184d0: 2065 7870 722c 2072 2c20 6c61 6265 6c3d   expr, r, label=
-000184e0: 2222 2c20 2a2a 6b77 6172 6773 293a 0a20  "", **kwargs):. 
-000184f0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
-00018500: 5f69 6e69 745f 5f28 6578 7072 2c20 722c  _init__(expr, r,
-00018510: 206c 6162 656c 2c20 2a2a 6b77 6172 6773   label, **kwargs
-00018520: 290a 2020 2020 2020 2020 6966 206b 7761  ).        if kwa
-00018530: 7267 732e 6765 7428 2274 6872 6565 6422  rgs.get("threed"
-00018540: 2c20 4661 6c73 6529 3a0a 2020 2020 2020  , False):.      
-00018550: 2020 2020 2020 7365 6c66 2e69 735f 3344        self.is_3D
-00018560: 7375 7266 6163 6520 3d20 5472 7565 0a20  surface = True. 
-00018570: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00018580: 7573 655f 636d 203d 206b 7761 7267 732e  use_cm = kwargs.
-00018590: 6765 7428 2275 7365 5f63 6d22 2c20 5472  get("use_cm", Tr
-000185a0: 7565 290a 0a20 2020 2020 2020 2073 656c  ue)..        sel
-000185b0: 662e 6578 7072 203d 2065 7870 7220 6966  f.expr = expr if
-000185c0: 2063 616c 6c61 626c 6528 6578 7072 2920   callable(expr) 
-000185d0: 656c 7365 2073 796d 7069 6679 2865 7870  else sympify(exp
-000185e0: 7229 0a20 2020 2020 2020 2023 2061 7070  r).        # app
-000185f0: 6c79 2074 6865 2074 7261 6e73 666f 726d  ly the transform
-00018600: 6174 696f 6e20 7a20 2d3e 2031 2f7a 2069  ation z -> 1/z i
-00018610: 6e20 6f72 6465 7220 746f 2073 7475 6479  n order to study
-00018620: 2074 6865 2062 6568 6176 696f 720a 2020   the behavior.  
-00018630: 2020 2020 2020 2320 6f66 2074 6865 2066        # of the f
-00018640: 756e 6374 696f 6e20 6174 207a 3d69 6e66  unction at z=inf
-00018650: 696e 6974 790a 2020 2020 2020 2020 7365  inity.        se
-00018660: 6c66 2e61 745f 696e 6669 6e69 7479 203d  lf.at_infinity =
-00018670: 206b 7761 7267 732e 6765 7428 2261 745f   kwargs.get("at_
-00018680: 696e 6669 6e69 7479 222c 2046 616c 7365  infinity", False
-00018690: 290a 2020 2020 2020 2020 6966 2073 656c  ).        if sel
-000186a0: 662e 6174 5f69 6e66 696e 6974 793a 0a20  f.at_infinity:. 
-000186b0: 2020 2020 2020 2020 2020 2069 6620 6361             if ca
-000186c0: 6c6c 6162 6c65 2873 656c 662e 6578 7072  llable(self.expr
-000186d0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-000186e0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-000186f0: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
-00018700: 2020 2020 2020 2020 2022 6060 6174 5f69           "``at_i
-00018710: 6e66 696e 6974 793d 5472 7565 6060 2069  nfinity=True`` i
-00018720: 7320 6f6e 6c79 2073 7570 706f 7274 6564  s only supported
-00018730: 2066 6f72 2073 796d 626f 6c69 6320 220a   for symbolic ".
-00018740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018750: 2020 2020 2265 7870 7265 7373 696f 6e73      "expressions
-00018760: 2e20 496e 7374 6561 642c 2061 2063 616c  . Instead, a cal
-00018770: 6c61 626c 6520 7761 7320 7072 6f76 6964  lable was provid
-00018780: 6564 2e22 290a 2020 2020 2020 2020 2020  ed.").          
-00018790: 2020 7a20 3d20 7365 6c66 2e72 616e 6765    z = self.range
-000187a0: 735b 305d 5b30 5d0a 2020 2020 2020 2020  s[0][0].        
-000187b0: 2020 2020 746d 7020 3d20 7365 6c66 2e65      tmp = self.e
-000187c0: 7870 722e 7375 6273 287a 2c20 3120 2f20  xpr.subs(z, 1 / 
-000187d0: 7a29 0a20 2020 2020 2020 2020 2020 2069  z).            i
-000187e0: 6620 7365 6c66 2e5f 6c61 6265 6c20 3d3d  f self._label ==
-000187f0: 2073 7472 2873 656c 662e 6578 7072 293a   str(self.expr):
-00018800: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018810: 2023 2061 646a 7573 7420 6c61 6265 6c73   # adjust labels
-00018820: 2074 6f20 7072 6576 656e 7420 7468 6520   to prevent the 
-00018830: 7772 6f6e 6720 6f6e 6520 746f 2062 6520  wrong one to be 
-00018840: 7365 656e 206f 6e20 636f 6c6f 7262 6172  seen on colorbar
-00018850: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018860: 2073 656c 662e 5f6c 6162 656c 203d 2073   self._label = s
-00018870: 7472 2874 6d70 290a 2020 2020 2020 2020  tr(tmp).        
-00018880: 2020 2020 2020 2020 7365 6c66 2e5f 6c61          self._la
-00018890: 7465 785f 6c61 6265 6c20 3d20 6c61 7465  tex_label = late
-000188a0: 7828 746d 7029 0a20 2020 2020 2020 2020  x(tmp).         
-000188b0: 2020 2073 656c 662e 6578 7072 203d 2074     self.expr = t
-000188c0: 6d70 0a0a 2020 2020 2020 2020 2320 646f  mp..        # do
-000188d0: 6d61 696e 2063 6f6c 6f72 696e 6720 6d6f  main coloring mo
-000188e0: 6465 0a20 2020 2020 2020 2073 656c 662e  de.        self.
-000188f0: 5f69 6e69 745f 646f 6d61 696e 5f63 6f6c  _init_domain_col
-00018900: 6f72 696e 675f 6b77 282a 2a6b 7761 7267  oring_kw(**kwarg
-00018910: 7329 0a0a 2020 2020 2020 2020 7365 6c66  s)..        self
-00018920: 2e61 6e6e 6f74 6174 6520 3d20 6b77 6172  .annotate = kwar
-00018930: 6773 2e67 6574 2822 616e 6e6f 7461 7465  gs.get("annotate
-00018940: 222c 2054 7275 6529 0a20 2020 2020 2020  ", True).       
-00018950: 2073 656c 662e 7269 656d 616e 6e5f 6d61   self.riemann_ma
-00018960: 736b 203d 206b 7761 7267 732e 6765 7428  sk = kwargs.get(
-00018970: 2272 6965 6d61 6e6e 5f6d 6173 6b22 2c20  "riemann_mask", 
-00018980: 4661 6c73 6529 0a20 2020 2020 2020 2073  False).        s
-00018990: 656c 662e 5f70 6f73 745f 696e 6974 2829  elf._post_init()
-000189a0: 0a0a 2020 2020 6465 6620 5f69 6e69 745f  ..    def _init_
-000189b0: 646f 6d61 696e 5f63 6f6c 6f72 696e 675f  domain_coloring_
-000189c0: 6b77 2873 656c 662c 202a 2a6b 7761 7267  kw(self, **kwarg
-000189d0: 7329 3a0a 2020 2020 2020 2020 7365 6c66  s):.        self
-000189e0: 2e63 6f6c 6f72 696e 6720 3d20 6b77 6172  .coloring = kwar
-000189f0: 6773 2e67 6574 2822 636f 6c6f 7269 6e67  gs.get("coloring
-00018a00: 222c 2022 6122 290a 2020 2020 2020 2020  ", "a").        
-00018a10: 6966 2069 7369 6e73 7461 6e63 6528 7365  if isinstance(se
-00018a20: 6c66 2e63 6f6c 6f72 696e 672c 2073 7472  lf.coloring, str
-00018a30: 293a 0a20 2020 2020 2020 2020 2020 2073  ):.            s
-00018a40: 656c 662e 636f 6c6f 7269 6e67 203d 2073  elf.coloring = s
-00018a50: 656c 662e 636f 6c6f 7269 6e67 2e6c 6f77  elf.coloring.low
-00018a60: 6572 2829 0a20 2020 2020 2020 2065 6c69  er().        eli
-00018a70: 6620 6e6f 7420 6361 6c6c 6162 6c65 2873  f not callable(s
-00018a80: 656c 662e 636f 6c6f 7269 6e67 293a 0a20  elf.coloring):. 
-00018a90: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00018aa0: 2054 7970 6545 7272 6f72 280a 2020 2020   TypeError(.    
-00018ab0: 2020 2020 2020 2020 2020 2020 2260 636f              "`co
-00018ac0: 6c6f 7269 6e67 6020 6d75 7374 2062 6520  loring` must be 
-00018ad0: 6120 6368 6172 6163 7465 7220 6672 6f6d  a character from
-00018ae0: 2027 6127 2074 6f20 276a 2720 6f72 2022   'a' to 'j' or "
-00018af0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018b00: 2022 6120 6361 6c6c 6162 6c65 2e22 290a   "a callable.").
-00018b10: 2020 2020 2020 2020 7365 6c66 2e70 6861          self.pha
-00018b20: 7365 7265 7320 3d20 6b77 6172 6773 2e67  seres = kwargs.g
-00018b30: 6574 2822 7068 6173 6572 6573 222c 2032  et("phaseres", 2
-00018b40: 3029 0a20 2020 2020 2020 2073 656c 662e  0).        self.
-00018b50: 636d 6170 203d 206b 7761 7267 732e 6765  cmap = kwargs.ge
-00018b60: 7428 2263 6d61 7022 2c20 4e6f 6e65 290a  t("cmap", None).
-00018b70: 2020 2020 2020 2020 7365 6c66 2e62 6c65          self.ble
-00018b80: 7665 6c20 3d20 666c 6f61 7428 6b77 6172  vel = float(kwar
-00018b90: 6773 2e67 6574 2822 626c 6576 656c 222c  gs.get("blevel",
-00018ba0: 2030 2e37 3529 290a 2020 2020 2020 2020   0.75)).        
-00018bb0: 6966 2073 656c 662e 626c 6576 656c 203c  if self.blevel <
-00018bc0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-00018bd0: 7761 726e 696e 6773 2e77 6172 6e28 0a20  warnings.warn(. 
-00018be0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00018bf0: 4974 206d 7573 7420 6265 2030 203c 3d20  It must be 0 <= 
-00018c00: 626c 6576 656c 203c 3d20 312e 2041 7574  blevel <= 1. Aut
-00018c10: 6f6d 6174 6963 616c 6c79 2022 0a20 2020  omatically ".   
-00018c20: 2020 2020 2020 2020 2020 2020 2022 7365               "se
-00018c30: 7474 696e 6720 626c 6576 656c 203d 2030  tting blevel = 0
-00018c40: 2e22 290a 2020 2020 2020 2020 2020 2020  .").            
-00018c50: 7365 6c66 2e62 6c65 7665 6c20 3d20 300a  self.blevel = 0.
-00018c60: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00018c70: 626c 6576 656c 203e 2031 3a0a 2020 2020  blevel > 1:.    
-00018c80: 2020 2020 2020 2020 7761 726e 696e 6773          warnings
-00018c90: 2e77 6172 6e28 0a20 2020 2020 2020 2020  .warn(.         
-00018ca0: 2020 2020 2020 2022 4974 206d 7573 7420         "It must 
-00018cb0: 6265 2030 203c 3d20 626c 6576 656c 203c  be 0 <= blevel <
-00018cc0: 3d20 312e 2041 7574 6f6d 6174 6963 616c  = 1. Automatical
-00018cd0: 6c79 2022 0a20 2020 2020 2020 2020 2020  ly ".           
-00018ce0: 2020 2020 2022 7365 7474 696e 6720 626c       "setting bl
-00018cf0: 6576 656c 203d 2031 2e22 290a 2020 2020  evel = 1.").    
-00018d00: 2020 2020 2020 2020 7365 6c66 2e62 6c65          self.ble
-00018d10: 7665 6c20 3d20 310a 2020 2020 2020 2020  vel = 1.        
-00018d20: 7365 6c66 2e70 6861 7365 6f66 6673 6574  self.phaseoffset
-00018d30: 203d 2066 6c6f 6174 286b 7761 7267 732e   = float(kwargs.
-00018d40: 6765 7428 2270 6861 7365 6f66 6673 6574  get("phaseoffset
-00018d50: 222c 2030 2929 0a0a 2020 2020 6465 6620  ", 0))..    def 
-00018d60: 5f63 7265 6174 655f 6469 7363 7265 7469  _create_discreti
-00018d70: 7a65 645f 646f 6d61 696e 2873 656c 6629  zed_domain(self)
-00018d80: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00018d90: 2043 6f6d 706c 6578 5375 7266 6163 6542   ComplexSurfaceB
-00018da0: 6173 6553 6572 6965 732e 5f63 7265 6174  aseSeries._creat
-00018db0: 655f 6469 7363 7265 7469 7a65 645f 646f  e_discretized_do
-00018dc0: 6d61 696e 2873 656c 6629 0a0a 2020 2020  main(self)..    
-00018dd0: 6465 6620 5f64 6f6d 6169 6e5f 636f 6c6f  def _domain_colo
-00018de0: 7269 6e67 2873 656c 662c 2064 6f6d 6169  ring(self, domai
-00018df0: 6e2c 2077 293a 0a20 2020 2020 2020 2069  n, w):.        i
-00018e00: 6620 6973 696e 7374 616e 6365 2873 656c  f isinstance(sel
-00018e10: 662e 636f 6c6f 7269 6e67 2c20 7374 7229  f.coloring, str)
-00018e20: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-00018e30: 6c66 2e63 6f6c 6f72 696e 6720 3d20 7365  lf.coloring = se
-00018e40: 6c66 2e63 6f6c 6f72 696e 672e 6c6f 7765  lf.coloring.lowe
-00018e50: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
-00018e60: 7265 7475 726e 2077 6567 6572 7428 0a20  return wegert(. 
-00018e70: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00018e80: 656c 662e 636f 6c6f 7269 6e67 2c20 772c  elf.coloring, w,
-00018e90: 2073 656c 662e 7068 6173 6572 6573 2c20   self.phaseres, 
-00018ea0: 7365 6c66 2e63 6d61 702c 0a20 2020 2020  self.cmap,.     
-00018eb0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00018ec0: 626c 6576 656c 2c20 7365 6c66 2e70 6861  blevel, self.pha
-00018ed0: 7365 6f66 6673 6574 2c0a 2020 2020 2020  seoffset,.      
-00018ee0: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
-00018ef0: 745f 696e 6669 6e69 7479 2c20 7365 6c66  t_infinity, self
-00018f00: 2e72 6965 6d61 6e6e 5f6d 6173 6b2c 0a20  .riemann_mask,. 
-00018f10: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00018f20: 6f6d 6169 6e3d 5b64 6f6d 6169 6e5b 302c  omain=[domain[0,
-00018f30: 2030 5d2c 2064 6f6d 6169 6e5b 2d31 2c20   0], domain[-1, 
-00018f40: 2d31 5d5d 290a 2020 2020 2020 2020 7265  -1]]).        re
-00018f50: 7475 726e 2073 656c 662e 636f 6c6f 7269  turn self.colori
-00018f60: 6e67 2877 290a 0a20 2020 2064 6566 2067  ng(w)..    def g
-00018f70: 6574 5f64 6174 6128 7365 6c66 293a 0a20  et_data(self):. 
-00018f80: 2020 2020 2020 2022 2222 5265 7475 726e         """Return
-00018f90: 2061 7272 6179 7320 6f66 2063 6f6f 7264   arrays of coord
-00018fa0: 696e 6174 6573 2066 6f72 2070 6c6f 7474  inates for plott
-00018fb0: 696e 672e 0a0a 2020 2020 2020 2020 5265  ing...        Re
-00018fc0: 7475 726e 730a 2020 2020 2020 2020 3d3d  turns.        ==
-00018fd0: 3d3d 3d3d 3d0a 0a20 2020 2020 2020 206d  =====..        m
-00018fe0: 6573 685f 7820 3a20 6e70 2e6e 6461 7272  esh_x : np.ndarr
-00018ff0: 6179 205b 6e32 2078 206e 315d 0a20 2020  ay [n2 x n1].   
-00019000: 2020 2020 2020 2020 2052 6561 6c20 6469           Real di
-00019010: 7363 7265 7469 7a65 6420 646f 6d61 696e  scretized domain
-00019020: 2e0a 0a20 2020 2020 2020 206d 6573 685f  ...        mesh_
-00019030: 7920 3a20 6e70 2e6e 6461 7272 6179 205b  y : np.ndarray [
-00019040: 6e32 2078 206e 315d 0a20 2020 2020 2020  n2 x n1].       
-00019050: 2020 2020 2049 6d61 6769 6e61 7279 2064       Imaginary d
-00019060: 6973 6372 6574 697a 6564 2064 6f6d 6169  iscretized domai
-00019070: 6e2e 0a0a 2020 2020 2020 2020 6162 7320  n...        abs 
-00019080: 3a20 6e70 2e6e 6461 7272 6179 205b 6e32  : np.ndarray [n2
-00019090: 2078 206e 315d 0a20 2020 2020 2020 2020   x n1].         
-000190a0: 2020 2041 6273 6f6c 7574 6520 7661 6c75     Absolute valu
-000190b0: 6520 6f66 2074 6865 2066 756e 6374 696f  e of the functio
-000190c0: 6e2e 0a0a 2020 2020 2020 2020 6172 6720  n...        arg 
-000190d0: 3a20 6e70 2e6e 6461 7272 6179 205b 6e32  : np.ndarray [n2
-000190e0: 2078 206e 315d 0a20 2020 2020 2020 2020   x n1].         
-000190f0: 2020 2041 7267 756d 656e 7420 6f66 2074     Argument of t
-00019100: 6865 2066 756e 6374 696f 6e2e 0a0a 2020  he function...  
-00019110: 2020 2020 2020 696d 6720 3a20 6e70 2e6e        img : np.n
-00019120: 6461 7272 6179 205b 6e32 2078 206e 3120  darray [n2 x n1 
-00019130: 7820 335d 0a20 2020 2020 2020 2020 2020  x 3].           
-00019140: 2052 4742 2069 6d61 6765 2076 616c 7565   RGB image value
-00019150: 7320 636f 6d70 7574 6564 2066 726f 6d20  s computed from 
-00019160: 7468 6520 6172 6775 6d65 6e74 206f 6620  the argument of 
-00019170: 7468 6520 6675 6e63 7469 6f6e 2e0a 2020  the function..  
-00019180: 2020 2020 2020 2020 2020 3020 3c3d 2052            0 <= R
-00019190: 2c20 472c 2042 203c 3d20 3235 350a 0a20  , G, B <= 255.. 
-000191a0: 2020 2020 2020 2063 6f6c 6f72 7320 3a20         colors : 
-000191b0: 6e70 2e6e 6461 7272 6179 205b 3235 3620  np.ndarray [256 
-000191c0: 7820 335d 0a20 2020 2020 2020 2020 2020  x 3].           
-000191d0: 2043 6f6c 6f72 2073 6361 6c65 2061 7373   Color scale ass
-000191e0: 6f63 6961 7465 6420 746f 2060 696d 6760  ociated to `img`
-000191f0: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-00019200: 2020 2020 2020 6e70 203d 2069 6d70 6f72        np = impor
-00019210: 745f 6d6f 6475 6c65 2827 6e75 6d70 7927  t_module('numpy'
-00019220: 290a 0a20 2020 2020 2020 2064 6f6d 6169  )..        domai
-00019230: 6e2c 207a 203d 2073 656c 662e 5f65 7661  n, z = self._eva
-00019240: 6c75 6174 6528 4661 6c73 6529 0a20 2020  luate(False).   
-00019250: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00019260: 2e5f 6170 706c 795f 7472 616e 7366 6f72  ._apply_transfor
-00019270: 6d28 0a20 2020 2020 2020 2020 2020 206e  m(.            n
-00019280: 702e 7265 616c 2864 6f6d 6169 6e29 2c20  p.real(domain), 
-00019290: 6e70 2e69 6d61 6728 646f 6d61 696e 292c  np.imag(domain),
-000192a0: 0a20 2020 2020 2020 2020 2020 206e 702e  .            np.
-000192b0: 6162 736f 6c75 7465 287a 292c 206e 702e  absolute(z), np.
-000192c0: 616e 676c 6528 7a29 2c0a 2020 2020 2020  angle(z),.      
-000192d0: 2020 2020 2020 2a73 656c 662e 5f64 6f6d        *self._dom
-000192e0: 6169 6e5f 636f 6c6f 7269 6e67 2864 6f6d  ain_coloring(dom
-000192f0: 6169 6e2c 207a 292c 0a20 2020 2020 2020  ain, z),.       
-00019300: 2029 0a0a 0a63 6c61 7373 2043 6f6d 706c   )...class Compl
-00019310: 6578 5061 7261 6d65 7472 6963 3344 4c69  exParametric3DLi
-00019320: 6e65 5365 7269 6573 2850 6172 616d 6574  neSeries(Paramet
-00019330: 7269 6333 444c 696e 6553 6572 6965 7329  ric3DLineSeries)
-00019340: 3a0a 2020 2020 2222 2252 6570 7265 7365  :.    """Represe
-00019350: 6e74 2061 206d 6573 682f 7769 7265 6672  nt a mesh/wirefr
-00019360: 616d 6520 6c69 6e65 206f 6620 6120 636f  ame line of a co
-00019370: 6d70 6c65 7820 7375 7266 6163 6520 7365  mplex surface se
-00019380: 7269 6573 2e0a 2020 2020 2222 220a 0a20  ries..    """.. 
-00019390: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
-000193a0: 7365 6c66 2c20 2a61 7267 732c 202a 2a6b  self, *args, **k
-000193b0: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
-000193c0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-000193d0: 282a 6172 6773 2c20 2a2a 6b77 6172 6773  (*args, **kwargs
-000193e0: 290a 2020 2020 2020 2020 2320 6465 7465  ).        # dete
-000193f0: 726d 696e 6573 2077 6861 7420 6461 7461  rmines what data
-00019400: 2074 6f20 7265 7475 726e 206f 6e20 7468   to return on th
-00019410: 6520 7a2d 6178 6973 0a20 2020 2020 2020  e z-axis.       
-00019420: 2073 656c 662e 5f72 6574 7572 6e20 3d20   self._return = 
-00019430: 6b77 6172 6773 2e67 6574 2822 7265 7475  kwargs.get("retu
-00019440: 726e 222c 204e 6f6e 6529 0a0a 2020 2020  rn", None)..    
-00019450: 6465 6620 5f61 6461 7074 6976 655f 7361  def _adaptive_sa
-00019460: 6d70 6c69 6e67 2873 656c 6629 3a0a 2020  mpling(self):.  
-00019470: 2020 2020 2020 7261 6973 6520 4e6f 7449        raise NotI
-00019480: 6d70 6c65 6d65 6e74 6564 4572 726f 720a  mplementedError.
-00019490: 0a20 2020 2064 6566 205f 756e 6966 6f72  .    def _unifor
-000194a0: 6d5f 7361 6d70 6c69 6e67 2873 656c 6629  m_sampling(self)
-000194b0: 3a0a 2020 2020 2020 2020 2222 2252 6574  :.        """Ret
-000194c0: 7572 6e73 2063 6f6f 7264 696e 6174 6573  urns coordinates
-000194d0: 2074 6861 7420 6e65 6564 7320 746f 2062   that needs to b
-000194e0: 6520 706f 7374 7072 6f63 6573 7365 642e  e postprocessed.
-000194f0: 2222 220a 2020 2020 2020 2020 6e70 203d  """.        np =
-00019500: 2069 6d70 6f72 745f 6d6f 6475 6c65 2827   import_module('
-00019510: 6e75 6d70 7927 290a 0a20 2020 2020 2020  numpy')..       
-00019520: 2072 6573 756c 7473 203d 2073 656c 662e   results = self.
-00019530: 5f65 7661 6c75 6174 6528 290a 2020 2020  _evaluate().    
-00019540: 2020 2020 666f 7220 6920 696e 2072 616e      for i in ran
-00019550: 6765 286c 656e 2872 6573 756c 7473 2920  ge(len(results) 
-00019560: 2d20 3129 3a0a 2020 2020 2020 2020 2020  - 1):.          
-00019570: 2020 5f72 652c 205f 696d 203d 206e 702e    _re, _im = np.
-00019580: 7265 616c 2872 6573 756c 7473 5b69 5d29  real(results[i])
-00019590: 2c20 6e70 2e69 6d61 6728 7265 7375 6c74  , np.imag(result
-000195a0: 735b 695d 290a 2020 2020 2020 2020 2020  s[i]).          
-000195b0: 2020 5f72 655b 6e70 2e69 6e76 6572 7428    _re[np.invert(
-000195c0: 6e70 2e69 7363 6c6f 7365 285f 696d 2c20  np.isclose(_im, 
-000195d0: 6e70 2e7a 6572 6f73 5f6c 696b 6528 5f69  np.zeros_like(_i
-000195e0: 6d29 2929 5d20 3d20 6e70 2e6e 616e 0a20  m)))] = np.nan. 
-000195f0: 2020 2020 2020 2020 2020 2072 6573 756c             resul
-00019600: 7473 5b69 5d20 3d20 5f72 650a 0a20 2020  ts[i] = _re..   
-00019610: 2020 2020 2069 6620 7365 6c66 2e5f 7265       if self._re
-00019620: 7475 726e 2069 7320 4e6f 6e65 3a0a 2020  turn is None:.  
-00019630: 2020 2020 2020 2020 2020 7061 7373 0a20            pass. 
-00019640: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-00019650: 2e5f 7265 7475 726e 203d 3d20 2272 6561  ._return == "rea
-00019660: 6c22 3a0a 2020 2020 2020 2020 2020 2020  l":.            
-00019670: 7265 7375 6c74 735b 2d31 5d20 3d20 6e70  results[-1] = np
-00019680: 2e72 6561 6c28 7265 7375 6c74 735b 2d31  .real(results[-1
-00019690: 5d29 0a20 2020 2020 2020 2065 6c69 6620  ]).        elif 
-000196a0: 7365 6c66 2e5f 7265 7475 726e 203d 3d20  self._return == 
-000196b0: 2269 6d61 6722 3a0a 2020 2020 2020 2020  "imag":.        
-000196c0: 2020 2020 7265 7375 6c74 735b 2d31 5d20      results[-1] 
-000196d0: 3d20 6e70 2e69 6d61 6728 7265 7375 6c74  = np.imag(result
-000196e0: 735b 2d31 5d29 0a20 2020 2020 2020 2065  s[-1]).        e
-000196f0: 6c69 6620 7365 6c66 2e5f 7265 7475 726e  lif self._return
-00019700: 203d 3d20 2261 6273 2220 6f72 2073 656c   == "abs" or sel
-00019710: 662e 5f72 6574 7572 6e20 3d3d 2022 6162  f._return == "ab
-00019720: 7361 7267 223a 0a20 2020 2020 2020 2020  sarg":.         
-00019730: 2020 2072 6573 756c 7473 5b2d 315d 203d     results[-1] =
-00019740: 206e 702e 6162 736f 6c75 7465 2872 6573   np.absolute(res
-00019750: 756c 7473 5b2d 315d 290a 2020 2020 2020  ults[-1]).      
-00019760: 2020 656c 6966 2073 656c 662e 5f72 6574    elif self._ret
-00019770: 7572 6e20 3d3d 2022 6172 6722 3a0a 2020  urn == "arg":.  
-00019780: 2020 2020 2020 2020 2020 7265 7375 6c74            result
-00019790: 735b 2d31 5d20 3d20 6e70 2e61 6e67 6c65  s[-1] = np.angle
-000197a0: 2872 6573 756c 7473 5b2d 315d 290a 2020  (results[-1]).  
-000197b0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000197c0: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-000197d0: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
-000197e0: 2020 2020 2020 2020 2020 2260 5f72 6574            "`_ret
-000197f0: 7572 6e60 206e 6f74 2072 6563 6f67 6e69  urn` not recogni
-00019800: 7a65 642e 2052 6563 6569 7665 643a 2025  zed. Received: %
-00019810: 7322 2025 2073 656c 662e 5f72 6574 7572  s" % self._retur
-00019820: 6e29 0a0a 2020 2020 2020 2020 7265 7475  n)..        retu
-00019830: 726e 205b 2a72 6573 756c 7473 5b31 3a5d  rn [*results[1:]
-00019840: 2c20 7265 7375 6c74 735b 305d 5d0a 0a0a  , results[0]]...
-00019850: 6465 6620 5f73 6574 5f64 6973 6372 6574  def _set_discret
-00019860: 697a 6174 696f 6e5f 706f 696e 7473 286b  ization_points(k
-00019870: 7761 7267 732c 2070 7429 3a0a 2020 2020  wargs, pt):.    
-00019880: 2222 2241 6c6c 6f77 2074 6865 2075 7365  """Allow the use
-00019890: 206f 6620 7468 6520 6b65 7977 6f72 6420   of the keyword 
-000198a0: 6172 6775 6d65 6e74 7320 6e2c 206e 3120  arguments n, n1 
-000198b0: 616e 6420 6e32 2028 616e 6420 6e33 2920  and n2 (and n3) 
-000198c0: 746f 0a20 2020 2073 7065 6369 6679 2074  to.    specify t
-000198d0: 6865 206e 756d 6265 7220 6f66 2064 6973  he number of dis
-000198e0: 6372 6574 697a 6174 696f 6e20 706f 696e  cretization poin
-000198f0: 7473 2069 6e20 7477 6f20 286f 7220 7468  ts in two (or th
-00019900: 7265 6529 2064 6972 6563 7469 6f6e 732e  ree) directions.
-00019910: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
-00019920: 0a20 2020 203d 3d3d 3d3d 3d3d 3d3d 3d0a  .    ==========.
-00019930: 0a20 2020 206b 7761 7267 7320 3a20 6469  .    kwargs : di
-00019940: 6374 0a0a 2020 2020 7074 203a 2074 7970  ct..    pt : typ
-00019950: 650a 2020 2020 2020 2020 5468 6520 7479  e.        The ty
-00019960: 7065 206f 6620 7468 6520 7365 7269 6573  pe of the series
-00019970: 2c20 7768 6963 6820 696e 6469 6361 7465  , which indicate
-00019980: 7320 7468 6520 6b69 6e64 206f 6620 706c  s the kind of pl
-00019990: 6f74 2077 6520 6172 650a 2020 2020 2020  ot we are.      
-000199a0: 2020 7472 7969 6e67 2074 6f20 6372 6561    trying to crea
-000199b0: 7465 2e0a 0a20 2020 2052 6574 7572 6e73  te...    Returns
-000199c0: 0a20 2020 203d 3d3d 3d3d 3d3d 0a0a 2020  .    =======..  
-000199d0: 2020 6b77 6172 6773 203a 2064 6963 740a    kwargs : dict.
-000199e0: 2020 2020 2222 220a 2020 2020 6465 7072      """.    depr
-000199f0: 6563 6174 6564 5f6b 6579 776f 7264 7320  ecated_keywords 
-00019a00: 3d20 7b0a 2020 2020 2020 2020 226e 625f  = {.        "nb_
-00019a10: 6f66 5f70 6f69 6e74 7322 3a20 226e 222c  of_points": "n",
-00019a20: 0a20 2020 2020 2020 2022 6e62 5f6f 665f  .        "nb_of_
-00019a30: 706f 696e 7473 5f78 223a 2022 6e31 222c  points_x": "n1",
-00019a40: 0a20 2020 2020 2020 2022 6e62 5f6f 665f  .        "nb_of_
-00019a50: 706f 696e 7473 5f79 223a 2022 6e32 222c  points_y": "n2",
-00019a60: 0a20 2020 2020 2020 2022 6e62 5f6f 665f  .        "nb_of_
-00019a70: 706f 696e 7473 5f75 223a 2022 6e31 222c  points_u": "n1",
-00019a80: 0a20 2020 2020 2020 2022 6e62 5f6f 665f  .        "nb_of_
-00019a90: 706f 696e 7473 5f76 223a 2022 6e32 222c  points_v": "n2",
-00019aa0: 0a20 2020 2020 2020 2022 706f 696e 7473  .        "points
-00019ab0: 223a 2022 6e22 0a20 2020 207d 0a20 2020  ": "n".    }.   
-00019ac0: 2066 6f72 206b 2c20 7620 696e 2064 6570   for k, v in dep
-00019ad0: 7265 6361 7465 645f 6b65 7977 6f72 6473  recated_keywords
-00019ae0: 2e69 7465 6d73 2829 3a0a 2020 2020 2020  .items():.      
-00019af0: 2020 6966 206b 2069 6e20 6b77 6172 6773    if k in kwargs
-00019b00: 2e6b 6579 7328 293a 0a20 2020 2020 2020  .keys():.       
-00019b10: 2020 2020 206b 7761 7267 735b 765d 203d       kwargs[v] =
-00019b20: 206b 7761 7267 732e 706f 7028 6b29 0a0a   kwargs.pop(k)..
-00019b30: 2020 2020 6966 2070 7420 696e 205b 0a20      if pt in [. 
-00019b40: 2020 2020 2020 204c 696e 654f 7665 7231         LineOver1
-00019b50: 4452 616e 6765 5365 7269 6573 2c20 5061  DRangeSeries, Pa
-00019b60: 7261 6d65 7472 6963 3244 4c69 6e65 5365  rametric2DLineSe
-00019b70: 7269 6573 2c0a 2020 2020 2020 2020 5061  ries,.        Pa
-00019b80: 7261 6d65 7472 6963 3344 4c69 6e65 5365  rametric3DLineSe
-00019b90: 7269 6573 2c20 4162 7341 7267 4c69 6e65  ries, AbsArgLine
-00019ba0: 5365 7269 6573 2c20 436f 6c6f 7265 644c  Series, ColoredL
-00019bb0: 696e 654f 7665 7231 4452 616e 6765 5365  ineOver1DRangeSe
-00019bc0: 7269 6573 2c0a 2020 2020 2020 2020 436f  ries,.        Co
-00019bd0: 6d70 6c65 7850 6172 616d 6574 7269 6333  mplexParametric3
-00019be0: 444c 696e 6553 6572 6965 732c 204e 7971  DLineSeries, Nyq
-00019bf0: 7569 7374 4c69 6e65 5365 7269 6573 2c20  uistLineSeries, 
-00019c00: 4e69 6368 6f6c 734c 696e 6553 6572 6965  NicholsLineSerie
-00019c10: 732c 0a20 2020 2020 2020 2053 7973 7465  s,.        Syste
-00019c20: 6d52 6573 706f 6e73 6553 6572 6965 732c  mResponseSeries,
-00019c30: 2043 6f6c 6f72 6564 5379 7374 656d 5265   ColoredSystemRe
-00019c40: 7370 6f6e 7365 5365 7269 6573 0a20 2020  sponseSeries.   
-00019c50: 205d 3a0a 2020 2020 2020 2020 6966 2022   ]:.        if "
-00019c60: 6e22 2069 6e20 6b77 6172 6773 2e6b 6579  n" in kwargs.key
-00019c70: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
-00019c80: 206b 7761 7267 735b 226e 3122 5d20 3d20   kwargs["n1"] = 
-00019c90: 6b77 6172 6773 5b22 6e22 5d0a 2020 2020  kwargs["n"].    
-00019ca0: 2020 2020 2020 2020 6966 2068 6173 6174          if hasat
-00019cb0: 7472 286b 7761 7267 735b 226e 225d 2c20  tr(kwargs["n"], 
-00019cc0: 225f 5f69 7465 725f 5f22 2920 616e 6420  "__iter__") and 
-00019cd0: 286c 656e 286b 7761 7267 735b 226e 225d  (len(kwargs["n"]
-00019ce0: 2920 3e20 3029 3a0a 2020 2020 2020 2020  ) > 0):.        
-00019cf0: 2020 2020 2020 2020 6b77 6172 6773 5b22          kwargs["
-00019d00: 6e31 225d 203d 206b 7761 7267 735b 226e  n1"] = kwargs["n
-00019d10: 225d 5b30 5d0a 2020 2020 656c 6966 2070  "][0].    elif p
-00019d20: 7420 696e 205b 0a20 2020 2020 2020 2053  t in [.        S
-00019d30: 7572 6661 6365 4f76 6572 3244 5261 6e67  urfaceOver2DRang
-00019d40: 6553 6572 6965 732c 2043 6f6e 746f 7572  eSeries, Contour
-00019d50: 5365 7269 6573 2c20 5061 7261 6d65 7472  Series, Parametr
-00019d60: 6963 5375 7266 6163 6553 6572 6965 732c  icSurfaceSeries,
-00019d70: 0a20 2020 2020 2020 2043 6f6d 706c 6578  .        Complex
-00019d80: 5375 7266 6163 6553 6572 6965 732c 2043  SurfaceSeries, C
-00019d90: 6f6d 706c 6578 446f 6d61 696e 436f 6c6f  omplexDomainColo
-00019da0: 7269 6e67 5365 7269 6573 2c0a 2020 2020  ringSeries,.    
-00019db0: 2020 2020 5665 6374 6f72 3244 5365 7269      Vector2DSeri
-00019dc0: 6573 2c20 496d 706c 6963 6974 5365 7269  es, ImplicitSeri
-00019dd0: 6573 2c20 5269 656d 616e 6e53 7068 6572  es, RiemannSpher
-00019de0: 6553 6572 6965 730a 2020 2020 5d3a 0a20  eSeries.    ]:. 
-00019df0: 2020 2020 2020 2069 6620 226e 2220 696e         if "n" in
-00019e00: 206b 7761 7267 732e 6b65 7973 2829 3a0a   kwargs.keys():.
-00019e10: 2020 2020 2020 2020 2020 2020 6966 2068              if h
-00019e20: 6173 6174 7472 286b 7761 7267 735b 226e  asattr(kwargs["n
-00019e30: 225d 2c20 225f 5f69 7465 725f 5f22 2920  "], "__iter__") 
-00019e40: 616e 6420 286c 656e 286b 7761 7267 735b  and (len(kwargs[
-00019e50: 226e 225d 2920 3e20 3129 3a0a 2020 2020  "n"]) > 1):.    
-00019e60: 2020 2020 2020 2020 2020 2020 6b77 6172              kwar
-00019e70: 6773 5b22 6e31 225d 203d 206b 7761 7267  gs["n1"] = kwarg
-00019e80: 735b 226e 225d 5b30 5d0a 2020 2020 2020  s["n"][0].      
-00019e90: 2020 2020 2020 2020 2020 6b77 6172 6773            kwargs
-00019ea0: 5b22 6e32 225d 203d 206b 7761 7267 735b  ["n2"] = kwargs[
-00019eb0: 226e 225d 5b31 5d0a 2020 2020 2020 2020  "n"][1].        
-00019ec0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00019ed0: 2020 2020 2020 2020 2020 6b77 6172 6773            kwargs
-00019ee0: 5b22 6e31 225d 203d 206b 7761 7267 735b  ["n1"] = kwargs[
-00019ef0: 226e 3222 5d20 3d20 6b77 6172 6773 5b22  "n2"] = kwargs["
-00019f00: 6e22 5d0a 2020 2020 656c 6966 2070 7420  n"].    elif pt 
-00019f10: 696e 205b 0a20 2020 2020 2020 2056 6563  in [.        Vec
-00019f20: 746f 7233 4453 6572 6965 732c 2053 6c69  tor3DSeries, Sli
-00019f30: 6365 5665 6374 6f72 3344 5365 7269 6573  ceVector3DSeries
-00019f40: 2c20 496d 706c 6963 6974 3344 5365 7269  , Implicit3DSeri
-00019f50: 6573 2c20 506c 616e 6553 6572 6965 730a  es, PlaneSeries.
-00019f60: 2020 2020 5d3a 0a20 2020 2020 2020 2069      ]:.        i
-00019f70: 6620 226e 2220 696e 206b 7761 7267 732e  f "n" in kwargs.
-00019f80: 6b65 7973 2829 3a0a 2020 2020 2020 2020  keys():.        
-00019f90: 2020 2020 6966 2068 6173 6174 7472 286b      if hasattr(k
-00019fa0: 7761 7267 735b 226e 225d 2c20 225f 5f69  wargs["n"], "__i
-00019fb0: 7465 725f 5f22 2920 616e 6420 286c 656e  ter__") and (len
-00019fc0: 286b 7761 7267 735b 226e 225d 2920 3e20  (kwargs["n"]) > 
-00019fd0: 3229 3a0a 2020 2020 2020 2020 2020 2020  2):.            
-00019fe0: 2020 2020 6b77 6172 6773 5b22 6e31 225d      kwargs["n1"]
-00019ff0: 203d 206b 7761 7267 735b 226e 225d 5b30   = kwargs["n"][0
-0001a000: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0001a010: 2020 6b77 6172 6773 5b22 6e32 225d 203d    kwargs["n2"] =
-0001a020: 206b 7761 7267 735b 226e 225d 5b31 5d0a   kwargs["n"][1].
-0001a030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a040: 6b77 6172 6773 5b22 6e33 225d 203d 206b  kwargs["n3"] = k
-0001a050: 7761 7267 735b 226e 225d 5b32 5d0a 2020  wargs["n"][2].  
-0001a060: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-0001a070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a080: 6b77 6172 6773 5b22 6e31 225d 203d 206b  kwargs["n1"] = k
-0001a090: 7761 7267 735b 226e 3222 5d20 3d20 6b77  wargs["n2"] = kw
-0001a0a0: 6172 6773 5b22 6e33 225d 203d 206b 7761  args["n3"] = kwa
-0001a0b0: 7267 735b 226e 225d 0a20 2020 2072 6574  rgs["n"].    ret
-0001a0c0: 7572 6e20 6b77 6172 6773 0a0a 0a63 6c61  urn kwargs...cla
-0001a0d0: 7373 2056 6563 746f 7242 6173 6528 436f  ss VectorBase(Co
-0001a0e0: 6d6d 6f6e 556e 6966 6f72 6d45 7661 6c75  mmonUniformEvalu
-0001a0f0: 6174 696f 6e2c 2042 6173 6553 6572 6965  ation, BaseSerie
-0001a100: 7329 3a0a 2020 2020 2222 2252 6570 7265  s):.    """Repre
-0001a110: 7365 6e74 2061 2076 6563 746f 7220 6669  sent a vector fi
-0001a120: 656c 642e 2222 220a 0a20 2020 2069 735f  eld."""..    is_
-0001a130: 7665 6374 6f72 203d 2054 7275 650a 2020  vector = True.  
-0001a140: 2020 6973 5f73 6c69 6365 203d 2046 616c    is_slice = Fal
-0001a150: 7365 0a20 2020 2069 735f 7374 7265 616d  se.    is_stream
-0001a160: 6c69 6e65 7320 3d20 4661 6c73 650a 2020  lines = False.  
-0001a170: 2020 5f61 6c6c 6f77 6564 5f6b 6579 7320    _allowed_keys 
-0001a180: 3d20 5b0a 2020 2020 2020 2020 2273 7472  = [.        "str
-0001a190: 6561 6d6c 696e 6573 222c 2022 7175 6976  eamlines", "quiv
-0001a1a0: 6572 5f6b 7722 2c20 2273 7472 6561 6d5f  er_kw", "stream_
-0001a1b0: 6b77 222c 2022 6e6f 726d 616c 697a 6522  kw", "normalize"
-0001a1c0: 5d0a 0a20 2020 2064 6566 205f 5f69 6e69  ]..    def __ini
-0001a1d0: 745f 5f28 7365 6c66 2c20 6578 7072 732c  t__(self, exprs,
-0001a1e0: 2072 616e 6765 732c 206c 6162 656c 2c20   ranges, label, 
-0001a1f0: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
-0001a200: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
-0001a210: 745f 5f28 2a2a 6b77 6172 6773 290a 2020  t__(**kwargs).  
-0001a220: 2020 2020 2020 7365 6c66 2e65 7870 7220        self.expr 
-0001a230: 3d20 7475 706c 6528 5b65 2069 6620 6361  = tuple([e if ca
-0001a240: 6c6c 6162 6c65 2865 2920 656c 7365 2073  llable(e) else s
-0001a250: 796d 7069 6679 2865 2920 666f 7220 6520  ympify(e) for e 
-0001a260: 696e 2065 7870 7273 5d29 0a20 2020 2020  in exprs]).     
-0001a270: 2020 2073 656c 662e 7261 6e67 6573 203d     self.ranges =
-0001a280: 2072 616e 6765 730a 2020 2020 2020 2020   ranges.        
-0001a290: 7365 6c66 2e5f 6c61 6265 6c20 3d20 7374  self._label = st
-0001a2a0: 7228 6578 7072 7329 2069 6620 6c61 6265  r(exprs) if labe
-0001a2b0: 6c20 6973 204e 6f6e 6520 656c 7365 206c  l is None else l
-0001a2c0: 6162 656c 0a20 2020 2020 2020 2073 656c  abel.        sel
-0001a2d0: 662e 5f6c 6174 6578 5f6c 6162 656c 203d  f._latex_label =
-0001a2e0: 206c 6174 6578 2865 7870 7273 2920 6966   latex(exprs) if
-0001a2f0: 206c 6162 656c 2069 7320 4e6f 6e65 2065   label is None e
-0001a300: 6c73 6520 6c61 6265 6c0a 2020 2020 2020  lse label.      
-0001a310: 2020 7365 6c66 2e69 735f 7374 7265 616d    self.is_stream
-0001a320: 6c69 6e65 7320 3d20 6b77 6172 6773 2e67  lines = kwargs.g
-0001a330: 6574 2822 7374 7265 616d 6c69 6e65 7322  et("streamlines"
-0001a340: 2c20 4661 6c73 6529 0a20 2020 2020 2020  , False).       
-0001a350: 2073 656c 662e 7573 655f 636d 203d 206b   self.use_cm = k
-0001a360: 7761 7267 732e 6765 7428 2275 7365 5f63  wargs.get("use_c
-0001a370: 6d22 2c20 5472 7565 290a 2020 2020 2020  m", True).      
-0001a380: 2020 2320 4e4f 5445 3a20 6e6f 726d 616c    # NOTE: normal
-0001a390: 697a 6174 696f 6e20 6973 2061 6368 6965  ization is achie
-0001a3a0: 7665 6420 6174 2074 6865 2062 6163 6b65  ved at the backe
-0001a3b0: 6e64 2073 6964 653a 2074 6869 7320 616c  nd side: this al
-0001a3c0: 6c6f 7773 2074 6f0a 2020 2020 2020 2020  lows to.        
-0001a3d0: 2320 6f62 7461 696e 2073 616d 6520 6c65  # obtain same le
-0001a3e0: 6e67 7468 2061 7272 6f77 732c 2062 7574  ngth arrows, but
-0001a3f0: 2063 6f6c 6f72 6564 2077 6974 6820 7468   colored with th
-0001a400: 6520 6163 7475 616c 206d 6167 6e69 7475  e actual magnitu
-0001a410: 6465 2e0a 2020 2020 2020 2020 2320 4966  de..        # If
-0001a420: 206e 6f72 6d61 6c69 7a61 7469 6f6e 2069   normalization i
-0001a430: 7320 6170 706c 6965 6420 6f6e 2074 6865  s applied on the
-0001a440: 2073 6572 6965 7320 6765 745f 6461 7461   series get_data
-0001a450: 2829 2c20 7468 6520 636f 6c6f 7269 6e67  (), the coloring
-0001a460: 0a20 2020 2020 2020 2023 2062 7920 6d61  .        # by ma
-0001a470: 676e 6974 7564 6520 776f 756c 6420 6e6f  gnitude would no
-0001a480: 7420 6265 2061 7070 6c69 6361 626c 6520  t be applicable 
-0001a490: 6174 2074 6865 2062 6163 6b65 6e64 2e0a  at the backend..
-0001a4a0: 2020 2020 2020 2020 7365 6c66 2e6e 6f72          self.nor
-0001a4b0: 6d61 6c69 7a65 203d 206b 7761 7267 732e  malize = kwargs.
-0001a4c0: 6765 7428 226e 6f72 6d61 6c69 7a65 222c  get("normalize",
-0001a4d0: 2046 616c 7365 290a 0a20 2020 2020 2020   False)..       
-0001a4e0: 2023 2069 6620 7468 6520 6578 7072 6573   # if the expres
-0001a4f0: 7369 6f6e 7320 6172 6520 6c61 6d62 6461  sions are lambda
-0001a500: 2066 756e 6374 696f 6e73 2061 6e64 206e   functions and n
-0001a510: 6f20 6c61 6265 6c20 6861 7320 6265 656e  o label has been
-0001a520: 0a20 2020 2020 2020 2023 2070 726f 7669  .        # provi
-0001a530: 6465 642c 2074 6865 6e20 6974 7320 6265  ded, then its be
-0001a540: 7474 6572 2074 6f20 646f 2074 6865 2066  tter to do the f
-0001a550: 6f6c 6c6f 7769 6e67 2069 6e20 6f72 6465  ollowing in orde
-0001a560: 7220 746f 2061 766f 6964 0a20 2020 2020  r to avoid.     
-0001a570: 2020 2023 2073 7570 7269 7365 7320 6f6e     # suprises on
-0001a580: 2074 6865 2062 6163 6b65 6e64 0a20 2020   the backend.   
-0001a590: 2020 2020 2069 6620 616e 7928 6361 6c6c       if any(call
-0001a5a0: 6162 6c65 2865 2920 666f 7220 6520 696e  able(e) for e in
-0001a5b0: 2073 656c 662e 6578 7072 293a 0a20 2020   self.expr):.   
-0001a5c0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-0001a5d0: 2e5f 6c61 6265 6c20 3d3d 2073 7472 2873  ._label == str(s
-0001a5e0: 656c 662e 6578 7072 293a 0a20 2020 2020  elf.expr):.     
-0001a5f0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001a600: 5f6c 6162 656c 203d 2022 4d61 676e 6974  _label = "Magnit
-0001a610: 7564 6522 0a0a 2020 2020 2020 2020 2320  ude"..        # 
-0001a620: 4e4f 5445 3a20 7768 656e 2070 6c6f 7474  NOTE: when plott
-0001a630: 696e 6720 7665 6374 6f72 2066 6965 6c64  ing vector field
-0001a640: 7320 6974 206d 6967 6874 2062 6520 7573  s it might be us
-0001a650: 6566 756c 2074 6f20 7265 7065 6174 2074  eful to repeat t
-0001a660: 6865 0a20 2020 2020 2020 2023 2070 6c6f  he.        # plo
-0001a670: 7420 636f 6d6d 616e 6420 7377 6974 6368  t command switch
-0001a680: 696e 6720 6265 7477 6565 6e20 7175 6976  ing between quiv
-0001a690: 6572 7320 616e 6420 7374 7265 616d 6c69  ers and streamli
-0001a6a0: 6e65 732e 0a20 2020 2020 2020 2023 2055  nes..        # U
-0001a6b0: 7375 616c 6c79 2c20 706c 6f74 7469 6e67  sually, plotting
-0001a6c0: 206c 6962 7261 7269 6573 2065 7870 6f73   libraries expos
-0001a6d0: 6520 6469 6666 6572 656e 7420 6675 6e63  e different func
-0001a6e0: 7469 6f6e 7320 666f 7220 7175 6976 6572  tions for quiver
-0001a6f0: 730a 2020 2020 2020 2020 2320 616e 6420  s.        # and 
-0001a700: 7374 7265 616d 6c69 6e65 732c 2061 6363  streamlines, acc
-0001a710: 6570 7469 6e67 2064 6966 6665 7265 6e74  epting different
-0001a720: 206b 6579 776f 7264 2061 7267 756d 656e   keyword argumen
-0001a730: 7473 2e0a 2020 2020 2020 2020 2320 5468  ts..        # Th
-0001a740: 6520 6368 6f69 6365 2074 6f20 696d 706c  e choice to impl
-0001a750: 656d 656e 7420 7365 7061 7261 7465 7320  ement separates 
-0001a760: 7374 7265 616d 5f6b 7720 616e 6420 7175  stream_kw and qu
-0001a770: 6976 6572 5f6b 7720 616c 6c6f 7773 0a20  iver_kw allows. 
-0001a780: 2020 2020 2020 2023 2074 6869 7320 7175         # this qu
-0001a790: 6963 6b20 7377 6974 6368 2e0a 2020 2020  ick switch..    
-0001a7a0: 2020 2020 6966 2073 656c 662e 6973 5f73      if self.is_s
-0001a7b0: 7472 6561 6d6c 696e 6573 3a0a 2020 2020  treamlines:.    
-0001a7c0: 2020 2020 2020 2020 7365 6c66 2e72 656e          self.ren
-0001a7d0: 6465 7269 6e67 5f6b 7720 3d20 6b77 6172  dering_kw = kwar
-0001a7e0: 6773 2e67 6574 280a 2020 2020 2020 2020  gs.get(.        
-0001a7f0: 2020 2020 2020 2020 2273 7472 6561 6d5f          "stream_
-0001a800: 6b77 222c 206b 7761 7267 732e 6765 7428  kw", kwargs.get(
-0001a810: 2272 656e 6465 7269 6e67 5f6b 7722 2c20  "rendering_kw", 
-0001a820: 6469 6374 2829 2929 0a20 2020 2020 2020  dict())).       
-0001a830: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0001a840: 2020 2073 656c 662e 7265 6e64 6572 696e     self.renderin
-0001a850: 675f 6b77 203d 206b 7761 7267 732e 6765  g_kw = kwargs.ge
-0001a860: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
-0001a870: 2020 2022 7175 6976 6572 5f6b 7722 2c20     "quiver_kw", 
-0001a880: 6b77 6172 6773 2e67 6574 2822 7265 6e64  kwargs.get("rend
-0001a890: 6572 696e 675f 6b77 222c 2064 6963 7428  ering_kw", dict(
-0001a8a0: 2929 290a 2020 2020 2020 2020 7365 6c66  ))).        self
-0001a8b0: 2e5f 706f 7374 5f69 6e69 7428 290a 0a20  ._post_init().. 
-0001a8c0: 2020 2064 6566 2067 6574 5f6c 6162 656c     def get_label
-0001a8d0: 2873 656c 662c 2075 7365 5f6c 6174 6578  (self, use_latex
-0001a8e0: 3d46 616c 7365 2c20 7772 6170 7065 723d  =False, wrapper=
-0001a8f0: 2224 2573 2422 293a 0a20 2020 2020 2020  "$%s$"):.       
-0001a900: 2069 6620 7573 655f 6c61 7465 783a 0a20   if use_latex:. 
-0001a910: 2020 2020 2020 2020 2020 2065 7870 7220             expr 
-0001a920: 3d20 7365 6c66 2e65 7870 720a 2020 2020  = self.expr.    
-0001a930: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-0001a940: 5f6c 6162 656c 2021 3d20 7374 7228 6578  _label != str(ex
-0001a950: 7072 293a 0a20 2020 2020 2020 2020 2020  pr):.           
-0001a960: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001a970: 2e5f 6c61 7465 785f 6c61 6265 6c0a 2020  ._latex_label.  
-0001a980: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001a990: 2073 656c 662e 5f67 6574 5f77 7261 7070   self._get_wrapp
-0001a9a0: 6564 5f6c 6162 656c 2873 656c 662e 5f6c  ed_label(self._l
-0001a9b0: 6174 6578 5f6c 6162 656c 2c20 7772 6170  atex_label, wrap
-0001a9c0: 7065 7229 0a20 2020 2020 2020 2072 6574  per).        ret
-0001a9d0: 7572 6e20 7365 6c66 2e5f 6c61 6265 6c0a  urn self._label.
-0001a9e0: 0a20 2020 2064 6566 2067 6574 5f64 6174  .    def get_dat
-0001a9f0: 6128 7365 6c66 293a 0a20 2020 2020 2020  a(self):.       
-0001aa00: 2022 2222 5265 7475 726e 2061 7272 6179   """Return array
-0001aa10: 7320 6f66 2063 6f6f 7264 696e 6174 6573  s of coordinates
-0001aa20: 2066 6f72 2070 6c6f 7474 696e 672e 2044   for plotting. D
-0001aa30: 6570 656e 6469 6e67 206f 6e20 7468 650a  epending on the.
-0001aa40: 2020 2020 2020 2020 6061 6461 7074 6976          `adaptiv
-0001aa50: 6560 206f 7074 696f 6e2c 2074 6869 7320  e` option, this 
-0001aa60: 6675 6e63 7469 6f6e 2077 696c 6c20 6569  function will ei
-0001aa70: 7468 6572 2075 7365 2061 6e20 6164 6170  ther use an adap
-0001aa80: 7469 7665 2061 6c67 6f72 6974 686d 0a20  tive algorithm. 
-0001aa90: 2020 2020 2020 206f 7220 6974 2077 696c         or it wil
-0001aaa0: 6c20 756e 6966 6f72 6d6c 7920 7361 6d70  l uniformly samp
-0001aab0: 6c65 2074 6865 2065 7870 7265 7373 696f  le the expressio
-0001aac0: 6e20 6f76 6572 2074 6865 2070 726f 7669  n over the provi
-0001aad0: 6465 6420 7261 6e67 652e 0a0a 2020 2020  ded range...    
-0001aae0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-0001aaf0: 2020 2020 3d3d 3d3d 3d3d 3d0a 0a20 2020      =======..   
-0001ab00: 2020 2020 206d 6573 685f 7820 3a20 6e70       mesh_x : np
-0001ab10: 2e6e 6461 7272 6179 205b 6e32 2078 206e  .ndarray [n2 x n
-0001ab20: 315d 0a20 2020 2020 2020 2020 2020 2044  1].            D
-0001ab30: 6973 6372 6574 697a 6564 2078 2d64 6f6d  iscretized x-dom
-0001ab40: 6169 6e2e 0a0a 2020 2020 2020 2020 6d65  ain...        me
-0001ab50: 7368 5f79 203a 206e 702e 6e64 6172 7261  sh_y : np.ndarra
-0001ab60: 7920 5b6e 3220 7820 6e31 5d0a 2020 2020  y [n2 x n1].    
-0001ab70: 2020 2020 2020 2020 4469 7363 7265 7469          Discreti
-0001ab80: 7a65 6420 792d 646f 6d61 696e 2e0a 0a20  zed y-domain... 
-0001ab90: 2020 2020 2020 206d 6573 685f 7a20 3a20         mesh_z : 
-0001aba0: 6e70 2e6e 6461 7272 6179 205b 6e32 2078  np.ndarray [n2 x
-0001abb0: 206e 315d 2028 6f70 7469 6f6e 616c 290a   n1] (optional).
-0001abc0: 2020 2020 2020 2020 2020 2020 4469 7363              Disc
-0001abd0: 7265 7469 7a65 6420 7a2d 646f 6d61 696e  retized z-domain
-0001abe0: 2069 6e20 7468 6520 6361 7365 206f 6620   in the case of 
-0001abf0: 5665 6374 6f72 3344 5365 7269 6573 2e0a  Vector3DSeries..
-0001ac00: 0a20 2020 2020 2020 2075 203a 206e 702e  .        u : np.
-0001ac10: 6e64 6172 7261 7920 5b6e 3220 7820 6e31  ndarray [n2 x n1
-0001ac20: 5d0a 2020 2020 2020 2020 2020 2020 4669  ].            Fi
-0001ac30: 7273 7420 636f 6d70 6f6e 656e 7420 6f66  rst component of
-0001ac40: 2074 6865 2076 6563 746f 7220 6669 656c   the vector fiel
-0001ac50: 642e 0a0a 2020 2020 2020 2020 7620 3a20  d...        v : 
-0001ac60: 6e70 2e6e 6461 7272 6179 205b 6e32 2078  np.ndarray [n2 x
-0001ac70: 206e 315d 0a20 2020 2020 2020 2020 2020   n1].           
-0001ac80: 2053 6563 6f6e 6420 636f 6d70 6f6e 656e   Second componen
-0001ac90: 7420 6f66 2074 6865 2076 6563 746f 7220  t of the vector 
-0001aca0: 6669 656c 642e 0a0a 2020 2020 2020 2020  field...        
-0001acb0: 7720 3a20 6e70 2e6e 6461 7272 6179 205b  w : np.ndarray [
-0001acc0: 6e32 2078 206e 315d 2028 6f70 7469 6f6e  n2 x n1] (option
-0001acd0: 616c 290a 2020 2020 2020 2020 2020 2020  al).            
-0001ace0: 5468 6972 6420 636f 6d70 6f6e 656e 7420  Third component 
-0001acf0: 6f66 2074 6865 2076 6563 746f 7220 6669  of the vector fi
-0001ad00: 656c 6420 696e 2074 6865 2063 6173 6520  eld in the case 
-0001ad10: 6f66 2056 6563 746f 7233 4453 6572 6965  of Vector3DSerie
-0001ad20: 732e 0a20 2020 2020 2020 2022 2222 0a20  s..        """. 
-0001ad30: 2020 2020 2020 206e 7020 3d20 696d 706f         np = impo
-0001ad40: 7274 5f6d 6f64 756c 6528 276e 756d 7079  rt_module('numpy
-0001ad50: 2729 0a0a 2020 2020 2020 2020 7265 7375  ')..        resu
-0001ad60: 6c74 7320 3d20 7365 6c66 2e5f 6576 616c  lts = self._eval
-0001ad70: 7561 7465 2829 0a20 2020 2020 2020 2066  uate().        f
-0001ad80: 6f72 2069 2c20 7220 696e 2065 6e75 6d65  or i, r in enume
-0001ad90: 7261 7465 2872 6573 756c 7473 293a 0a20  rate(results):. 
-0001ada0: 2020 2020 2020 2020 2020 2072 655f 762c             re_v,
-0001adb0: 2069 6d5f 7620 3d20 6e70 2e72 6561 6c28   im_v = np.real(
-0001adc0: 7229 2c20 6e70 2e69 6d61 6728 7229 0a20  r), np.imag(r). 
-0001add0: 2020 2020 2020 2020 2020 2072 655f 765b             re_v[
-0001ade0: 6e70 2e69 6e76 6572 7428 6e70 2e69 7363  np.invert(np.isc
-0001adf0: 6c6f 7365 2869 6d5f 762c 206e 702e 7a65  lose(im_v, np.ze
-0001ae00: 726f 735f 6c69 6b65 2869 6d5f 7629 2929  ros_like(im_v)))
-0001ae10: 5d20 3d20 6e70 2e6e 616e 0a20 2020 2020  ] = np.nan.     
-0001ae20: 2020 2020 2020 2072 6573 756c 7473 5b69         results[i
-0001ae30: 5d20 3d20 7265 5f76 0a0a 2020 2020 2020  ] = re_v..      
-0001ae40: 2020 7265 7475 726e 2073 656c 662e 5f61    return self._a
-0001ae50: 7070 6c79 5f74 7261 6e73 666f 726d 282a  pply_transform(*
-0001ae60: 7265 7375 6c74 7329 0a0a 0a63 6c61 7373  results)...class
-0001ae70: 2056 6563 746f 7232 4453 6572 6965 7328   Vector2DSeries(
-0001ae80: 5665 6374 6f72 4261 7365 293a 0a20 2020  VectorBase):.   
-0001ae90: 2022 2222 5265 7072 6573 656e 7473 2061   """Represents a
-0001aea0: 2032 4420 7665 6374 6f72 2066 6965 6c64   2D vector field
-0001aeb0: 2e22 2222 0a0a 2020 2020 6973 5f32 4476  ."""..    is_2Dv
-0001aec0: 6563 746f 7220 3d20 5472 7565 0a20 2020  ector = True.   
-0001aed0: 2023 2064 6566 6175 6c74 206e 756d 6265   # default numbe
-0001aee0: 7220 6f66 2064 6973 6372 6574 697a 6174  r of discretizat
-0001aef0: 696f 6e20 706f 696e 7473 0a20 2020 205f  ion points.    _
-0001af00: 4e20 3d20 3235 0a20 2020 205f 616c 6c6f  N = 25.    _allo
-0001af10: 7765 645f 6b65 7973 203d 205b 2273 6361  wed_keys = ["sca
-0001af20: 6c61 7222 5d0a 0a20 2020 2064 6566 205f  lar"]..    def _
-0001af30: 5f69 6e69 745f 5f28 7365 6c66 2c20 752c  _init__(self, u,
-0001af40: 2076 2c20 7261 6e67 6531 2c20 7261 6e67   v, range1, rang
-0001af50: 6532 2c20 6c61 6265 6c3d 2222 2c20 2a2a  e2, label="", **
-0001af60: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
-0001af70: 2073 7570 6572 2829 2e5f 5f69 6e69 745f   super().__init_
-0001af80: 5f28 2875 2c20 7629 2c20 2872 616e 6765  _((u, v), (range
-0001af90: 312c 2072 616e 6765 3229 2c20 6c61 6265  1, range2), labe
-0001afa0: 6c2c 202a 2a6b 7761 7267 7329 0a20 2020  l, **kwargs).   
-0001afb0: 2020 2020 2069 6620 2273 6361 6c61 7222       if "scalar"
-0001afc0: 206e 6f74 2069 6e20 6b77 6172 6773 2e6b   not in kwargs.k
-0001afd0: 6579 7328 293a 0a20 2020 2020 2020 2020  eys():.         
-0001afe0: 2020 2075 7365 5f63 6d20 3d20 4661 6c73     use_cm = Fals
-0001aff0: 650a 2020 2020 2020 2020 656c 6966 2028  e.        elif (
-0001b000: 6e6f 7420 6b77 6172 6773 5b22 7363 616c  not kwargs["scal
-0001b010: 6172 225d 2920 6f72 2028 6b77 6172 6773  ar"]) or (kwargs
-0001b020: 5b22 7363 616c 6172 225d 2069 7320 4e6f  ["scalar"] is No
-0001b030: 6e65 293a 0a20 2020 2020 2020 2020 2020  ne):.           
-0001b040: 2075 7365 5f63 6d20 3d20 5472 7565 0a20   use_cm = True. 
-0001b050: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0001b060: 2020 2020 2020 2020 2075 7365 5f63 6d20           use_cm 
-0001b070: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
-0001b080: 7365 6c66 2e75 7365 5f63 6d20 3d20 6b77  self.use_cm = kw
-0001b090: 6172 6773 2e67 6574 2822 7573 655f 636d  args.get("use_cm
-0001b0a0: 222c 2075 7365 5f63 6d29 0a0a 2020 2020  ", use_cm)..    
-0001b0b0: 6465 6620 5f5f 7374 725f 5f28 7365 6c66  def __str__(self
-0001b0c0: 293a 0a20 2020 2020 2020 2072 616e 6765  ):.        range
-0001b0d0: 7320 3d20 5b5d 0a20 2020 2020 2020 2066  s = [].        f
-0001b0e0: 203d 206c 616d 6264 6120 743a 2074 2069   = lambda t: t i
-0001b0f0: 6620 6c65 6e28 742e 6672 6565 5f73 796d  f len(t.free_sym
-0001b100: 626f 6c73 2920 3e20 3020 656c 7365 2066  bols) > 0 else f
-0001b110: 6c6f 6174 2874 290a 2020 2020 2020 2020  loat(t).        
-0001b120: 666f 7220 7220 696e 2073 656c 662e 7261  for r in self.ra
-0001b130: 6e67 6573 3a0a 2020 2020 2020 2020 2020  nges:.          
-0001b140: 2020 7261 6e67 6573 2e61 7070 656e 6428    ranges.append(
-0001b150: 2872 5b30 5d2c 2066 2872 5b31 5d29 2c20  (r[0], f(r[1]), 
-0001b160: 6628 725b 325d 2929 290a 2020 2020 2020  f(r[2]))).      
-0001b170: 2020 7265 7475 726e 2073 656c 662e 5f73    return self._s
-0001b180: 7472 5f68 656c 7065 7228 0a20 2020 2020  tr_helper(.     
-0001b190: 2020 2020 2020 2022 3244 2076 6563 746f         "2D vecto
-0001b1a0: 7220 7365 7269 6573 3a20 5b25 732c 2025  r series: [%s, %
-0001b1b0: 735d 206f 7665 7220 2573 2c20 2573 2220  s] over %s, %s" 
-0001b1c0: 2520 280a 2020 2020 2020 2020 2020 2020  % (.            
-0001b1d0: 2020 2020 2a73 656c 662e 6578 7072 2c20      *self.expr, 
-0001b1e0: 2a72 616e 6765 7329 290a 0a0a 636c 6173  *ranges))...clas
-0001b1f0: 7320 5665 6374 6f72 3344 5365 7269 6573  s Vector3DSeries
-0001b200: 2856 6563 746f 7242 6173 6529 3a0a 2020  (VectorBase):.  
-0001b210: 2020 2222 2252 6570 7265 7365 6e74 7320    """Represents 
-0001b220: 6120 3344 2076 6563 746f 7220 6669 656c  a 3D vector fiel
-0001b230: 642e 2222 220a 0a20 2020 2069 735f 3344  d."""..    is_3D
-0001b240: 203d 2054 7275 650a 2020 2020 6973 5f33   = True.    is_3
-0001b250: 4476 6563 746f 7220 3d20 5472 7565 0a20  Dvector = True. 
-0001b260: 2020 2023 2064 6566 6175 6c74 206e 756d     # default num
-0001b270: 6265 7220 6f66 2064 6973 6372 6574 697a  ber of discretiz
-0001b280: 6174 696f 6e20 706f 696e 7473 0a20 2020  ation points.   
-0001b290: 205f 4e20 3d20 3130 0a0a 2020 2020 6465   _N = 10..    de
-0001b2a0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
-0001b2b0: 2075 2c20 762c 207a 2c20 7261 6e67 6531   u, v, z, range1
-0001b2c0: 2c20 7261 6e67 6532 2c20 7261 6e67 6533  , range2, range3
-0001b2d0: 2c20 6c61 6265 6c3d 2222 2c20 2a2a 6b77  , label="", **kw
-0001b2e0: 6172 6773 293a 0a20 2020 2020 2020 2073  args):.        s
-0001b2f0: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
-0001b300: 2875 2c20 762c 207a 292c 2028 7261 6e67  (u, v, z), (rang
-0001b310: 6531 2c20 7261 6e67 6532 2c20 7261 6e67  e1, range2, rang
-0001b320: 6533 292c 206c 6162 656c 2c20 2a2a 6b77  e3), label, **kw
-0001b330: 6172 6773 290a 2020 2020 2020 2020 6966  args).        if
-0001b340: 2073 656c 662e 6973 5f73 7472 6561 6d6c   self.is_streaml
-0001b350: 696e 6573 2061 6e64 2069 7369 6e73 7461  ines and isinsta
-0001b360: 6e63 6528 7365 6c66 2e63 6f6c 6f72 5f66  nce(self.color_f
-0001b370: 756e 632c 2045 7870 7229 3a0a 2020 2020  unc, Expr):.    
-0001b380: 2020 2020 2020 2020 7261 6973 6520 5479          raise Ty
-0001b390: 7065 4572 726f 7228 0a20 2020 2020 2020  peError(.       
-0001b3a0: 2020 2020 2020 2020 2022 5665 6374 6f72           "Vector
-0001b3b0: 3344 5365 7269 6573 2077 6974 6820 7374  3DSeries with st
-0001b3c0: 7265 616d 6c69 6e65 7320 6361 6e27 7420  reamlines can't 
-0001b3d0: 7573 6520 220a 2020 2020 2020 2020 2020  use ".          
-0001b3e0: 2020 2020 2020 2273 796d 626f 6c69 6320        "symbolic 
-0001b3f0: 6063 6f6c 6f72 5f66 756e 6360 2e22 290a  `color_func`.").
-0001b400: 0a20 2020 2064 6566 205f 5f73 7472 5f5f  .    def __str__
-0001b410: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0001b420: 7261 6e67 6573 203d 205b 5d0a 2020 2020  ranges = [].    
-0001b430: 2020 2020 666f 7220 7220 696e 2073 656c      for r in sel
-0001b440: 662e 7261 6e67 6573 3a0a 2020 2020 2020  f.ranges:.      
-0001b450: 2020 2020 2020 7261 6e67 6573 2e61 7070        ranges.app
-0001b460: 656e 6428 2872 5b30 5d2c 2066 6c6f 6174  end((r[0], float
-0001b470: 2872 5b31 5d29 2c20 666c 6f61 7428 725b  (r[1]), float(r[
-0001b480: 325d 2929 290a 2020 2020 2020 2020 7265  2]))).        re
-0001b490: 7475 726e 2073 656c 662e 5f73 7472 5f68  turn self._str_h
-0001b4a0: 656c 7065 7228 0a20 2020 2020 2020 2020  elper(.         
-0001b4b0: 2020 2022 3344 2076 6563 746f 7220 7365     "3D vector se
-0001b4c0: 7269 6573 3a20 5b25 732c 2025 732c 2025  ries: [%s, %s, %
-0001b4d0: 735d 206f 7665 7220 2573 2c20 2573 2c20  s] over %s, %s, 
-0001b4e0: 2573 2220 2520 280a 2020 2020 2020 2020  %s" % (.        
-0001b4f0: 2020 2020 2020 2020 2a73 656c 662e 6578          *self.ex
-0001b500: 7072 2c20 2a72 616e 6765 7329 290a 0a0a  pr, *ranges))...
-0001b510: 6465 6620 5f62 7569 6c64 5f73 6c69 6365  def _build_slice
-0001b520: 5f73 6572 6965 7328 736c 6963 655f 7375  _series(slice_su
-0001b530: 7266 2c20 7261 6e67 6573 2c20 2a2a 6b77  rf, ranges, **kw
-0001b540: 6172 6773 293a 0a20 2020 2069 6620 6973  args):.    if is
-0001b550: 696e 7374 616e 6365 2873 6c69 6365 5f73  instance(slice_s
-0001b560: 7572 662c 2050 6c61 6e65 293a 0a20 2020  urf, Plane):.   
-0001b570: 2020 2020 2072 6574 7572 6e20 506c 616e       return Plan
-0001b580: 6553 6572 6965 7328 7379 6d70 6966 7928  eSeries(sympify(
-0001b590: 736c 6963 655f 7375 7266 292c 202a 7261  slice_surf), *ra
-0001b5a0: 6e67 6573 2c20 2a2a 6b77 6172 6773 290a  nges, **kwargs).
-0001b5b0: 2020 2020 656c 6966 2069 7369 6e73 7461      elif isinsta
-0001b5c0: 6e63 6528 736c 6963 655f 7375 7266 2c20  nce(slice_surf, 
-0001b5d0: 4261 7365 5365 7269 6573 293a 0a20 2020  BaseSeries):.   
-0001b5e0: 2020 2020 2069 6620 736c 6963 655f 7375       if slice_su
-0001b5f0: 7266 2e69 735f 3344 7375 7266 6163 653a  rf.is_3Dsurface:
-0001b600: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0001b610: 7572 6e20 736c 6963 655f 7375 7266 0a20  urn slice_surf. 
-0001b620: 2020 2020 2020 2072 6169 7365 2054 7970         raise Typ
-0001b630: 6545 7272 6f72 2822 4f6e 6c79 2033 4420  eError("Only 3D 
-0001b640: 7375 7266 6163 652d 7265 6c61 7465 6420  surface-related 
-0001b650: 7365 7269 6573 2061 7265 2073 7570 706f  series are suppo
-0001b660: 7274 6564 2e22 290a 0a20 2020 2023 2049  rted.")..    # I
-0001b670: 6620 7468 6520 7665 6374 6f72 2066 6965  f the vector fie
-0001b680: 6c64 2069 7320 5628 782c 2079 2c20 7a29  ld is V(x, y, z)
-0001b690: 2c20 7468 6520 736c 6963 6520 6578 7072  , the slice expr
-0001b6a0: 6573 7369 6f6e 2063 616e 2062 6520 6628  ession can be f(
-0001b6b0: 782c 2079 290a 2020 2020 2320 6f72 2066  x, y).    # or f
-0001b6c0: 2879 2c20 7a29 206f 7220 6628 782c 207a  (y, z) or f(x, z
-0001b6d0: 292e 2045 7874 7261 6374 2074 6865 2063  ). Extract the c
-0001b6e0: 6f72 7265 6374 2072 616e 6765 732e 0a20  orrect ranges.. 
-0001b6f0: 2020 2066 7320 3d20 736c 6963 655f 7375     fs = slice_su
-0001b700: 7266 2e66 7265 655f 7379 6d62 6f6c 730a  rf.free_symbols.
-0001b710: 2020 2020 6e65 775f 7261 6e67 6573 203d      new_ranges =
-0001b720: 205b 7220 666f 7220 7220 696e 2072 616e   [r for r in ran
-0001b730: 6765 7320 6966 2072 5b30 5d20 696e 2066  ges if r[0] in f
-0001b740: 735d 0a20 2020 2023 2061 7070 6c79 2074  s].    # apply t
-0001b750: 6865 2063 6f72 7265 6374 2064 6973 6372  he correct discr
-0001b760: 6574 697a 6174 696f 6e20 6e75 6d62 6572  etization number
-0001b770: 0a20 2020 206e 203d 205b 0a20 2020 2020  .    n = [.     
-0001b780: 2020 2069 6e74 286b 7761 7267 732e 6765     int(kwargs.ge
-0001b790: 7428 226e 3122 2c20 5665 6374 6f72 3344  t("n1", Vector3D
-0001b7a0: 5365 7269 6573 2e5f 4e29 292c 0a20 2020  Series._N)),.   
-0001b7b0: 2020 2020 2069 6e74 286b 7761 7267 732e       int(kwargs.
-0001b7c0: 6765 7428 226e 3222 2c20 5665 6374 6f72  get("n2", Vector
-0001b7d0: 3344 5365 7269 6573 2e5f 4e29 292c 0a20  3DSeries._N)),. 
-0001b7e0: 2020 2020 2020 2069 6e74 286b 7761 7267         int(kwarg
-0001b7f0: 732e 6765 7428 226e 3322 2c20 5665 6374  s.get("n3", Vect
-0001b800: 6f72 3344 5365 7269 6573 2e5f 4e29 295d  or3DSeries._N))]
-0001b810: 0a20 2020 2064 6973 6372 5f73 796d 626f  .    discr_symbo
-0001b820: 6c73 203d 205b 725b 305d 2066 6f72 2072  ls = [r[0] for r
-0001b830: 2069 6e20 7261 6e67 6573 5d0a 2020 2020   in ranges].    
-0001b840: 6964 7820 3d20 5b64 6973 6372 5f73 796d  idx = [discr_sym
-0001b850: 626f 6c73 2e69 6e64 6578 2873 2920 666f  bols.index(s) fo
-0001b860: 7220 7320 696e 205b 725b 305d 2066 6f72  r s in [r[0] for
-0001b870: 2072 2069 6e20 6e65 775f 7261 6e67 6573   r in new_ranges
-0001b880: 5d5d 0a20 2020 206b 7761 7267 7332 203d  ]].    kwargs2 =
-0001b890: 206b 7761 7267 732e 636f 7079 2829 0a20   kwargs.copy(). 
-0001b8a0: 2020 206b 7761 7267 7332 5b22 6e31 225d     kwargs2["n1"]
-0001b8b0: 203d 206e 5b69 6478 5b30 5d5d 0a20 2020   = n[idx[0]].   
-0001b8c0: 206b 7761 7267 7332 5b22 6e32 225d 203d   kwargs2["n2"] =
-0001b8d0: 206e 5b69 6478 5b31 5d5d 0a0a 2020 2020   n[idx[1]]..    
-0001b8e0: 7265 7475 726e 2053 7572 6661 6365 4f76  return SurfaceOv
-0001b8f0: 6572 3244 5261 6e67 6553 6572 6965 7328  er2DRangeSeries(
-0001b900: 736c 6963 655f 7375 7266 2c20 2a6e 6577  slice_surf, *new
-0001b910: 5f72 616e 6765 732c 202a 2a6b 7761 7267  _ranges, **kwarg
-0001b920: 7332 290a 0a0a 636c 6173 7320 536c 6963  s2)...class Slic
-0001b930: 6556 6563 746f 7233 4453 6572 6965 7328  eVector3DSeries(
-0001b940: 5665 6374 6f72 3344 5365 7269 6573 293a  Vector3DSeries):
-0001b950: 0a20 2020 2022 2222 5265 7072 6573 656e  .    """Represen
-0001b960: 7473 2061 2033 4420 7665 6374 6f72 2066  ts a 3D vector f
-0001b970: 6965 6c64 2070 6c6f 7474 6564 206f 7665  ield plotted ove
-0001b980: 7220 6120 736c 6963 652e 2054 6865 2073  r a slice. The s
-0001b990: 6c69 6365 2063 616e 2062 650a 2020 2020  lice can be.    
-0001b9a0: 6120 506c 616e 6520 6f72 2061 2073 7572  a Plane or a sur
-0001b9b0: 6661 6365 2e0a 2020 2020 2222 220a 2020  face..    """.  
-0001b9c0: 2020 6973 5f73 6c69 6365 203d 2054 7275    is_slice = Tru
-0001b9d0: 650a 0a20 2020 2064 6566 205f 5f69 6e69  e..    def __ini
-0001b9e0: 745f 5f28 0a20 2020 2020 2020 2073 656c  t__(.        sel
-0001b9f0: 662c 2073 6c69 6365 5f73 7572 662c 2075  f, slice_surf, u
-0001ba00: 2c20 762c 2077 2c20 7261 6e67 655f 782c  , v, w, range_x,
-0001ba10: 2072 616e 6765 5f79 2c20 7261 6e67 655f   range_y, range_
-0001ba20: 7a2c 0a20 2020 2020 2020 206c 6162 656c  z,.        label
-0001ba30: 3d22 222c 202a 2a6b 7761 7267 730a 2020  ="", **kwargs.  
-0001ba40: 2020 293a 0a20 2020 2020 2020 2073 656c    ):.        sel
-0001ba50: 662e 736c 6963 655f 7375 7266 5f73 6572  f.slice_surf_ser
-0001ba60: 6965 7320 3d20 5f62 7569 6c64 5f73 6c69  ies = _build_sli
-0001ba70: 6365 5f73 6572 6965 7328 0a20 2020 2020  ce_series(.     
-0001ba80: 2020 2020 2020 2073 6c69 6365 5f73 7572         slice_sur
-0001ba90: 662c 205b 7261 6e67 655f 782c 2072 616e  f, [range_x, ran
-0001baa0: 6765 5f79 2c20 7261 6e67 655f 7a5d 2c20  ge_y, range_z], 
-0001bab0: 2a2a 6b77 6172 6773 290a 2020 2020 2020  **kwargs).      
-0001bac0: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-0001bad0: 5f5f 2875 2c20 762c 2077 2c20 7261 6e67  __(u, v, w, rang
-0001bae0: 655f 782c 2072 616e 6765 5f79 2c20 7261  e_x, range_y, ra
-0001baf0: 6e67 655f 7a2c 206c 6162 656c 2c20 2a2a  nge_z, label, **
-0001bb00: 6b77 6172 6773 290a 0a20 2020 2064 6566  kwargs)..    def
-0001bb10: 205f 6469 7363 7265 7469 7a65 2873 656c   _discretize(sel
-0001bb20: 6629 3a0a 2020 2020 2020 2020 6461 7461  f):.        data
-0001bb30: 203d 2073 656c 662e 736c 6963 655f 7375   = self.slice_su
-0001bb40: 7266 5f73 6572 6965 732e 6765 745f 6461  rf_series.get_da
-0001bb50: 7461 2829 0a20 2020 2020 2020 2069 6620  ta().        if 
-0001bb60: 6973 696e 7374 616e 6365 2873 656c 662e  isinstance(self.
-0001bb70: 736c 6963 655f 7375 7266 5f73 6572 6965  slice_surf_serie
-0001bb80: 732c 2050 6c61 6e65 5365 7269 6573 293a  s, PlaneSeries):
-0001bb90: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0001bba0: 7572 6e20 6461 7461 0a20 2020 2020 2020  urn data.       
-0001bbb0: 2069 6620 7365 6c66 2e73 6c69 6365 5f73   if self.slice_s
-0001bbc0: 7572 665f 7365 7269 6573 2e69 735f 7061  urf_series.is_pa
-0001bbd0: 7261 6d65 7472 6963 3a0a 2020 2020 2020  rametric:.      
-0001bbe0: 2020 2020 2020 7265 7475 726e 2064 6174        return dat
-0001bbf0: 615b 3a33 5d0a 0a20 2020 2020 2020 2023  a[:3]..        #
-0001bc00: 2073 796d 626f 6c73 2075 7365 6420 6279   symbols used by
-0001bc10: 2074 6869 7320 7665 6374 6f72 2773 2064   this vector's d
-0001bc20: 6973 6372 6574 697a 6174 696f 6e0a 2020  iscretization.  
-0001bc30: 2020 2020 2020 6469 7363 725f 7379 6d62        discr_symb
-0001bc40: 6f6c 7320 3d20 5b72 5b30 5d20 666f 7220  ols = [r[0] for 
-0001bc50: 7220 696e 2073 656c 662e 7261 6e67 6573  r in self.ranges
-0001bc60: 5d0a 2020 2020 2020 2020 2320 6f72 6465  ].        # orde
-0001bc70: 7265 6420 7379 6d62 6f6c 7320 6672 6f6d  red symbols from
-0001bc80: 2073 6c69 6365 5f73 7572 665f 7365 7269   slice_surf_seri
-0001bc90: 6573 0a20 2020 2020 2020 206f 7264 6572  es.        order
-0001bca0: 203d 2073 656c 662e 5f64 6973 6372 6574   = self._discret
-0001bcb0: 697a 655f 6865 6c70 6572 2864 6973 6372  ize_helper(discr
-0001bcc0: 5f73 796d 626f 6c73 290a 2020 2020 2020  _symbols).      
-0001bcd0: 2020 7265 7475 726e 205b 6461 7461 5b6b    return [data[k
-0001bce0: 5d20 666f 7220 6b20 696e 206f 7264 6572  ] for k in order
-0001bcf0: 5d0a 0a20 2020 2064 6566 205f 6469 7363  ]..    def _disc
-0001bd00: 7265 7469 7a65 5f68 656c 7065 7228 7365  retize_helper(se
-0001bd10: 6c66 2c20 7665 635f 6469 7363 725f 7379  lf, vec_discr_sy
-0001bd20: 6d62 6f6c 7329 3a0a 2020 2020 2020 2020  mbols):.        
-0001bd30: 2320 4e4f 5445 3a20 6c65 7427 7320 7361  # NOTE: let's sa
-0001bd40: 7920 7468 6520 7665 6374 6f72 2066 6965  y the vector fie
-0001bd50: 6c64 2069 7320 6469 7363 7265 7469 7a65  ld is discretize
-0001bd60: 6420 616c 6f6e 6720 782c 2079 2c20 7a20  d along x, y, z 
-0001bd70: 2869 6e0a 2020 2020 2020 2020 2320 7468  (in.        # th
-0001bd80: 6973 206f 7264 6572 292c 2061 6e64 2074  is order), and t
-0001bd90: 6865 2073 6c69 6365 2073 7572 6661 6365  he slice surface
-0001bda0: 2069 7320 6628 792c 207a 292e 2054 6865   is f(y, z). The
-0001bdb0: 6e2c 2064 6174 6120 7769 6c6c 2062 650a  n, data will be.
-0001bdc0: 2020 2020 2020 2020 2320 5b79 792c 207a          # [yy, z
-0001bdd0: 7a2c 2066 2879 792c 207a 7a29 5d2c 2077  z, f(yy, zz)], w
-0001bde0: 6869 6368 2068 6173 206e 6f74 2074 6865  hich has not the
-0001bdf0: 2063 6f72 7265 6374 206f 7264 6572 2065   correct order e
-0001be00: 7870 6563 7465 6420 6279 0a20 2020 2020  xpected by.     
-0001be10: 2020 2023 2074 6865 2076 6563 746f 7220     # the vector 
-0001be20: 6669 656c 6427 7320 6469 7363 7265 7469  field's discreti
-0001be30: 7a61 7469 6f6e 2e20 4865 7265 2077 6520  zation. Here we 
-0001be40: 6172 6520 676f 696e 6720 746f 2066 6978  are going to fix
-0001be50: 2074 6861 742e 0a0a 2020 2020 2020 2020   that...        
-0001be60: 6966 206e 6f74 2069 7369 6e73 7461 6e63  if not isinstanc
-0001be70: 6528 7365 6c66 2e73 6c69 6365 5f73 7572  e(self.slice_sur
-0001be80: 665f 7365 7269 6573 2c20 5375 7266 6163  f_series, Surfac
-0001be90: 654f 7665 7232 4452 616e 6765 5365 7269  eOver2DRangeSeri
-0001bea0: 6573 293a 0a20 2020 2020 2020 2020 2020  es):.           
-0001beb0: 2072 6169 7365 2054 7970 6545 7272 6f72   raise TypeError
-0001bec0: 2822 5468 6973 2068 656c 7065 7220 6675  ("This helper fu
-0001bed0: 6e63 7469 6f6e 2069 7320 6d65 616e 7420  nction is meant 
-0001bee0: 746f 2062 6520 7573 6564 206f 6e6c 7920  to be used only 
-0001bef0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-0001bf00: 2020 2277 6974 6820 6e6f 6e2d 7061 7261    "with non-para
-0001bf10: 6d65 7472 6963 2073 6c69 6369 6e67 2073  metric slicing s
-0001bf20: 7572 6661 6365 7320 6f66 2032 2076 6172  urfaces of 2 var
-0001bf30: 6961 626c 6573 2e20 220a 2020 2020 2020  iables. ".      
-0001bf40: 2020 2020 2020 2020 2020 2274 7970 6528            "type(
-0001bf50: 7365 6c66 2e73 6c69 6365 5f73 7572 665f  self.slice_surf_
-0001bf60: 7365 7269 6573 2920 3d20 7b7d 222e 666f  series) = {}".fo
-0001bf70: 726d 6174 280a 2020 2020 2020 2020 2020  rmat(.          
-0001bf80: 2020 2020 2020 2020 2020 7479 7065 2873            type(s
-0001bf90: 656c 662e 736c 6963 655f 7375 7266 5f73  elf.slice_surf_s
-0001bfa0: 6572 6965 7329 2929 0a0a 2020 2020 2020  eries)))..      
-0001bfb0: 2020 2320 736c 6963 6520 7375 7266 6163    # slice surfac
-0001bfc0: 6520 6672 6565 2073 796d 626f 6c73 0a20  e free symbols. 
-0001bfd0: 2020 2020 2020 2023 2064 6f6e 2774 2075         # don't u
-0001bfe0: 7365 2073 656c 662e 736c 6963 655f 7375  se self.slice_su
-0001bff0: 7266 5f73 6572 6965 732e 6672 6565 5f73  rf_series.free_s
-0001c000: 796d 626f 6c73 2061 7320 7468 6973 2065  ymbols as this e
-0001c010: 7870 7265 7373 696f 6e0a 2020 2020 2020  xpression.      
-0001c020: 2020 2320 6d69 6768 7420 6e6f 7420 7573    # might not us
-0001c030: 6520 626f 7468 2069 7473 2064 6973 6372  e both its discr
-0001c040: 6574 697a 6174 696f 6e20 7379 6d62 6f6c  etization symbol
-0001c050: 730a 2020 2020 2020 2020 7373 6673 203d  s.        ssfs =
-0001c060: 205b 725b 305d 2066 6f72 2072 2069 6e20   [r[0] for r in 
-0001c070: 7365 6c66 2e73 6c69 6365 5f73 7572 665f  self.slice_surf_
-0001c080: 7365 7269 6573 2e72 616e 6765 735d 0a20  series.ranges]. 
-0001c090: 2020 2020 2020 2023 2067 6976 656e 2066         # given f
-0001c0a0: 2879 2c20 7a29 2c20 7765 2061 6c72 6561  (y, z), we alrea
-0001c0b0: 6479 2068 6176 6520 792c 207a 2028 7373  dy have y, z (ss
-0001c0c0: 6673 292c 206e 6f77 2066 696e 6420 780a  fs), now find x.
-0001c0d0: 2020 2020 2020 2020 6d69 7373 696e 675f          missing_
-0001c0e0: 7379 6d62 6f6c 203d 206c 6973 7428 7365  symbol = list(se
-0001c0f0: 7428 7665 635f 6469 7363 725f 7379 6d62  t(vec_discr_symb
-0001c100: 6f6c 7329 2e64 6966 6665 7265 6e63 6528  ols).difference(
-0001c110: 7373 6673 2929 0a20 2020 2020 2020 2023  ssfs)).        #
-0001c120: 206f 7264 6572 6564 2073 796d 626f 6c73   ordered symbols
-0001c130: 2069 6e20 7468 6520 7265 7475 726e 6564   in the returned
-0001c140: 2064 6174 610a 2020 2020 2020 2020 7265   data.        re
-0001c150: 7475 726e 6564 5f73 796d 626f 6c73 203d  turned_symbols =
-0001c160: 2073 7366 7320 2b20 6d69 7373 696e 675f   ssfs + missing_
-0001c170: 7379 6d62 6f6c 0a20 2020 2020 2020 2023  symbol.        #
-0001c180: 206f 7574 7075 7420 6f72 6465 720a 2020   output order.  
-0001c190: 2020 2020 2020 6f72 6465 7220 3d20 5b72        order = [r
-0001c1a0: 6574 7572 6e65 645f 7379 6d62 6f6c 732e  eturned_symbols.
-0001c1b0: 696e 6465 7828 7329 2066 6f72 2073 2069  index(s) for s i
-0001c1c0: 6e20 7665 635f 6469 7363 725f 7379 6d62  n vec_discr_symb
-0001c1d0: 6f6c 735d 0a20 2020 2020 2020 2072 6574  ols].        ret
-0001c1e0: 7572 6e20 6f72 6465 720a 0a20 2020 2064  urn order..    d
-0001c1f0: 6566 205f 6372 6561 7465 5f64 6973 6372  ef _create_discr
-0001c200: 6574 697a 6564 5f64 6f6d 6169 6e28 7365  etized_domain(se
-0001c210: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-0001c220: 4469 7363 7265 7469 7a65 2074 6865 2072  Discretize the r
-0001c230: 616e 6765 7320 696e 2063 6173 6520 6f66  anges in case of
-0001c240: 2075 6e69 666f 726d 206d 6573 6869 6e67   uniform meshing
-0001c250: 2073 7472 6174 6567 792e 0a20 2020 2020   strategy..     
-0001c260: 2020 2022 2222 0a20 2020 2020 2020 2023     """.        #
-0001c270: 2054 4f44 4f3a 206f 6e63 6520 496e 7465   TODO: once Inte
-0001c280: 7261 6374 6976 6553 6572 6965 7320 6861  ractiveSeries ha
-0001c290: 7320 6265 656e 2072 656d 6f76 652c 2074  s been remove, t
-0001c2a0: 6865 2066 6f6c 6c6f 7769 6e67 2063 616e  he following can
-0001c2b0: 0a20 2020 2020 2020 2023 2062 6520 7265  .        # be re
-0001c2c0: 6f72 6761 6e69 7a65 6420 696e 206f 7264  organized in ord
-0001c2d0: 6572 2074 6f20 7265 6d6f 7665 2063 6f64  er to remove cod
-0001c2e0: 6520 7265 7065 7469 7469 6f6e 2c20 7370  e repetition, sp
-0001c2f0: 6563 6966 6963 616c 6c79 2074 6865 0a20  ecifically the. 
-0001c300: 2020 2020 2020 2023 2066 6f6c 6c6f 7769         # followi
-0001c310: 6e67 206c 696e 6520 6f66 2063 6f64 652e  ng line of code.
-0001c320: 0a20 2020 2020 2020 2023 2073 796d 626f  .        # symbo
-0001c330: 6c73 2075 7365 6420 6279 2074 6869 7320  ls used by this 
-0001c340: 7665 6374 6f72 2773 2064 6973 6372 6574  vector's discret
-0001c350: 697a 6174 696f 6e0a 2020 2020 2020 2020  ization.        
-0001c360: 6469 7363 725f 7379 6d62 6f6c 7320 3d20  discr_symbols = 
-0001c370: 5b72 5b30 5d20 666f 7220 7220 696e 2073  [r[0] for r in s
-0001c380: 656c 662e 7261 6e67 6573 5d0a 2020 2020  elf.ranges].    
-0001c390: 2020 2020 6469 7363 7265 7469 7a61 7469      discretizati
-0001c3a0: 6f6e 7320 3d20 7365 6c66 2e5f 6469 7363  ons = self._disc
-0001c3b0: 7265 7469 7a65 2829 0a20 2020 2020 2020  retize().       
-0001c3c0: 2073 656c 662e 5f64 6973 6372 6574 697a   self._discretiz
-0001c3d0: 6564 5f64 6f6d 6169 6e20 3d20 7b0a 2020  ed_domain = {.  
-0001c3e0: 2020 2020 2020 2020 2020 6b3a 2076 2066            k: v f
-0001c3f0: 6f72 206b 2c20 7620 696e 207a 6970 2864  or k, v in zip(d
-0001c400: 6973 6372 5f73 796d 626f 6c73 2c20 6469  iscr_symbols, di
-0001c410: 7363 7265 7469 7a61 7469 6f6e 7329 7d0a  scretizations)}.
-0001c420: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-0001c430: 2020 2064 6566 2070 6172 616d 7328 7365     def params(se
-0001c440: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-0001c450: 4765 7420 6f72 2073 6574 2074 6865 2063  Get or set the c
-0001c460: 7572 7265 6e74 2070 6172 616d 6574 6572  urrent parameter
-0001c470: 7320 6469 6374 696f 6e61 7279 2e0a 0a20  s dictionary... 
-0001c480: 2020 2020 2020 2050 6172 616d 6574 6572         Parameter
-0001c490: 730a 2020 2020 2020 2020 3d3d 3d3d 3d3d  s.        ======
-0001c4a0: 3d3d 3d3d 0a0a 2020 2020 2020 2020 7020  ====..        p 
-0001c4b0: 3a20 6469 6374 0a20 2020 2020 2020 2020  : dict.         
-0001c4c0: 2020 206b 6579 3a20 7379 6d62 6f6c 2061     key: symbol a
-0001c4d0: 7373 6f63 6961 7465 6420 746f 2074 6865  ssociated to the
-0001c4e0: 2070 6172 616d 6574 6572 0a20 2020 2020   parameter.     
-0001c4f0: 2020 2020 2020 2076 616c 3a20 7468 6520         val: the 
-0001c500: 7661 6c75 650a 2020 2020 2020 2020 2222  value.        ""
-0001c510: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-0001c520: 2073 656c 662e 5f70 6172 616d 730a 0a20   self._params.. 
-0001c530: 2020 2040 7061 7261 6d73 2e73 6574 7465     @params.sette
-0001c540: 720a 2020 2020 6465 6620 7061 7261 6d73  r.    def params
-0001c550: 2873 656c 662c 2070 293a 0a20 2020 2020  (self, p):.     
-0001c560: 2020 2073 656c 662e 5f70 6172 616d 7320     self._params 
-0001c570: 3d20 700a 2020 2020 2020 2020 6966 2073  = p.        if s
-0001c580: 656c 662e 736c 6963 655f 7375 7266 5f73  elf.slice_surf_s
-0001c590: 6572 6965 732e 6973 5f69 6e74 6572 6163  eries.is_interac
-0001c5a0: 7469 7665 3a0a 2020 2020 2020 2020 2020  tive:.          
-0001c5b0: 2020 2320 7570 6461 7465 2062 6f74 6820    # update both 
-0001c5c0: 7061 7261 6d65 7465 7273 2061 6e64 2064  parameters and d
-0001c5d0: 6973 6372 6574 697a 6174 696f 6e20 7261  iscretization ra
-0001c5e0: 6e67 6573 0a20 2020 2020 2020 2020 2020  nges.           
-0001c5f0: 2073 656c 662e 736c 6963 655f 7375 7266   self.slice_surf
-0001c600: 5f73 6572 6965 732e 7061 7261 6d73 203d  _series.params =
-0001c610: 2070 0a20 2020 2020 2020 2023 2073 796d   p.        # sym
-0001c620: 626f 6c73 2075 7365 6420 6279 2074 6869  bols used by thi
-0001c630: 7320 7665 6374 6f72 2773 2064 6973 6372  s vector's discr
-0001c640: 6574 697a 6174 696f 6e0a 2020 2020 2020  etization.      
-0001c650: 2020 6469 7363 725f 7379 6d62 6f6c 7320    discr_symbols 
-0001c660: 3d20 5b72 5b30 5d20 666f 7220 7220 696e  = [r[0] for r in
-0001c670: 2073 656c 662e 7261 6e67 6573 5d0a 0a20   self.ranges].. 
-0001c680: 2020 2020 2020 2069 6620 280a 2020 2020         if (.    
-0001c690: 2020 2020 2020 2020 6973 696e 7374 616e          isinstan
-0001c6a0: 6365 2873 656c 662e 736c 6963 655f 7375  ce(self.slice_su
-0001c6b0: 7266 5f73 6572 6965 732c 2053 7572 6661  rf_series, Surfa
-0001c6c0: 6365 4f76 6572 3244 5261 6e67 6553 6572  ceOver2DRangeSer
-0001c6d0: 6965 7329 2061 6e64 0a20 2020 2020 2020  ies) and.       
-0001c6e0: 2020 2020 2028 6e6f 7420 7365 6c66 2e73       (not self.s
-0001c6f0: 6c69 6365 5f73 7572 665f 7365 7269 6573  lice_surf_series
-0001c700: 2e69 735f 7061 7261 6d65 7472 6963 290a  .is_parametric).
-0001c710: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
-0001c720: 2020 2020 2020 2023 206f 7264 6572 6564         # ordered
-0001c730: 2073 796d 626f 6c73 2066 726f 6d20 736c   symbols from sl
-0001c740: 6963 655f 7375 7266 5f73 6572 6965 730a  ice_surf_series.
-0001c750: 2020 2020 2020 2020 2020 2020 6f72 6465              orde
-0001c760: 7265 645f 7379 6d62 6f6c 7320 3d20 7365  red_symbols = se
-0001c770: 6c66 2e5f 6469 7363 7265 7469 7a65 5f68  lf._discretize_h
-0001c780: 656c 7065 7228 6469 7363 725f 7379 6d62  elper(discr_symb
-0001c790: 6f6c 7329 0a20 2020 2020 2020 2020 2020  ols).           
-0001c7a0: 2064 6174 6120 3d20 7365 6c66 2e73 6c69   data = self.sli
-0001c7b0: 6365 5f73 7572 665f 7365 7269 6573 2e67  ce_surf_series.g
-0001c7c0: 6574 5f64 6174 6128 290a 2020 2020 2020  et_data().      
-0001c7d0: 2020 2020 2020 7365 6c66 2e5f 6469 7363        self._disc
-0001c7e0: 7265 7469 7a65 645f 646f 6d61 696e 203d  retized_domain =
-0001c7f0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-0001c800: 2020 206b 3a20 6461 7461 5b76 5d20 666f     k: data[v] fo
-0001c810: 7220 6b2c 2076 2069 6e20 7a69 7028 6469  r k, v in zip(di
-0001c820: 7363 725f 7379 6d62 6f6c 732c 206f 7264  scr_symbols, ord
-0001c830: 6572 6564 5f73 796d 626f 6c73 290a 2020  ered_symbols).  
-0001c840: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-0001c850: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0001c860: 2020 2020 2020 7365 6c66 2e5f 6469 7363        self._disc
-0001c870: 7265 7469 7a65 645f 646f 6d61 696e 203d  retized_domain =
-0001c880: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-0001c890: 2020 206b 3a20 7620 666f 7220 6b2c 2076     k: v for k, v
-0001c8a0: 2069 6e20 7a69 7028 0a20 2020 2020 2020   in zip(.       
-0001c8b0: 2020 2020 2020 2020 2020 2020 2064 6973               dis
-0001c8c0: 6372 5f73 796d 626f 6c73 2c0a 2020 2020  cr_symbols,.    
-0001c8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c8e0: 7365 6c66 2e73 6c69 6365 5f73 7572 665f  self.slice_surf_
-0001c8f0: 7365 7269 6573 2e67 6574 5f64 6174 6128  series.get_data(
-0001c900: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0001c910: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-0001c920: 7d0a 0a20 2020 2064 6566 205f 5f73 7472  }..    def __str
-0001c930: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
-0001c940: 2020 7265 7475 726e 2022 736c 6963 6564    return "sliced
-0001c950: 2022 202b 2073 7570 6572 2829 2e5f 5f73   " + super().__s
-0001c960: 7472 5f5f 2829 202b 2022 2061 7420 7b7d  tr__() + " at {}
-0001c970: 222e 666f 726d 6174 280a 2020 2020 2020  ".format(.      
-0001c980: 2020 2020 2020 7365 6c66 2e73 6c69 6365        self.slice
-0001c990: 5f73 7572 665f 7365 7269 6573 290a 0a0a  _surf_series)...
-0001c9a0: 636c 6173 7320 506c 616e 6553 6572 6965  class PlaneSerie
-0001c9b0: 7328 5375 7266 6163 6542 6173 6553 6572  s(SurfaceBaseSer
-0001c9c0: 6965 7329 3a0a 2020 2020 2222 2252 6570  ies):.    """Rep
-0001c9d0: 7265 7365 6e74 7320 6120 706c 616e 6520  resents a plane 
-0001c9e0: 696e 2061 2033 4420 646f 6d61 696e 2e22  in a 3D domain."
-0001c9f0: 2222 0a0a 2020 2020 6973 5f33 4473 7572  ""..    is_3Dsur
-0001ca00: 6661 6365 203d 2054 7275 650a 2020 2020  face = True.    
-0001ca10: 5f4e 203d 2032 300a 0a20 2020 2023 2061  _N = 20..    # a
-0001ca20: 2067 656e 6572 6963 2070 6c61 6e65 2028   generic plane (
-0001ca30: 666f 7220 6578 616d 706c 6520 7769 7468  for example with
-0001ca40: 206e 6f72 6d61 6c20 2831 2c31 2c31 2929   normal (1,1,1))
-0001ca50: 2063 616e 2067 656e 6572 6174 6520 6120   can generate a 
-0001ca60: 6875 6765 0a20 2020 2023 2072 616e 6765  huge.    # range
-0001ca70: 2061 6c6f 6e67 2074 6865 207a 2d64 6972   along the z-dir
-0001ca80: 6563 7469 6f6e 2e20 5769 7468 205f 7573  ection. With _us
-0001ca90: 655f 6e61 6e3d 5472 7565 2c20 6576 6572  e_nan=True, ever
-0001caa0: 7920 7a2d 7661 6c75 6520 6f75 7473 6964  y z-value outsid
-0001cab0: 650a 2020 2020 2320 6f66 2074 6865 2070  e.    # of the p
-0001cac0: 726f 7669 6465 6420 7a5f 7261 6e67 6520  rovided z_range 
-0001cad0: 7769 6c6c 2062 6520 7365 7420 746f 204e  will be set to N
-0001cae0: 616e 2e0a 2020 2020 5f75 7365 5f6e 616e  an..    _use_nan
-0001caf0: 203d 2054 7275 650a 0a20 2020 2064 6566   = True..    def
-0001cb00: 205f 5f69 6e69 745f 5f28 0a20 2020 2020   __init__(.     
-0001cb10: 2020 2073 656c 662c 2070 6c61 6e65 2c20     self, plane, 
-0001cb20: 785f 7261 6e67 652c 2079 5f72 616e 6765  x_range, y_range
-0001cb30: 2c20 7a5f 7261 6e67 653d 4e6f 6e65 2c20  , z_range=None, 
-0001cb40: 6c61 6265 6c3d 2222 2c20 2a2a 6b77 6172  label="", **kwar
-0001cb50: 6773 0a20 2020 2029 3a0a 2020 2020 2020  gs.    ):.      
-0001cb60: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-0001cb70: 5f5f 282a 2a6b 7761 7267 7329 0a20 2020  __(**kwargs).   
-0001cb80: 2020 2020 2073 656c 662e 5f62 6c6f 636b       self._block
-0001cb90: 5f6c 616d 6264 615f 6675 6e63 7469 6f6e  _lambda_function
-0001cba0: 7328 706c 616e 6529 0a20 2020 2020 2020  s(plane).       
-0001cbb0: 2073 656c 662e 706c 616e 6520 3d20 7379   self.plane = sy
-0001cbc0: 6d70 6966 7928 706c 616e 6529 0a20 2020  mpify(plane).   
-0001cbd0: 2020 2020 2073 656c 662e 6578 7072 203d       self.expr =
-0001cbe0: 2073 656c 662e 706c 616e 650a 2020 2020   self.plane.    
-0001cbf0: 2020 2020 6966 206e 6f74 2069 7369 6e73      if not isins
-0001cc00: 7461 6e63 6528 7365 6c66 2e70 6c61 6e65  tance(self.plane
-0001cc10: 2c20 506c 616e 6529 3a0a 2020 2020 2020  , Plane):.      
-0001cc20: 2020 2020 2020 7261 6973 6520 5479 7065        raise Type
-0001cc30: 4572 726f 7228 0a20 2020 2020 2020 2020  Error(.         
-0001cc40: 2020 2020 2020 2022 6070 6c61 6e65 6020         "`plane` 
-0001cc50: 6d75 7374 2062 6520 616e 2069 6e73 7461  must be an insta
-0001cc60: 6e63 6520 6f66 2073 796d 7079 2e67 656f  nce of sympy.geo
-0001cc70: 6d65 7472 792e 506c 616e 6522 290a 2020  metry.Plane").  
-0001cc80: 2020 2020 2020 7365 6c66 2e78 5f72 616e        self.x_ran
-0001cc90: 6765 203d 2073 796d 7069 6679 2878 5f72  ge = sympify(x_r
-0001cca0: 616e 6765 290a 2020 2020 2020 2020 7365  ange).        se
-0001ccb0: 6c66 2e79 5f72 616e 6765 203d 2073 796d  lf.y_range = sym
-0001ccc0: 7069 6679 2879 5f72 616e 6765 290a 2020  pify(y_range).  
-0001ccd0: 2020 2020 2020 7365 6c66 2e7a 5f72 616e        self.z_ran
-0001cce0: 6765 203d 2073 796d 7069 6679 287a 5f72  ge = sympify(z_r
-0001ccf0: 616e 6765 290a 2020 2020 2020 2020 7365  ange).        se
-0001cd00: 6c66 2e72 616e 6765 7320 3d20 5b73 656c  lf.ranges = [sel
-0001cd10: 662e 785f 7261 6e67 652c 2073 656c 662e  f.x_range, self.
-0001cd20: 795f 7261 6e67 652c 2073 656c 662e 7a5f  y_range, self.z_
-0001cd30: 7261 6e67 655d 0a20 2020 2020 2020 2073  range].        s
-0001cd40: 656c 662e 5f73 6574 5f73 7572 6661 6365  elf._set_surface
-0001cd50: 5f6c 6162 656c 286c 6162 656c 290a 2020  _label(label).  
-0001cd60: 2020 2020 2020 6966 2073 656c 662e 7061        if self.pa
-0001cd70: 7261 6d73 2061 6e64 206e 6f74 2073 656c  rams and not sel
-0001cd80: 662e 706c 616e 652e 6672 6565 5f73 796d  f.plane.free_sym
-0001cd90: 626f 6c73 3a0a 2020 2020 2020 2020 2020  bols:.          
-0001cda0: 2020 7365 6c66 2e70 6172 616d 7320 3d20    self.params = 
-0001cdb0: 6469 6374 2829 0a20 2020 2020 2020 2020  dict().         
-0001cdc0: 2020 2073 656c 662e 6973 5f69 6e74 6572     self.is_inter
-0001cdd0: 6163 7469 7665 203d 2046 616c 7365 0a0a  active = False..
-0001cde0: 2020 2020 6465 6620 5f5f 7374 725f 5f28      def __str__(
-0001cdf0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-0001ce00: 6574 7572 6e20 7365 6c66 2e5f 7374 725f  eturn self._str_
-0001ce10: 6865 6c70 6572 280a 2020 2020 2020 2020  helper(.        
-0001ce20: 2020 2020 2270 6c61 6e65 2073 6572 6965      "plane serie
-0001ce30: 733a 2025 7320 6f76 6572 2025 732c 2025  s: %s over %s, %
-0001ce40: 732c 2025 7322 2025 2028 0a20 2020 2020  s, %s" % (.     
-0001ce50: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001ce60: 706c 616e 652c 2073 656c 662e 785f 7261  plane, self.x_ra
-0001ce70: 6e67 652c 2073 656c 662e 795f 7261 6e67  nge, self.y_rang
-0001ce80: 652c 2073 656c 662e 7a5f 7261 6e67 6529  e, self.z_range)
-0001ce90: 290a 0a20 2020 2064 6566 2067 6574 5f64  )..    def get_d
-0001cea0: 6174 6128 7365 6c66 293a 0a20 2020 2020  ata(self):.     
-0001ceb0: 2020 206e 7020 3d20 696d 706f 7274 5f6d     np = import_m
-0001cec0: 6f64 756c 6528 276e 756d 7079 2729 0a0a  odule('numpy')..
-0001ced0: 2020 2020 2020 2020 782c 2079 2c20 7a20          x, y, z 
-0001cee0: 3d20 7379 6d62 6f6c 7328 2278 2c20 792c  = symbols("x, y,
-0001cef0: 207a 2229 0a20 2020 2020 2020 2070 6c61   z").        pla
-0001cf00: 6e65 203d 2073 656c 662e 706c 616e 652e  ne = self.plane.
-0001cf10: 7375 6273 2873 656c 662e 5f70 6172 616d  subs(self._param
-0001cf20: 7329 0a20 2020 2020 2020 2066 7320 3d20  s).        fs = 
-0001cf30: 706c 616e 652e 6571 7561 7469 6f6e 2878  plane.equation(x
-0001cf40: 2c20 792c 207a 292e 6672 6565 5f73 796d  , y, z).free_sym
-0001cf50: 626f 6c73 0a20 2020 2020 2020 2078 782c  bols.        xx,
-0001cf60: 2079 792c 207a 7a20 3d20 4e6f 6e65 2c20   yy, zz = None, 
-0001cf70: 4e6f 6e65 2c20 4e6f 6e65 0a20 2020 2020  None, None.     
-0001cf80: 2020 2069 6620 6673 203d 3d20 7365 7428     if fs == set(
-0001cf90: 5b78 5d29 3a0a 2020 2020 2020 2020 2020  [x]):.          
-0001cfa0: 2020 2320 7061 7261 6c6c 656c 2074 6f20    # parallel to 
-0001cfb0: 797a 2070 6c61 6e65 2028 6e6f 726d 616c  yz plane (normal
-0001cfc0: 2076 6563 746f 7220 2831 2c20 302c 2030   vector (1, 0, 0
-0001cfd0: 2929 0a20 2020 2020 2020 2020 2020 2073  )).            s
-0001cfe0: 203d 2053 7572 6661 6365 4f76 6572 3244   = SurfaceOver2D
-0001cff0: 5261 6e67 6553 6572 6965 7328 0a20 2020  RangeSeries(.   
-0001d000: 2020 2020 2020 2020 2020 2020 2070 6c61               pla
-0001d010: 6e65 2e70 315b 305d 2c0a 2020 2020 2020  ne.p1[0],.      
-0001d020: 2020 2020 2020 2020 2020 2878 2c20 2a73            (x, *s
-0001d030: 656c 662e 7a5f 7261 6e67 655b 313a 5d29  elf.z_range[1:])
-0001d040: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001d050: 2020 2879 2c20 2a73 656c 662e 795f 7261    (y, *self.y_ra
-0001d060: 6e67 655b 313a 5d29 2c0a 2020 2020 2020  nge[1:]),.      
-0001d070: 2020 2020 2020 2020 2020 2222 2c0a 2020            "",.  
-0001d080: 2020 2020 2020 2020 2020 2020 2020 6e31                n1
-0001d090: 3d73 656c 662e 6e5b 325d 2c0a 2020 2020  =self.n[2],.    
-0001d0a0: 2020 2020 2020 2020 2020 2020 6e32 3d73              n2=s
-0001d0b0: 656c 662e 6e5b 315d 2c0a 2020 2020 2020  elf.n[1],.      
-0001d0c0: 2020 2020 2020 2020 2020 7873 6361 6c65            xscale
-0001d0d0: 3d73 656c 662e 5f73 6361 6c65 735b 305d  =self._scales[0]
-0001d0e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001d0f0: 2020 7973 6361 6c65 3d73 656c 662e 5f73    yscale=self._s
-0001d100: 6361 6c65 735b 315d 0a20 2020 2020 2020  cales[1].       
-0001d110: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-0001d120: 2020 2078 782c 2079 792c 207a 7a20 3d20     xx, yy, zz = 
-0001d130: 732e 6765 745f 6461 7461 2829 0a20 2020  s.get_data().   
-0001d140: 2020 2020 2020 2020 2078 782c 2079 792c           xx, yy,
-0001d150: 207a 7a20 3d20 7a7a 2c20 7979 2c20 7878   zz = zz, yy, xx
-0001d160: 0a20 2020 2020 2020 2065 6c69 6620 6673  .        elif fs
-0001d170: 203d 3d20 7365 7428 5b79 5d29 3a0a 2020   == set([y]):.  
-0001d180: 2020 2020 2020 2020 2020 2320 7061 7261            # para
-0001d190: 6c6c 656c 2074 6f20 787a 2070 6c61 6e65  llel to xz plane
-0001d1a0: 2028 6e6f 726d 616c 2076 6563 746f 7220   (normal vector 
-0001d1b0: 2830 2c20 312c 2030 2929 0a20 2020 2020  (0, 1, 0)).     
-0001d1c0: 2020 2020 2020 2073 203d 2053 7572 6661         s = Surfa
-0001d1d0: 6365 4f76 6572 3244 5261 6e67 6553 6572  ceOver2DRangeSer
-0001d1e0: 6965 7328 0a20 2020 2020 2020 2020 2020  ies(.           
-0001d1f0: 2020 2020 2070 6c61 6e65 2e70 315b 315d       plane.p1[1]
-0001d200: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001d210: 2020 2878 2c20 2a73 656c 662e 785f 7261    (x, *self.x_ra
-0001d220: 6e67 655b 313a 5d29 2c0a 2020 2020 2020  nge[1:]),.      
-0001d230: 2020 2020 2020 2020 2020 2879 2c20 2a73            (y, *s
-0001d240: 656c 662e 7a5f 7261 6e67 655b 313a 5d29  elf.z_range[1:])
-0001d250: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001d260: 2020 2222 2c0a 2020 2020 2020 2020 2020    "",.          
-0001d270: 2020 2020 2020 6e31 3d73 656c 662e 6e5b        n1=self.n[
-0001d280: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
-0001d290: 2020 2020 6e32 3d73 656c 662e 6e5b 325d      n2=self.n[2]
-0001d2a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001d2b0: 2020 7873 6361 6c65 3d73 656c 662e 5f73    xscale=self._s
-0001d2c0: 6361 6c65 735b 305d 2c0a 2020 2020 2020  cales[0],.      
-0001d2d0: 2020 2020 2020 2020 2020 7973 6361 6c65            yscale
-0001d2e0: 3d73 656c 662e 5f73 6361 6c65 735b 315d  =self._scales[1]
-0001d2f0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
-0001d300: 2020 2020 2020 2020 2020 2078 782c 2079             xx, y
-0001d310: 792c 207a 7a20 3d20 732e 6765 745f 6461  y, zz = s.get_da
-0001d320: 7461 2829 0a20 2020 2020 2020 2020 2020  ta().           
-0001d330: 2078 782c 2079 792c 207a 7a20 3d20 7878   xx, yy, zz = xx
-0001d340: 2c20 7a7a 2c20 7979 0a20 2020 2020 2020  , zz, yy.       
-0001d350: 2065 6c69 6620 6673 203d 3d20 7365 7428   elif fs == set(
-0001d360: 5b78 2c20 795d 293a 0a20 2020 2020 2020  [x, y]):.       
-0001d370: 2020 2020 2023 2076 6572 7469 6361 6c20       # vertical 
-0001d380: 706c 616e 6520 6f72 6965 6e74 6564 2077  plane oriented w
-0001d390: 6974 6820 736f 6d65 2061 6e67 6c65 0a0a  ith some angle..
-0001d3a0: 2020 2020 2020 2020 2020 2020 2320 4765              # Ge
-0001d3b0: 7420 6e75 6d70 7920 7665 6374 6f72 730a  t numpy vectors.
-0001d3c0: 2020 2020 2020 2020 2020 2020 7031 203d              p1 =
-0001d3d0: 206e 702e 6172 7261 7928 706c 616e 652e   np.array(plane.
-0001d3e0: 7031 2c20 6474 7970 653d 666c 6f61 7429  p1, dtype=float)
-0001d3f0: 0a20 2020 2020 2020 2020 2020 206e 7620  .            nv 
-0001d400: 3d20 6e70 2e61 7272 6179 2870 6c61 6e65  = np.array(plane
-0001d410: 2e6e 6f72 6d61 6c5f 7665 6374 6f72 2c20  .normal_vector, 
-0001d420: 6474 7970 653d 666c 6f61 7429 0a20 2020  dtype=float).   
-0001d430: 2020 2020 2020 2020 2023 2063 6f6e 7665           # conve
-0001d440: 7274 2074 6865 206e 6f72 6d61 6c20 7665  rt the normal ve
-0001d450: 6374 6f72 2074 6f20 756e 6974 206e 6f72  ctor to unit nor
-0001d460: 6d61 6c20 7665 6374 6f72 0a20 2020 2020  mal vector.     
-0001d470: 2020 2020 2020 206e 7620 3d20 6e76 202f         nv = nv /
-0001d480: 206e 702e 7371 7274 286e 762e 5420 4020   np.sqrt(nv.T @ 
-0001d490: 6e76 290a 0a20 2020 2020 2020 2020 2020  nv)..           
-0001d4a0: 2023 2070 6c61 6e65 2068 6173 2064 6973   # plane has dis
-0001d4b0: 7461 6e63 6520 746f 206f 7269 6769 6e20  tance to origin 
-0001d4c0: 6173 206c 656e 6774 6820 6f66 2070 726f  as length of pro
-0001d4d0: 6a65 6374 696f 6e20 6f66 0a20 2020 2020  jection of.     
-0001d4e0: 2020 2020 2020 2023 2070 3120 6f6e 746f         # p1 onto
-0001d4f0: 206e 6f72 6d61 6c20 7665 6374 6f72 0a20   normal vector. 
-0001d500: 2020 2020 2020 2020 2020 2070 726f 6a5f             proj_
-0001d510: 7032 6e76 203d 206e 762e 646f 7428 7031  p2nv = nv.dot(p1
-0001d520: 290a 0a20 2020 2020 2020 2020 2020 2073  )..            s
-0001d530: 203d 2053 7572 6661 6365 4f76 6572 3244   = SurfaceOver2D
-0001d540: 5261 6e67 6553 6572 6965 7328 0a20 2020  RangeSeries(.   
-0001d550: 2020 2020 2020 2020 2020 2020 2070 726f               pro
-0001d560: 6a5f 7032 6e76 2c0a 2020 2020 2020 2020  j_p2nv,.        
-0001d570: 2020 2020 2020 2020 2878 2c20 2a73 656c          (x, *sel
-0001d580: 662e 785f 7261 6e67 655b 313a 5d29 2c0a  f.x_range[1:]),.
-0001d590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d5a0: 2879 2c20 2a73 656c 662e 7a5f 7261 6e67  (y, *self.z_rang
-0001d5b0: 655b 313a 5d29 2c0a 2020 2020 2020 2020  e[1:]),.        
-0001d5c0: 2020 2020 2020 2020 2222 2c0a 2020 2020          "",.    
-0001d5d0: 2020 2020 2020 2020 2020 2020 6e31 3d73              n1=s
-0001d5e0: 656c 662e 6e5b 305d 2c0a 2020 2020 2020  elf.n[0],.      
-0001d5f0: 2020 2020 2020 2020 2020 6e32 3d73 656c            n2=sel
-0001d600: 662e 6e5b 325d 2c0a 2020 2020 2020 2020  f.n[2],.        
-0001d610: 2020 2020 2020 2020 7873 6361 6c65 3d73          xscale=s
-0001d620: 656c 662e 5f73 6361 6c65 735b 305d 2c0a  elf._scales[0],.
-0001d630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d640: 7973 6361 6c65 3d73 656c 662e 5f73 6361  yscale=self._sca
-0001d650: 6c65 735b 315d 0a20 2020 2020 2020 2020  les[1].         
-0001d660: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-0001d670: 2078 782c 2079 792c 207a 7a20 3d20 732e   xx, yy, zz = s.
-0001d680: 6765 745f 6461 7461 2829 0a20 2020 2020  get_data().     
-0001d690: 2020 2020 2020 2078 782c 2079 792c 207a         xx, yy, z
-0001d6a0: 7a20 3d20 7878 2c20 7a7a 2c20 7979 0a0a  z = xx, zz, yy..
-0001d6b0: 2020 2020 2020 2020 2020 2020 2320 726f              # ro
-0001d6c0: 7461 7465 2070 6c61 6e65 2063 6f72 7265  tate plane corre
-0001d6d0: 7370 6f6e 6469 6e67 2074 6f20 7468 6520  sponding to the 
-0001d6e0: 6e6f 726d 616c 2076 6563 746f 720a 2020  normal vector.  
-0001d6f0: 2020 2020 2020 2020 2020 6465 6620 5228            def R(
-0001d700: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
-0001d710: 2020 2020 7265 7475 726e 206e 702e 6172      return np.ar
-0001d720: 7261 7928 5b0a 2020 2020 2020 2020 2020  ray([.          
-0001d730: 2020 2020 2020 2020 2020 5b6e 702e 636f            [np.co
-0001d740: 7328 7429 2c20 2d6e 702e 7369 6e28 7429  s(t), -np.sin(t)
-0001d750: 2c20 305d 2c0a 2020 2020 2020 2020 2020  , 0],.          
-0001d760: 2020 2020 2020 2020 2020 5b6e 702e 7369            [np.si
-0001d770: 6e28 7429 2c20 6e70 2e63 6f73 2874 292c  n(t), np.cos(t),
-0001d780: 2030 5d2c 0a20 2020 2020 2020 2020 2020   0],.           
-0001d790: 2020 2020 2020 2020 205b 302c 2030 2c20           [0, 0, 
-0001d7a0: 315d 0a20 2020 2020 2020 2020 2020 2020  1].             
-0001d7b0: 2020 205d 290a 0a20 2020 2020 2020 2020     ])..         
-0001d7c0: 2020 2074 6865 7461 203d 206e 702e 6172     theta = np.ar
-0001d7d0: 6374 616e 3228 6e76 5b31 5d2c 206e 765b  ctan2(nv[1], nv[
-0001d7e0: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
-0001d7f0: 636f 6f72 6473 203d 206e 702e 7374 6163  coords = np.stac
-0001d800: 6b28 5b74 2e66 6c61 7474 656e 2829 2066  k([t.flatten() f
-0001d810: 6f72 2074 2069 6e20 5b78 782c 2079 792c  or t in [xx, yy,
-0001d820: 206e 702e 6f6e 6573 5f6c 696b 6528 7878   np.ones_like(xx
-0001d830: 295d 5d29 2e54 0a20 2020 2020 2020 2020  )]]).T.         
-0001d840: 2020 2063 6f6f 7264 7320 3d20 6e70 2e6d     coords = np.m
-0001d850: 6174 6d75 6c28 636f 6f72 6473 2c20 5228  atmul(coords, R(
-0001d860: 7468 6574 6129 290a 2020 2020 2020 2020  theta)).        
-0001d870: 2020 2020 7979 2c20 7878 203d 2063 6f6f      yy, xx = coo
-0001d880: 7264 735b 3a2c 2030 5d2e 7265 7368 6170  rds[:, 0].reshap
-0001d890: 6528 7979 2e73 6861 7065 292c 2063 6f6f  e(yy.shape), coo
-0001d8a0: 7264 735b 3a2c 2031 5d2e 7265 7368 6170  rds[:, 1].reshap
-0001d8b0: 6528 7878 2e73 6861 7065 290a 2020 2020  e(xx.shape).    
-0001d8c0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0001d8d0: 2020 2020 2020 2320 616e 7920 6f74 6865        # any othe
-0001d8e0: 7220 706c 616e 650a 2020 2020 2020 2020  r plane.        
-0001d8f0: 2020 2020 6571 203d 2070 6c61 6e65 2e65      eq = plane.e
-0001d900: 7175 6174 696f 6e28 782c 2079 2c20 7a29  quation(x, y, z)
-0001d910: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0001d920: 7a20 696e 2065 712e 6672 6565 5f73 796d  z in eq.free_sym
-0001d930: 626f 6c73 3a0a 2020 2020 2020 2020 2020  bols:.          
-0001d940: 2020 2020 2020 6571 203d 2073 6f6c 7665        eq = solve
-0001d950: 2865 712c 207a 295b 305d 0a20 2020 2020  (eq, z)[0].     
-0001d960: 2020 2020 2020 2073 203d 2053 7572 6661         s = Surfa
-0001d970: 6365 4f76 6572 3244 5261 6e67 6553 6572  ceOver2DRangeSer
-0001d980: 6965 7328 0a20 2020 2020 2020 2020 2020  ies(.           
-0001d990: 2020 2020 2065 712c 0a20 2020 2020 2020       eq,.       
-0001d9a0: 2020 2020 2020 2020 2028 782c 202a 7365           (x, *se
-0001d9b0: 6c66 2e78 5f72 616e 6765 5b31 3a5d 292c  lf.x_range[1:]),
-0001d9c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001d9d0: 2028 792c 202a 7365 6c66 2e79 5f72 616e   (y, *self.y_ran
-0001d9e0: 6765 5b31 3a5d 292c 0a20 2020 2020 2020  ge[1:]),.       
-0001d9f0: 2020 2020 2020 2020 2022 222c 0a20 2020           "",.   
-0001da00: 2020 2020 2020 2020 2020 2020 206e 313d               n1=
-0001da10: 7365 6c66 2e6e 5b30 5d2c 0a20 2020 2020  self.n[0],.     
-0001da20: 2020 2020 2020 2020 2020 206e 323d 7365             n2=se
-0001da30: 6c66 2e6e 5b31 5d2c 0a20 2020 2020 2020  lf.n[1],.       
-0001da40: 2020 2020 2020 2020 2078 7363 616c 653d           xscale=
-0001da50: 7365 6c66 2e5f 7363 616c 6573 5b30 5d2c  self._scales[0],
-0001da60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001da70: 2079 7363 616c 653d 7365 6c66 2e5f 7363   yscale=self._sc
-0001da80: 616c 6573 5b31 5d0a 2020 2020 2020 2020  ales[1].        
-0001da90: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
-0001daa0: 2020 7878 2c20 7979 2c20 7a7a 203d 2073    xx, yy, zz = s
-0001dab0: 2e67 6574 5f64 6174 6128 290a 2020 2020  .get_data().    
-0001dac0: 2020 2020 2020 2020 6966 2028 6c65 6e28          if (len(
-0001dad0: 6673 2920 3e20 3129 2061 6e64 2073 656c  fs) > 1) and sel
-0001dae0: 662e 5f75 7365 5f6e 616e 3a0a 2020 2020  f._use_nan:.    
-0001daf0: 2020 2020 2020 2020 2020 2020 6964 7820              idx 
-0001db00: 3d20 6e70 2e6c 6f67 6963 616c 5f6f 7228  = np.logical_or(
-0001db10: 7a7a 203c 2073 656c 662e 7a5f 7261 6e67  zz < self.z_rang
-0001db20: 655b 315d 2c20 7a7a 203e 2073 656c 662e  e[1], zz > self.
-0001db30: 7a5f 7261 6e67 655b 325d 290a 2020 2020  z_range[2]).    
-0001db40: 2020 2020 2020 2020 2020 2020 7a7a 5b69              zz[i
-0001db50: 6478 5d20 3d20 6e70 2e6e 616e 0a20 2020  dx] = np.nan.   
-0001db60: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001db70: 2e5f 6170 706c 795f 7472 616e 7366 6f72  ._apply_transfor
-0001db80: 6d28 7878 2c20 7979 2c20 7a7a 290a 0a0a  m(xx, yy, zz)...
-0001db90: 636c 6173 7320 4765 6f6d 6574 7279 5365  class GeometrySe
-0001dba0: 7269 6573 284c 696e 6532 4442 6173 6553  ries(Line2DBaseS
-0001dbb0: 6572 6965 7329 3a0a 2020 2020 2222 2252  eries):.    """R
-0001dbc0: 6570 7265 7365 6e74 7320 616e 2065 6e74  epresents an ent
-0001dbd0: 6974 7920 6672 6f6d 2074 6865 2073 796d  ity from the sym
-0001dbe0: 7079 2e67 656f 6d65 7472 7920 6d6f 6475  py.geometry modu
-0001dbf0: 6c65 2e0a 2020 2020 4465 7065 6e64 696e  le..    Dependin
-0001dc00: 6720 6f6e 2074 6865 2067 656f 6d65 7472  g on the geometr
-0001dc10: 7920 656e 7469 7479 2c20 7468 6973 2063  y entity, this c
-0001dc20: 6c61 7373 2063 616e 2065 6974 6865 7220  lass can either 
-0001dc30: 7265 7072 6573 656e 7473 2061 0a20 2020  represents a.   
-0001dc40: 2070 6f69 6e74 2c20 6120 6c69 6e65 2c20   point, a line, 
-0001dc50: 6f72 2061 2070 6172 616d 6574 7269 6320  or a parametric 
-0001dc60: 6c69 6e65 0a20 2020 2022 2222 0a0a 2020  line.    """..  
-0001dc70: 2020 6973 5f67 656f 6d65 7472 7920 3d20    is_geometry = 
-0001dc80: 5472 7565 0a0a 2020 2020 6465 6620 5f5f  True..    def __
-0001dc90: 6e65 775f 5f28 636c 732c 202a 6172 6773  new__(cls, *args
-0001dca0: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
-0001dcb0: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
-0001dcc0: 6365 2861 7267 735b 305d 2c20 506c 616e  ce(args[0], Plan
-0001dcd0: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
-0001dce0: 7265 7475 726e 2050 6c61 6e65 5365 7269  return PlaneSeri
-0001dcf0: 6573 282a 6172 6773 2c20 2a2a 6b77 6172  es(*args, **kwar
-0001dd00: 6773 290a 2020 2020 2020 2020 656c 6966  gs).        elif
-0001dd10: 2069 7369 6e73 7461 6e63 6528 6172 6773   isinstance(args
-0001dd20: 5b30 5d2c 2043 7572 7665 293a 0a20 2020  [0], Curve):.   
-0001dd30: 2020 2020 2020 2020 206e 6577 5f63 6c73           new_cls
-0001dd40: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
-0001dd50: 2020 2020 2050 6172 616d 6574 7269 6332       Parametric2
-0001dd60: 444c 696e 6553 6572 6965 730a 2020 2020  DLineSeries.    
-0001dd70: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-0001dd80: 656e 2861 7267 735b 305d 2e66 756e 6374  en(args[0].funct
-0001dd90: 696f 6e73 2920 3d3d 2032 0a20 2020 2020  ions) == 2.     
-0001dda0: 2020 2020 2020 2020 2020 2065 6c73 6520             else 
-0001ddb0: 5061 7261 6d65 7472 6963 3344 4c69 6e65  Parametric3DLine
-0001ddc0: 5365 7269 6573 0a20 2020 2020 2020 2020  Series.         
-0001ddd0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-0001dde0: 2072 6574 7572 6e20 6e65 775f 636c 7328   return new_cls(
-0001ddf0: 2a61 7267 735b 305d 2e66 756e 6374 696f  *args[0].functio
-0001de00: 6e73 2c20 6172 6773 5b30 5d2e 6c69 6d69  ns, args[0].limi
-0001de10: 7473 2c20 2a2a 6b77 6172 6773 290a 2020  ts, **kwargs).  
-0001de20: 2020 2020 2020 7265 7475 726e 206f 626a        return obj
-0001de30: 6563 742e 5f5f 6e65 775f 5f28 636c 7329  ect.__new__(cls)
-0001de40: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
-0001de50: 5f5f 2873 656c 662c 2065 7870 722c 205f  __(self, expr, _
-0001de60: 7261 6e67 653d 4e6f 6e65 2c20 6c61 6265  range=None, labe
-0001de70: 6c3d 2222 2c20 2a2a 6b77 6172 6773 293a  l="", **kwargs):
-0001de80: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-0001de90: 6973 696e 7374 616e 6365 2865 7870 722c  isinstance(expr,
-0001dea0: 2047 656f 6d65 7472 7945 6e74 6974 7929   GeometryEntity)
-0001deb0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-0001dec0: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
-0001ded0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001dee0: 2260 6578 7072 6020 6d75 7374 2062 6520  "`expr` must be 
-0001def0: 6120 6765 6f6d 7472 6963 2065 6e74 6974  a geomtric entit
-0001df00: 792e 5c6e 220a 2020 2020 2020 2020 2020  y.\n".          
-0001df10: 2020 2020 2020 2b20 2252 6563 6569 7665        + "Receive
-0001df20: 643a 2074 7970 6528 6578 7072 2920 3d20  d: type(expr) = 
-0001df30: 7b7d 5c6e 222e 666f 726d 6174 2874 7970  {}\n".format(typ
-0001df40: 6528 6578 7072 2929 0a20 2020 2020 2020  e(expr)).       
-0001df50: 2020 2020 2020 2020 202b 2022 4578 7072           + "Expr
-0001df60: 3a20 7b7d 222e 666f 726d 6174 2865 7870  : {}".format(exp
-0001df70: 7229 0a20 2020 2020 2020 2020 2020 2029  r).            )
-0001df80: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
-0001df90: 2e5f 5f69 6e69 745f 5f28 2a2a 6b77 6172  .__init__(**kwar
-0001dfa0: 6773 290a 2020 2020 2020 2020 7220 3d20  gs).        r = 
-0001dfb0: 6578 7072 2e66 7265 655f 7379 6d62 6f6c  expr.free_symbol
-0001dfc0: 732e 6469 6666 6572 656e 6365 2873 6574  s.difference(set
-0001dfd0: 2873 656c 662e 7061 7261 6d73 2e6b 6579  (self.params.key
-0001dfe0: 7328 2929 290a 2020 2020 2020 2020 6966  s())).        if
-0001dff0: 206c 656e 2872 2920 3e20 303a 0a20 2020   len(r) > 0:.   
-0001e000: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-0001e010: 616c 7565 4572 726f 7228 0a20 2020 2020  alueError(.     
-0001e020: 2020 2020 2020 2020 2020 2022 546f 6f20             "Too 
-0001e030: 6d61 6e79 2066 7265 6520 7379 6d62 6f6c  many free symbol
-0001e040: 732e 2050 6c65 6173 652c 2073 7065 6369  s. Please, speci
-0001e050: 6679 2074 6865 2076 616c 7565 7320 6f66  fy the values of
-0001e060: 2074 6865 2022 0a20 2020 2020 2020 2020   the ".         
-0001e070: 2020 2020 2020 2066 2266 6f6c 6c6f 7769         f"followi
-0001e080: 6e67 2073 796d 626f 6c73 2077 6974 6820  ng symbols with 
-0001e090: 7468 6520 6070 6172 616d 7360 2064 6963  the `params` dic
-0001e0a0: 7469 6f6e 6172 793a 207b 727d 220a 2020  tionary: {r}".  
-0001e0b0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-0001e0c0: 2020 2020 7365 6c66 2e5f 6578 7072 203d      self._expr =
-0001e0d0: 2065 7870 720a 2020 2020 2020 2020 7365   expr.        se
-0001e0e0: 6c66 2e72 616e 6765 7320 3d20 5b5f 7261  lf.ranges = [_ra
-0001e0f0: 6e67 655d 0a20 2020 2020 2020 2073 656c  nge].        sel
-0001e100: 662e 5f6c 6162 656c 203d 2073 7472 2865  f._label = str(e
-0001e110: 7870 7229 2069 6620 6c61 6265 6c20 6973  xpr) if label is
-0001e120: 204e 6f6e 6520 656c 7365 206c 6162 656c   None else label
-0001e130: 0a20 2020 2020 2020 2073 656c 662e 5f6c  .        self._l
-0001e140: 6174 6578 5f6c 6162 656c 203d 206c 6174  atex_label = lat
-0001e150: 6578 2865 7870 7229 2069 6620 6c61 6265  ex(expr) if labe
-0001e160: 6c20 6973 204e 6f6e 6520 656c 7365 206c  l is None else l
-0001e170: 6162 656c 0a20 2020 2020 2020 2069 6620  abel.        if 
-0001e180: 6973 696e 7374 616e 6365 2865 7870 722c  isinstance(expr,
-0001e190: 2028 4c69 6e65 6172 456e 7469 7479 3344   (LinearEntity3D
-0001e1a0: 2c20 506f 696e 7433 4429 293a 0a20 2020  , Point3D)):.   
-0001e1b0: 2020 2020 2020 2020 2073 656c 662e 6973           self.is
-0001e1c0: 5f32 446c 696e 6520 3d20 4661 6c73 650a  _2Dline = False.
-0001e1d0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001e1e0: 2e69 735f 3344 6c69 6e65 203d 2054 7275  .is_3Dline = Tru
-0001e1f0: 650a 2020 2020 2020 2020 2020 2020 7365  e.            se
-0001e200: 6c66 2e69 735f 7061 7261 6d65 7472 6963  lf.is_parametric
-0001e210: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
-0001e220: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
-0001e230: 6365 2865 7870 722c 2050 6f69 6e74 3344  ce(expr, Point3D
-0001e240: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-0001e250: 2020 2073 656c 662e 6973 5f70 6f69 6e74     self.is_point
-0001e260: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
-0001e270: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
-0001e280: 6578 7072 2c20 4c69 6e65 6172 456e 7469  expr, LinearEnti
-0001e290: 7479 3244 293a 0a20 2020 2020 2020 2020  ty2D):.         
-0001e2a0: 2020 2073 656c 662e 6973 5f32 446c 696e     self.is_2Dlin
-0001e2b0: 6520 3d20 5472 7565 0a20 2020 2020 2020  e = True.       
-0001e2c0: 2065 6c69 6620 6973 696e 7374 616e 6365   elif isinstance
-0001e2d0: 2865 7870 722c 2028 506f 6c79 676f 6e2c  (expr, (Polygon,
-0001e2e0: 2043 6972 636c 652c 2045 6c6c 6970 7365   Circle, Ellipse
-0001e2f0: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
-0001e300: 7365 6c66 2e69 735f 3244 6c69 6e65 203d  self.is_2Dline =
-0001e310: 206e 6f74 2073 656c 662e 6973 5f66 696c   not self.is_fil
-0001e320: 6c65 640a 2020 2020 2020 2020 656c 6966  led.        elif
-0001e330: 2069 7369 6e73 7461 6e63 6528 6578 7072   isinstance(expr
-0001e340: 2c20 506f 696e 7432 4429 3a0a 2020 2020  , Point2D):.    
-0001e350: 2020 2020 2020 2020 7365 6c66 2e69 735f          self.is_
-0001e360: 706f 696e 7420 3d20 5472 7565 0a20 2020  point = True.   
-0001e370: 2020 2020 2020 2020 2073 656c 662e 6973           self.is
-0001e380: 5f32 446c 696e 6520 3d20 5472 7565 0a20  _2Dline = True. 
-0001e390: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001e3a0: 706f 6c65 735f 6c6f 6361 7469 6f6e 7320  poles_locations 
-0001e3b0: 3d20 5b5d 0a0a 2020 2020 6465 6620 6765  = []..    def ge
-0001e3c0: 745f 6461 7461 2873 656c 6629 3a0a 2020  t_data(self):.  
-0001e3d0: 2020 2020 2020 6e70 203d 2069 6d70 6f72        np = impor
-0001e3e0: 745f 6d6f 6475 6c65 2827 6e75 6d70 7927  t_module('numpy'
-0001e3f0: 290a 0a20 2020 2020 2020 2065 7870 7220  )..        expr 
-0001e400: 3d20 7365 6c66 2e65 7870 722e 7375 6273  = self.expr.subs
-0001e410: 2873 656c 662e 7061 7261 6d73 290a 2020  (self.params).  
-0001e420: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-0001e430: 6e63 6528 6578 7072 2c20 506f 696e 7433  nce(expr, Point3
-0001e440: 4429 3a0a 2020 2020 2020 2020 2020 2020  D):.            
-0001e450: 7265 7475 726e 2073 656c 662e 5f61 7070  return self._app
-0001e460: 6c79 5f74 7261 6e73 666f 726d 280a 2020  ly_transform(.  
-0001e470: 2020 2020 2020 2020 2020 2020 2020 6e70                np
-0001e480: 2e61 7272 6179 285b 6578 7072 2e78 5d2c  .array([expr.x],
-0001e490: 2064 7479 7065 3d66 6c6f 6174 292c 0a20   dtype=float),. 
-0001e4a0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0001e4b0: 702e 6172 7261 7928 5b65 7870 722e 795d  p.array([expr.y]
-0001e4c0: 2c20 6474 7970 653d 666c 6f61 7429 2c0a  , dtype=float),.
-0001e4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e4e0: 6e70 2e61 7272 6179 285b 6578 7072 2e7a  np.array([expr.z
-0001e4f0: 5d2c 2064 7479 7065 3d66 6c6f 6174 290a  ], dtype=float).
-0001e500: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-0001e510: 2020 2020 2020 656c 6966 2069 7369 6e73        elif isins
-0001e520: 7461 6e63 6528 6578 7072 2c20 506f 696e  tance(expr, Poin
-0001e530: 7432 4429 3a0a 2020 2020 2020 2020 2020  t2D):.          
-0001e540: 2020 7265 7475 726e 2073 656c 662e 5f61    return self._a
-0001e550: 7070 6c79 5f74 7261 6e73 666f 726d 280a  pply_transform(.
-0001e560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e570: 6e70 2e61 7272 6179 285b 6578 7072 2e78  np.array([expr.x
-0001e580: 5d2c 2064 7479 7065 3d66 6c6f 6174 292c  ], dtype=float),
-0001e590: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001e5a0: 206e 702e 6172 7261 7928 5b65 7870 722e   np.array([expr.
-0001e5b0: 795d 2c20 6474 7970 653d 666c 6f61 7429  y], dtype=float)
-0001e5c0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
-0001e5d0: 2020 2020 2020 2065 6c69 6620 6973 696e         elif isin
-0001e5e0: 7374 616e 6365 2865 7870 722c 2050 6f6c  stance(expr, Pol
-0001e5f0: 7967 6f6e 293a 0a20 2020 2020 2020 2020  ygon):.         
-0001e600: 2020 2078 203d 205b 666c 6f61 7428 762e     x = [float(v.
-0001e610: 7829 2066 6f72 2076 2069 6e20 6578 7072  x) for v in expr
-0001e620: 2e76 6572 7469 6365 735d 0a20 2020 2020  .vertices].     
-0001e630: 2020 2020 2020 2079 203d 205b 666c 6f61         y = [floa
-0001e640: 7428 762e 7929 2066 6f72 2076 2069 6e20  t(v.y) for v in 
-0001e650: 6578 7072 2e76 6572 7469 6365 735d 0a20  expr.vertices]. 
-0001e660: 2020 2020 2020 2020 2020 2078 2e61 7070             x.app
-0001e670: 656e 6428 785b 305d 290a 2020 2020 2020  end(x[0]).      
-0001e680: 2020 2020 2020 792e 6170 7065 6e64 2879        y.append(y
-0001e690: 5b30 5d29 0a20 2020 2020 2020 2020 2020  [0]).           
-0001e6a0: 2072 6574 7572 6e20 7365 6c66 2e5f 6170   return self._ap
-0001e6b0: 706c 795f 7472 616e 7366 6f72 6d28 6e70  ply_transform(np
-0001e6c0: 2e61 7272 6179 2878 292c 206e 702e 6172  .array(x), np.ar
-0001e6d0: 7261 7928 7929 290a 2020 2020 2020 2020  ray(y)).        
-0001e6e0: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
-0001e6f0: 6578 7072 2c20 4369 7263 6c65 293a 0a20  expr, Circle):. 
-0001e700: 2020 2020 2020 2020 2020 2063 782c 2063             cx, c
-0001e710: 7920 3d20 666c 6f61 7428 6578 7072 2e63  y = float(expr.c
-0001e720: 656e 7465 725b 305d 292c 2066 6c6f 6174  enter[0]), float
-0001e730: 2865 7870 722e 6365 6e74 6572 5b31 5d29  (expr.center[1])
-0001e740: 0a20 2020 2020 2020 2020 2020 2072 203d  .            r =
-0001e750: 2066 6c6f 6174 2865 7870 722e 7261 6469   float(expr.radi
-0001e760: 7573 290a 2020 2020 2020 2020 2020 2020  us).            
-0001e770: 7420 3d20 6e70 2e6c 696e 7370 6163 6528  t = np.linspace(
-0001e780: 302c 2032 202a 206e 702e 7069 2c20 7365  0, 2 * np.pi, se
-0001e790: 6c66 2e6e 5b30 5d29 0a20 2020 2020 2020  lf.n[0]).       
-0001e7a0: 2020 2020 2078 2c20 7920 3d20 6378 202b       x, y = cx +
-0001e7b0: 2072 202a 206e 702e 636f 7328 7429 2c20   r * np.cos(t), 
-0001e7c0: 6379 202b 2072 202a 206e 702e 7369 6e28  cy + r * np.sin(
-0001e7d0: 7429 0a20 2020 2020 2020 2020 2020 2078  t).            x
-0001e7e0: 203d 206e 702e 6170 7065 6e64 2878 2c20   = np.append(x, 
-0001e7f0: 785b 305d 290a 2020 2020 2020 2020 2020  x[0]).          
-0001e800: 2020 7920 3d20 6e70 2e61 7070 656e 6428    y = np.append(
-0001e810: 792c 2079 5b30 5d29 0a20 2020 2020 2020  y, y[0]).       
-0001e820: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001e830: 2e5f 6170 706c 795f 7472 616e 7366 6f72  ._apply_transfor
-0001e840: 6d28 782c 2079 290a 2020 2020 2020 2020  m(x, y).        
-0001e850: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
-0001e860: 6578 7072 2c20 456c 6c69 7073 6529 3a0a  expr, Ellipse):.
-0001e870: 2020 2020 2020 2020 2020 2020 6378 2c20              cx, 
-0001e880: 6379 203d 2066 6c6f 6174 2865 7870 722e  cy = float(expr.
-0001e890: 6365 6e74 6572 5b30 5d29 2c20 666c 6f61  center[0]), floa
-0001e8a0: 7428 6578 7072 2e63 656e 7465 725b 315d  t(expr.center[1]
-0001e8b0: 290a 2020 2020 2020 2020 2020 2020 6120  ).            a 
-0001e8c0: 3d20 666c 6f61 7428 6578 7072 2e68 7261  = float(expr.hra
-0001e8d0: 6469 7573 290a 2020 2020 2020 2020 2020  dius).          
-0001e8e0: 2020 6520 3d20 666c 6f61 7428 6578 7072    e = float(expr
-0001e8f0: 2e65 6363 656e 7472 6963 6974 7929 0a20  .eccentricity). 
-0001e900: 2020 2020 2020 2020 2020 2078 203d 206e             x = n
-0001e910: 702e 6c69 6e73 7061 6365 282d 612c 2061  p.linspace(-a, a
-0001e920: 2c20 7365 6c66 2e6e 5b30 5d29 0a20 2020  , self.n[0]).   
-0001e930: 2020 2020 2020 2020 2079 203d 206e 702e           y = np.
-0001e940: 7371 7274 2828 6120 2a2a 2032 202d 2078  sqrt((a ** 2 - x
-0001e950: 202a 2a20 3229 202a 2028 3120 2d20 6520   ** 2) * (1 - e 
-0001e960: 2a2a 2032 2929 0a20 2020 2020 2020 2020  ** 2)).         
-0001e970: 2020 2078 202b 3d20 6378 0a20 2020 2020     x += cx.     
-0001e980: 2020 2020 2020 2078 2c20 7920 3d20 6e70         x, y = np
-0001e990: 2e63 6f6e 6361 7465 6e61 7465 2828 782c  .concatenate((x,
-0001e9a0: 2078 5b3a 3a2d 315d 2929 2c20 6e70 2e63   x[::-1])), np.c
-0001e9b0: 6f6e 6361 7465 6e61 7465 2828 6379 202b  oncatenate((cy +
-0001e9c0: 2079 2c20 6379 202d 2079 5b3a 3a2d 315d   y, cy - y[::-1]
-0001e9d0: 2929 0a20 2020 2020 2020 2020 2020 2078  )).            x
-0001e9e0: 203d 206e 702e 6170 7065 6e64 2878 2c20   = np.append(x, 
-0001e9f0: 785b 305d 290a 2020 2020 2020 2020 2020  x[0]).          
-0001ea00: 2020 7920 3d20 6e70 2e61 7070 656e 6428    y = np.append(
-0001ea10: 792c 2079 5b30 5d29 0a20 2020 2020 2020  y, y[0]).       
-0001ea20: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001ea30: 2e5f 6170 706c 795f 7472 616e 7366 6f72  ._apply_transfor
-0001ea40: 6d28 782c 2079 290a 2020 2020 2020 2020  m(x, y).        
-0001ea50: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
-0001ea60: 6578 7072 2c20 4c69 6e65 6172 456e 7469  expr, LinearEnti
-0001ea70: 7479 3344 293a 0a20 2020 2020 2020 2020  ty3D):.         
-0001ea80: 2020 2070 312c 2070 3220 3d20 6578 7072     p1, p2 = expr
-0001ea90: 2e70 6f69 6e74 730a 2020 2020 2020 2020  .points.        
-0001eaa0: 2020 2020 7820 3d20 6e70 2e61 7272 6179      x = np.array
-0001eab0: 285b 7031 2e78 2c20 7032 2e78 5d2c 2064  ([p1.x, p2.x], d
-0001eac0: 7479 7065 3d66 6c6f 6174 290a 2020 2020  type=float).    
-0001ead0: 2020 2020 2020 2020 7920 3d20 6e70 2e61          y = np.a
-0001eae0: 7272 6179 285b 7031 2e79 2c20 7032 2e79  rray([p1.y, p2.y
-0001eaf0: 5d2c 2064 7479 7065 3d66 6c6f 6174 290a  ], dtype=float).
-0001eb00: 2020 2020 2020 2020 2020 2020 7a20 3d20              z = 
-0001eb10: 6e70 2e61 7272 6179 285b 7031 2e7a 2c20  np.array([p1.z, 
-0001eb20: 7032 2e7a 5d2c 2064 7479 7065 3d66 6c6f  p2.z], dtype=flo
-0001eb30: 6174 290a 2020 2020 2020 2020 2020 2020  at).            
-0001eb40: 7265 7475 726e 2073 656c 662e 5f61 7070  return self._app
-0001eb50: 6c79 5f74 7261 6e73 666f 726d 2878 2c20  ly_transform(x, 
-0001eb60: 792c 207a 290a 2020 2020 2020 2020 656c  y, z).        el
-0001eb70: 6966 2069 7369 6e73 7461 6e63 6528 6578  if isinstance(ex
-0001eb80: 7072 2c20 2853 6567 6d65 6e74 2c20 5261  pr, (Segment, Ra
-0001eb90: 7929 293a 0a20 2020 2020 2020 2020 2020  y)):.           
-0001eba0: 2070 312c 2070 3220 3d20 6578 7072 2e70   p1, p2 = expr.p
-0001ebb0: 6f69 6e74 730a 2020 2020 2020 2020 2020  oints.          
-0001ebc0: 2020 7820 3d20 6e70 2e61 7272 6179 285b    x = np.array([
-0001ebd0: 7031 2e78 2c20 7032 2e78 5d29 0a20 2020  p1.x, p2.x]).   
-0001ebe0: 2020 2020 2020 2020 2079 203d 206e 702e           y = np.
-0001ebf0: 6172 7261 7928 5b70 312e 792c 2070 322e  array([p1.y, p2.
-0001ec00: 795d 290a 2020 2020 2020 2020 2020 2020  y]).            
-0001ec10: 7265 7475 726e 2073 656c 662e 5f61 7070  return self._app
-0001ec20: 6c79 5f74 7261 6e73 666f 726d 2878 2e61  ly_transform(x.a
-0001ec30: 7374 7970 6528 666c 6f61 7429 2c20 792e  stype(float), y.
-0001ec40: 6173 7479 7065 2866 6c6f 6174 2929 0a20  astype(float)). 
-0001ec50: 2020 2020 2020 2065 6c73 653a 2020 2320         else:  # 
-0001ec60: 4c69 6e65 0a20 2020 2020 2020 2020 2020  Line.           
-0001ec70: 2070 312c 2070 3220 3d20 6578 7072 2e70   p1, p2 = expr.p
-0001ec80: 6f69 6e74 730a 2020 2020 2020 2020 2020  oints.          
-0001ec90: 2020 6966 206e 6f74 2073 656c 662e 7261    if not self.ra
-0001eca0: 6e67 6573 3a0a 2020 2020 2020 2020 2020  nges:.          
-0001ecb0: 2020 2020 2020 7820 3d20 6e70 2e61 7272        x = np.arr
-0001ecc0: 6179 285b 7031 2e78 2c20 7032 2e78 5d29  ay([p1.x, p2.x])
-0001ecd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001ece0: 2079 203d 206e 702e 6172 7261 7928 5b70   y = np.array([p
-0001ecf0: 312e 792c 2070 322e 795d 290a 2020 2020  1.y, p2.y]).    
-0001ed00: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0001ed10: 2020 2020 2020 2020 2020 2020 2020 5f72                _r
-0001ed20: 616e 6765 203d 2073 656c 662e 7261 6e67  ange = self.rang
-0001ed30: 6573 5b30 5d0a 2020 2020 2020 2020 2020  es[0].          
-0001ed40: 2020 2020 2020 6d20 3d20 6578 7072 2e73        m = expr.s
-0001ed50: 6c6f 7065 0a20 2020 2020 2020 2020 2020  lope.           
-0001ed60: 2020 2020 2071 203d 2070 315b 315d 202d       q = p1[1] -
-0001ed70: 206d 202a 2070 315b 305d 0a20 2020 2020   m * p1[0].     
-0001ed80: 2020 2020 2020 2020 2020 2078 203d 206e             x = n
-0001ed90: 702e 6172 7261 7928 5b5f 7261 6e67 655b  p.array([_range[
-0001eda0: 315d 2c20 5f72 616e 6765 5b32 5d5d 290a  1], _range[2]]).
-0001edb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001edc0: 7920 3d20 6d20 2a20 7820 2b20 710a 2020  y = m * x + q.  
-0001edd0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001ede0: 2073 656c 662e 5f61 7070 6c79 5f74 7261   self._apply_tra
-0001edf0: 6e73 666f 726d 2878 2e61 7374 7970 6528  nsform(x.astype(
-0001ee00: 666c 6f61 7429 2c20 792e 6173 7479 7065  float), y.astype
-0001ee10: 2866 6c6f 6174 2929 0a0a 2020 2020 6465  (float))..    de
-0001ee20: 6620 5f5f 7374 725f 5f28 7365 6c66 293a  f __str__(self):
-0001ee30: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001ee40: 7365 6c66 2e5f 7374 725f 6865 6c70 6572  self._str_helper
-0001ee50: 2822 6765 6f6d 6574 7279 2065 6e74 6974  ("geometry entit
-0001ee60: 793a 2025 7322 2025 2073 7472 2873 656c  y: %s" % str(sel
-0001ee70: 662e 6578 7072 2929 0a0a 0a63 6c61 7373  f.expr))...class
-0001ee80: 2047 656e 6572 6963 4461 7461 5365 7269   GenericDataSeri
-0001ee90: 6573 2842 6173 6553 6572 6965 7329 3a0a  es(BaseSeries):.
-0001eea0: 2020 2020 2222 2252 6570 7265 7365 6e74      """Represent
-0001eeb0: 7320 6765 6e65 7269 6320 6e75 6d65 7269  s generic numeri
-0001eec0: 6361 6c20 6461 7461 2e0a 0a20 2020 204e  cal data...    N
-0001eed0: 4f54 453a 0a20 2020 2054 6869 7320 636c  OTE:.    This cl
-0001eee0: 6173 7320 696d 706c 656d 656e 7473 2062  ass implements b
-0001eef0: 6163 6b2d 636f 6d70 6174 6962 696c 6974  ack-compatibilit
-0001ef00: 7920 7769 7468 2053 796d 7079 203c 3d31  y with Sympy <=1
-0001ef10: 2e31 313a 2069 7473 2070 6c6f 7474 696e  .11: its plottin
-0001ef20: 670a 2020 2020 6d6f 6475 6c65 2061 6363  g.    module acc
-0001ef30: 6570 7473 2074 6865 2066 6f6c 6c6f 7769  epts the followi
-0001ef40: 6e67 206b 6579 776f 7264 2061 7267 756d  ng keyword argum
-0001ef50: 656e 7473 3a0a 0a20 2020 2061 6e6e 6f74  ents:..    annot
-0001ef60: 6174 696f 6e73 2c20 6d61 726b 6572 732c  ations, markers,
-0001ef70: 2072 6563 7461 6e67 6c65 732c 2066 696c   rectangles, fil
-0001ef80: 6c0a 0a20 2020 2053 6164 6c79 2c20 7468  l..    Sadly, th
-0001ef90: 6520 6465 7665 6c6f 7065 7273 2066 6f72  e developers for
-0001efa0: 676f 7420 746f 2070 726f 7065 726c 7920  got to properly 
-0001efb0: 646f 6375 6d65 6e74 2074 6865 6d3a 2074  document them: t
-0001efc0: 6865 7265 2061 7265 206e 6f0a 2020 2020  here are no.    
-0001efd0: 6578 616d 706c 6520 7768 6174 736f 6576  example whatsoev
-0001efe0: 6572 2061 626f 7574 2074 6865 6972 2075  er about their u
-0001eff0: 7361 6765 2e20 5468 6973 2069 7320 6163  sage. This is ac
-0001f000: 7475 616c 6c79 2061 2076 6572 7920 676f  tually a very go
-0001f010: 6f64 2074 6869 6e67 0a20 2020 2066 6f72  od thing.    for
-0001f020: 2074 6869 7320 6e65 7720 706c 6f74 7469   this new plotti
-0001f030: 6e67 206d 6f64 756c 652c 2077 6869 6368  ng module, which
-0001f040: 2073 7570 706f 7274 7320 6d75 6c74 6970   supports multip
-0001f050: 6c65 2062 6163 6b65 6e64 732e 0a20 2020  le backends..   
-0001f060: 2045 7665 7279 2062 6163 6b65 6e64 2065   Every backend e
-0001f070: 7870 6f73 6573 2064 6966 6665 7265 6e74  xposes different
-0001f080: 2066 756e 6374 696f 6e73 3a0a 0a20 2020   functions:..   
-0001f090: 2031 2e20 466f 7220 6578 616d 706c 652c   1. For example,
-0001f0a0: 2074 6f20 6372 6561 7465 206c 696e 6520   to create line 
-0001f0b0: 706c 6f74 7320 4d61 7470 6c6f 746c 6962  plots Matplotlib
-0001f0c0: 2065 7870 6f73 6573 2060 6061 782e 706c   exposes ``ax.pl
-0001f0d0: 6f74 6060 2c0a 2020 2020 2020 2077 6865  ot``,.       whe
-0001f0e0: 7265 6173 2050 6c6f 746c 7920 6578 706f  reas Plotly expo
-0001f0f0: 7365 7320 6060 676f 2e53 6361 7474 6572  ses ``go.Scatter
-0001f100: 6060 2c20 7768 6572 6561 7320 426f 6b65  ``, whereas Boke
-0001f110: 6820 6578 706f 7365 730a 2020 2020 2020  h exposes.      
-0001f120: 2060 6066 6967 2e6c 696e 6560 602c 2065   ``fig.line``, e
-0001f130: 7463 2e20 4275 7420 7468 6f73 6520 6469  tc. But those di
-0001f140: 6666 6572 656e 7420 7761 7973 2064 6f20  fferent ways do 
-0001f150: 6e6f 7420 6f76 6572 6c61 7020 636f 6d70  not overlap comp
-0001f160: 6c65 7465 6c79 3a0a 2020 2020 2020 2077  letely:.       w
-0001f170: 6974 6820 6060 676f 2e53 6361 7474 6572  ith ``go.Scatter
-0001f180: 6060 2069 7427 7320 616c 736f 2070 6f73  `` it's also pos
-0001f190: 7369 626c 6520 746f 2063 7265 6174 6520  sible to create 
-0001f1a0: 6669 6c6c 6564 2072 6567 696f 6e73 2c0a  filled regions,.
-0001f1b0: 2020 2020 2020 2077 6865 7265 6173 2077         whereas w
-0001f1c0: 6974 6820 6060 6178 2e70 6c6f 7460 6020  ith ``ax.plot`` 
-0001f1d0: 7468 6174 2773 206e 6f74 2070 6f73 7369  that's not possi
-0001f1e0: 626c 652e 0a20 2020 2032 2e20 4d6f 7265  ble..    2. More
-0001f1f0: 6f76 6572 2c20 736f 6d65 2070 6c6f 7474  over, some plott
-0001f200: 696e 6720 6c69 6272 6172 7920 6578 706f  ing library expo
-0001f210: 7365 7320 6675 6e63 7469 6f6e 616c 6974  ses functionalit
-0001f220: 6965 7320 7468 6174 2061 7265 0a20 2020  ies that are.   
-0001f230: 2020 2020 756e 6d61 7463 6865 6420 6279      unmatched by
-0001f240: 206f 7468 6572 732e 2046 6f72 2065 7861   others. For exa
-0001f250: 6d70 6c65 2c20 4d61 7470 6c6f 746c 6962  mple, Matplotlib
-0001f260: 2773 2060 6061 782e 6669 6c6c 5f62 6574  's ``ax.fill_bet
-0001f270: 7765 656e 6060 2069 730a 2020 2020 2020  ween`` is.      
-0001f280: 2073 7562 7374 616e 7469 616c 6c79 2064   substantially d
-0001f290: 6966 6665 7265 6e74 2066 726f 6d20 506c  ifferent from Pl
-0001f2a0: 6f74 6c79 2773 2066 696c 6c65 6420 6172  otly's filled ar
-0001f2b0: 6561 206f 7220 7768 6174 6576 6572 2042  ea or whatever B
-0001f2c0: 6f6b 6568 0a20 2020 2020 2020 6578 706f  okeh.       expo
-0001f2d0: 7365 732e 2053 696d 696c 6172 6c79 2c20  ses. Similarly, 
-0001f2e0: 4d61 7470 6c6f 746c 6962 2773 2052 6563  Matplotlib's Rec
-0001f2f0: 7461 6e67 6c65 2069 7320 7665 7279 2073  tangle is very s
-0001f300: 7065 6369 6669 632c 2077 6865 7265 6173  pecific, whereas
-0001f310: 0a20 2020 2020 2020 7769 7468 2050 6c6f  .       with Plo
-0001f320: 746c 7920 7765 2063 616e 2061 6464 2061  tly we can add a
-0001f330: 6e79 2073 6861 7065 2028 7265 6374 616e  ny shape (rectan
-0001f340: 676c 652c 206c 696e 652c 202e 2e2e 2920  gle, line, ...) 
-0001f350: 7769 7468 2074 6865 2073 616d 650a 2020  with the same.  
-0001f360: 2020 2020 2066 756e 6374 696f 6e20 6361       function ca
-0001f370: 6c6c 2e0a 0a20 2020 2053 6f2c 2074 6865  ll...    So, the
-0001f380: 2070 726f 626c 656d 2069 7320 636c 6561   problem is clea
-0001f390: 723a 2069 6620 6465 7665 6c6f 7065 7273  r: if developers
-0001f3a0: 2064 6f63 756d 656e 7420 6120 6665 6174   document a feat
-0001f3b0: 7572 6520 746f 2064 6f20 6f6e 650a 2020  ure to do one.  
-0001f3c0: 2020 7370 6563 6966 6963 2074 6869 6e67    specific thing
-0001f3d0: 2c20 7573 6572 7320 6578 7065 6374 2069  , users expect i
-0001f3e0: 7420 746f 2070 726f 6475 6365 2063 6f6e  t to produce con
-0001f3f0: 7369 7374 656e 7420 7265 7375 6c74 7320  sistent results 
-0001f400: 6163 726f 7373 0a20 2020 2062 6163 6b65  across.    backe
-0001f410: 6e64 732e 2054 6869 7320 6973 2063 6c65  nds. This is cle
-0001f420: 6172 6c79 2069 6d70 6f73 7369 626c 6520  arly impossible 
-0001f430: 746f 2061 6368 6965 7665 2e0a 0a20 2020  to achieve...   
-0001f440: 2054 6865 7265 2069 7320 616c 736f 2074   There is also t
-0001f450: 6865 2070 726f 626c 656d 206f 6620 7768  he problem of wh
-0001f460: 656e 2022 656e 6f75 6768 2069 7320 656e  en "enough is en
-0001f470: 6f75 6768 223f 204d 6561 6e69 6e67 2c20  ough"? Meaning, 
-0001f480: 7768 6f20 6973 2074 6f0a 2020 2020 7374  who is to.    st
-0001f490: 6f70 2061 6e79 6f6e 6520 6672 6f6d 2061  op anyone from a
-0001f4a0: 6464 696e 6720 6e65 7720 6b65 7977 6f72  dding new keywor
-0001f4b0: 6420 6172 6775 6d65 6e74 7320 7468 6174  d arguments that
-0001f4c0: 2061 7265 206a 7573 7420 7772 6170 7065   are just wrappe
-0001f4d0: 7273 2074 6f0a 2020 2020 7768 6174 2061  rs to.    what a
-0001f4e0: 2070 6c6f 7474 696e 6720 6c69 6272 6172   plotting librar
-0001f4f0: 7920 616c 7265 6164 7920 6361 6e20 646f  y already can do
-0001f500: 3f20 466f 7220 6578 616d 706c 652c 2049  ? For example, I
-0001f510: 2063 6f75 6c64 2061 6464 2074 6865 0a20   could add the. 
-0001f520: 2020 2060 6068 6578 5f74 696c 6560 6020     ``hex_tile`` 
-0001f530: 6b65 7977 6f72 643a 2069 7427 7320 6265  keyword: it's be
-0001f540: 6175 7469 6675 6c20 666f 7220 426f 6b65  autiful for Boke
-0001f550: 682c 2062 7574 2076 6572 7920 6469 6666  h, but very diff
-0001f560: 6963 756c 740a 2020 2020 746f 2069 6d70  icult.    to imp
-0001f570: 6c65 6d65 6e74 206f 6e20 6f74 6865 7220  lement on other 
-0001f580: 6261 636b 656e 6473 2e20 4f72 206d 6179  backends. Or may
-0001f590: 6265 2049 2063 6f75 6c64 2061 6464 2060  be I could add `
-0001f5a0: 6068 6c69 6e65 7360 6020 6f72 0a20 2020  `hlines`` or.   
-0001f5b0: 2060 6076 6c69 6e65 7360 6020 6b65 7977   ``vlines`` keyw
-0001f5c0: 6f72 6420 6172 6775 6d65 6e74 7320 746f  ord arguments to
-0001f5d0: 2061 6464 2068 6f72 697a 6f6e 7461 6c20   add horizontal 
-0001f5e0: 6f72 2076 6572 7469 6361 6c20 6c69 6e65  or vertical line
-0001f5f0: 732e 2049 6620 7468 6973 0a20 2020 2061  s. If this.    a
-0001f600: 7070 726f 6163 6820 7761 7320 746f 2062  pproach was to b
-0001f610: 6520 666f 6c6c 6f77 6564 2c20 7765 2077  e followed, we w
-0001f620: 696c 6c20 656e 6420 7570 2072 6577 7269  ill end up rewri
-0001f630: 7469 6e67 206d 756c 7469 706c 6520 706c  ting multiple pl
-0001f640: 6f74 7469 6e67 0a20 2020 206c 6962 7261  otting.    libra
-0001f650: 7269 6573 3a20 666f 7220 7768 6174 3f0a  ries: for what?.
-0001f660: 0a20 2020 2049 6e73 7465 6164 2c20 7468  .    Instead, th
-0001f670: 6520 676f 616c 206f 6620 7468 6973 206d  e goal of this m
-0001f680: 6f64 756c 6520 6973 2074 6f20 6661 6369  odule is to faci
-0001f690: 6c69 7461 7465 2074 6865 2070 6c6f 7474  litate the plott
-0001f6a0: 696e 6720 6f66 2073 796d 626f 6c69 630a  ing of symbolic.
-0001f6b0: 2020 2020 6578 7072 6573 7369 6f6e 732e      expressions.
-0001f6c0: 2049 6620 7573 6572 206e 6565 6473 2074   If user needs t
-0001f6d0: 6f20 6164 6420 6e75 6d65 7269 6361 6c20  o add numerical 
-0001f6e0: 6461 7461 2074 6f20 6120 706c 6f74 2c20  data to a plot, 
-0001f6f0: 6865 2f73 6865 2063 616e 0a20 2020 2065  he/she can.    e
-0001f700: 6173 696c 7920 7265 7472 6965 7665 2074  asily retrieve t
-0001f710: 6865 2066 6967 7572 6520 6f62 6a65 6374  he figure object
-0001f720: 2061 6e64 2070 726f 6365 6564 2077 6974   and proceed wit
-0001f730: 6820 7468 6520 7573 7561 6c20 636f 6d6d  h the usual comm
-0001f740: 616e 6473 0a20 2020 2061 7373 6f63 6961  ands.    associa
-0001f750: 7465 6420 746f 2061 2073 7065 6369 6669  ted to a specifi
-0001f760: 6320 706c 6f74 7469 6e67 206c 6962 7261  c plotting libra
-0001f770: 7279 2e0a 2020 2020 466f 7220 6578 616d  ry..    For exam
-0001f780: 706c 652c 2066 6f72 2060 604d 6174 706c  ple, for ``Matpl
-0001f790: 6f74 6c69 6242 6163 6b65 6e64 6060 3a0a  otlibBackend``:.
-0001f7a0: 0a20 2020 202e 2e20 636f 6465 2d62 6c6f  .    .. code-blo
-0001f7b0: 636b 3a3a 2070 7974 686f 6e0a 0a20 2020  ck:: python..   
-0001f7c0: 2020 2020 6672 6f6d 2073 796d 7079 2069      from sympy i
-0001f7d0: 6d70 6f72 7420 2a0a 2020 2020 2020 2066  mport *.       f
-0001f7e0: 726f 6d20 7370 6220 696d 706f 7274 202a  rom spb import *
-0001f7f0: 0a20 2020 2020 2020 696d 706f 7274 206e  .       import n
-0001f800: 756d 7079 2061 7320 6e70 0a20 2020 2020  umpy as np.     
-0001f810: 2020 7661 7228 2278 2229 0a0a 2020 2020    var("x")..    
-0001f820: 2020 2023 2070 6c6f 7420 7379 6d62 6f6c     # plot symbol
-0001f830: 6963 2065 7870 7265 7373 696f 6e73 0a20  ic expressions. 
-0001f840: 2020 2020 2020 7020 3d20 706c 6f74 2873        p = plot(s
-0001f850: 696e 2878 292c 2063 6f73 2878 292c 2062  in(x), cos(x), b
-0001f860: 6163 6b65 6e64 3d4d 4229 0a20 2020 2020  ackend=MB).     
-0001f870: 2020 2320 6578 7472 6163 7420 7468 6520    # extract the 
-0001f880: 6178 6573 206f 626a 6563 740a 2020 2020  axes object.    
-0001f890: 2020 2061 7820 3d20 702e 6669 672e 6178     ax = p.fig.ax
-0001f8a0: 6573 5b30 5d0a 2020 2020 2020 2023 2061  es[0].       # a
-0001f8b0: 6464 206e 756d 6572 6963 616c 2064 6174  dd numerical dat
-0001f8c0: 610a 2020 2020 2020 2078 7820 3d20 6e70  a.       xx = np
-0001f8d0: 2e6c 696e 7370 6163 6528 2d31 302c 2031  .linspace(-10, 1
-0001f8e0: 3029 0a20 2020 2020 2020 6620 3d20 3120  0).       f = 1 
-0001f8f0: 2f20 2831 202b 206e 702e 6578 7028 2d78  / (1 + np.exp(-x
-0001f900: 7829 290a 2020 2020 2020 2061 782e 706c  x)).       ax.pl
-0001f910: 6f74 2878 782c 2066 312c 2022 6b3a 222c  ot(xx, f1, "k:",
-0001f920: 206c 6162 656c 3d22 6e75 6d65 7269 6361   label="numerica
-0001f930: 6c20 6461 7461 2229 0a20 2020 2020 2020  l data").       
-0001f940: 6178 2e6c 6567 656e 6428 290a 2020 2020  ax.legend().    
-0001f950: 2020 2070 2e66 6967 0a0a 2020 2020 4865     p.fig..    He
-0001f960: 6e63 652c 2074 6865 2064 6563 6973 696f  nce, the decisio
-0001f970: 6e20 746f 206d 6169 6e74 6169 6e20 7468  n to maintain th
-0001f980: 6973 2062 6163 6b2d 636f 6d70 6174 6962  is back-compatib
-0001f990: 696c 6974 7920 2866 6f72 2074 6865 206d  ility (for the m
-0001f9a0: 6f6d 656e 7429 0a20 2020 2062 7574 206e  oment).    but n
-0001f9b0: 6f74 2074 6f20 646f 6375 6d65 6e74 2074  ot to document t
-0001f9c0: 686f 7365 206b 6579 776f 7264 2061 7267  hose keyword arg
-0001f9d0: 756d 656e 7473 206f 6e20 7468 6520 706c  uments on the pl
-0001f9e0: 6f74 7469 6e67 2066 756e 6374 696f 6e73  otting functions
-0001f9f0: 2e0a 2020 2020 2222 220a 2020 2020 6973  ..    """.    is
-0001fa00: 5f67 656e 6572 6963 203d 2054 7275 650a  _generic = True.
-0001fa10: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-0001fa20: 5f28 7365 6c66 2c20 7470 2c20 2a61 7267  _(self, tp, *arg
-0001fa30: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
-0001fa40: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
-0001fa50: 696e 6974 5f5f 282a 2a6b 7761 7267 7329  init__(**kwargs)
-0001fa60: 0a20 2020 2020 2020 2073 656c 662e 7479  .        self.ty
-0001fa70: 7065 203d 2074 700a 2020 2020 2020 2020  pe = tp.        
-0001fa80: 7365 6c66 2e61 7267 7320 3d20 6172 6773  self.args = args
-0001fa90: 0a20 2020 2020 2020 2073 656c 662e 7265  .        self.re
-0001faa0: 6e64 6572 696e 675f 6b77 203d 206b 7761  ndering_kw = kwa
-0001fab0: 7267 730a 0a20 2020 2064 6566 2067 6574  rgs..    def get
-0001fac0: 5f64 6174 6128 7365 6c66 293a 0a20 2020  _data(self):.   
-0001fad0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001fae0: 2e61 7267 730a 0a0a 636c 6173 7320 5269  .args...class Ri
-0001faf0: 656d 616e 6e53 7068 6572 6553 6572 6965  emannSphereSerie
-0001fb00: 7328 4261 7365 5365 7269 6573 293a 0a20  s(BaseSeries):. 
-0001fb10: 2020 2069 735f 636f 6d70 6c65 7820 3d20     is_complex = 
-0001fb20: 5472 7565 0a20 2020 2069 735f 646f 6d61  True.    is_doma
-0001fb30: 696e 5f63 6f6c 6f72 696e 6720 3d20 5472  in_coloring = Tr
-0001fb40: 7565 0a20 2020 2069 735f 3344 7375 7266  ue.    is_3Dsurf
-0001fb50: 6163 6520 3d20 5472 7565 0a20 2020 205f  ace = True.    _
-0001fb60: 4e20 3d20 3135 300a 2020 2020 5f61 6c6c  N = 150.    _all
-0001fb70: 6f77 6564 5f6b 6579 7320 3d20 5b0a 2020  owed_keys = [.  
-0001fb80: 2020 2020 2020 2263 6d61 7022 2c20 2263        "cmap", "c
-0001fb90: 6f6c 6f72 696e 6722 2c20 2262 6c65 7665  oloring", "bleve
-0001fba0: 6c22 2c20 2270 6861 7365 7265 7322 2c20  l", "phaseres", 
-0001fbb0: 2270 6861 7365 6f66 6673 6574 225d 0a0a  "phaseoffset"]..
-0001fbc0: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
-0001fbd0: 2873 656c 662c 2066 2c20 7261 6e67 655f  (self, f, range_
-0001fbe0: 742c 2072 616e 6765 5f70 2c20 2a2a 6b77  t, range_p, **kw
-0001fbf0: 6172 6773 293a 0a20 2020 2020 2020 2073  args):.        s
-0001fc00: 656c 662e 5f62 6c6f 636b 5f6c 616d 6264  elf._block_lambd
-0001fc10: 615f 6675 6e63 7469 6f6e 7328 6629 0a20  a_functions(f). 
-0001fc20: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
-0001fc30: 5f69 6e69 745f 5f28 2a2a 6b77 6172 6773  _init__(**kwargs
-0001fc40: 290a 2020 2020 2020 2020 6966 206c 656e  ).        if len
-0001fc50: 2866 2e66 7265 655f 7379 6d62 6f6c 7329  (f.free_symbols)
-0001fc60: 203e 2031 3a0a 2020 2020 2020 2020 2020   > 1:.          
-0001fc70: 2020 2320 4e4f 5445 3a20 636f 6e73 6964    # NOTE: consid
-0001fc80: 6572 696e 6720 686f 7720 636f 6d70 7574  ering how comput
-0001fc90: 6174 696f 6e61 6c6c 7920 6865 6176 7920  ationally heavy 
-0001fca0: 7468 6973 2073 6572 6965 7320 6973 2c0a  this series is,.
-0001fcb0: 2020 2020 2020 2020 2020 2020 2320 6974              # it
-0001fcc0: 2069 7320 7261 7468 6572 2075 6e75 7365   is rather unuse
-0001fcd0: 6675 6c20 746f 2061 6c6c 6f77 2069 6e74  ful to allow int
-0001fce0: 6572 6163 7469 7665 2d77 6964 6765 7473  eractive-widgets
-0001fcf0: 2070 6c6f 742e 0a20 2020 2020 2020 2020   plot..         
-0001fd00: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-0001fd10: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
-0001fd20: 2020 2020 2022 436f 6d70 6c65 7820 6675       "Complex fu
-0001fd30: 6e63 7469 6f6e 2063 616e 206f 6e6c 7920  nction can only 
-0001fd40: 6861 7665 206f 6e65 2066 7265 6520 7379  have one free sy
-0001fd50: 6d62 6f6c 2e20 220a 2020 2020 2020 2020  mbol. ".        
-0001fd60: 2020 2020 2020 2020 2252 6563 6569 7665          "Receive
-0001fd70: 6420 6672 6565 2073 796d 626f 6c73 3a20  d free symbols: 
-0001fd80: 2573 2220 2520 662e 6672 6565 5f73 796d  %s" % f.free_sym
-0001fd90: 626f 6c73 290a 2020 2020 2020 2020 7365  bols).        se
-0001fda0: 6c66 2e65 7870 7220 3d20 660a 2020 2020  lf.expr = f.    
-0001fdb0: 2020 2020 2320 4e4f 5445 3a20 7765 2063      # NOTE: we c
-0001fdc0: 616e 2065 6173 696c 7920 6372 6561 7465  an easily create
-0001fdd0: 2061 2073 7068 6572 6520 7769 7468 2061   a sphere with a
-0001fde0: 2073 696e 676c 6520 6461 7461 2073 6572   single data ser
-0001fdf0: 6965 732e 0a20 2020 2020 2020 2023 2048  ies..        # H
-0001fe00: 6f77 6576 6572 2c20 4b33 4442 6163 6b65  owever, K3DBacke
-0001fe10: 6e64 2069 7320 756e 6162 6c65 2074 6f20  nd is unable to 
-0001fe20: 7072 6f70 6572 6c79 2076 6973 7561 6c69  properly visuali
-0001fe30: 7a65 2069 742c 2061 6e64 2069 740a 2020  ze it, and it.  
-0001fe40: 2020 2020 2020 2320 776f 756c 6420 7265        # would re
-0001fe50: 7175 6972 6520 6120 6665 7720 686f 7572  quire a few hour
-0001fe60: 7320 6f66 2077 6f72 6b20 746f 2061 7070  s of work to app
-0001fe70: 6c79 2074 6865 206e 6563 6573 7361 7279  ly the necessary
-0001fe80: 2065 6469 7473 2e0a 2020 2020 2020 2020   edits..        
-0001fe90: 2320 496e 7374 6561 642c 2049 276d 2067  # Instead, I'm g
-0001fea0: 6f69 6e67 2074 6f20 6372 6561 7465 2074  oing to create t
-0001feb0: 776f 2073 7068 6572 6520 6361 7073 2028  wo sphere caps (
-0001fec0: 4e6f 7274 6865 6e20 616e 6420 536f 7574  Northen and Sout
-0001fed0: 6865 726e 0a20 2020 2020 2020 2023 2068  hern.        # h
-0001fee0: 656d 6973 7068 6572 6573 2c20 7265 7370  emispheres, resp
-0001fef0: 6563 7469 7665 6c79 292c 2068 656e 6365  ectively), hence
-0001ff00: 2074 6865 206e 6565 6420 666f 7220 7261   the need for ra
-0001ff10: 6e67 6573 203a 440a 2020 2020 2020 2020  nges :D.        
-0001ff20: 7365 6c66 2e72 616e 6765 7320 3d20 5b72  self.ranges = [r
-0001ff30: 616e 6765 5f74 2c20 7261 6e67 655f 705d  ange_t, range_p]
-0001ff40: 0a20 2020 2020 2020 2043 6f6d 706c 6578  .        Complex
-0001ff50: 446f 6d61 696e 436f 6c6f 7269 6e67 5365  DomainColoringSe
-0001ff60: 7269 6573 2e5f 696e 6974 5f64 6f6d 6169  ries._init_domai
-0001ff70: 6e5f 636f 6c6f 7269 6e67 5f6b 7728 7365  n_coloring_kw(se
-0001ff80: 6c66 2c20 2a2a 6b77 6172 6773 290a 2020  lf, **kwargs).  
-0001ff90: 2020 2020 2020 6966 2073 656c 662e 6e5b        if self.n[
-0001ffa0: 305d 203d 3d20 7365 6c66 2e6e 5b31 5d3a  0] == self.n[1]:
-0001ffb0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0001ffc0: 662e 6e20 3d20 5b73 656c 662e 6e5b 305d  f.n = [self.n[0]
-0001ffd0: 2c20 3420 2a20 7365 6c66 2e6e 5b30 5d5d  , 4 * self.n[0]]
-0001ffe0: 0a20 2020 2020 2020 2073 656c 662e 7573  .        self.us
-0001fff0: 655f 636d 203d 2054 7275 650a 0a20 2020  e_cm = True..   
-00020000: 2064 6566 2067 6574 5f64 6174 6128 7365   def get_data(se
-00020010: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-00020020: 5265 7475 726e 2061 7272 6179 7320 6f66  Return arrays of
-00020030: 2063 6f6f 7264 696e 6174 6573 2066 6f72   coordinates for
-00020040: 2070 6c6f 7474 696e 672e 0a0a 2020 2020   plotting...    
-00020050: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-00020060: 2020 2020 3d3d 3d3d 3d3d 3d0a 0a20 2020      =======..   
-00020070: 2020 2020 2078 2c20 792c 207a 203a 206e       x, y, z : n
-00020080: 702e 6e64 6172 7261 7920 5b6e 3220 7820  p.ndarray [n2 x 
-00020090: 6e31 5d0a 2020 2020 2020 2020 2020 2020  n1].            
-000200a0: 436f 6f72 6469 6e61 7465 7320 6f6e 2074  Coordinates on t
-000200b0: 6865 2075 6e69 7420 7370 6865 7265 2e0a  he unit sphere..
-000200c0: 0a20 2020 2020 2020 2061 7267 203a 206e  .        arg : n
-000200d0: 702e 6e64 6172 7261 7920 5b6e 3220 7820  p.ndarray [n2 x 
-000200e0: 6e31 5d0a 2020 2020 2020 2020 2020 2020  n1].            
-000200f0: 4172 6775 6d65 6e74 206f 6620 7468 6520  Argument of the 
-00020100: 6675 6e63 7469 6f6e 2e0a 0a20 2020 2020  function...     
-00020110: 2020 2069 6d67 203a 206e 702e 6e64 6172     img : np.ndar
-00020120: 7261 7920 5b6e 3220 7820 6e31 2078 2033  ray [n2 x n1 x 3
-00020130: 5d0a 2020 2020 2020 2020 2020 2020 5247  ].            RG
-00020140: 4220 696d 6167 6520 7661 6c75 6573 2063  B image values c
-00020150: 6f6d 7075 7465 6420 6672 6f6d 2074 6865  omputed from the
-00020160: 2061 7267 756d 656e 7420 6f66 2074 6865   argument of the
-00020170: 2066 756e 6374 696f 6e2e 0a20 2020 2020   function..     
-00020180: 2020 2020 2020 2030 203c 3d20 522c 2047         0 <= R, G
-00020190: 2c20 4220 3c3d 2032 3535 0a0a 2020 2020  , B <= 255..    
-000201a0: 2020 2020 636f 6c6f 7273 203a 206e 702e      colors : np.
-000201b0: 6e64 6172 7261 7920 5b32 3536 2078 2033  ndarray [256 x 3
-000201c0: 5d0a 2020 2020 2020 2020 2020 2020 436f  ].            Co
-000201d0: 6c6f 7220 7363 616c 6520 6173 736f 6369  lor scale associ
-000201e0: 6174 6564 2074 6f20 6069 6d67 602e 0a20  ated to `img`.. 
-000201f0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00020200: 2020 206e 7020 3d20 696d 706f 7274 5f6d     np = import_m
-00020210: 6f64 756c 6528 276e 756d 7079 2729 0a0a  odule('numpy')..
-00020220: 2020 2020 2020 2020 2320 6469 7363 7265          # discre
-00020230: 7469 7a65 2074 6865 2075 6e69 7420 7370  tize the unit sp
-00020240: 6865 7265 0a20 2020 2020 2020 2072 203d  here.        r =
-00020250: 2031 0a20 2020 2020 2020 2023 2054 4f44   1.        # TOD
-00020260: 4f3a 2074 6869 7320 7061 7261 6d65 7465  O: this paramete
-00020270: 7269 7a61 7469 6f6e 2070 6c61 6365 7320  rization places 
-00020280: 6120 6c6f 7420 6f66 2070 6f69 6e74 7320  a lot of points 
-00020290: 6e65 6172 2074 6865 2070 6f6c 6573 0a20  near the poles. 
-000202a0: 2020 2020 2020 2023 2062 7574 206e 6f74         # but not
-000202b0: 2065 6e6f 7567 6820 6e65 6172 2074 6865   enough near the
-000202c0: 2065 7175 6174 6f72 2e20 4361 6e20 6120   equator. Can a 
-000202d0: 6469 6666 6572 656e 7420 7061 7261 6d65  different parame
-000202e0: 7465 7269 7a61 7469 6f6e 0a20 2020 2020  terization.     
-000202f0: 2020 2023 2069 6d70 726f 7665 7320 7468     # improves th
-00020300: 6520 6669 6e61 6c20 7265 7375 6c74 2c20  e final result, 
-00020310: 6d61 7962 6520 6576 656e 2072 6564 7563  maybe even reduc
-00020320: 696e 6720 7468 6520 636f 6d70 7574 6174  ing the computat
-00020330: 696f 6e61 6c0a 2020 2020 2020 2020 2320  ional.        # 
-00020340: 636f 7374 3f0a 2020 2020 2020 2020 7473  cost?.        ts
-00020350: 2c20 7465 203d 205b 666c 6f61 7428 7429  , te = [float(t)
-00020360: 2066 6f72 2074 2069 6e20 7365 6c66 2e72   for t in self.r
-00020370: 616e 6765 735b 305d 5b31 3a5d 5d0a 2020  anges[0][1:]].  
-00020380: 2020 2020 2020 7073 2c20 7065 203d 205b        ps, pe = [
-00020390: 666c 6f61 7428 7429 2066 6f72 2074 2069  float(t) for t i
-000203a0: 6e20 7365 6c66 2e72 616e 6765 735b 315d  n self.ranges[1]
-000203b0: 5b31 3a5d 5d0a 2020 2020 2020 2020 742c  [1:]].        t,
-000203c0: 2070 203d 206e 702e 6d67 7269 645b 7473   p = np.mgrid[ts
-000203d0: 3a74 653a 7365 6c66 2e6e 5b30 5d2a 316a  :te:self.n[0]*1j
-000203e0: 2c20 7073 3a70 653a 7365 6c66 2e6e 5b31  , ps:pe:self.n[1
-000203f0: 5d2a 316a 5d0a 2020 2020 2020 2020 5820  ]*1j].        X 
-00020400: 3d20 7220 2a20 6e70 2e73 696e 2874 2920  = r * np.sin(t) 
-00020410: 2a20 6e70 2e63 6f73 2870 290a 2020 2020  * np.cos(p).    
-00020420: 2020 2020 5920 3d20 7220 2a20 6e70 2e73      Y = r * np.s
-00020430: 696e 2874 2920 2a20 6e70 2e73 696e 2870  in(t) * np.sin(p
-00020440: 290a 2020 2020 2020 2020 5a20 3d20 7220  ).        Z = r 
-00020450: 2a20 6e70 2e63 6f73 2874 290a 2020 2020  * np.cos(t).    
-00020460: 2020 2020 2320 7374 6572 656f 6772 6170      # stereograp
-00020470: 6869 6320 7072 6f6a 6563 7469 6f6e 0a20  hic projection. 
-00020480: 2020 2020 2020 2023 2054 4f44 4f3a 2073         # TODO: s
-00020490: 7570 7072 6573 7320 7761 726e 696e 6773  uppress warnings
-000204a0: 0a20 2020 2020 2020 2078 203d 2058 202f  .        x = X /
-000204b0: 2028 3120 2d20 5a29 0a20 2020 2020 2020   (1 - Z).       
-000204c0: 2079 203d 2059 202f 2028 3120 2d20 5a29   y = Y / (1 - Z)
-000204d0: 0a20 2020 2020 2020 2023 2065 7661 6c75  .        # evalu
-000204e0: 6174 696f 6e20 6f76 6572 2074 6865 2063  ation over the c
-000204f0: 6f6d 706c 6578 2070 6c61 6e65 0a20 2020  omplex plane.   
-00020500: 2020 2020 2023 204e 4f54 453a 205f 756e       # NOTE: _un
-00020510: 6966 6f72 6d5f 6576 616c 2073 686f 756c  iform_eval shoul
-00020520: 6420 6265 2075 7365 642c 2061 7320 6974  d be used, as it
-00020530: 2069 7320 6162 6c65 2074 6f20 6465 616c   is able to deal
-00020540: 2077 6974 680a 2020 2020 2020 2020 2320   with.        # 
-00020550: 6469 6666 6572 656e 7420 6576 616c 7561  different evalua
-00020560: 7469 6f6e 206d 6f64 756c 6573 2e20 486f  tion modules. Ho
-00020570: 7765 7665 722c 2074 6861 7420 6d65 7468  wever, that meth
-00020580: 6f64 2069 7320 6d75 6368 2073 6c6f 7765  od is much slowe
-00020590: 720a 2020 2020 2020 2020 2320 7468 616e  r.        # than
-000205a0: 2076 616e 696c 6c61 2d4e 756d 7079 2077   vanilla-Numpy w
-000205b0: 6974 6820 7665 6374 6f72 697a 6174 696f  ith vectorizatio
-000205c0: 6e2c 2065 7665 6e20 7768 656e 2075 7369  n, even when usi
-000205d0: 6e67 204e 756d 7079 2e0a 2020 2020 2020  ng Numpy..      
-000205e0: 2020 2320 546f 2067 6574 2064 6563 656e    # To get decen
-000205f0: 7420 7265 7375 6c74 732c 2074 6865 2066  t results, the f
-00020600: 756e 6374 696f 6e20 6d75 7374 2062 6520  unction must be 
-00020610: 6576 616c 7561 7465 6420 6f6e 2061 2062  evaluated on a b
-00020620: 6967 0a20 2020 2020 2020 2023 206e 756d  ig.        # num
-00020630: 6265 7220 6f66 2064 6973 6372 6574 697a  ber of discretiz
-00020640: 6174 696f 6e20 706f 696e 7473 2c20 7768  ation points, wh
-00020650: 6963 6820 6175 746f 6d61 7469 6361 6c6c  ich automaticall
-00020660: 7920 7072 6563 6c75 6465 730a 2020 2020  y precludes.    
-00020670: 2020 2020 2320 6d70 6d61 7468 206f 7220      # mpmath or 
-00020680: 7379 6d70 792e 2048 656e 6365 2c20 6a75  sympy. Hence, ju
-00020690: 7374 2075 7365 2062 6172 6520 626f 6e65  st use bare bone
-000206a0: 7320 4e75 6d70 792c 2065 7665 6e20 7468  s Numpy, even th
-000206b0: 6f75 6768 2074 6869 730a 2020 2020 2020  ough this.      
-000206c0: 2020 2320 6d6f 6475 6c65 206d 6967 6874    # module might
-000206d0: 206e 6f74 2069 6d70 6c65 6d65 6e74 2061   not implement a
-000206e0: 6c6c 2074 6865 2069 6e74 6572 6573 7469  ll the interesti
-000206f0: 6e67 2066 756e 6374 696f 6e73 2e0a 2020  ng functions..  
-00020700: 2020 2020 2020 7a20 3d20 7820 2b20 316a        z = x + 1j
-00020710: 202a 2079 0a20 2020 2020 2020 2066 203d   * y.        f =
-00020720: 206c 616d 6264 6966 7928 6c69 7374 2873   lambdify(list(s
-00020730: 656c 662e 6578 7072 2e66 7265 655f 7379  elf.expr.free_sy
-00020740: 6d62 6f6c 7329 5b30 5d2c 2073 656c 662e  mbols)[0], self.
-00020750: 6578 7072 290a 2020 2020 2020 2020 7720  expr).        w 
-00020760: 3d20 6628 7a29 0a20 2020 2020 2020 2069  = f(z).        i
-00020770: 6d67 2c20 6373 203d 2077 6567 6572 7428  mg, cs = wegert(
-00020780: 7365 6c66 2e63 6f6c 6f72 696e 672c 2077  self.coloring, w
-00020790: 2c20 7365 6c66 2e70 6861 7365 7265 732c  , self.phaseres,
-000207a0: 2073 656c 662e 636d 6170 290a 2020 2020   self.cmap).    
-000207b0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000207c0: 5f61 7070 6c79 5f74 7261 6e73 666f 726d  _apply_transform
-000207d0: 2858 2c20 592c 205a 2c20 6e70 2e61 6e67  (X, Y, Z, np.ang
-000207e0: 6c65 2877 292c 2069 6d67 2c20 6373 290a  le(w), img, cs).
-000207f0: 0a0a 636c 6173 7320 4856 4c69 6e65 5365  ..class HVLineSe
-00020800: 7269 6573 2842 6173 6553 6572 6965 7329  ries(BaseSeries)
-00020810: 3a0a 2020 2020 2222 2252 6570 7265 7365  :.    """Represe
-00020820: 6e74 2061 6e20 686f 7269 7a6f 6e74 616c  nt an horizontal
-00020830: 206f 7220 7665 7274 6963 616c 206c 696e   or vertical lin
-00020840: 6520 7365 7269 6573 2e0a 2020 2020 496e  e series..    In
-00020850: 204d 6174 706c 6f74 6c69 622c 2074 6869   Matplotlib, thi
-00020860: 7320 7769 6c6c 2062 6520 7265 6e64 6572  s will be render
-00020870: 6564 2062 7920 6178 686c 696e 6520 6f72  ed by axhline or
-00020880: 2061 7876 6c69 6e65 2e0a 2020 2020 2222   axvline..    ""
-00020890: 220a 2020 2020 6465 6620 5f5f 696e 6974  ".    def __init
-000208a0: 5f5f 2873 656c 662c 2076 2c20 686f 7269  __(self, v, hori
-000208b0: 7a6f 6e74 616c 2c20 6c61 6265 6c3d 2222  zontal, label=""
-000208c0: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
-000208d0: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
-000208e0: 6e69 745f 5f28 2a2a 6b77 6172 6773 290a  nit__(**kwargs).
-000208f0: 2020 2020 2020 2020 7365 6c66 2e5f 6578          self._ex
-00020900: 7072 203d 2073 796d 7069 6679 2876 290a  pr = sympify(v).
-00020910: 2020 2020 2020 2020 7365 6c66 2e69 735f          self.is_
-00020920: 686f 7269 7a6f 6e74 616c 203d 2068 6f72  horizontal = hor
-00020930: 697a 6f6e 7461 6c0a 2020 2020 2020 2020  izontal.        
-00020940: 7365 6c66 2e5f 6c61 6265 6c20 3d20 7374  self._label = st
-00020950: 7228 7365 6c66 2e65 7870 7229 2069 6620  r(self.expr) if 
-00020960: 6c61 6265 6c20 6973 204e 6f6e 6520 656c  label is None el
-00020970: 7365 206c 6162 656c 0a20 2020 2020 2020  se label.       
-00020980: 2073 656c 662e 5f6c 6174 6578 5f6c 6162   self._latex_lab
-00020990: 656c 203d 206c 6174 6578 2873 656c 662e  el = latex(self.
-000209a0: 6578 7072 2920 6966 206c 6162 656c 2069  expr) if label i
-000209b0: 7320 4e6f 6e65 2065 6c73 6520 6c61 6265  s None else labe
-000209c0: 6c0a 0a20 2020 2064 6566 2067 6574 5f64  l..    def get_d
-000209d0: 6174 6128 7365 6c66 293a 0a20 2020 2020  ata(self):.     
-000209e0: 2020 206c 6f63 6174 696f 6e20 3d20 7365     location = se
-000209f0: 6c66 2e65 7870 720a 2020 2020 2020 2020  lf.expr.        
-00020a00: 6966 2073 656c 662e 6973 5f69 6e74 6572  if self.is_inter
-00020a10: 6163 7469 7665 3a0a 2020 2020 2020 2020  active:.        
-00020a20: 2020 2020 6c6f 6361 7469 6f6e 203d 2073      location = s
-00020a30: 656c 662e 6578 7072 2e73 7562 7328 7365  elf.expr.subs(se
-00020a40: 6c66 2e70 6172 616d 7329 0a20 2020 2020  lf.params).     
-00020a50: 2020 2072 6574 7572 6e20 666c 6f61 7428     return float(
-00020a60: 6c6f 6361 7469 6f6e 290a 0a20 2020 2064  location)..    d
-00020a70: 6566 205f 5f73 7472 5f5f 2873 656c 6629  ef __str__(self)
-00020a80: 3a0a 2020 2020 2020 2020 7072 6520 3d20  :.        pre = 
-00020a90: 2268 6f72 697a 6f6e 7461 6c22 2069 6620  "horizontal" if 
-00020aa0: 7365 6c66 2e69 735f 686f 7269 7a6f 6e74  self.is_horizont
-00020ab0: 616c 2065 6c73 6520 2276 6572 7469 6361  al else "vertica
-00020ac0: 6c22 0a20 2020 2020 2020 2070 6f73 7420  l".        post 
-00020ad0: 3d20 2279 203d 2022 2069 6620 7365 6c66  = "y = " if self
-00020ae0: 2e69 735f 686f 7269 7a6f 6e74 616c 2065  .is_horizontal e
-00020af0: 6c73 6520 2278 203d 2022 0a20 2020 2020  lse "x = ".     
-00020b00: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00020b10: 7374 725f 6865 6c70 6572 2870 7265 202b  str_helper(pre +
-00020b20: 2022 206c 696e 6520 6174 2022 202b 2070   " line at " + p
-00020b30: 6f73 7420 2b20 7374 7228 7365 6c66 2e65  ost + str(self.e
-00020b40: 7870 7229 290a 0a0a 636c 6173 7320 4172  xpr))...class Ar
-00020b50: 726f 7732 4453 6572 6965 7328 4261 7365  row2DSeries(Base
-00020b60: 5365 7269 6573 293a 0a20 2020 2022 2222  Series):.    """
-00020b70: 5265 7072 6573 656e 7420 616e 2061 7272  Represent an arr
-00020b80: 6f77 2069 6e20 6120 3244 2073 7061 6365  ow in a 2D space
-00020b90: 2e0a 2020 2020 2222 220a 0a20 2020 2069  ..    """..    i
-00020ba0: 735f 3244 7665 6374 6f72 203d 2054 7275  s_2Dvector = Tru
-00020bb0: 650a 2020 2020 5f61 6c6c 6f77 6564 5f6b  e.    _allowed_k
-00020bc0: 6579 7320 3d20 5b22 6e6f 726d 616c 697a  eys = ["normaliz
-00020bd0: 6522 5d0a 0a20 2020 2064 6566 205f 5f69  e"]..    def __i
-00020be0: 6e69 745f 5f28 7365 6c66 2c20 7374 6172  nit__(self, star
-00020bf0: 742c 2064 6972 6563 7469 6f6e 2c20 6c61  t, direction, la
-00020c00: 6265 6c3d 2222 2c20 2a2a 6b77 6172 6773  bel="", **kwargs
-00020c10: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
-00020c20: 2829 2e5f 5f69 6e69 745f 5f28 2a2a 6b77  ().__init__(**kw
-00020c30: 6172 6773 290a 2020 2020 2020 2020 6e70  args).        np
-00020c40: 203d 2069 6d70 6f72 745f 6d6f 6475 6c65   = import_module
-00020c50: 2827 6e75 6d70 7927 290a 2020 2020 2020  ('numpy').      
-00020c60: 2020 6966 206c 656e 2873 7461 7274 2920    if len(start) 
-00020c70: 213d 206c 656e 2864 6972 6563 7469 6f6e  != len(direction
-00020c80: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-00020c90: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-00020ca0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00020cb0: 2022 6073 7461 7274 6020 616e 6420 6064   "`start` and `d
-00020cc0: 6972 6563 7469 6f6e 6020 6d75 7374 2068  irection` must h
-00020cd0: 6176 6520 7468 6520 7361 6d65 206e 756d  ave the same num
-00020ce0: 6265 7220 6f66 2065 6c65 6d65 6e74 732e  ber of elements.
-00020cf0: 5c6e 220a 2020 2020 2020 2020 2020 2020  \n".            
-00020d00: 2020 2020 6622 5265 6365 6976 6564 3a20      f"Received: 
-00020d10: 6c65 6e28 7374 6172 7429 203d 207b 6c65  len(start) = {le
-00020d20: 6e28 7374 6172 7429 7d20 220a 2020 2020  n(start)} ".    
-00020d30: 2020 2020 2020 2020 2020 2020 6622 616e              f"an
-00020d40: 6420 6c65 6e28 6469 7265 6374 696f 6e29  d len(direction)
-00020d50: 203d 207b 6c65 6e28 6469 7265 6374 696f   = {len(directio
-00020d60: 6e29 7d22 0a20 2020 2020 2020 2020 2020  n)}".           
-00020d70: 2029 0a20 2020 2020 2020 2073 656c 662e   ).        self.
-00020d80: 5f62 6c6f 636b 5f6c 616d 6264 615f 6675  _block_lambda_fu
-00020d90: 6e63 7469 6f6e 7328 7374 6172 742c 2064  nctions(start, d
-00020da0: 6972 6563 7469 6f6e 290a 2020 2020 2020  irection).      
-00020db0: 2020 6368 6563 6b20 3d20 6c61 6d62 6461    check = lambda
-00020dc0: 206c 3a20 5b0a 2020 2020 2020 2020 2020   l: [.          
-00020dd0: 2020 6973 696e 7374 616e 6365 2874 2c20    isinstance(t, 
-00020de0: 4578 7072 2920 616e 6420 286e 6f74 2074  Expr) and (not t
-00020df0: 2e69 735f 6e75 6d62 6572 2920 666f 7220  .is_number) for 
-00020e00: 7420 696e 206c 0a20 2020 2020 2020 205d  t in l.        ]
-00020e10: 0a20 2020 2020 2020 2069 6620 616e 7928  .        if any(
-00020e20: 6368 6563 6b28 7374 6172 7429 202b 2063  check(start) + c
-00020e30: 6865 636b 2864 6972 6563 7469 6f6e 2929  heck(direction))
-00020e40: 206f 7220 7365 6c66 2e70 6172 616d 733a   or self.params:
-00020e50: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00020e60: 6e6f 7420 7365 6c66 2e70 6172 616d 733a  not self.params:
-00020e70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00020e80: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00020e90: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
-00020ea0: 2020 2020 2020 2022 536f 6d65 206f 7220         "Some or 
-00020eb0: 616c 6c20 656c 656d 656e 7473 206f 6620  all elements of 
-00020ec0: 7468 6520 7072 6f76 6964 6564 2063 6f6f  the provided coo
-00020ed0: 7264 696e 6174 6573 2022 0a20 2020 2020  rdinates ".     
-00020ee0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00020ef0: 6172 6520 7379 6d62 6f6c 6963 2065 7870  are symbolic exp
-00020f00: 7265 7373 696f 6e73 2c20 6275 7420 7468  ressions, but th
-00020f10: 6520 6060 7061 7261 6d73 6060 2064 6963  e ``params`` dic
-00020f20: 7469 6f6e 6172 7920 220a 2020 2020 2020  tionary ".      
-00020f30: 2020 2020 2020 2020 2020 2020 2020 2277                "w
-00020f40: 6173 206e 6f74 2070 726f 7669 6465 643a  as not provided:
-00020f50: 2074 686f 7365 2065 6c65 6d65 6e74 7320   those elements 
-00020f60: 6361 6e27 7420 6265 2065 7661 6c75 6174  can't be evaluat
-00020f70: 6564 2e22 0a20 2020 2020 2020 2020 2020  ed.".           
-00020f80: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00020f90: 2020 2073 656c 662e 7374 6172 7420 3d20     self.start = 
-00020fa0: 5475 706c 6528 2a73 7461 7274 290a 2020  Tuple(*start).  
-00020fb0: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
-00020fc0: 6972 6563 7469 6f6e 203d 2054 7570 6c65  irection = Tuple
-00020fd0: 282a 6469 7265 6374 696f 6e29 0a20 2020  (*direction).   
-00020fe0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00020ff0: 2020 2020 2020 2073 656c 662e 7374 6172         self.star
-00021000: 7420 3d20 6e70 2e61 7272 6179 2873 7461  t = np.array(sta
-00021010: 7274 2c20 6474 7970 653d 6e70 2e66 6c6f  rt, dtype=np.flo
-00021020: 6174 3634 290a 2020 2020 2020 2020 2020  at64).          
-00021030: 2020 7365 6c66 2e64 6972 6563 7469 6f6e    self.direction
-00021040: 203d 206e 702e 6172 7261 7928 6469 7265   = np.array(dire
-00021050: 6374 696f 6e2c 2064 7479 7065 3d6e 702e  ction, dtype=np.
-00021060: 666c 6f61 7436 3429 0a0a 2020 2020 2020  float64)..      
-00021070: 2020 7365 6c66 2e5f 6578 7072 203d 2028    self._expr = (
-00021080: 7365 6c66 2e73 7461 7274 2c20 7365 6c66  self.start, self
-00021090: 2e64 6972 6563 7469 6f6e 290a 2020 2020  .direction).    
-000210a0: 2020 2020 6966 206e 6f74 2061 6e79 2869      if not any(i
-000210b0: 7369 6e73 7461 6e63 6528 742c 206e 702e  sinstance(t, np.
-000210c0: 6e64 6172 7261 7929 2066 6f72 2074 2069  ndarray) for t i
-000210d0: 6e20 5b73 656c 662e 7374 6172 742c 2073  n [self.start, s
-000210e0: 656c 662e 6469 7265 6374 696f 6e5d 293a  elf.direction]):
-000210f0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00021100: 662e 5f63 6865 636b 5f66 7328 290a 2020  f._check_fs().  
-00021110: 2020 2020 2020 6966 206c 6162 656c 3a0a        if label:.
-00021120: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00021130: 2e6c 6162 656c 203d 206c 6162 656c 0a20  .label = label. 
-00021140: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00021150: 2020 2020 2020 2020 2023 206c 6162 656c           # label
-00021160: 3a20 2866 726f 6d29 202d 3e20 2874 6f29  : (from) -> (to)
-00021170: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00021180: 662e 5f6c 6162 656c 203d 2028 0a20 2020  f._label = (.   
-00021190: 2020 2020 2020 2020 2020 2020 2022 287b               "({
-000211a0: 7d29 202d 3e20 287b 7d29 222e 666f 726d  }) -> ({})".form
-000211b0: 6174 280a 2020 2020 2020 2020 2020 2020  at(.            
-000211c0: 2020 2020 2020 2020 222c 2022 2e6a 6f69          ", ".joi
-000211d0: 6e28 5b73 7472 2874 2920 666f 7220 7420  n([str(t) for t 
-000211e0: 696e 2073 656c 662e 7374 6172 745d 292c  in self.start]),
-000211f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021200: 2020 2020 2022 2c20 222e 6a6f 696e 285b       ", ".join([
-00021210: 7374 7228 7520 2b20 7629 2066 6f72 2075  str(u + v) for u
-00021220: 2c20 7620 696e 207a 6970 280a 2020 2020  , v in zip(.    
-00021230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021240: 2020 2020 7365 6c66 2e73 7461 7274 2c20      self.start, 
-00021250: 7365 6c66 2e64 6972 6563 7469 6f6e 295d  self.direction)]
-00021260: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00021270: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00021280: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
-00021290: 6c66 2e5f 6c61 7465 785f 6c61 6265 6c20  lf._latex_label 
-000212a0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-000212b0: 2020 2020 7222 5c6c 6566 7428 7b7d 5c72      r"\left({}\r
-000212c0: 6967 6874 2920 5c72 6967 6874 6172 726f  ight) \rightarro
-000212d0: 7720 5c6c 6566 7428 7b7d 5c72 6967 6874  w \left({}\right
-000212e0: 2922 2e66 6f72 6d61 7428 0a20 2020 2020  )".format(.     
-000212f0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00021300: 2c20 222e 6a6f 696e 285b 6c61 7465 7828  , ".join([latex(
-00021310: 7429 2066 6f72 2074 2069 6e20 7365 6c66  t) for t in self
-00021320: 2e73 7461 7274 5d29 2c0a 2020 2020 2020  .start]),.      
-00021330: 2020 2020 2020 2020 2020 2020 2020 222c                ",
-00021340: 2022 2e6a 6f69 6e28 5b6c 6174 6578 2875   ".join([latex(u
-00021350: 202b 2076 2920 666f 7220 752c 2076 2069   + v) for u, v i
-00021360: 6e20 7a69 7028 0a20 2020 2020 2020 2020  n zip(.         
-00021370: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00021380: 656c 662e 7374 6172 742c 2073 656c 662e  elf.start, self.
-00021390: 6469 7265 6374 696f 6e29 5d29 0a20 2020  direction)]).   
-000213a0: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
-000213b0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-000213c0: 2020 2020 2073 656c 662e 7573 655f 7175       self.use_qu
-000213d0: 6976 6572 5f73 6f6c 6964 5f63 6f6c 6f72  iver_solid_color
-000213e0: 203d 206e 6f74 2073 656c 662e 7573 655f   = not self.use_
-000213f0: 636d 0a20 2020 2020 2020 2073 656c 662e  cm.        self.
-00021400: 6e6f 726d 616c 697a 6520 3d20 6b77 6172  normalize = kwar
-00021410: 6773 2e67 6574 2822 6e6f 726d 616c 697a  gs.get("normaliz
-00021420: 6522 2c20 4661 6c73 6529 0a20 2020 2020  e", False).     
-00021430: 2020 2023 2054 4f44 4f3a 2044 6f20 4920     # TODO: Do I 
-00021440: 4e65 6564 2074 6869 733f 0a20 2020 2020  Need this?.     
-00021450: 2020 2073 656c 662e 6973 5f73 7472 6561     self.is_strea
-00021460: 6d6c 696e 6573 203d 206b 7761 7267 732e  mlines = kwargs.
-00021470: 6765 7428 2273 7472 6561 6d6c 696e 6573  get("streamlines
-00021480: 222c 2046 616c 7365 290a 0a20 2020 2064  ", False)..    d
-00021490: 6566 205f 5f73 7472 5f5f 2873 656c 6629  ef __str__(self)
-000214a0: 3a0a 2020 2020 2020 2020 7072 6520 3d20  :.        pre = 
-000214b0: 2233 4420 2220 6966 2073 656c 662e 6973  "3D " if self.is
-000214c0: 5f33 4420 656c 7365 2022 3244 2022 0a20  _3D else "2D ". 
-000214d0: 2020 2020 2020 2073 7461 7274 203d 2074         start = t
-000214e0: 7570 6c65 2873 656c 662e 7374 6172 7429  uple(self.start)
-000214f0: 0a20 2020 2020 2020 2065 6e64 203d 2074  .        end = t
-00021500: 7570 6c65 2873 202b 2064 2066 6f72 2073  uple(s + d for s
-00021510: 2c20 6420 696e 207a 6970 2873 7461 7274  , d in zip(start
-00021520: 2c20 7365 6c66 2e64 6972 6563 7469 6f6e  , self.direction
-00021530: 2929 0a20 2020 2020 2020 2072 6574 7572  )).        retur
-00021540: 6e20 7365 6c66 2e5f 7374 725f 6865 6c70  n self._str_help
-00021550: 6572 280a 2020 2020 2020 2020 2020 2020  er(.            
-00021560: 7072 6520 2b20 6622 6172 726f 7720 6672  pre + f"arrow fr
-00021570: 6f6d 207b 7374 6172 747d 2074 6f20 7b65  om {start} to {e
-00021580: 6e64 7d22 0a20 2020 2020 2020 2029 0a0a  nd}".        )..
-00021590: 2020 2020 6465 6620 6765 745f 6c61 6265      def get_labe
-000215a0: 6c28 7365 6c66 2c20 7573 655f 6c61 7465  l(self, use_late
-000215b0: 783d 4661 6c73 652c 2077 7261 7070 6572  x=False, wrapper
-000215c0: 3d22 2425 7324 2229 3a0a 2020 2020 2020  ="$%s$"):.      
-000215d0: 2020 2222 2252 6574 7572 6e20 7468 6520    """Return the 
-000215e0: 6c61 6265 6c20 746f 2062 6520 7573 6564  label to be used
-000215f0: 2074 6f20 6469 7370 6c61 7920 7468 6520   to display the 
-00021600: 6578 7072 6573 7369 6f6e 2e0a 0a20 2020  expression...   
-00021610: 2020 2020 2050 6172 616d 6574 6572 730a       Parameters.
-00021620: 2020 2020 2020 2020 3d3d 3d3d 3d3d 3d3d          ========
-00021630: 3d3d 0a20 2020 2020 2020 2075 7365 5f6c  ==.        use_l
-00021640: 6174 6578 203a 2062 6f6f 6c0a 2020 2020  atex : bool.    
-00021650: 2020 2020 2020 2020 4966 2046 616c 7365          If False
-00021660: 2c20 7468 6520 7374 7269 6e67 2072 6570  , the string rep
-00021670: 7265 7365 6e74 6174 696f 6e20 6f66 2074  resentation of t
-00021680: 6865 2065 7870 7265 7373 696f 6e20 6973  he expression is
-00021690: 2072 6574 7572 6e65 642e 0a20 2020 2020   returned..     
-000216a0: 2020 2020 2020 2049 6620 5472 7565 2c20         If True, 
-000216b0: 7468 6520 6c61 7465 7820 7265 7072 6573  the latex repres
-000216c0: 656e 7461 7469 6f6e 2069 7320 7265 7475  entation is retu
-000216d0: 726e 6564 2e0a 2020 2020 2020 2020 7772  rned..        wr
-000216e0: 6170 7065 7220 3a20 7374 720a 2020 2020  apper : str.    
-000216f0: 2020 2020 2020 2020 5468 6520 6261 636b          The back
-00021700: 656e 6420 6d69 6768 7420 6e65 6564 2074  end might need t
-00021710: 6865 206c 6174 6578 2072 6570 7265 7365  he latex represe
-00021720: 6e74 6174 696f 6e20 746f 2062 6520 7772  ntation to be wr
-00021730: 6170 7065 6420 6279 0a20 2020 2020 2020  apped by.       
-00021740: 2020 2020 2073 6f6d 6520 6368 6172 6163       some charac
-00021750: 7465 7273 2e20 4465 6661 756c 7420 746f  ters. Default to
-00021760: 2060 6022 2425 7324 2260 602e 0a0a 2020   ``"$%s$"``...  
-00021770: 2020 2020 2020 5265 7475 726e 730a 2020        Returns.  
-00021780: 2020 2020 2020 3d3d 3d3d 3d3d 3d0a 2020        =======.  
-00021790: 2020 2020 2020 6c61 6265 6c20 3a20 7374        label : st
-000217a0: 720a 2020 2020 2020 2020 2222 220a 2020  r.        """.  
-000217b0: 2020 2020 2020 6966 2075 7365 5f6c 6174        if use_lat
-000217c0: 6578 2069 7320 4661 6c73 653a 0a20 2020  ex is False:.   
-000217d0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-000217e0: 7365 6c66 2e5f 6c61 6265 6c0a 2020 2020  self._label.    
-000217f0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00021800: 5f67 6574 5f77 7261 7070 6564 5f6c 6162  _get_wrapped_lab
-00021810: 656c 2873 656c 662e 5f6c 6174 6578 5f6c  el(self._latex_l
-00021820: 6162 656c 2c20 7772 6170 7065 7229 0a0a  abel, wrapper)..
-00021830: 2020 2020 6465 6620 6765 745f 6461 7461      def get_data
-00021840: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00021850: 2222 2252 6574 7572 6e20 6172 7261 7973  """Return arrays
-00021860: 206f 6620 636f 6f72 6469 6e61 7465 7320   of coordinates 
-00021870: 666f 7220 706c 6f74 7469 6e67 2e0a 0a20  for plotting... 
-00021880: 2020 2020 2020 2052 6574 7572 6e73 0a20         Returns. 
-00021890: 2020 2020 2020 203d 3d3d 3d3d 3d3d 0a20         =======. 
-000218a0: 2020 2020 2020 2078 312c 2079 312c 207a         x1, y1, z
-000218b0: 3120 5b6f 7074 696f 6e61 6c5d 203a 2066  1 [optional] : f
-000218c0: 6c6f 6174 0a20 2020 2020 2020 2020 2020  loat.           
-000218d0: 2043 6f6f 7264 696e 6174 6573 206f 6620   Coordinates of 
-000218e0: 7468 6520 7374 6172 7420 706f 7369 7469  the start positi
-000218f0: 6f6e 2e0a 2020 2020 2020 2020 7832 2c20  on..        x2, 
-00021900: 7932 2c20 7a32 205b 6f70 7469 6f6e 616c  y2, z2 [optional
-00021910: 5d20 3a20 666c 6f61 740a 2020 2020 2020  ] : float.      
-00021920: 2020 2020 2020 436f 6f72 6469 6e61 7465        Coordinate
-00021930: 7320 6f66 2074 6865 2065 6e64 2070 6f73  s of the end pos
-00021940: 6974 696f 6e2e 0a20 2020 2020 2020 2022  ition..        "
-00021950: 2222 0a20 2020 2020 2020 206e 7020 3d20  "".        np = 
-00021960: 696d 706f 7274 5f6d 6f64 756c 6528 276e  import_module('n
-00021970: 756d 7079 2729 0a20 2020 2020 2020 2073  umpy').        s
-00021980: 7461 7274 2c20 6469 7265 6374 696f 6e20  tart, direction 
-00021990: 3d20 7365 6c66 2e73 7461 7274 2c20 7365  = self.start, se
-000219a0: 6c66 2e64 6972 6563 7469 6f6e 0a0a 2020  lf.direction..  
-000219b0: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
-000219c0: 662e 6973 5f69 6e74 6572 6163 7469 7665  f.is_interactive
-000219d0: 3a0a 2020 2020 2020 2020 2020 2020 7374  :.            st
-000219e0: 6172 742c 2064 6972 6563 7469 6f6e 203d  art, direction =
-000219f0: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
-00021a00: 2020 206e 702e 6172 7261 7928 742c 2064     np.array(t, d
-00021a10: 7479 7065 3d66 6c6f 6174 2920 666f 7220  type=float) for 
-00021a20: 7420 696e 205b 7374 6172 742c 2064 6972  t in [start, dir
-00021a30: 6563 7469 6f6e 5d0a 2020 2020 2020 2020  ection].        
-00021a40: 2020 2020 5d0a 2020 2020 2020 2020 656c      ].        el
-00021a50: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00021a60: 7374 6172 7420 3d20 6e70 2e61 7272 6179  start = np.array
-00021a70: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00021a80: 2020 5b74 2e65 7661 6c66 2873 7562 733d    [t.evalf(subs=
-00021a90: 7365 6c66 2e70 6172 616d 7329 2066 6f72  self.params) for
-00021aa0: 2074 2069 6e20 7374 6172 745d 2c20 6474   t in start], dt
-00021ab0: 7970 653d 666c 6f61 7429 0a20 2020 2020  ype=float).     
-00021ac0: 2020 2020 2020 2064 6972 6563 7469 6f6e         direction
-00021ad0: 203d 206e 702e 6172 7261 7928 0a20 2020   = np.array(.   
-00021ae0: 2020 2020 2020 2020 2020 2020 205b 742e               [t.
-00021af0: 6576 616c 6628 7375 6273 3d73 656c 662e  evalf(subs=self.
-00021b00: 7061 7261 6d73 2920 666f 7220 7420 696e  params) for t in
-00021b10: 2064 6972 6563 7469 6f6e 5d2c 2064 7479   direction], dty
-00021b20: 7065 3d66 6c6f 6174 290a 0a20 2020 2020  pe=float)..     
-00021b30: 2020 2065 6e64 203d 2073 7461 7274 202b     end = start +
-00021b40: 2064 6972 6563 7469 6f6e 0a20 2020 2020   direction.     
-00021b50: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00021b60: 6170 706c 795f 7472 616e 7366 6f72 6d28  apply_transform(
-00021b70: 2a73 7461 7274 2c20 2a65 6e64 290a 0a0a  *start, *end)...
-00021b80: 636c 6173 7320 4172 726f 7733 4453 6572  class Arrow3DSer
-00021b90: 6965 7328 4172 726f 7732 4453 6572 6965  ies(Arrow2DSerie
-00021ba0: 7329 3a0a 2020 2020 2222 2252 6570 7265  s):.    """Repre
-00021bb0: 7365 6e74 2061 6e20 6172 726f 7720 696e  sent an arrow in
-00021bc0: 2061 2033 4420 7370 6163 652e 0a20 2020   a 3D space..   
-00021bd0: 2022 2222 0a20 2020 2069 735f 3344 203d   """.    is_3D =
-00021be0: 2054 7275 650a 2020 2020 6973 5f32 4476   True.    is_2Dv
-00021bf0: 6563 746f 7220 3d20 4661 6c73 650a 2020  ector = False.  
-00021c00: 2020 6973 5f33 4476 6563 746f 7220 3d20    is_3Dvector = 
-00021c10: 5472 7565 0a0a 2020 2020 6465 6620 6765  True..    def ge
-00021c20: 745f 6461 7461 2873 656c 6629 3a0a 2020  t_data(self):.  
-00021c30: 2020 2020 2020 2222 2252 6574 7572 6e20        """Return 
-00021c40: 6172 7261 7973 206f 6620 636f 6f72 6469  arrays of coordi
-00021c50: 6e61 7465 7320 666f 7220 706c 6f74 7469  nates for plotti
-00021c60: 6e67 2e0a 0a20 2020 2020 2020 2052 6574  ng...        Ret
-00021c70: 7572 6e73 0a20 2020 2020 2020 203d 3d3d  urns.        ===
-00021c80: 3d3d 3d3d 0a20 2020 2020 2020 2078 2c20  ====.        x, 
-00021c90: 792c 207a 203a 2066 6c6f 6174 0a20 2020  y, z : float.   
-00021ca0: 2020 2020 2020 2020 2043 6f6f 7264 696e           Coordin
-00021cb0: 6174 6573 206f 6620 7468 6520 7374 6172  ates of the star
-00021cc0: 7420 706f 7369 7469 6f6e 2e0a 2020 2020  t position..    
-00021cd0: 2020 2020 752c 2076 2c20 7720 3a20 666c      u, v, w : fl
-00021ce0: 6f61 740a 2020 2020 2020 2020 2020 2020  oat.            
-00021cf0: 436f 6f72 6469 6e61 7465 7320 6f66 2074  Coordinates of t
-00021d00: 6865 2065 6e64 2070 6f73 6974 696f 6e2e  he end position.
-00021d10: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00021d20: 2020 2020 2072 6574 7572 6e20 7375 7065       return supe
-00021d30: 7228 292e 6765 745f 6461 7461 2829 0a0a  r().get_data()..
-00021d40: 0a63 6c61 7373 2047 7269 6442 6173 653a  .class GridBase:
-00021d50: 0a20 2020 2022 2222 0a20 2020 202a 4772  .    """.    *Gr
-00021d60: 6964 4c69 6e65 5365 7269 6573 206d 6179  idLineSeries may
-00021d70: 2063 6f76 6572 2074 6865 2065 6e74 6972   cover the entir
-00021d80: 6520 7669 7369 626c 6520 6172 6561 2e20  e visible area. 
-00021d90: 4865 6e63 652c 2074 6865 7920 6e65 6564  Hence, they need
-00021da0: 2074 6f0a 2020 2020 6b6e 6f77 2074 6865   to.    know the
-00021db0: 2061 7869 7320 6c69 6d69 7473 2e0a 0a20   axis limits... 
-00021dc0: 2020 2041 7869 7320 6c69 6d69 7473 2063     Axis limits c
-00021dd0: 616e 2062 653a 0a20 2020 2031 2e20 7072  an be:.    1. pr
-00021de0: 6f76 6964 6564 2062 7920 7468 6520 7573  ovided by the us
-00021df0: 6572 2069 6e20 7468 6520 706c 6f74 2066  er in the plot f
-00021e00: 756e 6374 696f 6e20 6361 6c6c 2e20 466f  unction call. Fo
-00021e10: 7220 6578 616d 706c 653a 0a20 2020 2020  r example:.     
-00021e20: 2020 6060 706c 6f74 282e 2e2e 2c20 786c    ``plot(..., xl
-00021e30: 696d 3d28 612c 2062 292c 2079 6c69 6d3d  im=(a, b), ylim=
-00021e40: 2863 2c20 6429 2960 600a 2020 2020 322e  (c, d))``.    2.
-00021e50: 2063 6f6d 7075 7465 6420 6672 6f6d 2074   computed from t
-00021e60: 6865 2064 6174 6120 7468 6174 2068 6173  he data that has
-00021e70: 2061 6c72 6561 6479 2062 6520 706c 6f74   already be plot
-00021e80: 7465 642e 0a20 2020 2033 2e20 7072 6f76  ted..    3. prov
-00021e90: 6964 6564 2069 6e20 736f 6d65 2066 756e  ided in some fun
-00021ea0: 6374 696f 6e20 6361 6c6c 2074 6861 7420  ction call that 
-00021eb0: 6765 6e65 7261 7465 7320 6461 7461 2073  generates data s
-00021ec0: 6572 6965 732e 2046 6f72 2065 7861 6d70  eries. For examp
-00021ed0: 6c65 3a0a 2020 2020 2020 2060 6067 7261  le:.       ``gra
-00021ee0: 7068 6963 7328 7367 7269 6428 786c 696d  phics(sgrid(xlim
-00021ef0: 3d28 612c 2062 292c 2079 6c69 6d3d 2863  =(a, b), ylim=(c
-00021f00: 2c20 6429 2929 6060 0a0a 2020 2020 4569  , d)))``..    Ei
-00021f10: 7468 6572 2077 6179 2c20 7468 6520 6170  ther way, the ap
-00021f20: 7072 6f70 7269 6174 6520 7265 6e64 6572  propriate render
-00021f30: 6572 2077 696c 6c3a 0a0a 2020 2020 312e  er will:..    1.
-00021f40: 2066 6967 7572 6520 6974 206f 7574 2074   figure it out t
-00021f50: 6865 2061 7869 7320 6c69 6d69 7473 2e0a  he axis limits..
-00021f60: 2020 2020 322e 204c 6574 2074 6865 2067      2. Let the g
-00021f70: 7269 6420 7365 7269 6573 206b 6e6f 7773  rid series knows
-00021f80: 2061 626f 7574 2074 6869 7320 6c69 6d69   about this limi
-00021f90: 7473 2062 7920 6361 6c6c 696e 670a 2020  ts by calling.  
-00021fa0: 2020 2020 2060 6073 6572 6965 732e 7365       ``series.se
-00021fb0: 745f 6178 6973 5f6c 696d 6974 7328 786c  t_axis_limits(xl
-00021fc0: 696d 2c20 796c 696d 2960 602e 0a20 2020  im, ylim)``..   
-00021fd0: 2033 2e20 436f 6d70 7574 6520 7468 6520   3. Compute the 
-00021fe0: 6e75 6d65 7269 6361 6c20 6461 7461 2066  numerical data f
-00021ff0: 6f72 2074 6865 2073 7065 6369 6669 6564  or the specified
-00022000: 2067 7269 6420 7468 6174 2063 6f76 6572   grid that cover
-00022010: 2074 6865 0a20 2020 2020 2020 7370 6563   the.       spec
-00022020: 6966 6965 6420 6172 6561 2c20 7769 7468  ified area, with
-00022030: 2060 6073 6572 6965 732e 6765 745f 6461   ``series.get_da
-00022040: 7461 2829 6060 2e0a 0a20 2020 2022 2222  ta()``...    """
-00022050: 0a20 2020 2069 735f 6772 6964 203d 2054  .    is_grid = T
-00022060: 7275 650a 0a20 2020 2064 6566 205f 5f69  rue..    def __i
-00022070: 6e69 745f 5f28 7365 6c66 2c20 2a61 7267  nit__(self, *arg
-00022080: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
-00022090: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
-000220a0: 696e 6974 5f5f 282a 6172 6773 2c20 2a2a  init__(*args, **
-000220b0: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
-000220c0: 7365 6c66 2e73 686f 775f 696e 5f6c 6567  self.show_in_leg
-000220d0: 656e 6420 3d20 6b77 6172 6773 2e67 6574  end = kwargs.get
-000220e0: 2822 7368 6f77 5f69 6e5f 6c65 6765 6e64  ("show_in_legend
-000220f0: 222c 2046 616c 7365 290a 2020 2020 2020  ", False).      
-00022100: 2020 786c 696d 203d 206b 7761 7267 732e    xlim = kwargs.
-00022110: 6765 7428 2278 6c69 6d22 2c20 4e6f 6e65  get("xlim", None
-00022120: 290a 2020 2020 2020 2020 796c 696d 203d  ).        ylim =
-00022130: 206b 7761 7267 732e 6765 7428 2279 6c69   kwargs.get("yli
-00022140: 6d22 2c20 4e6f 6e65 290a 2020 2020 2020  m", None).      
-00022150: 2020 2320 4a75 7079 7465 7220 6c61 6220    # Jupyter lab 
-00022160: 2b20 2266 726f 6d20 7379 6d70 7920 696d  + "from sympy im
-00022170: 706f 7274 202a 2220 636f 6e76 6572 7420  port *" convert 
-00022180: 616c 6c20 6e75 6d62 6572 7320 746f 0a20  all numbers to. 
-00022190: 2020 2020 2020 2023 2073 796d 7079 2773         # sympy's
-000221a0: 2074 7970 6573 2e20 5468 6520 616c 676f   types. The algo
-000221b0: 7269 7468 6d20 6578 7065 6374 6573 2074  rithm expectes t
-000221c0: 6865 6d20 746f 2062 6520 6066 6c6f 6174  hem to be `float
-000221d0: 602e 0a20 2020 2020 2020 2073 656c 662e  `..        self.
-000221e0: 5f78 6c69 6d20 3d20 5b66 6c6f 6174 2874  _xlim = [float(t
-000221f0: 2920 666f 7220 7420 696e 2078 6c69 6d5d  ) for t in xlim]
-00022200: 2069 6620 786c 696d 2065 6c73 6520 4e6f   if xlim else No
-00022210: 6e65 0a20 2020 2020 2020 2073 656c 662e  ne.        self.
-00022220: 5f79 6c69 6d20 3d20 5b66 6c6f 6174 2874  _ylim = [float(t
-00022230: 2920 666f 7220 7420 696e 2079 6c69 6d5d  ) for t in ylim]
-00022240: 2069 6620 796c 696d 2065 6c73 6520 4e6f   if ylim else No
-00022250: 6e65 0a0a 2020 2020 6465 6620 7365 745f  ne..    def set_
-00022260: 6178 6973 5f6c 696d 6974 7328 7365 6c66  axis_limits(self
-00022270: 2c20 786c 696d 2c20 796c 696d 293a 0a20  , xlim, ylim):. 
-00022280: 2020 2020 2020 2073 656c 662e 5f78 6c69         self._xli
-00022290: 6d20 3d20 786c 696d 0a20 2020 2020 2020  m = xlim.       
-000222a0: 2073 656c 662e 5f79 6c69 6d20 3d20 796c   self._ylim = yl
-000222b0: 696d 0a0a 2020 2020 4070 726f 7065 7274  im..    @propert
-000222c0: 790a 2020 2020 6465 6620 786c 696d 2873  y.    def xlim(s
-000222d0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-000222e0: 7475 726e 2073 656c 662e 5f78 6c69 6d0a  turn self._xlim.
-000222f0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00022300: 2020 2064 6566 2079 6c69 6d28 7365 6c66     def ylim(self
-00022310: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-00022320: 6e20 7365 6c66 2e5f 796c 696d 0a0a 0a63  n self._ylim...c
-00022330: 6c61 7373 2053 4772 6964 4c69 6e65 5365  lass SGridLineSe
-00022340: 7269 6573 2847 7269 6442 6173 652c 2042  ries(GridBase, B
-00022350: 6173 6553 6572 6965 7329 3a0a 2020 2020  aseSeries):.    
-00022360: 2222 2252 6570 7265 7365 6e74 2061 2067  """Represent a g
-00022370: 7269 6420 6f66 2064 616d 7069 6e67 2072  rid of damping r
-00022380: 6174 696f 206c 696e 6573 2061 6e64 206e  atio lines and n
-00022390: 6174 7572 616c 2066 7265 7175 656e 6379  atural frequency
-000223a0: 206c 696e 6573 0a20 2020 206f 6e20 7468   lines.    on th
-000223b0: 6520 732d 706c 616e 652e 2054 6869 7320  e s-plane. This 
-000223c0: 6461 7461 2073 6572 6965 7320 696d 706c  data series impl
-000223d0: 656d 656e 7473 2074 776f 206d 6f64 6573  ements two modes
-000223e0: 206f 6620 6f70 6572 6174 696f 6e3a 0a0a   of operation:..
-000223f0: 2020 2020 312e 2055 7365 7220 6361 6e20      1. User can 
-00022400: 7072 6f76 6964 6520 7869 2c20 776e 2e0a  provide xi, wn..
-00022410: 2020 2020 322e 2055 7365 7220 6361 6e20      2. User can 
-00022420: 7072 6f76 6964 6520 6475 6d6d 7920 7869  provide dummy xi
-00022430: 2c20 776e 2c20 616e 6420 6120 6c69 7374  , wn, and a list
-00022440: 206f 6620 6173 736f 6369 6174 6564 2052   of associated R
-00022450: 6f6f 744c 6f63 7573 5365 7269 6573 2e0a  ootLocusSeries..
-00022460: 2020 2020 2020 2057 6865 6e20 6060 6765         When ``ge
-00022470: 745f 6461 7461 2829 6060 2077 696c 6c20  t_data()`` will 
-00022480: 6265 2063 616c 6c65 642c 2069 7420 6669  be called, it fi
-00022490: 7273 7420 6c6f 6f70 7320 6f76 6572 2074  rst loops over t
-000224a0: 6865 2061 7373 6f63 6961 7465 640a 2020  he associated.  
-000224b0: 2020 2020 2072 6f6f 7420 6c6f 6375 7320       root locus 
-000224c0: 7365 7269 6573 2069 6e20 6f72 6465 7220  series in order 
-000224d0: 746f 2064 6574 6572 6d69 6e65 2074 6865  to determine the
-000224e0: 2061 7869 7320 6c69 6d69 7473 206f 6620   axis limits of 
-000224f0: 7468 6520 7669 7369 626c 650a 2020 2020  the visible.    
-00022500: 2020 2061 7265 612e 2054 6865 6e2c 2069     area. Then, i
-00022510: 7420 636f 6d70 7574 6573 206e 6577 2076  t computes new v
-00022520: 616c 7565 7320 6f66 2078 692c 2077 6e20  alues of xi, wn 
-00022530: 696e 206f 7264 6572 2074 6f20 6765 7420  in order to get 
-00022540: 6772 6964 206c 696e 6573 0a20 2020 2020  grid lines.     
-00022550: 2020 2265 7665 6e6c 7922 2064 6973 7472    "evenly" distr
-00022560: 6962 7574 6564 206f 6e20 7468 6520 6176  ibuted on the av
-00022570: 6169 6c61 626c 6520 7370 6163 652e 0a20  ailable space.. 
-00022580: 2020 2022 2222 0a0a 2020 2020 6465 6620     """..    def 
-00022590: 5f5f 696e 6974 5f5f 2873 656c 662c 2078  __init__(self, x
-000225a0: 692c 2077 6e2c 2074 702c 2074 732c 2073  i, wn, tp, ts, s
-000225b0: 6572 6965 733d 5b5d 2c20 2a2a 6b77 6172  eries=[], **kwar
-000225c0: 6773 293a 0a20 2020 2020 2020 2073 7570  gs):.        sup
-000225d0: 6572 2829 2e5f 5f69 6e69 745f 5f28 2a2a  er().__init__(**
-000225e0: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
-000225f0: 7365 6c66 2e78 6920 3d20 7869 0a20 2020  self.xi = xi.   
-00022600: 2020 2020 2073 656c 662e 776e 203d 2077       self.wn = w
-00022610: 6e0a 2020 2020 2020 2020 7365 6c66 2e74  n.        self.t
-00022620: 7020 3d20 7470 0a20 2020 2020 2020 2073  p = tp.        s
-00022630: 656c 662e 7473 203d 2074 730a 2020 2020  elf.ts = ts.    
-00022640: 2020 2020 2320 7768 6574 6865 7220 636f      # whether co
-00022650: 6d70 7574 6573 2078 692f 776e 2069 6e20  mputes xi/wn in 
-00022660: 6f72 6465 7220 746f 2065 7665 6e6c 7920  order to evenly 
-00022670: 6469 7374 7269 6275 7465 206c 696e 6573  distribute lines
-00022680: 206f 7665 720a 2020 2020 2020 2020 2320   over.        # 
-00022690: 7468 6520 6176 6169 6c61 626c 6520 706c  the available pl
-000226a0: 6f74 2d61 7265 610a 2020 2020 2020 2020  ot-area.        
-000226b0: 7365 6c66 2e61 7574 6f20 3d20 6b77 6172  self.auto = kwar
-000226c0: 6773 2e67 6574 2822 6175 746f 222c 2046  gs.get("auto", F
-000226d0: 616c 7365 290a 2020 2020 2020 2020 7365  alse).        se
-000226e0: 6c66 2e73 686f 775f 636f 6e74 726f 6c5f  lf.show_control_
-000226f0: 6178 6973 203d 206b 7761 7267 732e 6765  axis = kwargs.ge
-00022700: 7428 2273 686f 775f 636f 6e74 726f 6c5f  t("show_control_
-00022710: 6178 6973 222c 2046 616c 7365 290a 0a20  axis", False).. 
-00022720: 2020 2064 6566 205f 5f73 7472 5f5f 2873     def __str__(s
-00022730: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-00022740: 7475 726e 2022 732d 6772 6964 220a 0a20  turn "s-grid".. 
-00022750: 2020 2064 6566 205f 7367 7269 645f 6465     def _sgrid_de
-00022760: 6661 756c 745f 7869 2873 656c 662c 2078  fault_xi(self, x
-00022770: 6c69 6d2c 2079 6c69 6d29 3a0a 2020 2020  lim, ylim):.    
-00022780: 2020 2020 2222 2252 6574 7572 6e20 6465      """Return de
-00022790: 6661 756c 7420 6c69 7374 206f 6620 6461  fault list of da
-000227a0: 6d70 696e 6720 636f 6566 6669 6369 656e  mping coefficien
-000227b0: 7473 0a0a 2020 2020 2020 2020 5468 6973  ts..        This
-000227c0: 2066 756e 6374 696f 6e20 636f 6d70 7574   function comput
-000227d0: 6573 2061 206c 6973 7420 6f66 2064 616d  es a list of dam
-000227e0: 7069 6e67 2063 6f65 6666 6963 6965 6e74  ping coefficient
-000227f0: 7320 6261 7365 6420 6f6e 2074 6865 206c  s based on the l
-00022800: 696d 6974 730a 2020 2020 2020 2020 6f66  imits.        of
-00022810: 2074 6865 2067 7261 7068 2e20 2041 2073   the graph.  A s
-00022820: 6574 206f 6620 3420 6461 6d70 696e 6720  et of 4 damping 
-00022830: 636f 6566 6669 6369 656e 7473 2061 7265  coefficients are
-00022840: 2063 6f6d 7075 7465 6420 666f 7220 7468   computed for th
-00022850: 6520 782d 6178 6973 0a20 2020 2020 2020  e x-axis.       
-00022860: 2061 6e64 2061 2073 6574 206f 6620 7468   and a set of th
-00022870: 7265 6520 6461 6d70 696e 6720 636f 6566  ree damping coef
-00022880: 6669 6369 656e 7473 2061 7265 2063 6f6d  ficients are com
-00022890: 7075 7465 6420 666f 7220 7468 6520 792d  puted for the y-
-000228a0: 6178 6973 0a20 2020 2020 2020 2028 636f  axis.        (co
-000228b0: 7272 6573 706f 6e64 696e 6720 746f 2074  rresponding to t
-000228c0: 6865 206e 6f72 6d61 6c20 343a 3320 706c  he normal 4:3 pl
-000228d0: 6f74 2061 7370 6563 7420 7261 7469 6f20  ot aspect ratio 
-000228e0: 696e 2060 6d61 7470 6c6f 746c 6962 603f  in `matplotlib`?
-000228f0: 292e 0a0a 2020 2020 2020 2020 5061 7261  )...        Para
-00022900: 6d65 7465 7273 0a20 2020 2020 2020 202d  meters.        -
-00022910: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
-00022920: 2020 786c 696d 203a 2061 7272 6179 5f6c    xlim : array_l
-00022930: 696b 650a 2020 2020 2020 2020 2020 2020  ike.            
-00022940: 4c69 7374 206f 6620 782d 6178 6973 206c  List of x-axis l
-00022950: 696d 6974 7320 5b6d 696e 2c20 6d61 785d  imits [min, max]
-00022960: 0a20 2020 2020 2020 2079 6c69 6d20 3a20  .        ylim : 
-00022970: 6172 7261 795f 6c69 6b65 0a20 2020 2020  array_like.     
-00022980: 2020 2020 2020 204c 6973 7420 6f66 2079         List of y
-00022990: 2d61 7869 7320 6c69 6d69 7473 205b 6d69  -axis limits [mi
-000229a0: 6e2c 206d 6178 5d0a 0a20 2020 2020 2020  n, max]..       
-000229b0: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
-000229c0: 202d 2d2d 2d2d 2d2d 0a20 2020 2020 2020   -------.       
-000229d0: 207a 6574 6120 3a20 6c69 7374 0a20 2020   zeta : list.   
-000229e0: 2020 2020 2020 2020 204c 6973 7420 6f66           List of
-000229f0: 2064 6566 6175 6c74 2064 616d 7069 6e67   default damping
-00022a00: 2063 6f65 6666 6963 6965 6e74 7320 666f   coefficients fo
-00022a10: 7220 7468 6520 706c 6f74 0a0a 2020 2020  r the plot..    
-00022a20: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00022a30: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
-00022a40: 6c65 2822 6e75 6d70 7922 290a 0a20 2020  le("numpy")..   
-00022a50: 2020 2020 2078 5f6c 6f77 6572 5f6c 696d       x_lower_lim
-00022a60: 203d 2078 6c69 6d5b 305d 2069 6620 786c   = xlim[0] if xl
-00022a70: 696d 2065 6c73 6520 2d31 300a 2020 2020  im else -10.    
-00022a80: 2020 2020 795f 7570 7065 725f 6c69 6d20      y_upper_lim 
-00022a90: 3d20 796c 696d 5b31 5d20 6966 2079 6c69  = ylim[1] if yli
-00022aa0: 6d20 656c 7365 2031 300a 0a20 2020 2020  m else 10..     
-00022ab0: 2020 2023 2044 616d 7069 6e67 2063 6f65     # Damping coe
-00022ac0: 6666 6963 6965 6e74 206c 696e 6573 2074  fficient lines t
-00022ad0: 6861 7420 696e 7465 7273 6563 7420 7468  hat intersect th
-00022ae0: 6520 782d 6178 6973 0a20 2020 2020 2020  e x-axis.       
-00022af0: 2073 6570 3120 3d20 2d78 5f6c 6f77 6572   sep1 = -x_lower
-00022b00: 5f6c 696d 202f 2034 0a20 2020 2020 2020  _lim / 4.       
-00022b10: 2061 6e67 3120 3d20 5b6e 702e 6172 6374   ang1 = [np.arct
-00022b20: 616e 2828 7365 7031 2a69 292f 795f 7570  an((sep1*i)/y_up
-00022b30: 7065 725f 6c69 6d29 2066 6f72 2069 2069  per_lim) for i i
-00022b40: 6e20 6e70 2e61 7261 6e67 6528 312c 2034  n np.arange(1, 4
-00022b50: 2c20 3129 5d0a 0a20 2020 2020 2020 2023  , 1)]..        #
-00022b60: 2044 616d 7069 6e67 2063 6f65 6666 6963   Damping coeffic
-00022b70: 6965 6e74 206c 696e 6573 2074 6861 7420  ient lines that 
-00022b80: 696e 7465 7273 6563 7469 6f6e 2074 6865  intersection the
-00022b90: 2079 2d61 7869 730a 2020 2020 2020 2020   y-axis.        
-00022ba0: 7365 7032 203d 2079 5f75 7070 6572 5f6c  sep2 = y_upper_l
-00022bb0: 696d 202f 2033 0a20 2020 2020 2020 2061  im / 3.        a
-00022bc0: 6e67 3220 3d20 5b0a 2020 2020 2020 2020  ng2 = [.        
-00022bd0: 2020 2020 6e70 2e61 7263 7461 6e28 2d78      np.arctan(-x
-00022be0: 5f6c 6f77 6572 5f6c 696d 2f28 795f 7570  _lower_lim/(y_up
-00022bf0: 7065 725f 6c69 6d2d 7365 7032 2a69 2929  per_lim-sep2*i))
-00022c00: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-00022c10: 2069 2069 6e20 6e70 2e61 7261 6e67 6528   i in np.arange(
-00022c20: 312c 2033 2c20 3129 0a20 2020 2020 2020  1, 3, 1).       
-00022c30: 205d 0a0a 2020 2020 2020 2020 2320 5075   ]..        # Pu
-00022c40: 7420 7468 6520 6c69 6e65 7320 746f 6765  t the lines toge
-00022c50: 7468 6572 2061 6e64 2061 6464 206f 6e65  ther and add one
-00022c60: 2061 7420 2d70 692f 3220 286e 6567 6174   at -pi/2 (negat
-00022c70: 6976 6520 7265 616c 2061 7869 7329 0a20  ive real axis). 
-00022c80: 2020 2020 2020 2061 6e67 6c65 7320 3d20         angles = 
-00022c90: 6e70 2e63 6f6e 6361 7465 6e61 7465 2828  np.concatenate((
-00022ca0: 616e 6731 2c20 616e 6732 2929 0a0a 2020  ang1, ang2))..  
-00022cb0: 2020 2020 2020 2320 5265 7475 726e 2074        # Return t
-00022cc0: 6865 2064 616d 7069 6e67 2063 6f65 6666  he damping coeff
-00022cd0: 6963 6965 6e74 7320 636f 7272 6573 706f  icients correspo
-00022ce0: 6e64 696e 6720 746f 2074 6865 7365 2061  nding to these a
-00022cf0: 6e67 6c65 730a 2020 2020 2020 2020 7a65  ngles.        ze
-00022d00: 7461 203d 206e 702e 7369 6e28 616e 676c  ta = np.sin(angl
-00022d10: 6573 292e 746f 6c69 7374 2829 0a20 2020  es).tolist().   
-00022d20: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
-00022d30: 2e73 686f 775f 636f 6e74 726f 6c5f 6178  .show_control_ax
-00022d40: 6973 3a0a 2020 2020 2020 2020 2020 2020  is:.            
-00022d50: 7a65 7461 202b 3d20 5b30 2c20 315d 0a20  zeta += [0, 1]. 
-00022d60: 2020 2020 2020 2072 6574 7572 6e20 7a65         return ze
-00022d70: 7461 0a0a 2020 2020 6465 6620 5f73 6772  ta..    def _sgr
-00022d80: 6964 5f64 6566 6175 6c74 5f77 6e28 7365  id_default_wn(se
-00022d90: 6c66 2c20 786c 696d 2c20 796c 696d 2c20  lf, xlim, ylim, 
-00022da0: 6d61 785f 6c69 6e65 733d 3729 3a0a 2020  max_lines=7):.  
-00022db0: 2020 2020 2020 2222 2252 6574 7572 6e20        """Return 
-00022dc0: 6465 6661 756c 7420 776e 2066 6f72 2072  default wn for r
-00022dd0: 6f6f 7420 6c6f 6375 7320 706c 6f74 0a0a  oot locus plot..
-00022de0: 2020 2020 2020 2020 5468 6973 2066 756e          This fun
-00022df0: 6374 696f 6e20 636f 6d70 7574 6573 2061  ction computes a
-00022e00: 206c 6973 7420 6f66 206e 6174 7572 616c   list of natural
-00022e10: 2066 7265 7175 656e 6369 6573 2062 6173   frequencies bas
-00022e20: 6564 206f 6e20 7468 6520 6772 6964 0a20  ed on the grid. 
-00022e30: 2020 2020 2020 2070 6172 616d 6574 6572         parameter
-00022e40: 7320 6f66 2074 6865 2067 7261 7068 2e0a  s of the graph..
-00022e50: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
-00022e60: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
-00022e70: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2078  ------.        x
-00022e80: 6c6f 6320 3a20 6172 7261 795f 6c69 6b65  loc : array_like
-00022e90: 0a20 2020 2020 2020 2020 2020 204c 6973  .            Lis
-00022ea0: 7420 6f66 2078 2d61 7869 7320 7469 636b  t of x-axis tick
-00022eb0: 2076 616c 7565 730a 2020 2020 2020 2020   values.        
-00022ec0: 796c 696d 203a 2061 7272 6179 5f6c 696b  ylim : array_lik
-00022ed0: 650a 2020 2020 2020 2020 2020 2020 4c69  e.            Li
-00022ee0: 7374 206f 6620 792d 6178 6973 206c 696d  st of y-axis lim
-00022ef0: 6974 7320 5b6d 696e 2c20 6d61 785d 0a20  its [min, max]. 
-00022f00: 2020 2020 2020 206d 6178 5f6c 696e 6573         max_lines
-00022f10: 203a 2069 6e74 2c20 6f70 7469 6f6e 616c   : int, optional
-00022f20: 0a20 2020 2020 2020 2020 2020 204d 6178  .            Max
-00022f30: 696d 756d 206e 756d 6265 7220 6f66 2066  imum number of f
-00022f40: 7265 7175 656e 6369 6573 2074 6f20 6765  requencies to ge
-00022f50: 6e65 7261 7465 2028 6465 6661 756c 7420  nerate (default 
-00022f60: 3d20 3729 0a0a 2020 2020 2020 2020 5265  = 7)..        Re
-00022f70: 7475 726e 730a 2020 2020 2020 2020 2d2d  turns.        --
-00022f80: 2d2d 2d2d 2d0a 2020 2020 2020 2020 776e  -----.        wn
-00022f90: 203a 206c 6973 740a 2020 2020 2020 2020   : list.        
-00022fa0: 2020 2020 4c69 7374 206f 6620 6465 6661      List of defa
-00022fb0: 756c 7420 6e61 7475 7261 6c20 6672 6571  ult natural freq
-00022fc0: 7565 6e63 6965 7320 666f 7220 7468 6520  uencies for the 
-00022fd0: 706c 6f74 0a0a 2020 2020 2020 2020 2222  plot..        ""
-00022fe0: 220a 2020 2020 2020 2020 6c6f 7765 725f  ".        lower_
-00022ff0: 6c69 6d20 3d20 786c 696d 5b30 5d20 6966  lim = xlim[0] if
-00023000: 2078 6c69 6d20 656c 7365 202d 3130 0a20   xlim else -10. 
-00023010: 2020 2020 2020 206e 7020 3d20 696d 706f         np = impo
-00023020: 7274 5f6d 6f64 756c 6528 226e 756d 7079  rt_module("numpy
-00023030: 2229 0a20 2020 2020 2020 2061 7661 696c  ").        avail
-00023040: 6162 6c65 5f77 6964 7468 203d 2030 202d  able_width = 0 -
-00023050: 206c 6f77 6572 5f6c 696d 0a20 2020 2020   lower_lim.     
-00023060: 2020 2077 6e20 3d20 6e70 2e6c 696e 7370     wn = np.linsp
-00023070: 6163 6528 302c 2061 6273 286c 6f77 6572  ace(0, abs(lower
-00023080: 5f6c 696d 292c 206d 6178 5f6c 696e 6573  _lim), max_lines
-00023090: 295b 313a 2d31 5d0a 2020 2020 2020 2020  )[1:-1].        
-000230a0: 7265 7475 726e 2077 6e0a 0a20 2020 2064  return wn..    d
-000230b0: 6566 2067 6574 5f64 6174 6128 7365 6c66  ef get_data(self
-000230c0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-000230d0: 2020 2020 2020 2052 6574 7572 6e73 0a20         Returns. 
-000230e0: 2020 2020 2020 203d 3d3d 3d3d 3d3d 0a20         =======. 
-000230f0: 2020 2020 2020 2078 695f 6469 6374 203a         xi_dict :
-00023100: 2064 6963 740a 2020 2020 2020 2020 776e   dict.        wn
-00023110: 5f64 6963 7420 3a20 6469 6374 0a20 2020  _dict : dict.   
-00023120: 2020 2020 2079 5f74 7020 3a20 6e70 2e6e       y_tp : np.n
-00023130: 6461 7272 6179 0a20 2020 2020 2020 2078  darray.        x
-00023140: 5f74 7320 3a20 6e70 2e6e 6461 7272 6179  _ts : np.ndarray
-00023150: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00023160: 2020 2020 206e 7020 3d20 696d 706f 7274       np = import
-00023170: 5f6d 6f64 756c 6528 226e 756d 7079 2229  _module("numpy")
-00023180: 0a0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
-00023190: 662e 6175 746f 3a0a 2020 2020 2020 2020  f.auto:.        
-000231a0: 2020 2020 7869 203d 2073 656c 662e 5f73      xi = self._s
-000231b0: 6772 6964 5f64 6566 6175 6c74 5f78 6928  grid_default_xi(
-000231c0: 7365 6c66 2e78 6c69 6d2c 2073 656c 662e  self.xlim, self.
-000231d0: 796c 696d 290a 2020 2020 2020 2020 2020  ylim).          
-000231e0: 2020 776e 203d 2073 656c 662e 5f73 6772    wn = self._sgr
-000231f0: 6964 5f64 6566 6175 6c74 5f77 6e28 7365  id_default_wn(se
-00023200: 6c66 2e78 6c69 6d2c 2073 656c 662e 796c  lf.xlim, self.yl
-00023210: 696d 290a 2020 2020 2020 2020 656c 7365  im).        else
-00023220: 3a0a 2020 2020 2020 2020 2020 2020 7869  :.            xi
-00023230: 203d 206e 702e 6172 7261 7928 5b0a 2020   = np.array([.  
-00023240: 2020 2020 2020 2020 2020 2020 2020 742e                t.
-00023250: 6576 616c 6628 7375 6273 3d73 656c 662e  evalf(subs=self.
-00023260: 7061 7261 6d73 2920 6966 2069 7369 6e73  params) if isins
-00023270: 7461 6e63 6528 742c 2045 7870 7229 2065  tance(t, Expr) e
-00023280: 6c73 6520 740a 2020 2020 2020 2020 2020  lse t.          
-00023290: 2020 2020 2020 666f 7220 7420 696e 2073        for t in s
-000232a0: 656c 662e 7869 5d2c 2064 7479 7065 3d66  elf.xi], dtype=f
-000232b0: 6c6f 6174 290a 2020 2020 2020 2020 2020  loat).          
-000232c0: 2020 6966 2061 6e79 2878 6920 3e20 3129    if any(xi > 1)
-000232d0: 206f 7220 616e 7928 7869 203c 2030 293a   or any(xi < 0):
-000232e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000232f0: 2023 2045 6e66 6f72 6365 2074 6869 7320   # Enforce this 
-00023300: 636f 6e64 6974 696f 6e0a 2020 2020 2020  condition.      
-00023310: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00023320: 5661 6c75 6545 7272 6f72 2822 4974 206d  ValueError("It m
-00023330: 7573 7420 6265 2060 6030 203c 3d20 7869  ust be ``0 <= xi
-00023340: 203c 3d20 312e 2022 0a20 2020 2020 2020   <= 1. ".       
-00023350: 2020 2020 2020 2020 2020 2020 2022 436f               "Co
-00023360: 6d70 7574 6564 3a20 2573 2220 2520 7869  mputed: %s" % xi
-00023370: 290a 2020 2020 2020 2020 2020 2020 776e  ).            wn
-00023380: 203d 206e 702e 6172 7261 7928 5b0a 2020   = np.array([.  
-00023390: 2020 2020 2020 2020 2020 2020 2020 742e                t.
-000233a0: 6576 616c 6628 7375 6273 3d73 656c 662e  evalf(subs=self.
-000233b0: 7061 7261 6d73 2920 6966 2069 7369 6e73  params) if isins
-000233c0: 7461 6e63 6528 742c 2045 7870 7229 2065  tance(t, Expr) e
-000233d0: 6c73 6520 740a 2020 2020 2020 2020 2020  lse t.          
-000233e0: 2020 2020 2020 666f 7220 7420 696e 2073        for t in s
-000233f0: 656c 662e 776e 5d2c 2064 7479 7065 3d66  elf.wn], dtype=f
-00023400: 6c6f 6174 290a 2020 2020 2020 2020 7470  loat).        tp
-00023410: 203d 206e 702e 6172 7261 7928 5b0a 2020   = np.array([.  
-00023420: 2020 2020 2020 2020 2020 742e 6576 616c            t.eval
-00023430: 6628 7375 6273 3d73 656c 662e 7061 7261  f(subs=self.para
-00023440: 6d73 2920 6966 2069 7369 6e73 7461 6e63  ms) if isinstanc
-00023450: 6528 742c 2045 7870 7229 2065 6c73 6520  e(t, Expr) else 
-00023460: 740a 2020 2020 2020 2020 2020 2020 666f  t.            fo
-00023470: 7220 7420 696e 2073 656c 662e 7470 5d2c  r t in self.tp],
-00023480: 2064 7479 7065 3d66 6c6f 6174 290a 2020   dtype=float).  
-00023490: 2020 2020 2020 7473 203d 206e 702e 6172        ts = np.ar
-000234a0: 7261 7928 5b0a 2020 2020 2020 2020 2020  ray([.          
-000234b0: 2020 742e 6576 616c 6628 7375 6273 3d73    t.evalf(subs=s
-000234c0: 656c 662e 7061 7261 6d73 2920 6966 2069  elf.params) if i
-000234d0: 7369 6e73 7461 6e63 6528 742c 2045 7870  sinstance(t, Exp
-000234e0: 7229 2065 6c73 6520 740a 2020 2020 2020  r) else t.      
-000234f0: 2020 2020 2020 666f 7220 7420 696e 2073        for t in s
-00023500: 656c 662e 7473 5d2c 2064 7479 7065 3d66  elf.ts], dtype=f
-00023510: 6c6f 6174 290a 0a20 2020 2020 2020 2061  loat)..        a
-00023520: 6e67 6c65 7320 3d20 6e70 2e70 6920 2d20  ngles = np.pi - 
-00023530: 6e70 2e61 7263 636f 7328 7869 290a 2020  np.arccos(xi).  
-00023540: 2020 2020 2020 795f 6f76 6572 5f78 203d        y_over_x =
-00023550: 206e 702e 7461 6e28 616e 676c 6573 290a   np.tan(angles).
-00023560: 2020 2020 2020 2020 7220 3d20 6d61 7828          r = max(
-00023570: 3130 3030 2c20 6d61 7828 776e 2929 2069  1000, max(wn)) i
-00023580: 6620 6c65 6e28 776e 2920 3e20 3020 656c  f len(wn) > 0 el
-00023590: 7365 2031 3030 300a 0a20 2020 2020 2020  se 1000..       
-000235a0: 2078 695f 6469 6374 203d 207b 6b3a 207b   xi_dict = {k: {
-000235b0: 7d20 666f 7220 6b20 696e 207a 6970 2878  } for k in zip(x
-000235c0: 692c 2061 6e67 6c65 732c 2079 5f6f 7665  i, angles, y_ove
-000235d0: 725f 7829 7d0a 2020 2020 2020 2020 776e  r_x)}.        wn
-000235e0: 5f64 6963 7420 3d20 7b6b 3a20 7b7d 2066  _dict = {k: {} f
-000235f0: 6f72 206b 2069 6e20 776e 7d0a 2020 2020  or k in wn}.    
-00023600: 2020 2020 7470 5f64 6963 7420 3d20 7b6b      tp_dict = {k
-00023610: 3a20 7b7d 2066 6f72 206b 2069 6e20 7470  : {} for k in tp
-00023620: 7d0a 2020 2020 2020 2020 7473 5f64 6963  }.        ts_dic
-00023630: 7420 3d20 7b6b 3a20 7b7d 2066 6f72 206b  t = {k: {} for k
-00023640: 2069 6e20 7473 7d0a 0a20 2020 2020 2020   in ts}..       
-00023650: 2023 2064 616d 7069 6e67 2072 6174 696f   # damping ratio
-00023660: 206c 696e 6573 0a20 2020 2020 2020 2066   lines.        f
-00023670: 6f72 206b 2069 6e20 7a69 7028 7869 2c20  or k in zip(xi, 
-00023680: 616e 676c 6573 2c20 795f 6f76 6572 5f78  angles, y_over_x
-00023690: 293a 0a20 2020 2020 2020 2020 2020 2078  ):.            x
-000236a0: 2c20 612c 2079 7020 3d20 6b0a 2020 2020  , a, yp = k.    
-000236b0: 2020 2020 2020 2020 7869 5f64 6963 745b          xi_dict[
-000236c0: 6b5d 5b22 7822 5d20 3d20 6e70 2e61 7272  k]["x"] = np.arr
-000236d0: 6179 285b 302c 2072 202a 206e 702e 636f  ay([0, r * np.co
-000236e0: 7328 6129 5d29 0a20 2020 2020 2020 2020  s(a)]).         
-000236f0: 2020 2078 695f 6469 6374 5b6b 5d5b 2279     xi_dict[k]["y
-00023700: 225d 203d 206e 702e 6172 7261 7928 5b30  "] = np.array([0
-00023710: 2c20 7220 2a20 6e70 2e73 696e 2861 295d  , r * np.sin(a)]
-00023720: 290a 2020 2020 2020 2020 2020 2020 7869  ).            xi
-00023730: 5f64 6963 745b 6b5d 5b22 6c61 6265 6c22  _dict[k]["label"
-00023740: 5d20 3d20 2225 2e32 6622 2025 2078 0a0a  ] = "%.2f" % x..
-00023750: 2020 2020 2020 2020 2320 6e61 7475 7261          # natura
-00023760: 6c20 6672 6571 7565 6e63 7920 6c69 6e65  l frequency line
-00023770: 730a 2020 2020 2020 2020 7420 3d20 6e70  s.        t = np
-00023780: 2e6c 696e 7370 6163 6528 6e70 2e70 692f  .linspace(np.pi/
-00023790: 322c 2033 2a6e 702e 7069 2f32 2c20 3130  2, 3*np.pi/2, 10
-000237a0: 3029 0a20 2020 2020 2020 2063 7420 3d20  0).        ct = 
-000237b0: 6e70 2e63 6f73 2874 290a 2020 2020 2020  np.cos(t).      
-000237c0: 2020 7374 203d 206e 702e 7369 6e28 7429    st = np.sin(t)
-000237d0: 0a20 2020 2020 2020 2079 6c69 6d20 3d20  .        ylim = 
-000237e0: 7365 6c66 2e5f 796c 696d 0a20 2020 2020  self._ylim.     
-000237f0: 2020 2079 5f6f 6666 7365 7420 3d20 3020     y_offset = 0 
-00023800: 6966 2079 6c69 6d20 6973 204e 6f6e 6520  if ylim is None 
-00023810: 656c 7365 2030 2e30 3135 202a 2061 6273  else 0.015 * abs
-00023820: 2879 6c69 6d5b 315d 202d 2079 6c69 6d5b  (ylim[1] - ylim[
-00023830: 305d 290a 2020 2020 2020 2020 666f 7220  0]).        for 
-00023840: 7720 696e 2077 6e3a 0a20 2020 2020 2020  w in wn:.       
-00023850: 2020 2020 2077 6e5f 6469 6374 5b77 5d5b       wn_dict[w][
-00023860: 2278 225d 203d 2077 202a 2063 740a 2020  "x"] = w * ct.  
-00023870: 2020 2020 2020 2020 2020 776e 5f64 6963            wn_dic
-00023880: 745b 775d 5b22 7922 5d20 3d20 7720 2a20  t[w]["y"] = w * 
-00023890: 7374 0a20 2020 2020 2020 2020 2020 2077  st.            w
-000238a0: 6e5f 6469 6374 5b77 5d5b 226c 6162 656c  n_dict[w]["label
-000238b0: 225d 203d 2022 252e 3266 2220 2520 770a  "] = "%.2f" % w.
-000238c0: 2020 2020 2020 2020 2020 2020 776e 5f64              wn_d
-000238d0: 6963 745b 775d 5b22 6c78 225d 203d 202d  ict[w]["lx"] = -
-000238e0: 770a 2020 2020 2020 2020 2020 2020 776e  w.            wn
-000238f0: 5f64 6963 745b 775d 5b22 6c79 225d 203d  _dict[w]["ly"] =
-00023900: 2079 5f6f 6666 7365 740a 0a20 2020 2020   y_offset..     
-00023910: 2020 2023 2070 6561 6b20 7469 6d65 206c     # peak time l
-00023920: 696e 6573 0a20 2020 2020 2020 2079 5f74  ines.        y_t
-00023930: 7020 3d20 6e70 2e70 6920 2f20 7470 0a20  p = np.pi / tp. 
-00023940: 2020 2020 2020 2023 2073 6574 746c 696e         # settlin
-00023950: 6720 7469 6d65 206c 696e 6573 0a20 2020  g time lines.   
-00023960: 2020 2020 2078 5f74 7320 3d20 2d34 202f       x_ts = -4 /
-00023970: 2074 730a 0a20 2020 2020 2020 2072 6574   ts..        ret
-00023980: 7572 6e20 7869 5f64 6963 742c 2077 6e5f  urn xi_dict, wn_
-00023990: 6469 6374 2c20 795f 7470 2c20 785f 7473  dict, y_tp, x_ts
-000239a0: 0a0a 0a63 6c61 7373 205a 4772 6964 4c69  ...class ZGridLi
-000239b0: 6e65 5365 7269 6573 2847 7269 6442 6173  neSeries(GridBas
-000239c0: 652c 2042 6173 6553 6572 6965 7329 3a0a  e, BaseSeries):.
-000239d0: 2020 2020 2222 2252 6570 7265 7365 6e74      """Represent
-000239e0: 2061 2067 7269 6420 6f66 2064 616d 7069   a grid of dampi
-000239f0: 6e67 2072 6174 696f 206c 696e 6573 2061  ng ratio lines a
-00023a00: 6e64 206e 6174 7572 616c 2066 7265 7175  nd natural frequ
-00023a10: 656e 6379 206c 696e 6573 0a20 2020 206f  ency lines.    o
-00023a20: 6e20 7468 6520 7a2d 706c 616e 652e 0a20  n the z-plane.. 
-00023a30: 2020 2022 2222 0a0a 2020 2020 6465 6620     """..    def 
-00023a40: 5f5f 696e 6974 5f5f 2873 656c 662c 2078  __init__(self, x
-00023a50: 692c 2077 6e2c 2074 702c 2074 732c 202a  i, wn, tp, ts, *
-00023a60: 2a6b 7761 7267 7329 3a0a 2020 2020 2020  *kwargs):.      
-00023a70: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-00023a80: 5f5f 282a 2a6b 7761 7267 7329 0a20 2020  __(**kwargs).   
-00023a90: 2020 2020 2054 203d 206b 7761 7267 732e       T = kwargs.
-00023aa0: 6765 7428 2254 222c 204e 6f6e 6529 0a20  get("T", None). 
-00023ab0: 2020 2020 2020 2073 656c 662e 7361 6d70         self.samp
-00023ac0: 6c69 6e67 5f70 6572 696f 6420 3d20 5420  ling_period = T 
-00023ad0: 6966 2054 2069 7320 4e6f 6e65 2065 6c73  if T is None els
-00023ae0: 6520 666c 6f61 7428 5429 0a20 2020 2020  e float(T).     
-00023af0: 2020 2073 656c 662e 7869 203d 2078 690a     self.xi = xi.
-00023b00: 2020 2020 2020 2020 7365 6c66 2e77 6e20          self.wn 
-00023b10: 3d20 776e 0a20 2020 2020 2020 2073 656c  = wn.        sel
-00023b20: 662e 7470 203d 2074 700a 2020 2020 2020  f.tp = tp.      
-00023b30: 2020 7365 6c66 2e74 7320 3d20 7473 0a20    self.ts = ts. 
-00023b40: 2020 2020 2020 2073 656c 662e 7368 6f77         self.show
-00023b50: 5f63 6f6e 7472 6f6c 5f61 7869 7320 3d20  _control_axis = 
-00023b60: 6b77 6172 6773 2e67 6574 2822 7368 6f77  kwargs.get("show
-00023b70: 5f63 6f6e 7472 6f6c 5f61 7869 7322 2c20  _control_axis", 
-00023b80: 4661 6c73 6529 0a0a 2020 2020 6465 6620  False)..    def 
-00023b90: 5f5f 7374 725f 5f28 7365 6c66 293a 0a20  __str__(self):. 
-00023ba0: 2020 2020 2020 2072 6574 7572 6e20 227a         return "z
-00023bb0: 2d67 7269 6422 0a0a 2020 2020 6465 6620  -grid"..    def 
-00023bc0: 6765 745f 6461 7461 2873 656c 6629 3a0a  get_data(self):.
-00023bd0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00023be0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-00023bf0: 2020 2020 3d3d 3d3d 3d3d 3d0a 2020 2020      =======.    
-00023c00: 2020 2020 7869 2c20 776e 2c20 7470 2c20      xi, wn, tp, 
-00023c10: 7473 203a 2064 6963 740a 2020 2020 2020  ts : dict.      
-00023c20: 2020 2020 2020 4469 6374 696f 6e61 7269        Dictionari
-00023c30: 6573 2063 6f6e 7461 696e 696e 6720 7468  es containing th
-00023c40: 6520 7265 7175 6972 6564 206e 756d 6572  e required numer
-00023c50: 6963 616c 2064 6174 6120 746f 2063 7265  ical data to cre
-00023c60: 6174 650a 2020 2020 2020 2020 2020 2020  ate.            
-00023c70: 6c69 6e65 7320 616e 6420 616e 6e6f 7461  lines and annota
-00023c80: 7469 6f6e 732e 0a20 2020 2020 2020 2022  tions..        "
-00023c90: 2222 0a20 2020 2020 2020 206e 7020 3d20  "".        np = 
-00023ca0: 696d 706f 7274 5f6d 6f64 756c 6528 226e  import_module("n
-00023cb0: 756d 7079 2229 0a20 2020 2020 2020 2069  umpy").        i
-00023cc0: 6620 7365 6c66 2e69 735f 696e 7465 7261  f self.is_intera
-00023cd0: 6374 6976 653a 0a20 2020 2020 2020 2020  ctive:.         
-00023ce0: 2020 2078 6920 3d20 6e70 2e61 7272 6179     xi = np.array
-00023cf0: 285b 0a20 2020 2020 2020 2020 2020 2020  ([.             
-00023d00: 2020 2074 2e65 7661 6c66 2873 7562 733d     t.evalf(subs=
-00023d10: 7365 6c66 2e70 6172 616d 7329 2069 6620  self.params) if 
-00023d20: 6973 696e 7374 616e 6365 2874 2c20 4578  isinstance(t, Ex
-00023d30: 7072 2920 656c 7365 2074 0a20 2020 2020  pr) else t.     
-00023d40: 2020 2020 2020 2020 2020 2066 6f72 2074             for t
-00023d50: 2069 6e20 7365 6c66 2e78 695d 2c20 6474   in self.xi], dt
-00023d60: 7970 653d 666c 6f61 7429 0a20 2020 2020  ype=float).     
-00023d70: 2020 2020 2020 2077 6e20 3d20 6e70 2e61         wn = np.a
-00023d80: 7272 6179 285b 0a20 2020 2020 2020 2020  rray([.         
-00023d90: 2020 2020 2020 2074 2e65 7661 6c66 2873         t.evalf(s
-00023da0: 7562 733d 7365 6c66 2e70 6172 616d 7329  ubs=self.params)
-00023db0: 2069 6620 6973 696e 7374 616e 6365 2874   if isinstance(t
-00023dc0: 2c20 4578 7072 2920 656c 7365 2074 0a20  , Expr) else t. 
-00023dd0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00023de0: 6f72 2074 2069 6e20 7365 6c66 2e77 6e5d  or t in self.wn]
-00023df0: 2c20 6474 7970 653d 666c 6f61 7429 0a20  , dtype=float). 
-00023e00: 2020 2020 2020 2020 2020 2074 7020 3d20             tp = 
-00023e10: 6e70 2e61 7272 6179 285b 0a20 2020 2020  np.array([.     
-00023e20: 2020 2020 2020 2020 2020 2074 2e65 7661             t.eva
-00023e30: 6c66 2873 7562 733d 7365 6c66 2e70 6172  lf(subs=self.par
-00023e40: 616d 7329 2069 6620 6973 696e 7374 616e  ams) if isinstan
-00023e50: 6365 2874 2c20 4578 7072 2920 656c 7365  ce(t, Expr) else
-00023e60: 2074 0a20 2020 2020 2020 2020 2020 2020   t.             
-00023e70: 2020 2066 6f72 2074 2069 6e20 7365 6c66     for t in self
-00023e80: 2e74 705d 2c20 6474 7970 653d 666c 6f61  .tp], dtype=floa
-00023e90: 7429 0a20 2020 2020 2020 2020 2020 2074  t).            t
-00023ea0: 7320 3d20 6e70 2e61 7272 6179 285b 0a20  s = np.array([. 
-00023eb0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00023ec0: 2e65 7661 6c66 2873 7562 733d 7365 6c66  .evalf(subs=self
-00023ed0: 2e70 6172 616d 7329 2069 6620 6973 696e  .params) if isin
-00023ee0: 7374 616e 6365 2874 2c20 4578 7072 2920  stance(t, Expr) 
-00023ef0: 656c 7365 2074 0a20 2020 2020 2020 2020  else t.         
-00023f00: 2020 2020 2020 2066 6f72 2074 2069 6e20         for t in 
-00023f10: 7365 6c66 2e74 735d 2c20 6474 7970 653d  self.ts], dtype=
-00023f20: 666c 6f61 7429 0a20 2020 2020 2020 2065  float).        e
-00023f30: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00023f40: 2078 6920 3d20 6e70 2e61 7272 6179 2873   xi = np.array(s
-00023f50: 656c 662e 7869 2c20 6474 7970 653d 666c  elf.xi, dtype=fl
-00023f60: 6f61 7429 0a20 2020 2020 2020 2020 2020  oat).           
-00023f70: 2077 6e20 3d20 6e70 2e61 7272 6179 2873   wn = np.array(s
-00023f80: 656c 662e 776e 2c20 6474 7970 653d 666c  elf.wn, dtype=fl
-00023f90: 6f61 7429 0a20 2020 2020 2020 2020 2020  oat).           
-00023fa0: 2074 7020 3d20 6e70 2e61 7272 6179 2873   tp = np.array(s
-00023fb0: 656c 662e 7470 2c20 6474 7970 653d 666c  elf.tp, dtype=fl
-00023fc0: 6f61 7429 0a20 2020 2020 2020 2020 2020  oat).           
-00023fd0: 2074 7320 3d20 6e70 2e61 7272 6179 2873   ts = np.array(s
-00023fe0: 656c 662e 7473 2c20 6474 7970 653d 666c  elf.ts, dtype=fl
-00023ff0: 6f61 7429 0a0a 2020 2020 2020 2020 5420  oat)..        T 
-00024000: 3d20 7365 6c66 2e73 616d 706c 696e 675f  = self.sampling_
-00024010: 7065 7269 6f64 0a20 2020 2020 2020 2078  period.        x
-00024020: 695f 6469 6374 203d 207b 6b3a 207b 7d20  i_dict = {k: {} 
-00024030: 666f 7220 6b20 696e 2078 697d 0a20 2020  for k in xi}.   
-00024040: 2020 2020 2077 6e5f 6469 6374 203d 207b       wn_dict = {
-00024050: 6b3a 207b 7d20 666f 7220 6b20 696e 2077  k: {} for k in w
-00024060: 6e7d 0a20 2020 2020 2020 2074 705f 6469  n}.        tp_di
-00024070: 6374 203d 207b 6b3a 207b 7d20 666f 7220  ct = {k: {} for 
-00024080: 6b20 696e 2074 707d 0a20 2020 2020 2020  k in tp}.       
-00024090: 2074 735f 6469 6374 203d 207b 6b3a 207b   ts_dict = {k: {
-000240a0: 7d20 666f 7220 6b20 696e 2074 737d 0a0a  } for k in ts}..
-000240b0: 2020 2020 2020 2020 2320 6461 6d70 696e          # dampin
-000240c0: 6720 7261 7469 6f20 6c69 6e65 730a 2020  g ratio lines.  
-000240d0: 2020 2020 2020 666f 7220 7a65 7461 2069        for zeta i
-000240e0: 6e20 7869 3a0a 2020 2020 2020 2020 2020  n xi:.          
-000240f0: 2020 2320 4361 6c63 756c 6174 6520 696e    # Calculate in
-00024100: 2070 6f6c 6172 2063 6f6f 7264 696e 6174   polar coordinat
-00024110: 6573 0a20 2020 2020 2020 2020 2020 2066  es.            f
-00024120: 6163 746f 7220 3d20 7a65 7461 2f6e 702e  actor = zeta/np.
-00024130: 7371 7274 2831 2d7a 6574 612a 2a32 290a  sqrt(1-zeta**2).
-00024140: 2020 2020 2020 2020 2020 2020 7820 3d20              x = 
-00024150: 6e70 2e6c 696e 7370 6163 6528 302c 206e  np.linspace(0, n
-00024160: 702e 7371 7274 2831 2d7a 6574 612a 2a32  p.sqrt(1-zeta**2
-00024170: 292c 2032 3030 290a 2020 2020 2020 2020  ), 200).        
-00024180: 2020 2020 616e 6720 3d20 6e70 2e70 692a      ang = np.pi*
-00024190: 780a 2020 2020 2020 2020 2020 2020 6d61  x.            ma
-000241a0: 6720 3d20 6e70 2e65 7870 282d 6e70 2e70  g = np.exp(-np.p
-000241b0: 692a 6661 6374 6f72 2a78 290a 2020 2020  i*factor*x).    
-000241c0: 2020 2020 2020 2020 2320 4472 6177 2075          # Draw u
-000241d0: 7070 6572 2070 6172 7420 696e 2072 6574  pper part in ret
-000241e0: 616e 6775 6c61 7220 636f 6f72 6469 6e61  angular coordina
-000241f0: 7465 730a 2020 2020 2020 2020 2020 2020  tes.            
-00024200: 7872 6574 203d 206d 6167 2a6e 702e 636f  xret = mag*np.co
-00024210: 7328 616e 6729 0a20 2020 2020 2020 2020  s(ang).         
-00024220: 2020 2079 7265 7420 3d20 6d61 672a 6e70     yret = mag*np
-00024230: 2e73 696e 2861 6e67 290a 2020 2020 2020  .sin(ang).      
-00024240: 2020 2020 2020 7869 5f64 6963 745b 7a65        xi_dict[ze
-00024250: 7461 5d5b 2278 3122 5d20 3d20 7872 6574  ta]["x1"] = xret
-00024260: 0a20 2020 2020 2020 2020 2020 2078 695f  .            xi_
-00024270: 6469 6374 5b7a 6574 615d 5b22 7931 225d  dict[zeta]["y1"]
-00024280: 203d 2079 7265 740a 2020 2020 2020 2020   = yret.        
-00024290: 2020 2020 2320 4472 6177 206c 6f77 6572      # Draw lower
-000242a0: 2070 6172 7420 696e 2072 6574 616e 6775   part in retangu
-000242b0: 6c61 7220 636f 6f72 6469 6e61 7465 730a  lar coordinates.
-000242c0: 2020 2020 2020 2020 2020 2020 7872 6574              xret
-000242d0: 203d 206d 6167 2a6e 702e 636f 7328 2d61   = mag*np.cos(-a
-000242e0: 6e67 290a 2020 2020 2020 2020 2020 2020  ng).            
-000242f0: 7972 6574 203d 206d 6167 2a6e 702e 7369  yret = mag*np.si
-00024300: 6e28 2d61 6e67 290a 2020 2020 2020 2020  n(-ang).        
-00024310: 2020 2020 7869 5f64 6963 745b 7a65 7461      xi_dict[zeta
-00024320: 5d5b 2278 3222 5d20 3d20 7872 6574 0a20  ]["x2"] = xret. 
-00024330: 2020 2020 2020 2020 2020 2078 695f 6469             xi_di
-00024340: 6374 5b7a 6574 615d 5b22 7932 225d 203d  ct[zeta]["y2"] =
-00024350: 2079 7265 740a 2020 2020 2020 2020 2020   yret.          
-00024360: 2020 2320 416e 6e6f 7461 7469 6f6e 0a20    # Annotation. 
-00024370: 2020 2020 2020 2020 2020 2061 6e5f 6920             an_i 
-00024380: 3d20 696e 7428 6c65 6e28 7872 6574 292f  = int(len(xret)/
-00024390: 322e 3529 0a20 2020 2020 2020 2020 2020  2.5).           
-000243a0: 2061 6e5f 7820 3d20 7872 6574 5b61 6e5f   an_x = xret[an_
-000243b0: 695d 0a20 2020 2020 2020 2020 2020 2061  i].            a
-000243c0: 6e5f 7920 3d20 7972 6574 5b61 6e5f 695d  n_y = yret[an_i]
-000243d0: 0a20 2020 2020 2020 2020 2020 2078 695f  .            xi_
-000243e0: 6469 6374 5b7a 6574 615d 5b22 6c78 225d  dict[zeta]["lx"]
-000243f0: 203d 2078 7265 745b 616e 5f69 5d0a 2020   = xret[an_i].  
-00024400: 2020 2020 2020 2020 2020 7869 5f64 6963            xi_dic
-00024410: 745b 7a65 7461 5d5b 226c 7922 5d20 3d20  t[zeta]["ly"] = 
-00024420: 7972 6574 5b61 6e5f 695d 0a20 2020 2020  yret[an_i].     
-00024430: 2020 2020 2020 2078 695f 6469 6374 5b7a         xi_dict[z
-00024440: 6574 615d 5b22 6c61 6265 6c22 5d20 3d20  eta]["label"] = 
-00024450: 7374 7228 726f 756e 6428 7a65 7461 2c20  str(round(zeta, 
-00024460: 3229 290a 0a20 2020 2020 2020 2023 206e  2))..        # n
-00024470: 6174 7572 616c 2066 7265 7175 656e 6379  atural frequency
-00024480: 206c 696e 6573 0a20 2020 2020 2020 2072   lines.        r
-00024490: 5f61 6e20 3d20 312e 3037 350a 2020 2020  _an = 1.075.    
-000244a0: 2020 2020 666d 7420 3d20 277b 3a31 2e31      fmt = '{:1.1
-000244b0: 667d 2720 6966 206c 656e 2877 6e29 203e  f}' if len(wn) >
-000244c0: 2031 2065 6c73 6520 277b 3a31 2e32 667d   1 else '{:1.2f}
-000244d0: 270a 2020 2020 2020 2020 666f 7220 6120  '.        for a 
-000244e0: 696e 2077 6e3a 0a20 2020 2020 2020 2020  in wn:.         
-000244f0: 2020 2023 2043 616c 6375 6c61 7465 2069     # Calculate i
-00024500: 6e20 706f 6c61 7220 636f 6f72 6469 6e61  n polar coordina
-00024510: 7465 730a 2020 2020 2020 2020 2020 2020  tes.            
-00024520: 7820 3d20 6e70 2e6c 696e 7370 6163 6528  x = np.linspace(
-00024530: 2d6e 702e 7069 2f32 2c20 6e70 2e70 692f  -np.pi/2, np.pi/
-00024540: 322c 2032 3030 290a 2020 2020 2020 2020  2, 200).        
-00024550: 2020 2020 616e 6720 3d20 6e70 2e70 692a      ang = np.pi*
-00024560: 612a 6e70 2e73 696e 2878 290a 2020 2020  a*np.sin(x).    
-00024570: 2020 2020 2020 2020 6d61 6720 3d20 6e70          mag = np
-00024580: 2e65 7870 282d 6e70 2e70 692a 612a 6e70  .exp(-np.pi*a*np
-00024590: 2e63 6f73 2878 2929 0a20 2020 2020 2020  .cos(x)).       
-000245a0: 2020 2020 2023 2044 7261 7720 696e 2072       # Draw in r
-000245b0: 6574 616e 6775 6c61 7220 636f 6f72 6469  etangular coordi
-000245c0: 6e61 7465 730a 2020 2020 2020 2020 2020  nates.          
-000245d0: 2020 7872 6574 203d 206d 6167 2a6e 702e    xret = mag*np.
-000245e0: 636f 7328 616e 6729 0a20 2020 2020 2020  cos(ang).       
-000245f0: 2020 2020 2079 7265 7420 3d20 6d61 672a       yret = mag*
-00024600: 6e70 2e73 696e 2861 6e67 290a 2020 2020  np.sin(ang).    
-00024610: 2020 2020 2020 2020 776e 5f64 6963 745b          wn_dict[
-00024620: 615d 5b22 7822 5d20 3d20 7872 6574 0a20  a]["x"] = xret. 
-00024630: 2020 2020 2020 2020 2020 2077 6e5f 6469             wn_di
-00024640: 6374 5b61 5d5b 2279 225d 203d 2079 7265  ct[a]["y"] = yre
-00024650: 740a 2020 2020 2020 2020 2020 2020 2320  t.            # 
-00024660: 416e 6e6f 7461 7469 6f6e 0a20 2020 2020  Annotation.     
-00024670: 2020 2020 2020 2061 6e67 6c65 203d 206e         angle = n
-00024680: 702e 6172 6374 616e 3228 7972 6574 5b2d  p.arctan2(yret[-
-00024690: 315d 2c20 7872 6574 5b2d 315d 290a 2020  1], xret[-1]).  
-000246a0: 2020 2020 2020 2020 2020 776e 5f64 6963            wn_dic
-000246b0: 745b 615d 5b22 6c78 225d 203d 2072 5f61  t[a]["lx"] = r_a
-000246c0: 6e20 2a20 6e70 2e63 6f73 2861 6e67 6c65  n * np.cos(angle
-000246d0: 290a 2020 2020 2020 2020 2020 2020 776e  ).            wn
-000246e0: 5f64 6963 745b 615d 5b22 6c79 225d 203d  _dict[a]["ly"] =
-000246f0: 2072 5f61 6e20 2a20 6e70 2e73 696e 2861   r_an * np.sin(a
-00024700: 6e67 6c65 290a 2020 2020 2020 2020 2020  ngle).          
-00024710: 2020 6966 2054 2069 7320 4e6f 6e65 3a0a    if T is None:.
-00024720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024730: 6e75 6d20 3d20 666d 742e 666f 726d 6174  num = fmt.format
-00024740: 2861 290a 2020 2020 2020 2020 2020 2020  (a).            
-00024750: 2020 2020 616e 203d 2072 2224 5c66 7261      an = r"$\fra
-00024760: 637b 222b 6e75 6d2b 7222 5c70 697d 7b54  c{"+num+r"\pi}{T
-00024770: 7d24 220a 2020 2020 2020 2020 2020 2020  }$".            
-00024780: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00024790: 2020 2020 2020 616e 203d 2022 252e 3266        an = "%.2f
-000247a0: 2220 2520 2861 202a 206e 702e 7069 202a  " % (a * np.pi *
-000247b0: 2054 290a 2020 2020 2020 2020 2020 2020   T).            
-000247c0: 776e 5f64 6963 745b 615d 5b22 6c61 6265  wn_dict[a]["labe
-000247d0: 6c22 5d20 3d20 616e 0a0a 2020 2020 2020  l"] = an..      
-000247e0: 2020 2320 7065 616b 2074 696d 6520 6c69    # peak time li
-000247f0: 6e65 730a 2020 2020 2020 2020 616e 676c  nes.        angl
-00024800: 6573 203d 206e 702e 7069 202f 2074 700a  es = np.pi / tp.
-00024810: 2020 2020 2020 2020 666f 7220 5f74 702c          for _tp,
-00024820: 2061 2069 6e20 7a69 7028 7470 2c20 616e   a in zip(tp, an
-00024830: 676c 6573 293a 0a20 2020 2020 2020 2020  gles):.         
-00024840: 2020 2074 705f 6469 6374 5b5f 7470 5d5b     tp_dict[_tp][
-00024850: 2278 225d 203d 205b 302c 206e 702e 636f  "x"] = [0, np.co
-00024860: 7328 6129 5d0a 2020 2020 2020 2020 2020  s(a)].          
-00024870: 2020 7470 5f64 6963 745b 5f74 705d 5b22    tp_dict[_tp]["
-00024880: 7922 5d20 3d20 5b30 2c20 6e70 2e73 696e  y"] = [0, np.sin
-00024890: 2861 295d 0a20 2020 2020 2020 2020 2020  (a)].           
-000248a0: 2023 2041 6e6e 6f74 6174 696f 6e0a 2020   # Annotation.  
-000248b0: 2020 2020 2020 2020 2020 7470 5f64 6963            tp_dic
-000248c0: 745b 5f74 705d 5b22 6c78 225d 203d 2072  t[_tp]["lx"] = r
-000248d0: 5f61 6e20 2a20 6e70 2e63 6f73 2861 290a  _an * np.cos(a).
-000248e0: 2020 2020 2020 2020 2020 2020 7470 5f64              tp_d
-000248f0: 6963 745b 5f74 705d 5b22 6c79 225d 203d  ict[_tp]["ly"] =
-00024900: 2072 5f61 6e20 2a20 6e70 2e73 696e 2861   r_an * np.sin(a
-00024910: 290a 2020 2020 2020 2020 2020 2020 616e  ).            an
-00024920: 203d 205f 7470 2069 6620 6e6f 7420 5420   = _tp if not T 
-00024930: 656c 7365 205f 7470 202a 2054 0a20 2020  else _tp * T.   
-00024940: 2020 2020 2020 2020 2061 6e20 3d20 2225           an = "%
-00024950: 2e32 6622 2025 2061 6e20 6966 206e 6f74  .2f" % an if not
-00024960: 2054 2065 6c73 6520 2225 2e32 6620 7322   T else "%.2f s"
-00024970: 2025 2061 6e0a 2020 2020 2020 2020 2020   % an.          
-00024980: 2020 7470 5f64 6963 745b 5f74 705d 5b22    tp_dict[_tp]["
-00024990: 6c61 6265 6c22 5d20 3d20 616e 0a0a 2020  label"] = an..  
-000249a0: 2020 2020 2020 2320 7365 7474 6c69 6e67        # settling
-000249b0: 2074 696d 6520 6c69 6e65 730a 2020 2020   time lines.    
-000249c0: 2020 2020 7261 6469 7573 203d 206e 702e      radius = np.
-000249d0: 6578 7028 2d34 202f 2074 7329 0a20 2020  exp(-4 / ts).   
-000249e0: 2020 2020 2074 6865 7461 203d 206e 702e       theta = np.
-000249f0: 6c69 6e73 7061 6365 2830 2c20 322a 6e70  linspace(0, 2*np
-00024a00: 2e70 692c 2034 3030 290a 2020 2020 2020  .pi, 400).      
-00024a10: 2020 6374 203d 206e 702e 636f 7328 7468    ct = np.cos(th
-00024a20: 6574 6129 0a20 2020 2020 2020 2073 7420  eta).        st 
-00024a30: 3d20 6e70 2e73 696e 2874 6865 7461 290a  = np.sin(theta).
-00024a40: 2020 2020 2020 2020 666f 7220 5f74 732c          for _ts,
-00024a50: 2072 2069 6e20 7a69 7028 7473 2c20 7261   r in zip(ts, ra
-00024a60: 6469 7573 293a 0a20 2020 2020 2020 2020  dius):.         
-00024a70: 2020 2074 735f 6469 6374 5b5f 7473 5d5b     ts_dict[_ts][
-00024a80: 2278 225d 203d 2072 202a 2063 740a 2020  "x"] = r * ct.  
-00024a90: 2020 2020 2020 2020 2020 7473 5f64 6963            ts_dic
-00024aa0: 745b 5f74 735d 5b22 7922 5d20 3d20 7220  t[_ts]["y"] = r 
-00024ab0: 2a20 7374 0a20 2020 2020 2020 2020 2020  * st.           
-00024ac0: 2023 2041 6e6e 6f74 6174 696f 6e0a 2020   # Annotation.  
-00024ad0: 2020 2020 2020 2020 2020 616e 5f69 203d            an_i =
-00024ae0: 2069 6e74 286c 656e 2874 6865 7461 292a   int(len(theta)*
-00024af0: 302e 3735 290a 2020 2020 2020 2020 2020  0.75).          
-00024b00: 2020 7473 5f64 6963 745b 5f74 735d 5b22    ts_dict[_ts]["
-00024b10: 6c78 225d 203d 2074 735f 6469 6374 5b5f  lx"] = ts_dict[_
-00024b20: 7473 5d5b 2278 225d 5b61 6e5f 695d 0a20  ts]["x"][an_i]. 
-00024b30: 2020 2020 2020 2020 2020 2074 735f 6469             ts_di
-00024b40: 6374 5b5f 7473 5d5b 226c 7922 5d20 3d20  ct[_ts]["ly"] = 
-00024b50: 7473 5f64 6963 745b 5f74 735d 5b22 7922  ts_dict[_ts]["y"
-00024b60: 5d5b 616e 5f69 5d0a 2020 2020 2020 2020  ][an_i].        
-00024b70: 2020 2020 616e 203d 205f 7473 2069 6620      an = _ts if 
-00024b80: 6e6f 7420 5420 656c 7365 205f 7473 202a  not T else _ts *
-00024b90: 2054 0a20 2020 2020 2020 2020 2020 2061   T.            a
-00024ba0: 6e20 3d20 2225 2e32 6622 2025 2061 6e20  n = "%.2f" % an 
-00024bb0: 6966 206e 6f74 2054 2065 6c73 6520 2225  if not T else "%
-00024bc0: 2e32 6620 7322 2025 2061 6e0a 2020 2020  .2f s" % an.    
-00024bd0: 2020 2020 2020 2020 7473 5f64 6963 745b          ts_dict[
-00024be0: 5f74 735d 5b22 6c61 6265 6c22 5d20 3d20  _ts]["label"] = 
-00024bf0: 616e 0a0a 2020 2020 2020 2020 7265 7475  an..        retu
-00024c00: 726e 2078 695f 6469 6374 2c20 776e 5f64  rn xi_dict, wn_d
-00024c10: 6963 742c 2074 705f 6469 6374 2c20 7473  ict, tp_dict, ts
-00024c20: 5f64 6963 740a 0a0a 636c 6173 7320 4e69  _dict...class Ni
-00024c30: 6368 6f6c 734c 696e 6553 6572 6965 7328  cholsLineSeries(
-00024c40: 5061 7261 6d65 7472 6963 3244 4c69 6e65  Parametric2DLine
-00024c50: 5365 7269 6573 293a 0a20 2020 2022 2222  Series):.    """
-00024c60: 5265 7072 6573 656e 7420 6120 4e69 6368  Represent a Nich
-00024c70: 6f6c 7320 6c69 6e65 2069 6e20 636f 6e74  ols line in cont
-00024c80: 726f 6c20 7379 7374 656d 2070 6c6f 7474  rol system plott
-00024c90: 696e 672e 0a20 2020 2022 2222 0a20 2020  ing..    """.   
-00024ca0: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
-00024cb0: 6c66 2c20 2a61 7267 732c 202a 2a6b 7761  lf, *args, **kwa
-00024cc0: 7267 7329 3a0a 2020 2020 2020 2020 7375  rgs):.        su
-00024cd0: 7065 7228 292e 5f5f 696e 6974 5f5f 282a  per().__init__(*
-00024ce0: 6172 6773 2c20 2a2a 6b77 6172 6773 290a  args, **kwargs).
-00024cf0: 0a20 2020 2064 6566 2067 6574 5f64 6174  .    def get_dat
-00024d00: 6128 7365 6c66 293a 0a20 2020 2020 2020  a(self):.       
-00024d10: 206e 7020 3d20 696d 706f 7274 5f6d 6f64   np = import_mod
-00024d20: 756c 6528 276e 756d 7079 2729 0a20 2020  ule('numpy').   
-00024d30: 2020 2020 2070 6861 7365 2c20 6d61 672c       phase, mag,
-00024d40: 206f 6d65 6761 203d 2073 7570 6572 2829   omega = super()
-00024d50: 2e67 6574 5f64 6174 6128 290a 2020 2020  .get_data().    
-00024d60: 2020 2020 6d61 6720 3d20 3230 202a 206e      mag = 20 * n
-00024d70: 702e 6c6f 6731 3028 6d61 6729 0a20 2020  p.log10(mag).   
-00024d80: 2020 2020 2070 6861 7365 203d 2075 6e77       phase = unw
-00024d90: 7261 7028 7068 6173 6529 0a20 2020 2020  rap(phase).     
-00024da0: 2020 2070 6861 7365 203d 206e 702e 6465     phase = np.de
-00024db0: 6772 6565 7328 7068 6173 6529 0a20 2020  grees(phase).   
-00024dc0: 2020 2020 2072 6574 7572 6e20 7068 6173       return phas
-00024dd0: 652c 206d 6167 2c20 6f6d 6567 610a 0a0a  e, mag, omega...
-00024de0: 636c 6173 7320 436f 6e74 726f 6c42 6173  class ControlBas
-00024df0: 6553 6572 6965 7328 4c69 6e65 3244 4261  eSeries(Line2DBa
-00024e00: 7365 5365 7269 6573 293a 0a20 2020 2022  seSeries):.    "
-00024e10: 2222 4120 6261 7365 2073 6572 6965 7320  ""A base series 
-00024e20: 666f 7220 636c 6173 7365 7320 7468 6174  for classes that
-00024e30: 2061 7265 2067 6f69 6e67 2074 6f20 7072   are going to pr
-00024e40: 6f64 7563 6520 6e75 6d65 7269 6361 6c0a  oduce numerical.
-00024e50: 2020 2020 6461 7461 2075 7369 6e67 2074      data using t
-00024e60: 6865 2060 6063 6f6e 7472 6f6c 6060 206d  he ``control`` m
-00024e70: 6f64 756c 6520 666f 7220 636f 6e74 726f  odule for contro
-00024e80: 6c2d 7379 7374 656d 2070 6c6f 7474 696e  l-system plottin
-00024e90: 672e 0a20 2020 2054 686f 7365 2073 6572  g..    Those ser
-00024ea0: 6965 7320 7265 7072 6573 656e 7420 6120  ies represent a 
-00024eb0: 5349 534f 2073 7973 7465 6d2e 0a20 2020  SISO system..   
-00024ec0: 2022 2222 0a0a 2020 2020 5f61 6c6c 6f77   """..    _allow
-00024ed0: 6564 5f6b 6579 7320 3d20 5b22 636f 6e74  ed_keys = ["cont
-00024ee0: 726f 6c5f 6b77 225d 0a0a 2020 2020 6465  rol_kw"]..    de
-00024ef0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
-00024f00: 202a 6172 6773 2c20 2a2a 6b77 6172 6773   *args, **kwargs
-00024f10: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
-00024f20: 2829 2e5f 5f69 6e69 745f 5f28 2a2a 6b77  ().__init__(**kw
-00024f30: 6172 6773 290a 2020 2020 2020 2020 5472  args).        Tr
-00024f40: 616e 7366 6572 4675 6e63 7469 6f6e 203d  ansferFunction =
-00024f50: 2073 796d 7079 2e70 6879 7369 6373 2e63   sympy.physics.c
-00024f60: 6f6e 7472 6f6c 2e6c 7469 2e54 7261 6e73  ontrol.lti.Trans
-00024f70: 6665 7246 756e 6374 696f 6e0a 2020 2020  ferFunction.    
-00024f80: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
-00024f90: 6d6f 6475 6c65 2827 6e75 6d70 7927 290a  module('numpy').
-00024fa0: 2020 2020 2020 2020 7370 203d 2069 6d70          sp = imp
-00024fb0: 6f72 745f 6d6f 6475 6c65 2827 7363 6970  ort_module('scip
-00024fc0: 7927 290a 2020 2020 2020 2020 6374 203d  y').        ct =
-00024fd0: 2069 6d70 6f72 745f 6d6f 6475 6c65 2827   import_module('
-00024fe0: 636f 6e74 726f 6c27 290a 2020 2020 2020  control').      
-00024ff0: 2020 6c61 6265 6c20 3d20 6b77 6172 6773    label = kwargs
-00025000: 2e67 6574 2822 6c61 6265 6c22 2c20 2222  .get("label", ""
-00025010: 290a 2020 2020 2020 2020 7466 203d 2061  ).        tf = a
-00025020: 7267 735b 305d 0a0a 2020 2020 2020 2020  rgs[0]..        
-00025030: 6966 2069 7369 6e73 7461 6e63 6528 7466  if isinstance(tf
-00025040: 2c20 2845 7870 722c 2054 7261 6e73 6665  , (Expr, Transfe
-00025050: 7246 756e 6374 696f 6e29 293a 0a20 2020  rFunction)):.   
-00025060: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
-00025070: 7374 616e 6365 2874 662c 2045 7870 7229  stance(tf, Expr)
-00025080: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00025090: 2020 7061 7261 6d73 5f66 7320 3d20 7365    params_fs = se
-000250a0: 7428 7365 6c66 2e70 6172 616d 732e 6b65  t(self.params.ke
-000250b0: 7973 2829 290a 2020 2020 2020 2020 2020  ys()).          
-000250c0: 2020 2020 2020 6673 203d 2074 662e 6672        fs = tf.fr
-000250d0: 6565 5f73 796d 626f 6c73 2e64 6966 6665  ee_symbols.diffe
-000250e0: 7265 6e63 6528 7061 7261 6d73 5f66 7329  rence(params_fs)
-000250f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00025100: 2066 7320 3d20 6673 2e70 6f70 2829 2069   fs = fs.pop() i
-00025110: 6620 6c65 6e28 6673 2920 3e20 3020 656c  f len(fs) > 0 el
-00025120: 7365 2073 796d 626f 6c73 2822 7322 290a  se symbols("s").
-00025130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025140: 7466 203d 2054 7261 6e73 6665 7246 756e  tf = TransferFun
-00025150: 6374 696f 6e2e 6672 6f6d 5f72 6174 696f  ction.from_ratio
-00025160: 6e61 6c5f 6578 7072 6573 7369 6f6e 2874  nal_expression(t
-00025170: 662c 2066 7329 0a20 2020 2020 2020 2020  f, fs).         
-00025180: 2020 2073 656c 662e 5f65 7870 7220 3d20     self._expr = 
-00025190: 7466 0a20 2020 2020 2020 2020 2020 2073  tf.            s
-000251a0: 656c 662e 5f63 6f6e 7472 6f6c 5f74 6620  elf._control_tf 
-000251b0: 3d20 4e6f 6e65 0a20 2020 2020 2020 2020  = None.         
-000251c0: 2020 2069 6620 6e6f 7420 7365 6c66 2e69     if not self.i
-000251d0: 735f 696e 7465 7261 6374 6976 653a 0a20  s_interactive:. 
-000251e0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000251f0: 656c 662e 5f63 6f6e 7472 6f6c 5f74 6620  elf._control_tf 
-00025200: 3d20 7466 5f74 6f5f 636f 6e74 726f 6c28  = tf_to_control(
-00025210: 7466 290a 2020 2020 2020 2020 2020 2020  tf).            
-00025220: 7365 6c66 2e5f 6c61 6265 6c20 3d20 7374  self._label = st
-00025230: 7228 7365 6c66 2e65 7870 7229 2069 6620  r(self.expr) if 
-00025240: 6c61 6265 6c20 6973 204e 6f6e 6520 656c  label is None el
-00025250: 7365 206c 6162 656c 0a20 2020 2020 2020  se label.       
-00025260: 2020 2020 2073 656c 662e 5f6c 6174 6578       self._latex
-00025270: 5f6c 6162 656c 203d 206c 6174 6578 2873  _label = latex(s
-00025280: 656c 662e 6578 7072 2920 6966 206c 6162  elf.expr) if lab
-00025290: 656c 2069 7320 4e6f 6e65 2065 6c73 6520  el is None else 
-000252a0: 6c61 6265 6c0a 2020 2020 2020 2020 656c  label.        el
-000252b0: 6966 2069 7369 6e73 7461 6e63 6528 7466  if isinstance(tf
-000252c0: 2c20 2873 702e 7369 676e 616c 2e54 7261  , (sp.signal.Tra
-000252d0: 6e73 6665 7246 756e 6374 696f 6e2c 2063  nsferFunction, c
-000252e0: 742e 5472 616e 7366 6572 4675 6e63 7469  t.TransferFuncti
-000252f0: 6f6e 2929 3a0a 2020 2020 2020 2020 2020  on)):.          
-00025300: 2020 7365 6c66 2e5f 6578 7072 203d 204e    self._expr = N
-00025310: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
-00025320: 7365 6c66 2e5f 6c61 6265 6c20 3d20 6c61  self._label = la
-00025330: 6265 6c0a 2020 2020 2020 2020 2020 2020  bel.            
-00025340: 7365 6c66 2e5f 6c61 7465 785f 6c61 6265  self._latex_labe
-00025350: 6c20 3d20 6c61 6265 6c0a 2020 2020 2020  l = label.      
-00025360: 2020 2020 2020 6966 206c 6162 656c 2069        if label i
-00025370: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-00025380: 2020 2020 2020 2020 7320 3d20 7379 6d62          s = symb
-00025390: 6f6c 7328 2273 2220 6966 2074 662e 6474  ols("s" if tf.dt
-000253a0: 2069 7320 4e6f 6e65 2065 6c73 6520 227a   is None else "z
-000253b0: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
-000253c0: 2020 206e 203d 2074 662e 6e75 6d5b 305d     n = tf.num[0]
-000253d0: 5b30 5d20 6966 2069 7369 6e73 7461 6e63  [0] if isinstanc
-000253e0: 6528 6374 2e54 7261 6e73 6665 7246 756e  e(ct.TransferFun
-000253f0: 6374 696f 6e29 2065 6c73 6520 7466 2e6e  ction) else tf.n
-00025400: 756d 0a20 2020 2020 2020 2020 2020 2020  um.             
-00025410: 2020 2064 203d 2074 662e 6465 6e5b 305d     d = tf.den[0]
-00025420: 5b30 5d20 6966 2069 7369 6e73 7461 6e63  [0] if isinstanc
-00025430: 6528 6374 2e54 7261 6e73 6665 7246 756e  e(ct.TransferFun
-00025440: 6374 696f 6e29 2065 6c73 6520 7466 2e64  ction) else tf.d
-00025450: 656e 0a20 2020 2020 2020 2020 2020 2020  en.             
-00025460: 2020 2065 7870 7220 3d20 506f 6c79 2e66     expr = Poly.f
-00025470: 726f 6d5f 6c69 7374 286e 2c20 7329 202f  rom_list(n, s) /
-00025480: 2050 6f6c 792e 6672 6f6d 5f6c 6973 7428   Poly.from_list(
-00025490: 642c 2073 290a 2020 2020 2020 2020 2020  d, s).          
-000254a0: 2020 2020 2020 7365 6c66 2e5f 6c61 6265        self._labe
-000254b0: 6c20 3d20 7374 7228 6578 7072 290a 2020  l = str(expr).  
-000254c0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-000254d0: 6c66 2e5f 6c61 7465 785f 6c61 6265 6c20  lf._latex_label 
-000254e0: 3d20 6c61 7465 7828 6578 7072 290a 2020  = latex(expr).  
-000254f0: 2020 2020 2020 2020 2020 6966 2069 7369            if isi
-00025500: 6e73 7461 6e63 6528 7466 2c20 7370 2e73  nstance(tf, sp.s
-00025510: 6967 6e61 6c2e 5472 616e 7366 6572 4675  ignal.TransferFu
-00025520: 6e63 7469 6f6e 293a 0a20 2020 2020 2020  nction):.       
-00025530: 2020 2020 2020 2020 2073 656c 662e 5f63           self._c
-00025540: 6f6e 7472 6f6c 5f74 6620 3d20 7466 5f74  ontrol_tf = tf_t
-00025550: 6f5f 636f 6e74 726f 6c28 7466 290a 2020  o_control(tf).  
-00025560: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-00025570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025580: 7365 6c66 2e5f 636f 6e74 726f 6c5f 7466  self._control_tf
-00025590: 203d 2074 660a 2020 2020 2020 2020 656c   = tf.        el
-000255a0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-000255b0: 7261 6973 6520 5479 7065 4572 726f 7228  raise TypeError(
-000255c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000255d0: 2022 5472 616e 7366 6572 2066 756e 6374   "Transfer funct
-000255e0: 696f 6e27 7320 7479 7065 206e 6f74 2072  ion's type not r
-000255f0: 6563 6f67 6e69 7a65 642e 2022 0a20 2020  ecognized. ".   
-00025600: 2020 2020 2020 2020 2020 2020 2022 5265               "Re
-00025610: 6365 6976 6564 3a20 2220 2b20 7374 7228  ceived: " + str(
-00025620: 7479 7065 2874 6629 290a 2020 2020 2020  type(tf)).      
-00025630: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
-00025640: 2073 656c 662e 5f63 6f6e 7472 6f6c 5f6b   self._control_k
-00025650: 7720 3d20 6b77 6172 6773 2e67 6574 2822  w = kwargs.get("
-00025660: 636f 6e74 726f 6c5f 6b77 222c 207b 7d29  control_kw", {})
-00025670: 0a0a 2020 2020 6465 6620 5f63 6865 636b  ..    def _check
-00025680: 5f66 7328 7365 6c66 293a 0a20 2020 2020  _fs(self):.     
-00025690: 2020 2022 2222 2043 6865 636b 7320 6966     """ Checks if
-000256a0: 2074 6865 7265 2061 7265 2065 6e6f 6768   there are enogh
-000256b0: 2070 6172 616d 6574 6572 7320 616e 6420   parameters and 
-000256c0: 6672 6565 2073 796d 626f 6c73 2e0a 2020  free symbols..  
-000256d0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-000256e0: 2020 6673 203d 2073 6574 2829 0a20 2020    fs = set().   
-000256f0: 2020 2020 2069 6620 7365 6c66 2e5f 6578       if self._ex
-00025700: 7072 3a0a 2020 2020 2020 2020 2020 2020  pr:.            
-00025710: 6673 203d 207b 7365 6c66 2e5f 6578 7072  fs = {self._expr
-00025720: 2e76 6172 7d0a 2020 2020 2020 2020 7261  .var}.        ra
-00025730: 6e67 6573 2c20 7061 7261 6d73 203d 2073  nges, params = s
-00025740: 656c 662e 7261 6e67 6573 2c20 7365 6c66  elf.ranges, self
-00025750: 2e70 6172 616d 730a 0a20 2020 2020 2020  .params..       
-00025760: 2023 2066 726f 6d20 7468 6520 6578 7072   # from the expr
-00025770: 6573 7369 6f6e 2773 2066 7265 6520 7379  ession's free sy
-00025780: 6d62 6f6c 732c 2072 656d 6f76 6520 7468  mbols, remove th
-00025790: 6520 6f6e 6573 2075 7365 6420 696e 0a20  e ones used in. 
-000257a0: 2020 2020 2020 2023 2074 6865 2070 6172         # the par
-000257b0: 616d 6574 6572 7320 616e 6420 7468 6520  ameters and the 
-000257c0: 7261 6e67 6573 0a20 2020 2020 2020 2066  ranges.        f
-000257d0: 7320 3d20 6673 2e64 6966 6665 7265 6e63  s = fs.differenc
-000257e0: 6528 7061 7261 6d73 2e6b 6579 7328 2929  e(params.keys())
-000257f0: 0a20 2020 2020 2020 2069 6620 7261 6e67  .        if rang
-00025800: 6573 2069 7320 6e6f 7420 4e6f 6e65 3a0a  es is not None:.
-00025810: 2020 2020 2020 2020 2020 2020 6673 203d              fs =
-00025820: 2066 732e 6469 6666 6572 656e 6365 285b   fs.difference([
-00025830: 725b 305d 2066 6f72 2072 2069 6e20 7261  r[0] for r in ra
-00025840: 6e67 6573 5d29 0a0a 2020 2020 2020 2020  nges])..        
-00025850: 6966 206c 656e 2866 7329 203e 2031 3a0a  if len(fs) > 1:.
-00025860: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00025870: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
-00025880: 2020 2020 2020 2020 2020 2020 2020 2249                "I
-00025890: 6e63 6f6d 7061 7469 626c 6520 6578 7072  ncompatible expr
-000258a0: 6573 7369 6f6e 2061 6e64 2070 6172 616d  ession and param
-000258b0: 6574 6572 732e 5c6e 220a 2020 2020 2020  eters.\n".      
-000258c0: 2020 2020 2020 2020 2020 2b20 2253 7065            + "Spe
-000258d0: 6369 6679 2077 6861 7420 7468 6573 6520  cify what these 
-000258e0: 7379 6d62 6f6c 7320 7265 7072 6573 656e  symbols represen
-000258f0: 743a 207b 7d5c 6e22 2e66 6f72 6d61 7428  t: {}\n".format(
-00025900: 6673 290a 2020 2020 2020 2020 2020 2020  fs).            
-00025910: 2020 2020 2b20 2241 7265 2074 6865 7920      + "Are they 
-00025920: 7261 6e67 6573 206f 7220 7061 7261 6d65  ranges or parame
-00025930: 7465 7273 3f22 0a20 2020 2020 2020 2020  ters?".         
-00025940: 2020 2029 0a0a 2020 2020 2020 2020 2320     )..        # 
-00025950: 7665 7269 6679 2074 6861 7420 616c 6c20  verify that all 
-00025960: 7379 6d62 6f6c 7320 6172 6520 6b6e 6f77  symbols are know
-00025970: 6e20 2874 6865 7920 6569 7468 6572 2072  n (they either r
-00025980: 6570 7265 7365 6e74 2070 6c6f 7474 696e  epresent plottin
-00025990: 670a 2020 2020 2020 2020 2320 7261 6e67  g.        # rang
-000259a0: 6573 206f 7220 7061 7261 6d65 7465 7273  es or parameters
-000259b0: 290a 2020 2020 2020 2020 7261 6e67 655f  ).        range_
-000259c0: 7379 6d62 6f6c 7320 3d20 5b72 5b30 5d20  symbols = [r[0] 
-000259d0: 666f 7220 7220 696e 2072 616e 6765 735d  for r in ranges]
-000259e0: 0a20 2020 2020 2020 2066 6f72 2072 2069  .        for r i
-000259f0: 6e20 7261 6e67 6573 3a0a 2020 2020 2020  n ranges:.      
-00025a00: 2020 2020 2020 6673 203d 2073 6574 2829        fs = set()
-00025a10: 2e75 6e69 6f6e 282a 5b65 2e66 7265 655f  .union(*[e.free_
-00025a20: 7379 6d62 6f6c 7320 666f 7220 6520 696e  symbols for e in
-00025a30: 2072 5b31 3a5d 5d29 0a20 2020 2020 2020   r[1:]]).       
-00025a40: 2020 2020 2069 6620 616e 7928 7420 696e       if any(t in
-00025a50: 2066 7320 666f 7220 7420 696e 2072 616e   fs for t in ran
-00025a60: 6765 5f73 796d 626f 6c73 293a 0a20 2020  ge_symbols):.   
-00025a70: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-00025a80: 7365 2056 616c 7565 4572 726f 7228 2252  se ValueError("R
-00025a90: 616e 6765 2073 796d 626f 6c73 2063 616e  ange symbols can
-00025aa0: 2774 2062 6520 696e 636c 7564 6564 2069  't be included i
-00025ab0: 6e74 6f20 220a 2020 2020 2020 2020 2020  nto ".          
-00025ac0: 2020 2020 2020 2020 2020 226d 696e 696d            "minim
-00025ad0: 756d 2061 6e64 206d 6178 696d 756d 206f  um and maximum o
-00025ae0: 6620 6120 7261 6e67 652e 2022 0a20 2020  f a range. ".   
-00025af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025b00: 2022 5265 6365 6976 6564 2072 616e 6765   "Received range
-00025b10: 3a20 2573 2220 2520 7374 7228 7229 290a  : %s" % str(r)).
-00025b20: 2020 2020 2020 2020 2020 2020 7265 6d61              rema
-00025b30: 696e 696e 675f 6673 203d 2066 732e 6469  ining_fs = fs.di
-00025b40: 6666 6572 656e 6365 2870 6172 616d 732e  fference(params.
-00025b50: 6b65 7973 2829 290a 2020 2020 2020 2020  keys()).        
-00025b60: 2020 2020 6966 206c 656e 2872 656d 6169      if len(remai
-00025b70: 6e69 6e67 5f66 7329 203e 2030 3a0a 2020  ning_fs) > 0:.  
-00025b80: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-00025b90: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
-00025ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025bb0: 2020 2020 2255 6e6b 6f77 6e20 7379 6d62      "Unkown symb
-00025bc0: 6f6c 7320 666f 756e 6420 696e 2070 6c6f  ols found in plo
-00025bd0: 7474 696e 6720 7261 6e67 653a 2025 732e  tting range: %s.
-00025be0: 2022 2025 2028 722c 2920 2b0a 2020 2020   " % (r,) +.    
-00025bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025c00: 2241 7265 2074 6865 2066 6f6c 6c6f 7769  "Are the followi
-00025c10: 6e67 2070 6172 616d 6574 6572 733f 2025  ng parameters? %
-00025c20: 7322 2025 2072 656d 6169 6e69 6e67 5f66  s" % remaining_f
-00025c30: 7329 0a0a 0a63 6c61 7373 204e 7971 7569  s)...class Nyqui
-00025c40: 7374 4c69 6e65 5365 7269 6573 2843 6f6e  stLineSeries(Con
-00025c50: 7472 6f6c 4261 7365 5365 7269 6573 293a  trolBaseSeries):
-00025c60: 0a20 2020 2022 2222 4765 6e65 7261 7465  .    """Generate
-00025c70: 7320 6e75 6d65 7269 6361 6c20 6461 7461  s numerical data
-00025c80: 2066 6f72 204e 7971 7569 7374 2070 6c6f   for Nyquist plo
-00025c90: 7420 7573 696e 6720 7468 6520 6060 636f  t using the ``co
-00025ca0: 6e74 726f 6c60 600a 2020 2020 6d6f 6475  ntrol``.    modu
-00025cb0: 6c65 2e0a 2020 2020 2222 220a 0a20 2020  le..    """..   
-00025cc0: 205f 616c 6c6f 7765 645f 6b65 7973 203d   _allowed_keys =
-00025cd0: 205b 0a20 2020 2020 2020 2022 6172 726f   [.        "arro
-00025ce0: 7773 222c 2022 6d61 785f 6375 7276 655f  ws", "max_curve_
-00025cf0: 6d61 676e 6974 7564 6522 2c20 226d 6178  magnitude", "max
-00025d00: 5f63 7572 7665 5f6f 6666 7365 7422 2c0a  _curve_offset",.
-00025d10: 2020 2020 2020 2020 2273 7461 7274 5f6d          "start_m
-00025d20: 6172 6b65 7222 2c20 2270 7269 6d61 7279  arker", "primary
-00025d30: 5f73 7479 6c65 222c 2022 6d69 7272 6f72  _style", "mirror
-00025d40: 5f73 7479 6c65 220a 2020 2020 5d0a 0a20  _style".    ].. 
-00025d50: 2020 2064 6566 205f 636f 7079 5f66 726f     def _copy_fro
-00025d60: 6d5f 6469 6374 2873 656c 662c 2064 2c20  m_dict(self, d, 
-00025d70: 6b29 3a0a 2020 2020 2020 2020 6966 206b  k):.        if k
-00025d80: 2069 6e20 642e 6b65 7973 2829 3a0a 2020   in d.keys():.  
-00025d90: 2020 2020 2020 2020 2020 7365 7461 7474            setatt
-00025da0: 7228 7365 6c66 2c20 6b2c 2064 5b6b 5d29  r(self, k, d[k])
-00025db0: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
-00025dc0: 5f5f 2873 656c 662c 2074 662c 2076 6172  __(self, tf, var
-00025dd0: 5f73 7461 7274 5f65 6e64 2c20 6c61 6265  _start_end, labe
-00025de0: 6c3d 2222 2c20 2a2a 6b77 6172 6773 293a  l="", **kwargs):
-00025df0: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
-00025e00: 2e5f 5f69 6e69 745f 5f28 7466 2c20 6c61  .__init__(tf, la
-00025e10: 6265 6c3d 6c61 6265 6c2c 202a 2a6b 7761  bel=label, **kwa
-00025e20: 7267 7329 0a20 2020 2020 2020 2073 656c  rgs).        sel
-00025e30: 662e 7261 6e67 6573 203d 205b 7661 725f  f.ranges = [var_
-00025e40: 7374 6172 745f 656e 645d 0a20 2020 2020  start_end].     
-00025e50: 2020 2073 656c 662e 5f63 6865 636b 5f66     self._check_f
-00025e60: 7328 290a 0a20 2020 2020 2020 2023 2074  s()..        # t
-00025e70: 6865 7365 2061 7474 7269 6275 7465 7320  hese attributes 
-00025e80: 6172 6520 7573 6564 2062 7920 6060 636f  are used by ``co
-00025e90: 6e74 726f 6c60 6020 696e 2074 6865 2072  ntrol`` in the r
-00025ea0: 656e 6465 7269 6e67 2073 7465 702c 0a20  endering step,. 
-00025eb0: 2020 2020 2020 2023 206e 6f74 2069 6e20         # not in 
-00025ec0: 7468 6520 6461 7461 2067 656e 6572 6174  the data generat
-00025ed0: 696f 6e20 7374 6570 2e20 4920 6e65 6564  ion step. I need
-00025ee0: 2074 6865 6d20 6865 7265 2069 6e20 6f72   them here in or
-00025ef0: 6465 7220 746f 0a20 2020 2020 2020 2023  der to.        #
-00025f00: 2063 6f6e 7472 6f6c 2074 6865 2072 656e   control the ren
-00025f10: 6465 7269 6e67 2069 6e20 6561 6368 2062  dering in each b
-00025f20: 6163 6b65 6e64 2e0a 2020 2020 2020 2020  ackend..        
-00025f30: 7365 6c66 2e61 7272 6f77 7320 3d20 6b77  self.arrows = kw
-00025f40: 6172 6773 2e67 6574 2822 6172 726f 7773  args.get("arrows
-00025f50: 222c 2032 290a 2020 2020 2020 2020 7365  ", 2).        se
-00025f60: 6c66 2e6d 6178 5f63 7572 7665 5f6d 6167  lf.max_curve_mag
-00025f70: 6e69 7475 6465 203d 206b 7761 7267 732e  nitude = kwargs.
-00025f80: 6765 7428 226d 6178 5f63 7572 7665 5f6d  get("max_curve_m
-00025f90: 6167 6e69 7475 6465 222c 2032 3029 0a20  agnitude", 20). 
-00025fa0: 2020 2020 2020 2073 656c 662e 6d61 785f         self.max_
-00025fb0: 6375 7276 655f 6f66 6673 6574 203d 206b  curve_offset = k
-00025fc0: 7761 7267 732e 6765 7428 226d 6178 5f63  wargs.get("max_c
-00025fd0: 7572 7665 5f6f 6666 7365 7422 2c20 302e  urve_offset", 0.
-00025fe0: 3032 290a 2020 2020 2020 2020 7365 6c66  02).        self
-00025ff0: 2e73 7461 7274 5f6d 6172 6b65 7220 3d20  .start_marker = 
-00026000: 6b77 6172 6773 2e67 6574 2822 7374 6172  kwargs.get("star
-00026010: 745f 6d61 726b 6572 222c 2054 7275 6529  t_marker", True)
-00026020: 0a20 2020 2020 2020 2073 656c 662e 7072  .        self.pr
-00026030: 696d 6172 795f 7374 796c 6520 3d20 6b77  imary_style = kw
-00026040: 6172 6773 2e67 6574 2822 7072 696d 6172  args.get("primar
-00026050: 795f 7374 796c 6522 2c20 4e6f 6e65 290a  y_style", None).
-00026060: 2020 2020 2020 2020 7365 6c66 2e6d 6972          self.mir
-00026070: 726f 725f 7374 796c 6520 3d20 6b77 6172  ror_style = kwar
-00026080: 6773 2e67 6574 2822 6d69 7272 6f72 5f73  gs.get("mirror_s
-00026090: 7479 6c65 222c 204e 6f6e 6529 0a20 2020  tyle", None).   
-000260a0: 2020 2020 2066 6f72 206b 2069 6e20 5b22       for k in ["
-000260b0: 6172 726f 7773 222c 2022 6d61 785f 6375  arrows", "max_cu
-000260c0: 7276 655f 6d61 676e 6974 7564 6522 2c20  rve_magnitude", 
-000260d0: 226d 6178 5f63 7572 7665 5f6f 6666 7365  "max_curve_offse
-000260e0: 7422 2c0a 2020 2020 2020 2020 2020 2020  t",.            
-000260f0: 2273 7461 7274 5f6d 6172 6b65 7222 2c20  "start_marker", 
-00026100: 2270 7269 6d61 7279 5f73 7479 6c65 222c  "primary_style",
-00026110: 2022 6d69 7272 6f72 5f73 7479 6c65 225d   "mirror_style"]
-00026120: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-00026130: 6c66 2e5f 636f 7079 5f66 726f 6d5f 6469  lf._copy_from_di
-00026140: 6374 2873 656c 662e 5f63 6f6e 7472 6f6c  ct(self._control
-00026150: 5f6b 772c 206b 290a 0a20 2020 2020 2020  _kw, k)..       
-00026160: 2023 2050 6172 7365 2074 6865 2061 7272   # Parse the arr
-00026170: 6f77 7320 6b65 7977 6f72 640a 2020 2020  ows keyword.    
-00026180: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
-00026190: 6d6f 6475 6c65 2822 6e75 6d70 7922 290a  module("numpy").
-000261a0: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
-000261b0: 656c 662e 6172 726f 7773 3a0a 2020 2020  elf.arrows:.    
-000261c0: 2020 2020 2020 2020 7365 6c66 2e61 7272          self.arr
-000261d0: 6f77 5f6c 6f63 7320 3d20 5b5d 0a20 2020  ow_locs = [].   
-000261e0: 2020 2020 2065 6c69 6620 6973 696e 7374       elif isinst
-000261f0: 616e 6365 2873 656c 662e 6172 726f 7773  ance(self.arrows
-00026200: 2c20 696e 7429 3a0a 2020 2020 2020 2020  , int):.        
-00026210: 2020 2020 4e20 3d20 7365 6c66 2e61 7272      N = self.arr
-00026220: 6f77 730a 2020 2020 2020 2020 2020 2020  ows.            
-00026230: 2320 5370 6163 6520 6172 726f 7773 206f  # Space arrows o
-00026240: 7574 2c20 7374 6172 7469 6e67 206d 6964  ut, starting mid
-00026250: 7761 7920 616c 6f6e 6720 6561 6368 2022  way along each "
-00026260: 7265 6769 6f6e 220a 2020 2020 2020 2020  region".        
-00026270: 2020 2020 7365 6c66 2e61 7272 6f77 5f6c      self.arrow_l
-00026280: 6f63 7320 3d20 6e70 2e6c 696e 7370 6163  ocs = np.linspac
-00026290: 6528 302e 352f 4e2c 2031 202b 2030 2e35  e(0.5/N, 1 + 0.5
-000262a0: 2f4e 2c20 4e2c 2065 6e64 706f 696e 743d  /N, N, endpoint=
-000262b0: 4661 6c73 6529 0a20 2020 2020 2020 2065  False).        e
-000262c0: 6c69 6620 6973 696e 7374 616e 6365 2873  lif isinstance(s
-000262d0: 656c 662e 6172 726f 7773 2c20 286c 6973  elf.arrows, (lis
-000262e0: 742c 206e 702e 6e64 6172 7261 7929 293a  t, np.ndarray)):
-000262f0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00026300: 662e 6172 726f 775f 6c6f 6373 203d 206e  f.arrow_locs = n
-00026310: 702e 736f 7274 286e 702e 6174 6c65 6173  p.sort(np.atleas
-00026320: 745f 3164 2873 656c 662e 6172 726f 7773  t_1d(self.arrows
-00026330: 2929 0a20 2020 2020 2020 2065 6c73 653a  )).        else:
-00026340: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-00026350: 7365 2056 616c 7565 4572 726f 7228 2275  se ValueError("u
-00026360: 6e6b 6e6f 776e 206f 7220 756e 7375 7070  nknown or unsupp
-00026370: 6f72 7465 6420 6172 726f 7720 6c6f 6361  orted arrow loca
-00026380: 7469 6f6e 2229 0a0a 2020 2020 6465 6620  tion")..    def 
-00026390: 6765 745f 6461 7461 2873 656c 6629 3a0a  get_data(self):.
-000263a0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-000263b0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-000263c0: 2020 2020 3d3d 3d3d 3d3d 3d0a 2020 2020      =======.    
-000263d0: 2020 2020 785f 7265 672c 2079 5f72 6567      x_reg, y_reg
-000263e0: 203a 206e 702e 6e64 6172 7261 790a 2020   : np.ndarray.  
-000263f0: 2020 2020 2020 785f 7363 6c2c 2079 5f73        x_scl, y_s
-00026400: 636c 203a 206e 702e 6e64 6172 7261 790a  cl : np.ndarray.
-00026410: 2020 2020 2020 2020 785f 696e 7631 2c20          x_inv1, 
-00026420: 795f 696e 7631 203a 206e 702e 6e64 6172  y_inv1 : np.ndar
-00026430: 7261 790a 2020 2020 2020 2020 785f 696e  ray.        x_in
-00026440: 7632 2c20 795f 696e 7632 203a 206e 702e  v2, y_inv2 : np.
-00026450: 6e64 6172 7261 790a 2020 2020 2020 2020  ndarray.        
-00026460: 6375 7276 655f 6f66 6673 6574 203a 206e  curve_offset : n
-00026470: 702e 6e64 6172 7261 790a 2020 2020 2020  p.ndarray.      
-00026480: 2020 2222 220a 2020 2020 2020 2020 6e70    """.        np
-00026490: 203d 2069 6d70 6f72 745f 6d6f 6475 6c65   = import_module
-000264a0: 2822 6e75 6d70 7922 290a 2020 2020 2020  ("numpy").      
-000264b0: 2020 6374 203d 2069 6d70 6f72 745f 6d6f    ct = import_mo
-000264c0: 6475 6c65 2822 636f 6e74 726f 6c22 290a  dule("control").
-000264d0: 2020 2020 2020 2020 6d65 7267 6564 6565          mergedee
-000264e0: 7020 3d20 696d 706f 7274 5f6d 6f64 756c  p = import_modul
-000264f0: 6528 276d 6572 6765 6465 6570 2729 0a0a  e('mergedeep')..
-00026500: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00026510: 6973 5f69 6e74 6572 6163 7469 7665 3a0a  is_interactive:.
-00026520: 2020 2020 2020 2020 2020 2020 7466 203d              tf =
-00026530: 2073 656c 662e 5f65 7870 722e 7375 6273   self._expr.subs
-00026540: 2873 656c 662e 7061 7261 6d73 290a 2020  (self.params).  
-00026550: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
-00026560: 636f 6e74 726f 6c5f 7466 203d 2074 665f  control_tf = tf_
-00026570: 746f 5f63 6f6e 7472 6f6c 2874 6629 0a0a  to_control(tf)..
-00026580: 2020 2020 2020 2020 636f 6e74 726f 6c5f          control_
-00026590: 6b77 203d 207b 7d0a 2020 2020 2020 2020  kw = {}.        
-000265a0: 7379 6d2c 2073 7461 7274 2c20 656e 6420  sym, start, end 
-000265b0: 3d20 7365 6c66 2e72 616e 6765 735b 305d  = self.ranges[0]
-000265c0: 0a20 2020 2020 2020 2069 6620 2873 7461  .        if (sta
-000265d0: 7274 2021 3d20 656e 6429 206f 7220 7365  rt != end) or se
-000265e0: 6c66 2e5f 696e 7465 7261 6374 6976 655f  lf._interactive_
-000265f0: 7261 6e67 6573 3a0a 2020 2020 2020 2020  ranges:.        
-00026600: 2020 2020 7374 6172 7420 3d20 7365 6c66      start = self
-00026610: 2e5f 7570 6461 7465 5f72 616e 6765 5f76  ._update_range_v
-00026620: 616c 7565 2873 7461 7274 292e 7265 616c  alue(start).real
-00026630: 0a20 2020 2020 2020 2020 2020 2065 6e64  .            end
-00026640: 203d 2073 656c 662e 5f75 7064 6174 655f   = self._update_
-00026650: 7261 6e67 655f 7661 6c75 6528 656e 6429  range_value(end)
-00026660: 2e72 6561 6c0a 2020 2020 2020 2020 2020  .real.          
-00026670: 2020 636f 6e74 726f 6c5f 6b77 5b22 6f6d    control_kw["om
-00026680: 6567 615f 6c69 6d69 7473 225d 203d 205b  ega_limits"] = [
-00026690: 3130 2a2a 7374 6172 742c 2031 302a 2a65  10**start, 10**e
-000266a0: 6e64 5d0a 0a20 2020 2020 2020 2063 6b77  nd]..        ckw
-000266b0: 203d 206d 6572 6765 6465 6570 2e6d 6572   = mergedeep.mer
-000266c0: 6765 287b 7d2c 2063 6f6e 7472 6f6c 5f6b  ge({}, control_k
-000266d0: 772c 2073 656c 662e 5f63 6f6e 7472 6f6c  w, self._control
-000266e0: 5f6b 7729 0a20 2020 2020 2020 2063 6b77  _kw).        ckw
-000266f0: 5b22 706c 6f74 225d 203d 2046 616c 7365  ["plot"] = False
-00026700: 0a20 2020 2020 2020 2063 6b77 5b22 7265  .        ckw["re
-00026710: 7475 726e 5f63 6f6e 746f 7572 225d 203d  turn_contour"] =
-00026720: 2054 7275 650a 2020 2020 2020 2020 5f2c   True.        _,
-00026730: 2063 6f6e 746f 7572 203d 2063 742e 6e79   contour = ct.ny
-00026740: 7175 6973 745f 706c 6f74 2873 656c 662e  quist_plot(self.
-00026750: 5f63 6f6e 7472 6f6c 5f74 662c 202a 2a63  _control_tf, **c
-00026760: 6b77 290a 0a20 2020 2020 2020 2072 6573  kw)..        res
-00026770: 7020 3d20 7365 6c66 2e5f 636f 6e74 726f  p = self._contro
-00026780: 6c5f 7466 2863 6f6e 746f 7572 290a 0a20  l_tf(contour).. 
-00026790: 2020 2020 2020 2023 0a20 2020 2020 2020         #.       
-000267a0: 2023 204e 4f54 453a 2074 6865 2066 6f6c   # NOTE: the fol
-000267b0: 6c6f 7769 6e67 2069 7320 6164 6170 7465  lowing is adapte
-000267c0: 6420 6672 6f6d 3a0a 2020 2020 2020 2020  d from:.        
-000267d0: 2320 6060 636f 6e74 726f 6c2e 6672 6571  # ``control.freq
-000267e0: 706c 6f74 2e70 6c6f 745f 6e79 7175 6973  plot.plot_nyquis
-000267f0: 7428 2960 600a 2020 2020 2020 2020 2320  t()``.        # 
-00026800: 4265 6361 7573 6520 7468 6174 2066 756e  Because that fun
-00026810: 6374 696f 6e20 646f 6573 6e27 7420 7265  ction doesn't re
-00026820: 7475 726e 2060 6073 706c 616e 655f 636f  turn ``splane_co
-00026830: 6e74 6f75 7260 6020 616e 6420 6974 2069  ntour`` and it i
-00026840: 730a 2020 2020 2020 2020 2320 7665 7279  s.        # very
-00026850: 2064 6966 6669 6375 6c74 2074 6f20 7265   difficult to re
-00026860: 6275 696c 6420 6974 2c20 4920 7265 6d6f  build it, I remo
-00026870: 7665 6420 6974 2066 726f 6d20 7468 6520  ved it from the 
-00026880: 666f 6c6c 6f77 696e 6720 636f 6465 2e0a  following code..
-00026890: 2020 2020 2020 2020 2320 4669 6e67 6572          # Finger
-000268a0: 2063 726f 7373 6564 2e0a 2020 2020 2020   crossed..      
-000268b0: 2020 230a 0a20 2020 2020 2020 206d 6178    #..        max
-000268c0: 5f63 7572 7665 5f6d 6167 6e69 7475 6465  _curve_magnitude
-000268d0: 203d 2073 656c 662e 6d61 785f 6375 7276   = self.max_curv
-000268e0: 655f 6d61 676e 6974 7564 650a 2020 2020  e_magnitude.    
-000268f0: 2020 2020 6d61 785f 6375 7276 655f 6f66      max_curve_of
-00026900: 6673 6574 203d 2073 656c 662e 6d61 785f  fset = self.max_
-00026910: 6375 7276 655f 6f66 6673 6574 0a0a 2020  curve_offset..  
-00026920: 2020 2020 2020 7265 675f 6d61 736b 203d        reg_mask =
-00026930: 206e 702e 6162 7328 7265 7370 2920 3e20   np.abs(resp) > 
-00026940: 6d61 785f 6375 7276 655f 6d61 676e 6974  max_curve_magnit
-00026950: 7564 650a 0a20 2020 2020 2020 2073 6361  ude..        sca
-00026960: 6c65 5f6d 6173 6b20 3d20 7e72 6567 5f6d  le_mask = ~reg_m
-00026970: 6173 6b20 5c0a 2020 2020 2020 2020 2020  ask \.          
-00026980: 2020 2620 6e70 2e63 6f6e 6361 7465 6e61    & np.concatena
-00026990: 7465 2828 7e72 6567 5f6d 6173 6b5b 313a  te((~reg_mask[1:
-000269a0: 5d2c 207e 7265 675f 6d61 736b 5b2d 313a  ], ~reg_mask[-1:
-000269b0: 5d29 2920 5c0a 2020 2020 2020 2020 2020  ])) \.          
-000269c0: 2020 2620 6e70 2e63 6f6e 6361 7465 6e61    & np.concatena
-000269d0: 7465 2828 7e72 6567 5f6d 6173 6b5b 303a  te((~reg_mask[0:
-000269e0: 315d 2c20 7e72 6567 5f6d 6173 6b5b 3a2d  1], ~reg_mask[:-
-000269f0: 315d 2929 0a0a 2020 2020 2020 2020 2320  1]))..        # 
-00026a00: 5265 7363 616c 6520 7468 6520 706f 696e  Rescale the poin
-00026a10: 7473 2077 6974 6820 6c61 7267 6520 6d61  ts with large ma
-00026a20: 676e 6974 7564 650a 2020 2020 2020 2020  gnitude.        
-00026a30: 7265 7363 616c 6520 3d20 6e70 2e6c 6f67  rescale = np.log
-00026a40: 6963 616c 5f61 6e64 280a 2020 2020 2020  ical_and(.      
-00026a50: 2020 2020 2020 7265 675f 6d61 736b 2c20        reg_mask, 
-00026a60: 6162 7328 7265 7370 2920 3e20 6d61 785f  abs(resp) > max_
-00026a70: 6375 7276 655f 6d61 676e 6974 7564 6529  curve_magnitude)
-00026a80: 0a20 2020 2020 2020 2072 6573 705b 7265  .        resp[re
-00026a90: 7363 616c 655d 202a 3d20 6d61 785f 6375  scale] *= max_cu
-00026aa0: 7276 655f 6d61 676e 6974 7564 6520 2f20  rve_magnitude / 
-00026ab0: 6162 7328 7265 7370 5b72 6573 6361 6c65  abs(resp[rescale
-00026ac0: 5d29 0a0a 2020 2020 2020 2020 2320 506c  ])..        # Pl
-00026ad0: 6f74 2074 6865 2072 6567 756c 6172 2070  ot the regular p
-00026ae0: 6f72 7469 6f6e 7320 6f66 2074 6865 2063  ortions of the c
-00026af0: 7572 7665 2028 616e 6420 6772 6162 2074  urve (and grab t
-00026b00: 6865 2063 6f6c 6f72 290a 2020 2020 2020  he color).      
-00026b10: 2020 785f 7265 6720 3d20 6e70 2e6d 612e    x_reg = np.ma.
-00026b20: 6d61 736b 6564 5f77 6865 7265 2872 6567  masked_where(reg
-00026b30: 5f6d 6173 6b2c 2072 6573 702e 7265 616c  _mask, resp.real
-00026b40: 290a 2020 2020 2020 2020 795f 7265 6720  ).        y_reg 
-00026b50: 3d20 6e70 2e6d 612e 6d61 736b 6564 5f77  = np.ma.masked_w
-00026b60: 6865 7265 2872 6567 5f6d 6173 6b2c 2072  here(reg_mask, r
-00026b70: 6573 702e 696d 6167 290a 0a20 2020 2020  esp.imag)..     
-00026b80: 2020 2023 2046 6967 7572 6520 6f75 7420     # Figure out 
-00026b90: 686f 7720 6d75 6368 2074 6f20 6f66 6673  how much to offs
-00026ba0: 6574 2074 6865 2063 7572 7665 3a20 7468  et the curve: th
-00026bb0: 6520 6f66 6673 6574 2067 6f65 7320 6672  e offset goes fr
-00026bc0: 6f6d 0a20 2020 2020 2020 2023 207a 6572  om.        # zer
-00026bd0: 6f20 6174 2074 6865 2073 7461 7274 206f  o at the start o
-00026be0: 6620 7468 6520 7363 616c 6564 2073 6563  f the scaled sec
-00026bf0: 7469 6f6e 2074 6f20 6d61 785f 6375 7276  tion to max_curv
-00026c00: 655f 6f66 6673 6574 2061 730a 2020 2020  e_offset as.    
-00026c10: 2020 2020 2320 7765 206d 6f76 6520 616c      # we move al
-00026c20: 6f6e 6720 7468 6520 6375 7276 650a 2020  ong the curve.  
-00026c30: 2020 2020 2020 6375 7276 655f 6f66 6673        curve_offs
-00026c40: 6574 203d 2073 656c 662e 5f63 6f6d 7075  et = self._compu
-00026c50: 7465 5f63 7572 7665 5f6f 6666 7365 7428  te_curve_offset(
-00026c60: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
-00026c70: 702c 2073 6361 6c65 5f6d 6173 6b2c 206d  p, scale_mask, m
-00026c80: 6178 5f63 7572 7665 5f6f 6666 7365 7429  ax_curve_offset)
-00026c90: 0a0a 2020 2020 2020 2020 2320 506c 6f74  ..        # Plot
-00026ca0: 2074 6865 2073 6361 6c65 6420 7365 6374   the scaled sect
-00026cb0: 696f 6e73 206f 6620 7468 6520 6375 7276  ions of the curv
-00026cc0: 6520 2863 6861 6e67 696e 6720 6c69 6e65  e (changing line
-00026cd0: 7374 796c 6529 0a20 2020 2020 2020 2078  style).        x
-00026ce0: 5f73 636c 203d 206e 702e 6d61 2e6d 6173  _scl = np.ma.mas
-00026cf0: 6b65 645f 7768 6572 6528 7363 616c 655f  ked_where(scale_
-00026d00: 6d61 736b 2c20 7265 7370 2e72 6561 6c29  mask, resp.real)
-00026d10: 0a20 2020 2020 2020 2079 5f73 636c 203d  .        y_scl =
-00026d20: 206e 702e 6d61 2e6d 6173 6b65 645f 7768   np.ma.masked_wh
-00026d30: 6572 6528 7363 616c 655f 6d61 736b 2c20  ere(scale_mask, 
-00026d40: 7265 7370 2e69 6d61 6729 0a0a 2020 2020  resp.imag)..    
-00026d50: 2020 2020 2320 7468 6520 7072 696d 6172      # the primar
-00026d60: 7920 6375 7276 6520 2869 6e76 6973 6962  y curve (invisib
-00026d70: 6c65 2920 666f 7220 7365 7474 696e 6720  le) for setting 
-00026d80: 6172 726f 7773 0a20 2020 2020 2020 2078  arrows.        x
-00026d90: 5f69 6e76 312c 2079 5f69 6e76 3120 3d20  _inv1, y_inv1 = 
-00026da0: 7265 7370 2e72 6561 6c2e 636f 7079 2829  resp.real.copy()
-00026db0: 2c20 7265 7370 2e69 6d61 672e 636f 7079  , resp.imag.copy
-00026dc0: 2829 0a20 2020 2020 2020 2078 5f69 6e76  ().        x_inv
-00026dd0: 315b 7265 675f 6d61 736b 5d20 2a3d 2028  1[reg_mask] *= (
-00026de0: 3120 2b20 6375 7276 655f 6f66 6673 6574  1 + curve_offset
-00026df0: 5b72 6567 5f6d 6173 6b5d 290a 2020 2020  [reg_mask]).    
-00026e00: 2020 2020 795f 696e 7631 5b72 6567 5f6d      y_inv1[reg_m
-00026e10: 6173 6b5d 202a 3d20 2831 202b 2063 7572  ask] *= (1 + cur
-00026e20: 7665 5f6f 6666 7365 745b 7265 675f 6d61  ve_offset[reg_ma
-00026e30: 736b 5d29 0a0a 2020 2020 2020 2020 2320  sk])..        # 
-00026e40: 4164 6420 7468 6520 6172 726f 7773 2074  Add the arrows t
-00026e50: 6f20 7468 6520 6d69 7272 6f72 2069 6d61  o the mirror ima
-00026e60: 6765 2028 6f6e 2074 6f70 206f 6620 616e  ge (on top of an
-00026e70: 2069 6e76 6973 6962 6c65 2063 6f6e 746f   invisible conto
-00026e80: 7572 290a 2020 2020 2020 2020 785f 696e  ur).        x_in
-00026e90: 7632 2c20 795f 696e 7632 203d 2072 6573  v2, y_inv2 = res
-00026ea0: 702e 7265 616c 2e63 6f70 7928 292c 2072  p.real.copy(), r
-00026eb0: 6573 702e 696d 6167 2e63 6f70 7928 290a  esp.imag.copy().
-00026ec0: 2020 2020 2020 2020 785f 696e 7632 5b72          x_inv2[r
-00026ed0: 6567 5f6d 6173 6b5d 202a 3d20 2831 202d  eg_mask] *= (1 -
-00026ee0: 2063 7572 7665 5f6f 6666 7365 745b 7265   curve_offset[re
-00026ef0: 675f 6d61 736b 5d29 0a20 2020 2020 2020  g_mask]).       
-00026f00: 2079 5f69 6e76 325b 7265 675f 6d61 736b   y_inv2[reg_mask
-00026f10: 5d20 2a3d 2028 3120 2d20 6375 7276 655f  ] *= (1 - curve_
-00026f20: 6f66 6673 6574 5b72 6567 5f6d 6173 6b5d  offset[reg_mask]
-00026f30: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
-00026f40: 6e20 785f 7265 672c 2079 5f72 6567 2c20  n x_reg, y_reg, 
-00026f50: 785f 7363 6c2c 2079 5f73 636c 2c20 785f  x_scl, y_scl, x_
-00026f60: 696e 7631 2c20 795f 696e 7631 2c20 785f  inv1, y_inv1, x_
-00026f70: 696e 7632 2c20 795f 696e 7632 2c20 6375  inv2, y_inv2, cu
-00026f80: 7276 655f 6f66 6673 6574 0a0a 2020 2020  rve_offset..    
-00026f90: 4073 7461 7469 636d 6574 686f 640a 2020  @staticmethod.  
-00026fa0: 2020 6465 6620 5f63 6f6d 7075 7465 5f63    def _compute_c
-00026fb0: 7572 7665 5f6f 6666 7365 7428 7265 7370  urve_offset(resp
-00026fc0: 2c20 6d61 736b 2c20 6d61 785f 6f66 6673  , mask, max_offs
-00026fd0: 6574 293a 0a20 2020 2020 2020 2022 2222  et):.        """
-00026fe0: 0a20 2020 2020 2020 2020 2020 2046 756e  .            Fun
-00026ff0: 6374 696f 6e20 746f 2063 6f6d 7075 7465  ction to compute
-00027000: 204e 7971 7569 7374 2063 7572 7665 206f   Nyquist curve o
-00027010: 6666 7365 7473 0a0a 2020 2020 2020 2020  ffsets..        
-00027020: 5468 6973 2066 756e 6374 696f 6e20 636f  This function co
-00027030: 6d70 7574 6573 2061 2073 6d6f 6f74 686c  mputes a smoothl
-00027040: 7920 7661 7279 696e 6720 6f66 6673 6574  y varying offset
-00027050: 2074 6861 7420 7374 6172 7473 2061 6e64   that starts and
-00027060: 2065 6e64 7320 6174 0a20 2020 2020 2020   ends at.       
-00027070: 207a 6572 6f20 6174 2074 6865 2065 6e64   zero at the end
-00027080: 7320 6f66 2061 2073 6361 6c65 6420 7365  s of a scaled se
-00027090: 676d 656e 742e 0a0a 2020 2020 2020 2020  gment...        
-000270a0: 5468 6973 2066 756e 6374 696f 6e20 636f  This function co
-000270b0: 6d65 7320 6672 6f6d 2060 6063 6f6e 7472  mes from ``contr
-000270c0: 6f6c 2f66 7265 7170 6c6f 742e 7079 6060  ol/freqplot.py``
-000270d0: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-000270e0: 2020 2020 2020 6e70 203d 2069 6d70 6f72        np = impor
-000270f0: 745f 6d6f 6475 6c65 2822 6e75 6d70 7922  t_module("numpy"
-00027100: 290a 0a20 2020 2020 2020 2023 2043 6f6d  )..        # Com
-00027110: 7075 7465 2074 6865 2061 7263 206c 656e  pute the arc len
-00027120: 6774 6820 616c 6f6e 6720 7468 6520 6375  gth along the cu
-00027130: 7276 650a 2020 2020 2020 2020 735f 6375  rve.        s_cu
-00027140: 7276 6520 3d20 6e70 2e63 756d 7375 6d28  rve = np.cumsum(
-00027150: 0a20 2020 2020 2020 2020 2020 206e 702e  .            np.
-00027160: 7371 7274 286e 702e 6469 6666 2872 6573  sqrt(np.diff(res
-00027170: 702e 7265 616c 2920 2a2a 2032 202b 206e  p.real) ** 2 + n
-00027180: 702e 6469 6666 2872 6573 702e 696d 6167  p.diff(resp.imag
-00027190: 2920 2a2a 2032 2929 0a0a 2020 2020 2020  ) ** 2))..      
-000271a0: 2020 2320 496e 6974 6961 6c69 7a65 2074    # Initialize t
-000271b0: 6865 206f 6666 7365 740a 2020 2020 2020  he offset.      
-000271c0: 2020 6f66 6673 6574 203d 206e 702e 7a65    offset = np.ze
-000271d0: 726f 7328 7265 7370 2e73 697a 6529 0a20  ros(resp.size). 
-000271e0: 2020 2020 2020 2061 7263 6c65 6e20 3d20         arclen = 
-000271f0: 6e70 2e7a 6572 6f73 2872 6573 702e 7369  np.zeros(resp.si
-00027200: 7a65 290a 0a20 2020 2020 2020 2023 2057  ze)..        # W
-00027210: 616c 6b20 7468 726f 7567 6820 7468 6520  alk through the 
-00027220: 7265 7370 6f6e 7365 2061 6e64 206b 6565  response and kee
-00027230: 7020 7472 6163 6b20 6f66 2065 6163 6820  p track of each 
-00027240: 636f 6e74 696e 6f75 7320 636f 6d70 6f6e  continous compon
-00027250: 656e 740a 2020 2020 2020 2020 692c 206e  ent.        i, n
-00027260: 7365 6773 203d 2030 2c20 300a 2020 2020  segs = 0, 0.    
-00027270: 2020 2020 7768 696c 6520 6920 3c20 7265      while i < re
-00027280: 7370 2e73 697a 653a 0a20 2020 2020 2020  sp.size:.       
-00027290: 2020 2020 2023 2053 6b69 7020 7468 6520       # Skip the 
-000272a0: 7265 6775 6c61 7220 7365 676d 656e 740a  regular segment.
-000272b0: 2020 2020 2020 2020 2020 2020 7768 696c              whil
-000272c0: 6520 6920 3c20 7265 7370 2e73 697a 6520  e i < resp.size 
-000272d0: 616e 6420 6d61 736b 5b69 5d3a 0a20 2020  and mask[i]:.   
-000272e0: 2020 2020 2020 2020 2020 2020 2069 202b               i +
-000272f0: 3d20 3120 2020 2020 2020 2020 2020 2020  = 1             
-00027300: 2023 2049 6e63 7265 6d65 6e74 2074 6865   # Increment the
-00027310: 2063 6f75 6e74 6572 0a20 2020 2020 2020   counter.       
-00027320: 2020 2020 2020 2020 2069 6620 6920 3d3d           if i ==
-00027330: 2072 6573 702e 7369 7a65 3a0a 2020 2020   resp.size:.    
-00027340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027350: 6272 6561 6b0a 2020 2020 2020 2020 2020  break.          
-00027360: 2020 2020 2020 2320 4b65 6570 2074 7261        # Keep tra
-00027370: 636b 206f 6620 7468 6520 6172 636c 656e  ck of the arclen
-00027380: 6774 680a 2020 2020 2020 2020 2020 2020  gth.            
-00027390: 2020 2020 6172 636c 656e 5b69 5d20 3d20      arclen[i] = 
-000273a0: 6172 636c 656e 5b69 2d31 5d20 2b20 6e70  arclen[i-1] + np
-000273b0: 2e61 6273 2872 6573 705b 695d 202d 2072  .abs(resp[i] - r
-000273c0: 6573 705b 692d 315d 290a 0a20 2020 2020  esp[i-1])..     
-000273d0: 2020 2020 2020 206e 7365 6773 202b 3d20         nsegs += 
-000273e0: 302e 350a 2020 2020 2020 2020 2020 2020  0.5.            
-000273f0: 6966 2069 203d 3d20 7265 7370 2e73 697a  if i == resp.siz
-00027400: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00027410: 2020 2062 7265 616b 0a0a 2020 2020 2020     break..      
-00027420: 2020 2020 2020 2320 5361 7665 2074 6865        # Save the
-00027430: 2073 7461 7274 696e 6720 6f66 6673 6574   starting offset
-00027440: 206f 6620 7468 6973 2073 6567 6d65 6e74   of this segment
-00027450: 0a20 2020 2020 2020 2020 2020 2073 6567  .            seg
-00027460: 5f73 7461 7274 203d 2069 0a0a 2020 2020  _start = i..    
-00027470: 2020 2020 2020 2020 2320 5761 6c6b 2074          # Walk t
-00027480: 6872 6f75 6768 2074 6865 2073 6361 6c65  hrough the scale
-00027490: 6420 7365 676d 656e 740a 2020 2020 2020  d segment.      
-000274a0: 2020 2020 2020 7768 696c 6520 6920 3c20        while i < 
-000274b0: 7265 7370 2e73 697a 6520 616e 6420 6e6f  resp.size and no
-000274c0: 7420 6d61 736b 5b69 5d3a 0a20 2020 2020  t mask[i]:.     
-000274d0: 2020 2020 2020 2020 2020 2069 202b 3d20             i += 
-000274e0: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
-000274f0: 2020 6966 2069 203d 3d20 7265 7370 2e73    if i == resp.s
-00027500: 697a 653a 2020 2320 5365 6520 6966 2077  ize:  # See if w
-00027510: 6520 6172 6520 646f 6e65 2077 6974 6820  e are done with 
-00027520: 7468 6973 2073 6567 6d65 6e74 0a20 2020  this segment.   
-00027530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027540: 2062 7265 616b 0a20 2020 2020 2020 2020   break.         
-00027550: 2020 2020 2020 2023 204b 6565 7020 7472         # Keep tr
-00027560: 6163 6b20 6f66 2074 6865 2061 7263 6c65  ack of the arcle
-00027570: 6e67 7468 0a20 2020 2020 2020 2020 2020  ngth.           
-00027580: 2020 2020 2061 7263 6c65 6e5b 695d 203d       arclen[i] =
-00027590: 2061 7263 6c65 6e5b 692d 315d 202b 206e   arclen[i-1] + n
-000275a0: 702e 6162 7328 7265 7370 5b69 5d20 2d20  p.abs(resp[i] - 
-000275b0: 7265 7370 5b69 2d31 5d29 0a0a 2020 2020  resp[i-1])..    
-000275c0: 2020 2020 2020 2020 6e73 6567 7320 2b3d          nsegs +=
-000275d0: 2030 2e35 0a20 2020 2020 2020 2020 2020   0.5.           
-000275e0: 2069 6620 6920 3d3d 2072 6573 702e 7369   if i == resp.si
-000275f0: 7a65 3a0a 2020 2020 2020 2020 2020 2020  ze:.            
-00027600: 2020 2020 6272 6561 6b0a 0a20 2020 2020      break..     
-00027610: 2020 2020 2020 2023 2053 6176 6520 7468         # Save th
-00027620: 6520 656e 6469 6e67 206f 6666 7365 7420  e ending offset 
-00027630: 6f66 2074 6869 7320 7365 676d 656e 740a  of this segment.
-00027640: 2020 2020 2020 2020 2020 2020 7365 675f              seg_
-00027650: 656e 6420 3d20 690a 0a20 2020 2020 2020  end = i..       
-00027660: 2020 2020 2023 204e 6f77 2063 6f6d 7075       # Now compu
-00027670: 7465 2074 6865 2073 6361 6c69 6e67 2066  te the scaling f
-00027680: 6f72 2074 6869 7320 7365 676d 656e 740a  or this segment.
-00027690: 2020 2020 2020 2020 2020 2020 735f 7365              s_se
-000276a0: 676d 656e 7420 3d20 6172 636c 656e 5b73  gment = arclen[s
-000276b0: 6567 5f65 6e64 2d31 5d20 2d20 6172 636c  eg_end-1] - arcl
-000276c0: 656e 5b73 6567 5f73 7461 7274 5d0a 2020  en[seg_start].  
-000276d0: 2020 2020 2020 2020 2020 6f66 6673 6574            offset
-000276e0: 5b73 6567 5f73 7461 7274 3a73 6567 5f65  [seg_start:seg_e
-000276f0: 6e64 5d20 3d20 6d61 785f 6f66 6673 6574  nd] = max_offset
-00027700: 202a 2073 5f73 6567 6d65 6e74 2f73 5f63   * s_segment/s_c
-00027710: 7572 7665 5b2d 315d 202a 205c 0a20 2020  urve[-1] * \.   
-00027720: 2020 2020 2020 2020 2020 2020 206e 702e               np.
-00027730: 7369 6e28 6e70 2e70 6920 2a20 2861 7263  sin(np.pi * (arc
-00027740: 6c65 6e5b 7365 675f 7374 6172 743a 7365  len[seg_start:se
-00027750: 675f 656e 645d 0a20 2020 2020 2020 2020  g_end].         
-00027760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027770: 2020 2020 2020 202d 2061 7263 6c65 6e5b         - arclen[
-00027780: 7365 675f 7374 6172 745d 292f 735f 7365  seg_start])/s_se
-00027790: 676d 656e 7429 0a0a 2020 2020 2020 2020  gment)..        
-000277a0: 7265 7475 726e 206f 6666 7365 740a 0a0a  return offset...
-000277b0: 636c 6173 7320 526f 6f74 4c6f 6375 7353  class RootLocusS
-000277c0: 6572 6965 7328 436f 6e74 726f 6c42 6173  eries(ControlBas
-000277d0: 6553 6572 6965 7329 3a0a 2020 2020 2222  eSeries):.    ""
-000277e0: 2247 656e 6572 6174 6573 206e 756d 6572  "Generates numer
-000277f0: 6963 616c 2064 6174 6120 666f 7220 726f  ical data for ro
-00027800: 6f74 206c 6f63 7573 2070 6c6f 7420 7573  ot locus plot us
-00027810: 696e 6720 7468 6520 6060 636f 6e74 726f  ing the ``contro
-00027820: 6c60 600a 2020 2020 6d6f 6475 6c65 2e0a  l``.    module..
-00027830: 0a20 2020 2053 796d 626f 6c69 6320 6578  .    Symbolic ex
-00027840: 7072 6573 7369 6f6e 7320 6f72 2053 796d  pressions or Sym
-00027850: 5079 2773 2074 7261 6e73 6665 7220 6675  Py's transfer fu
-00027860: 6e63 7469 6f6e 7320 6172 6520 636f 6e76  nctions are conv
-00027870: 6572 7465 6420 746f 0a20 2020 2060 6063  erted to.    ``c
-00027880: 6f6e 7472 6f6c 2e54 7261 6e73 6665 7246  ontrol.TransferF
-00027890: 756e 6374 696f 6e60 602e 2049 6620 6120  unction``. If a 
-000278a0: 696e 7465 7261 6374 6976 652d 7769 6467  interactive-widg
-000278b0: 6574 2070 6c6f 7420 6973 2063 7265 6174  et plot is creat
-000278c0: 6564 2c0a 2020 2020 6174 2065 6163 6820  ed,.    at each 
-000278d0: 7769 6467 6574 2773 2073 7461 7465 2d63  widget's state-c
-000278e0: 6861 6e67 6520 7468 6520 7570 6461 7465  hange the update
-000278f0: 6420 7379 6d62 6f6c 6963 2074 7261 6e73  d symbolic trans
-00027900: 6665 7220 6675 6e63 7469 6f6e 0a20 2020  fer function.   
-00027910: 2077 696c 6c20 6265 2063 6f6e 7665 7274   will be convert
-00027920: 6564 2074 6f20 6060 636f 6e74 726f 6c2e  ed to ``control.
-00027930: 5472 616e 7366 6572 4675 6e63 7469 6f6e  TransferFunction
-00027940: 6060 2e0a 0a20 2020 2049 7420 6861 7320  ``...    It has 
-00027950: 6265 656e 2073 686f 776e 2074 6861 7420  been shown that 
-00027960: 6e75 6d70 792e 726f 6f74 7328 2920 7072  numpy.roots() pr
-00027970: 6f64 7563 6573 2069 6e61 6363 7572 6174  oduces inaccurat
-00027980: 6520 7265 7375 6c74 7320 696e 0a20 2020  e results in.   
-00027990: 2063 6f6d 7061 7269 736f 6e20 746f 2073   comparison to s
-000279a0: 796d 7079 2e72 6f6f 7473 2829 2e20 6874  ympy.roots(). ht
-000279b0: 7470 733a 2f2f 6769 7468 7562 2e63 6f6d  tps://github.com
-000279c0: 2f73 796d 7079 2f73 796d 7079 2f69 7373  /sympy/sympy/iss
-000279d0: 7565 732f 3235 3233 340a 2020 2020 486f  ues/25234.    Ho
-000279e0: 7765 7665 722c 2077 6520 6172 6520 6465  wever, we are de
-000279f0: 616c 696e 6720 7769 7468 2061 2072 6f6f  aling with a roo
-00027a00: 7420 6c6f 6375 7320 706c 6f74 2c20 7768  t locus plot, wh
-00027a10: 6572 6520 6272 616e 6368 6573 2073 7461  ere branches sta
-00027a20: 7274 2066 726f 6d0a 2020 2020 706f 6c65  rt from.    pole
-00027a30: 7320 616e 6420 676f 6573 2074 6f20 7a65  s and goes to ze
-00027a40: 726f 7320 286f 7220 746f 2069 6e66 696e  ros (or to infin
-00027a50: 6974 7929 2e20 4865 6e63 652c 2074 6865  ity). Hence, the
-00027a60: 7365 2065 7272 6f72 7320 6172 650a 2020  se errors are.  
-00027a70: 2020 6c69 6b65 6c79 2074 6f20 6265 2069    likely to be i
-00027a80: 7272 656c 6576 616e 7420 6f6e 2061 2070  rrelevant on a p
-00027a90: 7261 6374 6963 616c 2063 6173 652e 2054  ractical case. T
-00027aa0: 6869 7320 6461 7461 2073 6572 6965 7320  his data series 
-00027ab0: 7573 6573 0a20 2020 2060 6063 6f6e 7472  uses.    ``contr
-00027ac0: 6f6c 6060 2028 6865 6e63 6520 6e75 6d70  ol`` (hence nump
-00027ad0: 7929 2066 6f72 2070 6572 666f 726d 6163  y) for performac
-00027ae0: 652e 0a0a 2020 2020 5265 6665 7265 6e63  e...    Referenc
-00027af0: 6573 0a20 2020 203d 3d3d 3d3d 3d3d 3d3d  es.    =========
-00027b00: 3d0a 0a20 2020 2068 7474 7073 3a2f 2f67  =..    https://g
-00027b10: 6974 6875 622e 636f 6d2f 7079 7468 6f6e  ithub.com/python
-00027b20: 2d63 6f6e 7472 6f6c 2f70 7974 686f 6e2d  -control/python-
-00027b30: 636f 6e74 726f 6c0a 0a20 2020 2022 2222  control..    """
-00027b40: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
-00027b50: 5f5f 2873 656c 662c 2074 662c 206c 6162  __(self, tf, lab
-00027b60: 656c 3d22 222c 202a 2a6b 7761 7267 7329  el="", **kwargs)
-00027b70: 3a0a 2020 2020 2020 2020 7375 7065 7228  :.        super(
-00027b80: 292e 5f5f 696e 6974 5f5f 2874 662c 206c  ).__init__(tf, l
-00027b90: 6162 656c 3d6c 6162 656c 2c20 2a2a 6b77  abel=label, **kw
-00027ba0: 6172 6773 290a 2020 2020 2020 2020 7365  args).        se
-00027bb0: 6c66 2e5f 6368 6563 6b5f 6673 2829 0a0a  lf._check_fs()..
-00027bc0: 2020 2020 2020 2020 2320 636f 6d70 7574          # comput
-00027bd0: 6520 6170 7072 6f70 7269 6174 6520 6178  e appropriate ax
-00027be0: 6973 206c 696d 6974 7320 6672 6f6d 2074  is limits from t
-00027bf0: 6865 2074 7261 6e73 6665 7220 6675 6e63  he transfer func
-00027c00: 7469 6f6e 0a20 2020 2020 2020 2023 2061  tion.        # a
-00027c10: 7373 6f63 6961 7465 6420 746f 2074 6869  ssociated to thi
-00027c20: 7320 6461 7461 2073 6572 6965 732e 0a20  s data series.. 
-00027c30: 2020 2020 2020 2073 656c 662e 5f78 6c69         self._xli
-00027c40: 6d20 3d20 4e6f 6e65 0a20 2020 2020 2020  m = None.       
-00027c50: 2073 656c 662e 5f79 6c69 6d20 3d20 4e6f   self._ylim = No
-00027c60: 6e65 0a20 2020 2020 2020 2023 207a 6572  ne.        # zer
-00027c70: 6f73 2061 6e64 2070 6f6c 6573 2061 7265  os and poles are
-00027c80: 206e 6563 6573 7361 7279 2069 6e20 6f72   necessary in or
-00027c90: 6465 7220 746f 2073 686f 7720 6170 7072  der to show appr
-00027ca0: 6f70 7269 6174 6520 6d61 726b 6572 732e  opriate markers.
-00027cb0: 0a20 2020 2020 2020 2073 656c 662e 5f7a  .        self._z
-00027cc0: 6572 6f73 203d 204e 6f6e 650a 2020 2020  eros = None.    
-00027cd0: 2020 2020 7365 6c66 2e5f 706f 6c65 7320      self._poles 
-00027ce0: 3d20 4e6f 6e65 0a0a 2020 2020 2020 2020  = None..        
-00027cf0: 7365 6c66 2e5f 636f 6e74 726f 6c5f 6b77  self._control_kw
-00027d00: 5b22 706c 6f74 225d 203d 2046 616c 7365  ["plot"] = False
-00027d10: 0a20 2020 2020 2020 2073 656c 662e 5f7a  .        self._z
-00027d20: 6572 6f73 5f72 6b20 3d20 6b77 6172 6773  eros_rk = kwargs
-00027d30: 2e67 6574 2822 7a65 726f 735f 726b 222c  .get("zeros_rk",
-00027d40: 2064 6963 7428 2929 0a20 2020 2020 2020   dict()).       
-00027d50: 2073 656c 662e 5f70 6f6c 6573 5f72 6b20   self._poles_rk 
-00027d60: 3d20 6b77 6172 6773 2e67 6574 2822 706f  = kwargs.get("po
-00027d70: 6c65 735f 726b 222c 2064 6963 7428 2929  les_rk", dict())
-00027d80: 0a0a 2020 2020 6465 6620 5f5f 7374 725f  ..    def __str_
-00027d90: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
-00027da0: 2065 7870 7220 3d20 7365 6c66 2e5f 6578   expr = self._ex
-00027db0: 7072 2069 6620 7365 6c66 2e5f 6578 7072  pr if self._expr
-00027dc0: 2065 6c73 6520 7365 6c66 2e5f 636f 6e74   else self._cont
-00027dd0: 726f 6c5f 7466 0a20 2020 2020 2020 2072  rol_tf.        r
-00027de0: 6574 7572 6e20 2272 6f6f 7420 6c6f 6375  eturn "root locu
-00027df0: 7320 6f66 2022 202b 2073 7472 2865 7870  s of " + str(exp
-00027e00: 7229 0a0a 2020 2020 6465 6620 5f63 6f6d  r)..    def _com
-00027e10: 7075 7465 5f61 7869 735f 6c69 6d69 7473  pute_axis_limits
-00027e20: 2873 656c 662c 2072 6f6f 7473 5f61 7272  (self, roots_arr
-00027e30: 6179 293a 0a20 2020 2020 2020 2022 2222  ay):.        """
-00027e40: 4174 7465 6d70 7420 746f 2063 6f6d 7075  Attempt to compu
-00027e50: 7465 2061 7070 726f 7072 6961 7465 2061  te appropriate a
-00027e60: 7869 7320 6c69 6d69 7473 2073 6f20 7468  xis limits so th
-00027e70: 6174 2074 6865 2070 6c6f 740a 2020 2020  at the plot.    
-00027e80: 2020 2020 7669 7375 616c 697a 6573 2074      visualizes t
-00027e90: 6865 2069 6d70 6f72 7461 6e74 2070 6172  he important par
-00027ea0: 7473 206f 6620 7468 6520 726f 6f74 206c  ts of the root l
-00027eb0: 6f63 7573 2e0a 2020 2020 2020 2020 2222  ocus..        ""
-00027ec0: 220a 2020 2020 2020 2020 6e70 203d 2069  ".        np = i
-00027ed0: 6d70 6f72 745f 6d6f 6475 6c65 2822 6e75  mport_module("nu
-00027ee0: 6d70 7922 290a 0a20 2020 2020 2020 2074  mpy")..        t
-00027ef0: 6620 3d20 7365 6c66 2e5f 636f 6e74 726f  f = self._contro
-00027f00: 6c5f 7466 0a20 2020 2020 2020 205f 6270  l_tf.        _bp
-00027f10: 203d 2073 656c 662e 5f62 7265 616b 5f70   = self._break_p
-00027f20: 6f69 6e74 7328 0a20 2020 2020 2020 2020  oints(.         
-00027f30: 2020 206e 702e 706f 6c79 3164 2874 662e     np.poly1d(tf.
-00027f40: 6e75 6d5b 305d 5b30 5d29 2c0a 2020 2020  num[0][0]),.    
-00027f50: 2020 2020 2020 2020 6e70 2e70 6f6c 7931          np.poly1
-00027f60: 6428 7466 2e64 656e 5b30 5d5b 305d 290a  d(tf.den[0][0]).
-00027f70: 2020 2020 2020 2020 295b 315d 0a0a 2020          )[1]..  
-00027f80: 2020 2020 2020 2320 726f 6f74 206c 6f63        # root loc
-00027f90: 7573 2062 7261 6e63 6865 7320 7374 6172  us branches star
-00027fa0: 7473 2066 726f 6d20 706f 6c65 7320 616e  ts from poles an
-00027fb0: 6420 676f 6573 2074 6f20 7a65 726f 7320  d goes to zeros 
-00027fc0: 6f72 0a20 2020 2020 2020 2023 2069 6e66  or.        # inf
-00027fd0: 696e 6974 792e 204c 6f6f 6b20 666f 7220  inity. Look for 
-00027fe0: 7468 6520 6272 616e 6368 6573 2074 6861  the branches tha
-00027ff0: 7420 676f 6573 2074 6f20 7a65 726f 732c  t goes to zeros,
-00028000: 2066 696e 6420 7468 650a 2020 2020 2020   find the.      
-00028010: 2020 2320 6d61 7869 6d75 6d20 696d 6167    # maximum imag
-00028020: 696e 6172 7920 7061 7274 2e20 5468 6973  inary part. This
-00028030: 2077 696c 6c20 6265 2075 7365 6420 746f   will be used to
-00028040: 2063 6f6d 7075 7465 2079 6c69 6d2e 0a20   compute ylim.. 
-00028050: 2020 2020 2020 206d 6178 5f68 6569 6768         max_heigh
-00028060: 7473 203d 205b 5d0a 2020 2020 2020 2020  ts = [].        
-00028070: 666f 7220 7020 696e 2073 656c 662e 5f70  for p in self._p
-00028080: 6f6c 6573 3a0a 2020 2020 2020 2020 2020  oles:.          
-00028090: 2020 666f 7220 6320 696e 2072 6f6f 7473    for c in roots
-000280a0: 5f61 7272 6179 2e54 3a0a 2020 2020 2020  _array.T:.      
-000280b0: 2020 2020 2020 2020 2020 6966 2061 6273            if abs
-000280c0: 2870 202d 2063 5b30 5d29 203c 2031 652d  (p - c[0]) < 1e-
-000280d0: 3033 3a0a 2020 2020 2020 2020 2020 2020  03:.            
-000280e0: 2020 2020 2020 2020 6966 2061 6e79 2861          if any(a
-000280f0: 6273 287a 202d 2063 5b2d 315d 2920 3c20  bs(z - c[-1]) < 
-00028100: 3165 2d30 3320 666f 7220 7a20 696e 2073  1e-03 for z in s
-00028110: 656c 662e 5f7a 6572 6f73 293a 0a20 2020  elf._zeros):.   
-00028120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028130: 2020 2020 2069 203d 206e 702e 6172 676d       i = np.argm
-00028140: 6178 286e 702e 6162 7328 632e 696d 6167  ax(np.abs(c.imag
-00028150: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
-00028160: 2020 2020 2020 2020 2020 206d 6178 5f68             max_h
-00028170: 6569 6768 7473 2e61 7070 656e 6428 635b  eights.append(c[
-00028180: 695d 290a 2020 2020 2020 2020 6d69 6e5f  i]).        min_
-00028190: 6865 6967 6874 7320 3d20 5b2d 7420 666f  heights = [-t fo
-000281a0: 7220 7420 696e 206d 6178 5f68 6569 6768  r t in max_heigh
-000281b0: 7473 5d0a 0a20 2020 2020 2020 2064 6566  ts]..        def
-000281c0: 205f 6865 6c70 6572 2878 2c20 6d61 7267   _helper(x, marg
-000281d0: 696e 5f66 6163 746f 725f 6c6f 7765 722c  in_factor_lower,
-000281e0: 206d 6172 6769 6e5f 6661 6374 6f72 5f75   margin_factor_u
-000281f0: 7070 6572 293a 0a20 2020 2020 2020 2020  pper):.         
-00028200: 2020 206d 696e 5f78 2c20 6d61 785f 7820     min_x, max_x 
-00028210: 3d20 6e70 2e6e 616e 6d69 6e28 7829 2c20  = np.nanmin(x), 
-00028220: 6e70 2e6e 616e 6d61 7828 7829 0a20 2020  np.nanmax(x).   
-00028230: 2020 2020 2020 2020 2023 2074 6869 7320           # this 
-00028240: 6f66 6673 6574 2061 6c6c 6f77 7320 746f  offset allows to
-00028250: 2068 6176 6520 6120 6c69 7474 6c65 2062   have a little b
-00028260: 6974 206f 6620 656d 7074 7920 7370 6163  it of empty spac
-00028270: 6520 6f6e 2074 6865 0a20 2020 2020 2020  e on the.       
-00028280: 2020 2020 2023 204c 4850 206f 6620 726f       # LHP of ro
-00028290: 6f74 206c 6f63 7573 2070 6c6f 740a 2020  ot locus plot.  
-000282a0: 2020 2020 2020 2020 2020 6f66 6673 6574            offset
-000282b0: 203d 2030 2e32 350a 2020 2020 2020 2020   = 0.25.        
-000282c0: 2020 2020 6d69 6e5f 7820 3d20 6d69 6e5f      min_x = min_
-000282d0: 7820 2d20 6f66 6673 6574 2069 6620 6e70  x - offset if np
-000282e0: 2e69 7363 6c6f 7365 286d 696e 5f78 2c20  .isclose(min_x, 
-000282f0: 3029 2065 6c73 6520 6d69 6e5f 780a 2020  0) else min_x.  
-00028300: 2020 2020 2020 2020 2020 6d61 785f 7820            max_x 
-00028310: 3d20 6d61 785f 7820 2b20 6f66 6673 6574  = max_x + offset
-00028320: 2069 6620 6e70 2e69 7363 6c6f 7365 286d   if np.isclose(m
-00028330: 6178 5f78 2c20 3029 2065 6c73 6520 6d61  ax_x, 0) else ma
-00028340: 785f 780a 2020 2020 2020 2020 2020 2020  x_x.            
-00028350: 2320 7072 6f76 6964 6520 6120 6c69 7474  # provide a litt
-00028360: 6c65 2062 6974 206f 6620 6d61 7267 696e  le bit of margin
-00028370: 0a20 2020 2020 2020 2020 2020 2064 656c  .            del
-00028380: 7461 203d 2061 6273 286d 6178 5f78 202d  ta = abs(max_x -
-00028390: 206d 696e 5f78 290a 2020 2020 2020 2020   min_x).        
-000283a0: 2020 2020 6c69 6d20 3d20 5b6d 696e 5f78      lim = [min_x
-000283b0: 202d 2064 656c 7461 202a 206d 6172 6769   - delta * margi
-000283c0: 6e5f 6661 6374 6f72 5f6c 6f77 6572 2c20  n_factor_lower, 
-000283d0: 6d61 785f 7820 2b20 6465 6c74 6120 2a20  max_x + delta * 
-000283e0: 6d61 7267 696e 5f66 6163 746f 725f 7570  margin_factor_up
-000283f0: 7065 725d 0a20 2020 2020 2020 2020 2020  per].           
-00028400: 2069 6620 6e70 2e69 7363 6c6f 7365 282a   if np.isclose(*
-00028410: 6c69 6d29 3a0a 2020 2020 2020 2020 2020  lim):.          
-00028420: 2020 2020 2020 2320 7072 6576 656e 7420        # prevent 
-00028430: 6178 6973 206c 696d 6974 7320 746f 2062  axis limits to b
-00028440: 6520 7468 6520 7361 6d65 0a20 2020 2020  e the same.     
-00028450: 2020 2020 2020 2020 2020 206c 696d 5b30             lim[0
-00028460: 5d20 2d3d 2031 0a20 2020 2020 2020 2020  ] -= 1.         
-00028470: 2020 2020 2020 206c 696d 5b31 5d20 2b3d         lim[1] +=
-00028480: 2031 0a20 2020 2020 2020 2020 2020 2072   1.            r
-00028490: 6574 7572 6e20 6c69 6d0a 0a20 2020 2020  eturn lim..     
-000284a0: 2020 2069 6d70 6f72 7461 6e74 5f70 6f69     important_poi
-000284b0: 6e74 7320 3d20 6e70 2e63 6f6e 6361 7465  nts = np.concate
-000284c0: 6e61 7465 280a 2020 2020 2020 2020 2020  nate(.          
-000284d0: 2020 5b73 656c 662e 5f7a 6572 6f73 2c20    [self._zeros, 
-000284e0: 7365 6c66 2e5f 706f 6c65 732c 205f 6270  self._poles, _bp
-000284f0: 2c20 6d61 785f 6865 6967 6874 732c 206d  , max_heights, m
-00028500: 696e 5f68 6569 6768 7473 5d29 0a20 2020  in_heights]).   
-00028510: 2020 2020 2073 656c 662e 5f78 6c69 6d20       self._xlim 
-00028520: 3d20 5f68 656c 7065 7228 696d 706f 7274  = _helper(import
-00028530: 616e 745f 706f 696e 7473 2e72 6561 6c2c  ant_points.real,
-00028540: 2030 2e31 352c 2030 2e30 3529 0a20 2020   0.15, 0.05).   
-00028550: 2020 2020 2073 656c 662e 5f79 6c69 6d20       self._ylim 
-00028560: 3d20 5f68 656c 7065 7228 696d 706f 7274  = _helper(import
-00028570: 616e 745f 706f 696e 7473 2e69 6d61 672c  ant_points.imag,
-00028580: 2030 2e30 352c 2030 2e30 3529 0a0a 2020   0.05, 0.05)..  
-00028590: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-000285a0: 6465 6620 7a65 726f 7328 7365 6c66 293a  def zeros(self):
-000285b0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-000285c0: 2e5f 7a65 726f 7320 6973 204e 6f6e 653a  ._zeros is None:
-000285d0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-000285e0: 662e 6765 745f 6461 7461 2829 0a20 2020  f.get_data().   
-000285f0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00028600: 2e5f 7a65 726f 730a 0a20 2020 2040 7072  ._zeros..    @pr
-00028610: 6f70 6572 7479 0a20 2020 2064 6566 2070  operty.    def p
-00028620: 6f6c 6573 2873 656c 6629 3a0a 2020 2020  oles(self):.    
-00028630: 2020 2020 6966 2073 656c 662e 5f70 6f6c      if self._pol
-00028640: 6573 2069 7320 4e6f 6e65 3a0a 2020 2020  es is None:.    
-00028650: 2020 2020 2020 2020 7365 6c66 2e67 6574          self.get
-00028660: 5f64 6174 6128 290a 2020 2020 2020 2020  _data().        
-00028670: 7265 7475 726e 2073 656c 662e 5f70 6f6c  return self._pol
-00028680: 6573 0a0a 2020 2020 4070 726f 7065 7274  es..    @propert
-00028690: 790a 2020 2020 6465 6620 786c 696d 2873  y.    def xlim(s
-000286a0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-000286b0: 7475 726e 2073 656c 662e 5f78 6c69 6d0a  turn self._xlim.
-000286c0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-000286d0: 2020 2064 6566 2079 6c69 6d28 7365 6c66     def ylim(self
-000286e0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-000286f0: 6e20 7365 6c66 2e5f 796c 696d 0a0a 2020  n self._ylim..  
-00028700: 2020 6465 6620 5f62 7265 616b 5f70 6f69    def _break_poi
-00028710: 6e74 7328 7365 6c66 2c20 6e75 6d2c 2064  nts(self, num, d
-00028720: 656e 293a 0a20 2020 2020 2020 2022 2222  en):.        """
-00028730: 4578 7472 6163 7420 6272 6561 6b20 706f  Extract break po
-00028740: 696e 7473 206f 7665 7220 7265 616c 2061  ints over real a
-00028750: 7869 7320 616e 6420 6761 696e 7320 6769  xis and gains gi
-00028760: 7665 6e20 7468 6573 6520 6c6f 6361 7469  ven these locati
-00028770: 6f6e 7322 2222 0a20 2020 2020 2020 2023  ons""".        #
-00028780: 2074 7970 653a 2028 6e70 2e70 6f6c 7931   type: (np.poly1
-00028790: 642c 206e 702e 706f 6c79 3164 2920 2d3e  d, np.poly1d) ->
-000287a0: 2028 6e70 2e61 7272 6179 2c20 6e70 2e61   (np.array, np.a
-000287b0: 7272 6179 290a 2020 2020 2020 2020 646e  rray).        dn
-000287c0: 756d 203d 206e 756d 2e64 6572 6976 286d  um = num.deriv(m
-000287d0: 3d31 290a 2020 2020 2020 2020 6464 656e  =1).        dden
-000287e0: 203d 2064 656e 2e64 6572 6976 286d 3d31   = den.deriv(m=1
-000287f0: 290a 2020 2020 2020 2020 706f 6c79 6e6f  ).        polyno
-00028800: 6d20 3d20 6465 6e20 2a20 646e 756d 202d  m = den * dnum -
-00028810: 206e 756d 202a 2064 6465 6e0a 2020 2020   num * dden.    
-00028820: 2020 2020 7265 616c 5f62 7265 616b 5f70      real_break_p
-00028830: 7473 203d 2070 6f6c 796e 6f6d 2e72 0a20  ts = polynom.r. 
-00028840: 2020 2020 2020 2023 2064 6f6e 2774 2063         # don't c
-00028850: 6172 6520 6162 6f75 7420 696e 6669 6e69  are about infini
-00028860: 7465 2062 7265 616b 2070 6f69 6e74 730a  te break points.
-00028870: 2020 2020 2020 2020 7265 616c 5f62 7265          real_bre
-00028880: 616b 5f70 7473 203d 2072 6561 6c5f 6272  ak_pts = real_br
-00028890: 6561 6b5f 7074 735b 6e75 6d28 7265 616c  eak_pts[num(real
-000288a0: 5f62 7265 616b 5f70 7473 2920 213d 2030  _break_pts) != 0
-000288b0: 5d0a 2020 2020 2020 2020 6b5f 6272 6561  ].        k_brea
-000288c0: 6b20 3d20 2d64 656e 2872 6561 6c5f 6272  k = -den(real_br
-000288d0: 6561 6b5f 7074 7329 202f 206e 756d 2872  eak_pts) / num(r
-000288e0: 6561 6c5f 6272 6561 6b5f 7074 7329 0a20  eal_break_pts). 
-000288f0: 2020 2020 2020 2069 6478 203d 206b 5f62         idx = k_b
-00028900: 7265 616b 203e 3d20 696e 7428 3029 2020  reak >= int(0)  
-00028910: 2023 206f 6e6c 7920 706f 7369 7469 7665   # only positive
-00028920: 7320 6761 696e 730a 2020 2020 2020 2020  s gains.        
-00028930: 6b5f 6272 6561 6b20 3d20 6b5f 6272 6561  k_break = k_brea
-00028940: 6b5b 6964 785d 0a20 2020 2020 2020 2072  k[idx].        r
-00028950: 6561 6c5f 6272 6561 6b5f 7074 7320 3d20  eal_break_pts = 
-00028960: 7265 616c 5f62 7265 616b 5f70 7473 5b69  real_break_pts[i
-00028970: 6478 5d0a 2020 2020 2020 2020 6966 206c  dx].        if l
-00028980: 656e 286b 5f62 7265 616b 2920 3d3d 2030  en(k_break) == 0
-00028990: 3a0a 2020 2020 2020 2020 2020 2020 6b5f  :.            k_
-000289a0: 6272 6561 6b20 3d20 5b30 5d0a 2020 2020  break = [0].    
-000289b0: 2020 2020 2020 2020 7265 616c 5f62 7265          real_bre
-000289c0: 616b 5f70 7473 203d 2064 656e 2e72 6f6f  ak_pts = den.roo
-000289d0: 7473 0a20 2020 2020 2020 2072 6574 7572  ts.        retur
-000289e0: 6e20 6b5f 6272 6561 6b2c 2072 6561 6c5f  n k_break, real_
-000289f0: 6272 6561 6b5f 7074 730a 0a20 2020 2064  break_pts..    d
-00028a00: 6566 2067 6574 5f64 6174 6128 7365 6c66  ef get_data(self
-00028a10: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-00028a20: 2020 2020 2020 2052 6574 7572 6e73 0a20         Returns. 
-00028a30: 2020 2020 2020 203d 3d3d 3d3d 3d3d 0a20         =======. 
-00028a40: 2020 2020 2020 2072 6f6f 7473 203a 206e         roots : n
-00028a50: 6461 7272 6179 0a20 2020 2020 2020 2020  darray.         
-00028a60: 2020 2043 6c6f 7365 642d 6c6f 6f70 2072     Closed-loop r
-00028a70: 6f6f 7420 6c6f 6361 7469 6f6e 732c 2061  oot locations, a
-00028a80: 7272 616e 6765 6420 696e 2077 6869 6368  rranged in which
-00028a90: 2065 6163 6820 726f 7720 636f 7272 6573   each row corres
-00028aa0: 706f 6e64 730a 2020 2020 2020 2020 2020  ponds.          
-00028ab0: 2020 746f 2061 2067 6169 6e20 696e 2067    to a gain in g
-00028ac0: 6169 6e73 0a20 2020 2020 2020 2067 6169  ains.        gai
-00028ad0: 6e73 203a 206e 6461 7272 6179 0a20 2020  ns : ndarray.   
-00028ae0: 2020 2020 2020 2020 2047 6169 6e73 2075           Gains u
-00028af0: 7365 642e 2020 5361 6d65 2061 7320 6b76  sed.  Same as kv
-00028b00: 6563 7420 6b65 7977 6f72 6420 6172 6775  ect keyword argu
-00028b10: 6d65 6e74 2069 6620 7072 6f76 6964 6564  ment if provided
-00028b20: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-00028b30: 2020 2020 2020 6966 2073 656c 662e 6973        if self.is
-00028b40: 5f69 6e74 6572 6163 7469 7665 3a0a 2020  _interactive:.  
-00028b50: 2020 2020 2020 2020 2020 7466 203d 2073            tf = s
-00028b60: 656c 662e 5f65 7870 722e 7375 6273 2873  elf._expr.subs(s
-00028b70: 656c 662e 7061 7261 6d73 290a 2020 2020  elf.params).    
-00028b80: 2020 2020 2020 2020 7365 6c66 2e5f 636f          self._co
-00028b90: 6e74 726f 6c5f 7466 203d 2074 665f 746f  ntrol_tf = tf_to
-00028ba0: 5f63 6f6e 7472 6f6c 2874 6629 0a0a 2020  _control(tf)..  
-00028bb0: 2020 2020 2020 6374 203d 2069 6d70 6f72        ct = impor
-00028bc0: 745f 6d6f 6475 6c65 2822 636f 6e74 726f  t_module("contro
-00028bd0: 6c22 290a 2020 2020 2020 2020 7365 6c66  l").        self
-00028be0: 2e5f 7a65 726f 7320 3d20 7365 6c66 2e5f  ._zeros = self._
-00028bf0: 636f 6e74 726f 6c5f 7466 2e7a 6572 6f73  control_tf.zeros
-00028c00: 2829 0a20 2020 2020 2020 2073 656c 662e  ().        self.
-00028c10: 5f70 6f6c 6573 203d 2073 656c 662e 5f63  _poles = self._c
-00028c20: 6f6e 7472 6f6c 5f74 662e 706f 6c65 7328  ontrol_tf.poles(
-00028c30: 290a 2020 2020 2020 2020 726f 6f74 735f  ).        roots_
-00028c40: 6172 7261 792c 2067 6169 6e73 203d 2063  array, gains = c
-00028c50: 742e 726f 6f74 5f6c 6f63 7573 2873 656c  t.root_locus(sel
-00028c60: 662e 5f63 6f6e 7472 6f6c 5f74 662c 202a  f._control_tf, *
-00028c70: 2a73 656c 662e 5f63 6f6e 7472 6f6c 5f6b  *self._control_k
-00028c80: 7729 0a20 2020 2020 2020 2073 656c 662e  w).        self.
-00028c90: 5f63 6f6d 7075 7465 5f61 7869 735f 6c69  _compute_axis_li
-00028ca0: 6d69 7473 2872 6f6f 7473 5f61 7272 6179  mits(roots_array
-00028cb0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-00028cc0: 2072 6f6f 7473 5f61 7272 6179 2c20 6761   roots_array, ga
-00028cd0: 696e 730a 0a0a 636c 6173 7320 5379 7374  ins...class Syst
-00028ce0: 656d 5265 7370 6f6e 7365 5365 7269 6573  emResponseSeries
-00028cf0: 2843 6f6e 7472 6f6c 4261 7365 5365 7269  (ControlBaseSeri
-00028d00: 6573 293a 0a20 2020 2022 2222 5265 7072  es):.    """Repr
-00028d10: 6573 656e 7420 6120 7379 7374 656d 2072  esent a system r
-00028d20: 6573 706f 6e73 6520 636f 6d70 7574 6564  esponse computed
-00028d30: 2077 6974 6820 7468 6520 6060 636f 6e74   with the ``cont
-00028d40: 726f 6c60 6020 6d6f 6475 6c65 2e0a 0a20  rol`` module... 
-00028d50: 2020 2043 6f6d 7075 7469 6e67 2074 6865     Computing the
-00028d60: 2069 6e76 6572 7365 206c 6170 6c61 6365   inverse laplace
-00028d70: 2074 7261 6e73 666f 726d 206f 6620 6120   transform of a 
-00028d80: 7379 7374 656d 2077 6974 6820 5379 6d50  system with SymP
-00028d90: 7920 6973 206e 6f74 0a20 2020 2074 7269  y is not.    tri
-00028da0: 7669 616c 3a20 736f 6d65 7469 6d65 7320  vial: sometimes 
-00028db0: 6974 2077 6f72 6b73 2066 696e 652c 206f  it works fine, o
-00028dc0: 7468 6572 2074 696d 6573 2069 7420 7072  ther times it pr
-00028dd0: 6f64 7563 6573 2077 726f 6e67 2072 6573  oduces wrong res
-00028de0: 756c 7473 2c0a 2020 2020 6f74 6865 7220  ults,.    other 
-00028df0: 7469 6d65 7320 6974 206a 7573 7420 636f  times it just co
-00028e00: 6e73 756d 6573 2074 6f20 6d75 6368 206d  nsumes to much m
-00028e10: 656d 6f72 7920 6576 656e 2066 6f72 2074  emory even for t
-00028e20: 7269 7669 616c 2074 7261 6e73 6665 720a  rivial transfer.
-00028e30: 2020 2020 6675 6e63 7469 6f6e 732e 2054      functions. T
-00028e40: 6869 7320 6973 2074 7275 6520 666f 7220  his is true for 
-00028e50: 626f 7468 2074 6865 2070 7562 6c69 6320  both the public 
-00028e60: 6060 696e 7665 7273 655f 6c61 706c 6163  ``inverse_laplac
-00028e70: 655f 7472 616e 7366 6f72 6d60 600a 2020  e_transform``.  
-00028e80: 2020 6173 2077 656c 6c20 6173 2074 6865    as well as the
-00028e90: 2070 7269 7661 7465 2060 605f 6661 7374   private ``_fast
-00028ea0: 5f69 6e76 6572 7365 5f6c 6170 6c61 6365  _inverse_laplace
-00028eb0: 6060 2075 7365 6420 696e 0a20 2020 2060  `` used in.    `
-00028ec0: 6073 7062 2e67 7261 7068 6963 732e 636f  `spb.graphics.co
-00028ed0: 6e74 726f 6c60 602e 0a0a 2020 2020 496e  ntrol``...    In
-00028ee0: 206f 7264 6572 2074 6f20 6164 6472 6573   order to addres
-00028ef0: 7320 7468 6573 6520 6973 7375 6573 2c20  s these issues, 
-00028f00: 6c65 7427 7320 6576 616c 7561 7465 2074  let's evaluate t
-00028f10: 6865 2073 7973 7465 6d20 7769 7468 2074  he system with t
-00028f20: 6865 0a20 2020 2060 6063 6f6e 7472 6f6c  he.    ``control
-00028f30: 6060 206d 6f64 756c 652e 2053 7572 652c  `` module. Sure,
-00028f40: 2069 7420 7265 6c69 6573 206f 6e20 6e75   it relies on nu
-00028f50: 6d65 7269 6361 6c20 696e 7465 6772 6174  merical integrat
-00028f60: 696f 6e2c 2068 656e 6365 2065 7272 6f72  ion, hence error
-00028f70: 732e 0a20 2020 2042 7574 2c20 6174 206c  s..    But, at l
-00028f80: 6561 7374 2069 7420 646f 6573 6e27 7420  east it doesn't 
-00028f90: 6372 6173 6820 7468 6520 6d61 6368 696e  crash the machin
-00028fa0: 6520 616e 6420 6974 2069 7320 7265 6c69  e and it is reli
-00028fb0: 6162 6c65 2e0a 2020 2020 2222 220a 0a20  able..    """.. 
-00028fc0: 2020 2064 6566 205f 5f6e 6577 5f5f 2863     def __new__(c
-00028fd0: 6c73 2c20 2a61 7267 732c 202a 2a6b 7761  ls, *args, **kwa
-00028fe0: 7267 7329 3a0a 2020 2020 2020 2020 6366  rgs):.        cf
-00028ff0: 203d 206b 7761 7267 732e 6765 7428 2263   = kwargs.get("c
-00029000: 6f6c 6f72 5f66 756e 6322 2c20 4e6f 6e65  olor_func", None
-00029010: 290a 2020 2020 2020 2020 6c63 203d 206b  ).        lc = k
-00029020: 7761 7267 732e 6765 7428 226c 696e 655f  wargs.get("line_
-00029030: 636f 6c6f 7222 2c20 4e6f 6e65 290a 2020  color", None).  
-00029040: 2020 2020 2020 6966 2028 6361 6c6c 6162        if (callab
-00029050: 6c65 2863 6629 206f 7220 6361 6c6c 6162  le(cf) or callab
-00029060: 6c65 286c 6329 206f 7220 6973 696e 7374  le(lc) or isinst
-00029070: 616e 6365 2863 662c 2045 7870 7229 293a  ance(cf, Expr)):
-00029080: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00029090: 7572 6e20 7375 7065 7228 292e 5f5f 6e65  urn super().__ne
-000290a0: 775f 5f28 436f 6c6f 7265 6453 7973 7465  w__(ColoredSyste
-000290b0: 6d52 6573 706f 6e73 6553 6572 6965 7329  mResponseSeries)
-000290c0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000290d0: 6f62 6a65 6374 2e5f 5f6e 6577 5f5f 2863  object.__new__(c
-000290e0: 6c73 290a 0a20 2020 2064 6566 205f 5f69  ls)..    def __i
-000290f0: 6e69 745f 5f28 7365 6c66 2c20 7466 2c20  nit__(self, tf, 
-00029100: 7661 725f 7374 6172 745f 656e 642c 206c  var_start_end, l
-00029110: 6162 656c 3d22 222c 202a 2a6b 7761 7267  abel="", **kwarg
-00029120: 7329 3a0a 2020 2020 2020 2020 7375 7065  s):.        supe
-00029130: 7228 292e 5f5f 696e 6974 5f5f 2874 662c  r().__init__(tf,
-00029140: 206c 6162 656c 3d6c 6162 656c 2c20 2a2a   label=label, **
-00029150: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
-00029160: 7365 6c66 2e72 616e 6765 7320 3d20 5b76  self.ranges = [v
-00029170: 6172 5f73 7461 7274 5f65 6e64 5d0a 2020  ar_start_end].  
-00029180: 2020 2020 2020 7365 6c66 2e5f 6368 6563        self._chec
-00029190: 6b5f 6673 2829 0a20 2020 2020 2020 2023  k_fs().        #
-000291a0: 2064 6973 6372 6574 697a 6520 7468 6520   discretize the 
-000291b0: 646f 6d61 696e 2075 7369 6e67 206f 6e6c  domain using onl
-000291c0: 7920 696e 7465 6765 7220 6e75 6d62 6572  y integer number
-000291d0: 730a 2020 2020 2020 2020 7365 6c66 2e6f  s.        self.o
-000291e0: 6e6c 795f 696e 7465 6765 7273 203d 206b  nly_integers = k
-000291f0: 7761 7267 732e 6765 7428 226f 6e6c 795f  wargs.get("only_
-00029200: 696e 7465 6765 7273 222c 2046 616c 7365  integers", False
-00029210: 290a 0a20 2020 2020 2020 2072 7420 3d20  )..        rt = 
-00029220: 6b77 6172 6773 2e67 6574 2822 7265 7370  kwargs.get("resp
-00029230: 6f6e 7365 5f74 7970 6522 2c20 2273 7465  onse_type", "ste
-00029240: 7022 290a 2020 2020 2020 2020 7274 203d  p").        rt =
-00029250: 2072 742e 6c6f 7765 7228 2920 6966 2069   rt.lower() if i
-00029260: 7369 6e73 7461 6e63 6528 7274 2c20 7374  sinstance(rt, st
-00029270: 7229 2065 6c73 6520 7274 0a20 2020 2020  r) else rt.     
-00029280: 2020 2061 6c6c 6f77 6564 5f72 6573 706f     allowed_respo
-00029290: 6e73 655f 7479 7065 7320 3d20 5b22 696d  nse_types = ["im
-000292a0: 7075 6c73 6522 2c20 2273 7465 7022 2c20  pulse", "step", 
-000292b0: 2272 616d 7022 5d0a 2020 2020 2020 2020  "ramp"].        
-000292c0: 6966 2028 6e6f 7420 6973 696e 7374 616e  if (not isinstan
-000292d0: 6365 2872 742c 2073 7472 2929 206f 7220  ce(rt, str)) or 
-000292e0: 2872 7420 6e6f 7420 696e 2061 6c6c 6f77  (rt not in allow
-000292f0: 6564 5f72 6573 706f 6e73 655f 7479 7065  ed_response_type
-00029300: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-00029310: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00029320: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00029330: 2020 2260 6072 6573 706f 6e73 655f 7479    "``response_ty
-00029340: 7065 6060 206d 7573 7420 6265 206f 6e65  pe`` must be one
-00029350: 206f 6620 7468 6520 666f 6c6c 6f77 696e   of the followin
-00029360: 673a 2025 735c 6e22 0a20 2020 2020 2020  g: %s\n".       
-00029370: 2020 2020 2020 2020 2022 5265 6365 6976           "Receiv
-00029380: 6564 3a20 2573 2220 2520 2872 742c 2061  ed: %s" % (rt, a
-00029390: 6c6c 6f77 6564 5f72 6573 706f 6e73 655f  llowed_response_
-000293a0: 7479 7065 7329 0a20 2020 2020 2020 2020  types).         
-000293b0: 2020 2029 0a20 2020 2020 2020 2073 656c     ).        sel
-000293c0: 662e 5f72 6573 706f 6e73 655f 7479 7065  f._response_type
-000293d0: 203d 2072 740a 0a20 2020 2020 2020 2073   = rt..        s
-000293e0: 7465 7073 203d 206b 7761 7267 732e 6765  teps = kwargs.ge
-000293f0: 7428 2273 7465 7073 222c 204e 6f6e 6529  t("steps", None)
-00029400: 0a20 2020 2020 2020 2069 6620 7374 6570  .        if step
-00029410: 7320 6973 204e 6f6e 653a 0a20 2020 2020  s is None:.     
-00029420: 2020 2020 2020 2069 6620 7365 6c66 2e5f         if self._
-00029430: 6578 7072 2069 7320 4e6f 6e65 3a0a 2020  expr is None:.  
-00029440: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00029450: 6c66 2e73 7465 7073 203d 2073 656c 662e  lf.steps = self.
-00029460: 5f63 6f6e 7472 6f6c 5f74 662e 6973 6474  _control_tf.isdt
-00029470: 696d 6528 290a 2020 2020 2020 2020 2020  ime().          
-00029480: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00029490: 2020 2020 2020 2020 7365 6c66 2e73 7465          self.ste
-000294a0: 7073 203d 2046 616c 7365 0a20 2020 2020  ps = False.     
-000294b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-000294c0: 2020 2020 2073 656c 662e 7374 6570 7320       self.steps 
-000294d0: 3d20 7374 6570 730a 2020 2020 2020 2020  = steps.        
-000294e0: 2320 7469 6d65 2076 616c 7565 7320 6f76  # time values ov
-000294f0: 6572 2077 6869 6368 2074 6865 2065 7661  er which the eva
-00029500: 6c75 6174 696f 6e20 7769 6c6c 2062 6520  luation will be 
-00029510: 7065 7266 6f72 6d65 640a 2020 2020 2020  performed.      
-00029520: 2020 7365 6c66 2e5f 7469 6d65 5f61 7272    self._time_arr
-00029530: 6179 203d 204e 6f6e 650a 0a20 2020 2064  ay = None..    d
-00029540: 6566 205f 6765 745f 6461 7461 5f68 656c  ef _get_data_hel
-00029550: 7065 7228 7365 6c66 293a 0a20 2020 2020  per(self):.     
-00029560: 2020 2063 7420 3d20 696d 706f 7274 5f6d     ct = import_m
-00029570: 6f64 756c 6528 2263 6f6e 7472 6f6c 2229  odule("control")
-00029580: 0a20 2020 2020 2020 206e 7020 3d20 696d  .        np = im
-00029590: 706f 7274 5f6d 6f64 756c 6528 226e 756d  port_module("num
-000295a0: 7079 2229 0a20 2020 2020 2020 206d 6572  py").        mer
-000295b0: 6765 6465 6570 203d 2069 6d70 6f72 745f  gedeep = import_
-000295c0: 6d6f 6475 6c65 2827 6d65 7267 6564 6565  module('mergedee
-000295d0: 7027 290a 0a20 2020 2020 2020 2069 6620  p')..        if 
-000295e0: 7365 6c66 2e69 735f 696e 7465 7261 6374  self.is_interact
-000295f0: 6976 653a 0a20 2020 2020 2020 2020 2020  ive:.           
-00029600: 2074 6620 3d20 7365 6c66 2e5f 6578 7072   tf = self._expr
-00029610: 2e73 7562 7328 7365 6c66 2e70 6172 616d  .subs(self.param
-00029620: 7329 0a20 2020 2020 2020 2020 2020 2073  s).            s
-00029630: 656c 662e 5f63 6f6e 7472 6f6c 5f74 6620  elf._control_tf 
-00029640: 3d20 7466 5f74 6f5f 636f 6e74 726f 6c28  = tf_to_control(
-00029650: 7466 290a 0a20 2020 2020 2020 2023 2063  tf)..        # c
-00029660: 7265 6174 6520 286f 7220 7570 6461 7465  reate (or update
-00029670: 2920 7468 6520 6469 7363 7265 7469 7a65  ) the discretize
-00029680: 6420 646f 6d61 696e 0a20 2020 2020 2020  d domain.       
-00029690: 205f 2c20 7374 6172 742c 2065 6e64 203d   _, start, end =
-000296a0: 2073 656c 662e 7261 6e67 6573 5b30 5d0a   self.ranges[0].
-000296b0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-000296c0: 5f69 6e74 6572 6163 7469 7665 5f72 616e  _interactive_ran
-000296d0: 6765 733a 0a20 2020 2020 2020 2020 2020  ges:.           
-000296e0: 2073 7461 7274 203d 2073 656c 662e 5f75   start = self._u
-000296f0: 7064 6174 655f 7261 6e67 655f 7661 6c75  pdate_range_valu
-00029700: 6528 7374 6172 7429 2e72 6561 6c0a 2020  e(start).real.  
-00029710: 2020 2020 2020 2020 2020 656e 6420 3d20            end = 
-00029720: 7365 6c66 2e5f 7570 6461 7465 5f72 616e  self._update_ran
-00029730: 6765 5f76 616c 7565 2865 6e64 292e 7265  ge_value(end).re
-00029740: 616c 0a20 2020 2020 2020 2065 6c73 653a  al.        else:
-00029750: 0a20 2020 2020 2020 2020 2020 2073 7461  .            sta
-00029760: 7274 2c20 656e 6420 3d20 666c 6f61 7428  rt, end = float(
-00029770: 7374 6172 7429 2c20 666c 6f61 7428 656e  start), float(en
-00029780: 6429 0a0a 2020 2020 2020 2020 6966 2028  d)..        if (
-00029790: 6e6f 7420 7365 6c66 2e5f 7469 6d65 5f61  not self._time_a
-000297a0: 7272 6179 2920 6f72 2073 656c 662e 5f69  rray) or self._i
-000297b0: 6e74 6572 6163 7469 7665 5f72 616e 6765  nteractive_range
-000297c0: 733a 0a20 2020 2020 2020 2020 2020 2069  s:.            i
-000297d0: 6620 6e6f 7420 7365 6c66 2e5f 636f 6e74  f not self._cont
-000297e0: 726f 6c5f 7466 2e69 7364 7469 6d65 2829  rol_tf.isdtime()
-000297f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00029800: 2020 6e20 3d20 7365 6c66 2e6e 5b30 5d0a    n = self.n[0].
-00029810: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00029820: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00029830: 2020 6e20 3d20 696e 7428 2865 6e64 202d    n = int((end -
-00029840: 2073 7461 7274 2920 2f20 7365 6c66 2e5f   start) / self._
-00029850: 636f 6e74 726f 6c5f 7466 2e64 7429 202b  control_tf.dt) +
-00029860: 2031 0a20 2020 2020 2020 2020 2020 2073   1.            s
-00029870: 656c 662e 5f74 696d 655f 6172 7261 7920  elf._time_array 
-00029880: 3d20 7365 6c66 2e5f 6469 7363 7265 7469  = self._discreti
-00029890: 7a65 280a 2020 2020 2020 2020 2020 2020  ze(.            
-000298a0: 2020 2020 2020 2020 7374 6172 742c 2065          start, e
-000298b0: 6e64 2c20 6e2c 2073 656c 662e 7363 616c  nd, n, self.scal
-000298c0: 6573 5b30 5d2c 2073 656c 662e 6f6e 6c79  es[0], self.only
-000298d0: 5f69 6e74 6567 6572 7329 0a0a 2020 2020  _integers)..    
-000298e0: 2020 2020 636f 6e74 726f 6c5f 6b77 203d      control_kw =
-000298f0: 207b 2254 223a 2073 656c 662e 5f74 696d   {"T": self._tim
-00029900: 655f 6172 7261 792c 2022 7371 7565 657a  e_array, "squeez
-00029910: 6522 3a20 5472 7565 7d0a 0a20 2020 2020  e": True}..     
-00029920: 2020 2069 6620 7365 6c66 2e5f 7265 7370     if self._resp
-00029930: 6f6e 7365 5f74 7970 6520 3d3d 2022 7374  onse_type == "st
-00029940: 6570 223a 0a20 2020 2020 2020 2020 2020  ep":.           
-00029950: 2063 6b77 203d 206d 6572 6765 6465 6570   ckw = mergedeep
-00029960: 2e6d 6572 6765 287b 7d2c 2063 6f6e 7472  .merge({}, contr
-00029970: 6f6c 5f6b 772c 2073 656c 662e 5f63 6f6e  ol_kw, self._con
-00029980: 7472 6f6c 5f6b 7729 0a20 2020 2020 2020  trol_kw).       
-00029990: 2020 2020 2078 2c20 7920 3d20 6374 2e73       x, y = ct.s
-000299a0: 7465 705f 7265 7370 6f6e 7365 2873 656c  tep_response(sel
-000299b0: 662e 5f63 6f6e 7472 6f6c 5f74 662c 202a  f._control_tf, *
-000299c0: 2a63 6b77 290a 2020 2020 2020 2020 656c  *ckw).        el
-000299d0: 6966 2073 656c 662e 5f72 6573 706f 6e73  if self._respons
-000299e0: 655f 7479 7065 203d 3d20 2269 6d70 756c  e_type == "impul
-000299f0: 7365 223a 0a20 2020 2020 2020 2020 2020  se":.           
-00029a00: 2063 6b77 203d 206d 6572 6765 6465 6570   ckw = mergedeep
-00029a10: 2e6d 6572 6765 287b 7d2c 2063 6f6e 7472  .merge({}, contr
-00029a20: 6f6c 5f6b 772c 2073 656c 662e 5f63 6f6e  ol_kw, self._con
-00029a30: 7472 6f6c 5f6b 7729 0a20 2020 2020 2020  trol_kw).       
-00029a40: 2020 2020 2078 2c20 7920 3d20 6374 2e69       x, y = ct.i
-00029a50: 6d70 756c 7365 5f72 6573 706f 6e73 6528  mpulse_response(
-00029a60: 7365 6c66 2e5f 636f 6e74 726f 6c5f 7466  self._control_tf
-00029a70: 2c20 2a2a 636b 7729 0a20 2020 2020 2020  , **ckw).       
-00029a80: 2065 6c69 6620 7365 6c66 2e5f 7265 7370   elif self._resp
-00029a90: 6f6e 7365 5f74 7970 6520 3d3d 2022 7261  onse_type == "ra
-00029aa0: 6d70 223a 0a20 2020 2020 2020 2020 2020  mp":.           
-00029ab0: 2072 616d 7020 3d20 7365 6c66 2e5f 7469   ramp = self._ti
-00029ac0: 6d65 5f61 7272 6179 0a20 2020 2020 2020  me_array.       
-00029ad0: 2020 2020 2063 6f6e 7472 6f6c 5f6b 775b       control_kw[
-00029ae0: 2255 225d 203d 2072 616d 700a 2020 2020  "U"] = ramp.    
-00029af0: 2020 2020 2020 2020 636b 7720 3d20 6d65          ckw = me
-00029b00: 7267 6564 6565 702e 6d65 7267 6528 7b7d  rgedeep.merge({}
-00029b10: 2c20 636f 6e74 726f 6c5f 6b77 2c20 7365  , control_kw, se
-00029b20: 6c66 2e5f 636f 6e74 726f 6c5f 6b77 290a  lf._control_kw).
-00029b30: 2020 2020 2020 2020 2020 2020 782c 2079              x, y
-00029b40: 203d 2063 742e 666f 7263 6564 5f72 6573   = ct.forced_res
-00029b50: 706f 6e73 6528 7365 6c66 2e5f 636f 6e74  ponse(self._cont
-00029b60: 726f 6c5f 7466 2c20 2a2a 636b 7729 0a20  rol_tf, **ckw). 
-00029b70: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00029b80: 2020 2020 2020 2020 2072 6169 7365 204e           raise N
-00029b90: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
-00029ba0: 6f72 0a0a 2020 2020 2020 2020 7265 7475  or..        retu
-00029bb0: 726e 2078 2c20 790a 0a0a 636c 6173 7320  rn x, y...class 
-00029bc0: 436f 6c6f 7265 6453 7973 7465 6d52 6573  ColoredSystemRes
-00029bd0: 706f 6e73 6553 6572 6965 7328 5379 7374  ponseSeries(Syst
-00029be0: 656d 5265 7370 6f6e 7365 5365 7269 6573  emResponseSeries
-00029bf0: 293a 0a20 2020 2022 2222 5265 7072 6573  ):.    """Repres
-00029c00: 656e 7420 6120 7379 7374 656d 2072 6573  ent a system res
-00029c10: 706f 6e73 6520 636f 6d70 7574 6564 2077  ponse computed w
-00029c20: 6974 6820 7468 6520 6060 636f 6e74 726f  ith the ``contro
-00029c30: 6c60 6020 6d6f 6475 6c65 2c0a 2020 2020  l`` module,.    
-00029c40: 616e 6420 636f 6c6f 7265 6420 6163 636f  and colored acco
-00029c50: 7264 696e 6720 736f 6d65 2063 6f6c 6f72  rding some color
-00029c60: 2066 756e 6374 696f 6e2e 0a20 2020 2022   function..    "
-00029c70: 2222 0a20 2020 2069 735f 7061 7261 6d65  "".    is_parame
-00029c80: 7472 6963 203d 2054 7275 650a 0a20 2020  tric = True..   
-00029c90: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
-00029ca0: 6c66 2c20 2a61 7267 732c 202a 2a6b 7761  lf, *args, **kwa
-00029cb0: 7267 7329 3a0a 2020 2020 2020 2020 7375  rgs):.        su
-00029cc0: 7065 7228 292e 5f5f 696e 6974 5f5f 282a  per().__init__(*
-00029cd0: 6172 6773 2c20 2a2a 6b77 6172 6773 290a  args, **kwargs).
-00029ce0: 2020 2020 2020 2020 7365 6c66 2e75 7365          self.use
-00029cf0: 5f63 6d20 3d20 6b77 6172 6773 2e67 6574  _cm = kwargs.get
-00029d00: 2822 7573 655f 636d 222c 2054 7275 6529  ("use_cm", True)
-00029d10: 0a0a 2020 2020 6465 6620 5f67 6574 5f64  ..    def _get_d
-00029d20: 6174 615f 6865 6c70 6572 2873 656c 6629  ata_helper(self)
-00029d30: 3a0a 2020 2020 2020 2020 782c 2079 203d  :.        x, y =
-00029d40: 2073 7570 6572 2829 2e5f 6765 745f 6461   super()._get_da
-00029d50: 7461 5f68 656c 7065 7228 290a 2020 2020  ta_helper().    
-00029d60: 2020 2020 7265 7475 726e 2078 2c20 792c      return x, y,
-00029d70: 2073 656c 662e 6576 616c 5f63 6f6c 6f72   self.eval_color
-00029d80: 5f66 756e 6328 782c 2079 290a 0a0a 636c  _func(x, y)...cl
-00029d90: 6173 7320 506f 6c65 5a65 726f 5365 7269  ass PoleZeroSeri
-00029da0: 6573 2843 6f6e 7472 6f6c 4261 7365 5365  es(ControlBaseSe
-00029db0: 7269 6573 293a 0a20 2020 2022 2222 5265  ries):.    """Re
-00029dc0: 7072 6573 656e 7420 6120 7468 6520 706f  present a the po
-00029dd0: 6c65 2d7a 6572 6f20 6f66 2061 6e20 4c54  le-zero of an LT
-00029de0: 4920 5349 534f 2073 7973 7465 6d20 636f  I SISO system co
-00029df0: 6d70 7574 6564 0a20 2020 2077 6974 6820  mputed.    with 
-00029e00: 7468 6520 6060 636f 6e74 726f 6c60 6020  the ``control`` 
-00029e10: 6d6f 6475 6c65 2e0a 0a20 2020 2054 6869  module...    Thi
-00029e20: 7320 7365 7269 6573 2072 6570 7265 7365  s series represe
-00029e30: 6e74 7320 6569 7468 6572 2070 6f6c 6573  nts either poles
-00029e40: 206f 7220 7a65 726f 732c 206e 6f74 2062   or zeros, not b
-00029e50: 6f74 6820 6174 2074 6865 2073 616d 6520  oth at the same 
-00029e60: 7469 6d65 2e0a 2020 2020 496e 2073 6f6d  time..    In som
-00029e70: 6520 7365 6e73 652c 2069 7420 6265 6861  e sense, it beha
-00029e80: 7665 7320 6c69 6b65 2061 204c 6973 7432  ves like a List2
-00029e90: 4453 6572 6965 732e 2053 6f2c 2074 6f20  DSeries. So, to 
-00029ea0: 7265 7072 6573 656e 7473 2062 6f74 680a  represents both.
-00029eb0: 2020 2020 706f 6c65 7320 616e 6420 7a65      poles and ze
-00029ec0: 726f 7320 6f66 2061 2074 7261 6e73 6665  ros of a transfe
-00029ed0: 7220 6675 6e63 7469 6f6e 2c20 7765 206e  r function, we n
-00029ee0: 6565 6420 746f 2069 6e73 7461 7469 6174  eed to instatiat
-00029ef0: 6520 7477 6f0a 2020 2020 6469 6666 6572  e two.    differ
-00029f00: 656e 7420 7365 7269 6573 2070 6173 7369  ent series passi
-00029f10: 6e67 2069 6e20 7468 6520 7361 6d65 2074  ng in the same t
-00029f20: 7261 6e73 6665 7220 6675 6e63 7469 6f6e  ransfer function
-00029f30: 2e0a 0a20 2020 2057 6869 6c65 2063 6f6d  ...    While com
-00029f40: 7075 7461 7469 6f6e 616c 6c79 206c 6573  putationally les
-00029f50: 7320 6566 6669 6369 656e 742c 2074 6869  s efficient, thi
-00029f60: 7320 6465 7369 676e 2063 686f 6963 6520  s design choice 
-00029f70: 6861 7665 2062 6565 6e20 6d61 6465 0a20  have been made. 
-00029f80: 2020 2069 6e20 6f72 6465 7220 746f 2072     in order to r
-00029f90: 6575 7365 2074 6865 2065 7869 7374 696e  euse the existin
-00029fa0: 6720 4261 7365 4261 636b 656e 6420 6172  g BaseBackend ar
-00029fb0: 6368 6974 6563 7475 7265 2c20 7468 6174  chitecture, that
-00029fc0: 2073 6574 7320 7570 0a20 2020 2074 6865   sets up.    the
-00029fd0: 206e 756d 6265 7220 6f66 2063 6f6c 6f72   number of color
-00029fe0: 7320 6261 7365 6420 6f6e 2074 6865 206e  s based on the n
-00029ff0: 756d 6265 7220 6f66 2064 6174 6120 7365  umber of data se
-0002a000: 7269 6573 2c20 6173 2077 656c 6c20 6173  ries, as well as
-0002a010: 2074 6865 0a20 2020 206c 6f67 6963 2074   the.    logic t
-0002a020: 6f20 7368 6f77 206f 7220 6869 6465 2074  o show or hide t
-0002a030: 6865 206c 6567 656e 642e 0a20 2020 2022  he legend..    "
-0002a040: 2222 0a20 2020 2064 6566 205f 5f69 6e69  "".    def __ini
-0002a050: 745f 5f28 7365 6c66 2c20 7466 2c20 6c61  t__(self, tf, la
-0002a060: 6265 6c3d 2222 2c20 2a2a 6b77 6172 6773  bel="", **kwargs
-0002a070: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
-0002a080: 2829 2e5f 5f69 6e69 745f 5f28 7466 2c20  ().__init__(tf, 
-0002a090: 6c61 6265 6c3d 6c61 6265 6c2c 202a 2a6b  label=label, **k
-0002a0a0: 7761 7267 7329 0a20 2020 2020 2020 2073  wargs).        s
-0002a0b0: 656c 662e 5f63 6865 636b 5f66 7328 290a  elf._check_fs().
-0002a0c0: 2020 2020 2020 2020 7365 6c66 2e69 735f          self.is_
-0002a0d0: 706f 696e 7420 3d20 5472 7565 0a20 2020  point = True.   
-0002a0e0: 2020 2020 2073 656c 662e 5f72 6574 7572       self._retur
-0002a0f0: 6e5f 706f 6c65 7320 3d20 6b77 6172 6773  n_poles = kwargs
-0002a100: 2e67 6574 2822 7265 7475 726e 5f70 6f6c  .get("return_pol
-0002a110: 6573 222c 2054 7275 6529 0a0a 2020 2020  es", True)..    
-0002a120: 6465 6620 5f5f 7374 725f 5f28 7365 6c66  def __str__(self
-0002a130: 293a 0a20 2020 2020 2020 2070 7265 203d  ):.        pre =
-0002a140: 2022 706f 6c65 206f 6620 2220 6966 2073   "pole of " if s
-0002a150: 656c 662e 5f72 6574 7572 6e5f 706f 6c65  elf._return_pole
-0002a160: 7320 656c 7365 2022 7a65 726f 7320 6f66  s else "zeros of
-0002a170: 2022 0a20 2020 2020 2020 2065 7870 7220   ".        expr 
-0002a180: 3d20 7365 6c66 2e5f 6578 7072 2069 6620  = self._expr if 
-0002a190: 7365 6c66 2e5f 6578 7072 2069 7320 6e6f  self._expr is no
-0002a1a0: 7420 4e6f 6e65 2065 6c73 6520 7365 6c66  t None else self
-0002a1b0: 2e5f 636f 6e74 726f 6c5f 7466 0a20 2020  ._control_tf.   
-0002a1c0: 2020 2020 2072 6574 7572 6e20 7072 6520       return pre 
-0002a1d0: 2b20 7374 7228 6578 7072 290a 0a20 2020  + str(expr)..   
-0002a1e0: 2064 6566 205f 6765 745f 6461 7461 5f68   def _get_data_h
-0002a1f0: 656c 7065 7228 7365 6c66 293a 0a20 2020  elper(self):.   
-0002a200: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0002a210: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
-0002a220: 203d 3d3d 3d3d 3d3d 0a20 2020 2020 2020   =======.       
-0002a230: 2078 203a 206e 702e 6e64 6172 7261 790a   x : np.ndarray.
-0002a240: 2020 2020 2020 2020 7920 3a20 6e70 2e6e          y : np.n
-0002a250: 6461 7272 6179 0a20 2020 2020 2020 2022  darray.        "
-0002a260: 2222 0a20 2020 2020 2020 206e 7020 3d20  "".        np = 
-0002a270: 696d 706f 7274 5f6d 6f64 756c 6528 226e  import_module("n
-0002a280: 756d 7079 2229 0a20 2020 2020 2020 2069  umpy").        i
-0002a290: 6620 7365 6c66 2e69 735f 696e 7465 7261  f self.is_intera
-0002a2a0: 6374 6976 653a 0a20 2020 2020 2020 2020  ctive:.         
-0002a2b0: 2020 2074 6620 3d20 7365 6c66 2e5f 6578     tf = self._ex
-0002a2c0: 7072 2e73 7562 7328 7365 6c66 2e70 6172  pr.subs(self.par
-0002a2d0: 616d 7329 0a20 2020 2020 2020 2020 2020  ams).           
-0002a2e0: 2073 656c 662e 5f63 6f6e 7472 6f6c 5f74   self._control_t
-0002a2f0: 6620 3d20 7466 5f74 6f5f 636f 6e74 726f  f = tf_to_contro
-0002a300: 6c28 7466 290a 2020 2020 2020 2020 6966  l(tf).        if
-0002a310: 2073 656c 662e 5f72 6574 7572 6e5f 706f   self._return_po
-0002a320: 6c65 733a 0a20 2020 2020 2020 2020 2020  les:.           
-0002a330: 2070 6f69 6e74 7320 3d20 7365 6c66 2e5f   points = self._
-0002a340: 636f 6e74 726f 6c5f 7466 2e70 6f6c 6573  control_tf.poles
-0002a350: 2829 0a20 2020 2020 2020 2065 6c73 653a  ().        else:
-0002a360: 0a20 2020 2020 2020 2020 2020 2070 6f69  .            poi
-0002a370: 6e74 7320 3d20 7365 6c66 2e5f 636f 6e74  nts = self._cont
-0002a380: 726f 6c5f 7466 2e7a 6572 6f73 2829 0a20  rol_tf.zeros(). 
-0002a390: 2020 2020 2020 2072 6574 7572 6e20 6e70         return np
-0002a3a0: 2e72 6561 6c28 706f 696e 7473 292c 206e  .real(points), n
-0002a3b0: 702e 696d 6167 2870 6f69 6e74 7329 0a0a  p.imag(points)..
-0002a3c0: 0a63 6c61 7373 204e 4772 6964 4c69 6e65  .class NGridLine
-0002a3d0: 5365 7269 6573 2847 7269 6442 6173 652c  Series(GridBase,
-0002a3e0: 2042 6173 6553 6572 6965 7329 3a0a 2020   BaseSeries):.  
-0002a3f0: 2020 2222 2220 5468 6520 636f 6465 206f    """ The code o
-0002a400: 6620 7468 6973 2063 6c61 7373 2063 6f6d  f this class com
-0002a410: 6573 2066 726f 6d20 7468 6520 6060 636f  es from the ``co
-0002a420: 6e74 726f 6c60 6020 7061 636b 6167 652c  ntrol`` package,
-0002a430: 2077 6869 6368 2068 6173 0a20 2020 2062   which has.    b
-0002a440: 6565 6e20 7265 6172 7261 6e67 6564 2074  een rearranged t
-0002a450: 6f20 776f 726b 2077 6974 6820 7468 6520  o work with the 
-0002a460: 6172 6368 6974 6563 7475 7265 206f 6620  architecture of 
-0002a470: 7468 6973 206d 6f64 756c 652e 0a20 2020  this module..   
-0002a480: 2022 2222 0a0a 2020 2020 6465 6620 5f5f   """..    def __
-0002a490: 696e 6974 5f5f 2873 656c 662c 2063 6c5f  init__(self, cl_
-0002a4a0: 6d61 6773 3d4e 6f6e 652c 2063 6c5f 7068  mags=None, cl_ph
-0002a4b0: 6173 6573 3d4e 6f6e 652c 206c 6162 656c  ases=None, label
-0002a4c0: 5f63 6c5f 7068 6173 6573 3d46 616c 7365  _cl_phases=False
-0002a4d0: 2c0a 2020 2020 2020 2020 2a2a 6b77 6172  ,.        **kwar
-0002a4e0: 6773 293a 0a20 2020 2020 2020 2073 7570  gs):.        sup
-0002a4f0: 6572 2829 2e5f 5f69 6e69 745f 5f28 2a2a  er().__init__(**
-0002a500: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
-0002a510: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
-0002a520: 6c65 2822 6e75 6d70 7922 290a 2020 2020  le("numpy").    
-0002a530: 2020 2020 7365 6c66 2e63 6c5f 6d61 6773      self.cl_mags
-0002a540: 203d 2063 6c5f 6d61 6773 2069 6620 636c   = cl_mags if cl
-0002a550: 5f6d 6167 7320 6973 204e 6f6e 6520 656c  _mags is None el
-0002a560: 7365 206e 702e 6172 7261 7928 636c 5f6d  se np.array(cl_m
-0002a570: 6167 7329 0a20 2020 2020 2020 2073 656c  ags).        sel
-0002a580: 662e 636c 5f70 6861 7365 7320 3d20 636c  f.cl_phases = cl
-0002a590: 5f70 6861 7365 7320 6966 2063 6c5f 7068  _phases if cl_ph
-0002a5a0: 6173 6573 2069 7320 4e6f 6e65 2065 6c73  ases is None els
-0002a5b0: 6520 6e70 2e61 7272 6179 2863 6c5f 7068  e np.array(cl_ph
-0002a5c0: 6173 6573 290a 2020 2020 2020 2020 7365  ases).        se
-0002a5d0: 6c66 2e6c 6162 656c 5f63 6c5f 7068 6173  lf.label_cl_phas
-0002a5e0: 6573 203d 206c 6162 656c 5f63 6c5f 7068  es = label_cl_ph
-0002a5f0: 6173 6573 0a20 2020 2020 2020 2073 656c  ases.        sel
-0002a600: 662e 7368 6f77 5f69 6e5f 6c65 6765 6e64  f.show_in_legend
-0002a610: 203d 206b 7761 7267 732e 6765 7428 2273   = kwargs.get("s
-0002a620: 686f 775f 696e 5f6c 6567 656e 6422 2c20  how_in_legend", 
-0002a630: 4661 6c73 6529 0a20 2020 2020 2020 2073  False).        s
-0002a640: 656c 662e 7368 6f77 5f63 6c5f 6d61 6773  elf.show_cl_mags
-0002a650: 203d 206b 7761 7267 732e 6765 7428 2273   = kwargs.get("s
-0002a660: 686f 775f 636c 5f6d 6167 7322 2c20 5472  how_cl_mags", Tr
-0002a670: 7565 290a 2020 2020 2020 2020 7365 6c66  ue).        self
-0002a680: 2e73 686f 775f 636c 5f70 6861 7365 7320  .show_cl_phases 
-0002a690: 3d20 6b77 6172 6773 2e67 6574 2822 7368  = kwargs.get("sh
-0002a6a0: 6f77 5f63 6c5f 7068 6173 6573 222c 2054  ow_cl_phases", T
-0002a6b0: 7275 6529 0a0a 2020 2020 6465 6620 5f5f  rue)..    def __
-0002a6c0: 7374 725f 5f28 7365 6c66 293a 0a20 2020  str__(self):.   
-0002a6d0: 2020 2020 2072 6574 7572 6e20 226e 2d67       return "n-g
-0002a6e0: 7269 6422 0a0a 2020 2020 4073 7461 7469  rid"..    @stati
-0002a6f0: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
-0002a700: 636c 6f73 6564 5f6c 6f6f 705f 636f 6e74  closed_loop_cont
-0002a710: 6f75 7273 2847 636c 5f6d 6167 732c 2047  ours(Gcl_mags, G
-0002a720: 636c 5f70 6861 7365 7329 3a0a 2020 2020  cl_phases):.    
-0002a730: 2020 2020 2222 2243 6f6e 746f 7572 7320      """Contours 
-0002a740: 6f66 2074 6865 2066 756e 6374 696f 6e20  of the function 
-0002a750: 4763 6c20 3d20 476f 6c2f 2831 2b47 6f6c  Gcl = Gol/(1+Gol
-0002a760: 292c 2077 6865 7265 0a20 2020 2020 2020  ), where.       
-0002a770: 2047 6f6c 2069 7320 616e 206f 7065 6e2d   Gol is an open-
-0002a780: 6c6f 6f70 2074 7261 6e73 6665 7220 6675  loop transfer fu
-0002a790: 6e63 7469 6f6e 2c20 616e 6420 4763 6c20  nction, and Gcl 
-0002a7a0: 6973 2061 2063 6f72 7265 7370 6f6e 6469  is a correspondi
-0002a7b0: 6e67 0a20 2020 2020 2020 2063 6c6f 7365  ng.        close
-0002a7c0: 642d 6c6f 6f70 2074 7261 6e73 6665 7220  d-loop transfer 
-0002a7d0: 6675 6e63 7469 6f6e 2e0a 0a20 2020 2020  function...     
-0002a7e0: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
-0002a7f0: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
-0002a800: 0a20 2020 2020 2020 2047 636c 5f6d 6167  .        Gcl_mag
-0002a810: 7320 3a20 6172 7261 792d 6c69 6b65 0a20  s : array-like. 
-0002a820: 2020 2020 2020 2020 2020 2041 7272 6179             Array
-0002a830: 206f 6620 6d61 676e 6974 7564 6573 206f   of magnitudes o
-0002a840: 6620 7468 6520 636f 6e74 6f75 7273 0a20  f the contours. 
-0002a850: 2020 2020 2020 2047 636c 5f70 6861 7365         Gcl_phase
-0002a860: 7320 3a20 6172 7261 792d 6c69 6b65 0a20  s : array-like. 
-0002a870: 2020 2020 2020 2020 2020 2041 7272 6179             Array
-0002a880: 206f 6620 7068 6173 6573 2069 6e20 7261   of phases in ra
-0002a890: 6469 616e 7320 6f66 2074 6865 2063 6f6e  dians of the con
-0002a8a0: 746f 7572 730a 0a20 2020 2020 2020 2052  tours..        R
-0002a8b0: 6574 7572 6e73 0a20 2020 2020 2020 202d  eturns.        -
-0002a8c0: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2063  ------.        c
-0002a8d0: 6f6e 746f 7572 7320 3a20 636f 6d70 6c65  ontours : comple
-0002a8e0: 7820 6172 7261 790a 2020 2020 2020 2020  x array.        
-0002a8f0: 2020 2020 4172 7261 7920 6f66 2063 6f6d      Array of com
-0002a900: 706c 6578 206e 756d 6265 7273 2063 6f72  plex numbers cor
-0002a910: 7265 7370 6f6e 6469 6e67 2074 6f20 7468  responding to th
-0002a920: 6520 636f 6e74 6f75 7273 2e0a 2020 2020  e contours..    
-0002a930: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0002a940: 2320 436f 6d70 7574 6520 7468 6520 636f  # Compute the co
-0002a950: 6e74 6f75 7273 2069 6e20 4763 6c2d 7370  ntours in Gcl-sp
-0002a960: 6163 652e 2053 696e 6365 2077 6527 7265  ace. Since we're
-0002a970: 2067 6976 656e 2063 6c6f 7365 642d 6c6f   given closed-lo
-0002a980: 6f70 0a20 2020 2020 2020 2023 206d 6167  op.        # mag
-0002a990: 6e69 7475 6465 7320 616e 6420 7068 6173  nitudes and phas
-0002a9a0: 6573 2c20 7468 6973 2069 7320 6a75 7374  es, this is just
-0002a9b0: 2061 2063 6173 6520 6f66 2063 6f6e 7665   a case of conve
-0002a9c0: 7274 696e 6720 7468 656d 2069 6e74 6f0a  rting them into.
-0002a9d0: 2020 2020 2020 2020 2320 6120 636f 6d70          # a comp
-0002a9e0: 6c65 7820 6e75 6d62 6572 2e0a 2020 2020  lex number..    
-0002a9f0: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
-0002aa00: 6d6f 6475 6c65 2822 6e75 6d70 7922 290a  module("numpy").
-0002aa10: 2020 2020 2020 2020 4763 6c20 3d20 4763          Gcl = Gc
-0002aa20: 6c5f 6d61 6773 2a6e 702e 6578 7028 312e  l_mags*np.exp(1.
-0002aa30: 6a2a 4763 6c5f 7068 6173 6573 290a 0a20  j*Gcl_phases).. 
-0002aa40: 2020 2020 2020 2023 2049 6e76 6572 7420         # Invert 
-0002aa50: 4763 6c20 3d20 476f 6c2f 2831 2b47 6f6c  Gcl = Gol/(1+Gol
-0002aa60: 2920 746f 206d 6170 2074 6865 2063 6f6e  ) to map the con
-0002aa70: 746f 7572 7320 696e 746f 2074 6865 206f  tours into the o
-0002aa80: 7065 6e2d 6c6f 6f70 2073 7061 6365 0a20  pen-loop space. 
-0002aa90: 2020 2020 2020 2072 6574 7572 6e20 4763         return Gc
-0002aaa0: 6c2f 2831 2e30 202d 2047 636c 290a 0a20  l/(1.0 - Gcl).. 
-0002aab0: 2020 2040 7374 6174 6963 6d65 7468 6f64     @staticmethod
-0002aac0: 0a20 2020 2064 6566 206d 5f63 6972 636c  .    def m_circl
-0002aad0: 6573 286d 6167 732c 2070 6861 7365 5f6d  es(mags, phase_m
-0002aae0: 696e 3d2d 3335 392e 3735 2c20 7068 6173  in=-359.75, phas
-0002aaf0: 655f 6d61 783d 2d30 2e32 3529 3a0a 2020  e_max=-0.25):.  
-0002ab00: 2020 2020 2020 2222 2243 6f6e 7374 616e        """Constan
-0002ab10: 742d 6d61 676e 6974 7564 6520 636f 6e74  t-magnitude cont
-0002ab20: 6f75 7273 206f 6620 7468 6520 6675 6e63  ours of the func
-0002ab30: 7469 6f6e 2047 636c 203d 2047 6f6c 2f28  tion Gcl = Gol/(
-0002ab40: 312b 476f 6c29 2c20 7768 6572 650a 2020  1+Gol), where.  
-0002ab50: 2020 2020 2020 476f 6c20 6973 2061 6e20        Gol is an 
-0002ab60: 6f70 656e 2d6c 6f6f 7020 7472 616e 7366  open-loop transf
-0002ab70: 6572 2066 756e 6374 696f 6e2c 2061 6e64  er function, and
-0002ab80: 2047 636c 2069 7320 6120 636f 7272 6573   Gcl is a corres
-0002ab90: 706f 6e64 696e 670a 2020 2020 2020 2020  ponding.        
-0002aba0: 636c 6f73 6564 2d6c 6f6f 7020 7472 616e  closed-loop tran
-0002abb0: 7366 6572 2066 756e 6374 696f 6e2e 0a0a  sfer function...
-0002abc0: 2020 2020 2020 2020 5061 7261 6d65 7465          Paramete
-0002abd0: 7273 0a20 2020 2020 2020 202d 2d2d 2d2d  rs.        -----
-0002abe0: 2d2d 2d2d 2d0a 2020 2020 2020 2020 6d61  -----.        ma
-0002abf0: 6773 203a 2061 7272 6179 2d6c 696b 650a  gs : array-like.
-0002ac00: 2020 2020 2020 2020 2020 2020 4172 7261              Arra
-0002ac10: 7920 6f66 206d 6167 6e69 7475 6465 7320  y of magnitudes 
-0002ac20: 696e 2064 4220 6f66 2074 6865 204d 2d63  in dB of the M-c
-0002ac30: 6972 636c 6573 0a20 2020 2020 2020 2070  ircles.        p
-0002ac40: 6861 7365 5f6d 696e 203a 2064 6567 7265  hase_min : degre
-0002ac50: 6573 0a20 2020 2020 2020 2020 2020 204d  es.            M
-0002ac60: 696e 696d 756d 2070 6861 7365 2069 6e20  inimum phase in 
-0002ac70: 6465 6772 6565 7320 6f66 2074 6865 204e  degrees of the N
-0002ac80: 2d63 6972 636c 6573 0a20 2020 2020 2020  -circles.       
-0002ac90: 2070 6861 7365 5f6d 6178 203a 2064 6567   phase_max : deg
-0002aca0: 7265 6573 0a20 2020 2020 2020 2020 2020  rees.           
-0002acb0: 204d 6178 696d 756d 2070 6861 7365 2069   Maximum phase i
-0002acc0: 6e20 6465 6772 6565 7320 6f66 2074 6865  n degrees of the
-0002acd0: 204e 2d63 6972 636c 6573 0a0a 2020 2020   N-circles..    
-0002ace0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-0002acf0: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
-0002ad00: 2020 2020 636f 6e74 6f75 7273 203a 2063      contours : c
-0002ad10: 6f6d 706c 6578 2061 7272 6179 0a20 2020  omplex array.   
-0002ad20: 2020 2020 2020 2020 2041 7272 6179 206f           Array o
-0002ad30: 6620 636f 6d70 6c65 7820 6e75 6d62 6572  f complex number
-0002ad40: 7320 636f 7272 6573 706f 6e64 696e 6720  s corresponding 
-0002ad50: 746f 2074 6865 2063 6f6e 746f 7572 732e  to the contours.
-0002ad60: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0002ad70: 2020 2020 2023 2043 6f6e 7665 7274 206d       # Convert m
-0002ad80: 6167 6e69 7475 6465 7320 616e 6420 7068  agnitudes and ph
-0002ad90: 6173 6520 7261 6e67 6520 696e 746f 2061  ase range into a
-0002ada0: 2067 7269 6420 7375 6974 6162 6c65 2066   grid suitable f
-0002adb0: 6f72 0a20 2020 2020 2020 2023 2062 7569  or.        # bui
-0002adc0: 6c64 696e 6720 636f 6e74 6f75 7273 0a20  lding contours. 
-0002add0: 2020 2020 2020 206e 7020 3d20 696d 706f         np = impo
-0002ade0: 7274 5f6d 6f64 756c 6528 226e 756d 7079  rt_module("numpy
-0002adf0: 2229 0a20 2020 2020 2020 2070 6861 7365  ").        phase
-0002ae00: 7320 3d20 6e70 2e72 6164 6961 6e73 286e  s = np.radians(n
-0002ae10: 702e 6c69 6e73 7061 6365 2870 6861 7365  p.linspace(phase
-0002ae20: 5f6d 696e 2c20 7068 6173 655f 6d61 782c  _min, phase_max,
-0002ae30: 2032 3030 3029 290a 2020 2020 2020 2020   2000)).        
-0002ae40: 4763 6c5f 6d61 6773 2c20 4763 6c5f 7068  Gcl_mags, Gcl_ph
-0002ae50: 6173 6573 203d 206e 702e 6d65 7368 6772  ases = np.meshgr
-0002ae60: 6964 2831 302e 302a 2a28 6d61 6773 2f32  id(10.0**(mags/2
-0002ae70: 302e 3029 2c20 7068 6173 6573 290a 2020  0.0), phases).  
-0002ae80: 2020 2020 2020 7265 7475 726e 204e 4772        return NGr
-0002ae90: 6964 4c69 6e65 5365 7269 6573 2e63 6c6f  idLineSeries.clo
-0002aea0: 7365 645f 6c6f 6f70 5f63 6f6e 746f 7572  sed_loop_contour
-0002aeb0: 7328 4763 6c5f 6d61 6773 2c20 4763 6c5f  s(Gcl_mags, Gcl_
-0002aec0: 7068 6173 6573 290a 0a20 2020 2040 7374  phases)..    @st
-0002aed0: 6174 6963 6d65 7468 6f64 0a20 2020 2064  aticmethod.    d
-0002aee0: 6566 206e 5f63 6972 636c 6573 2870 6861  ef n_circles(pha
-0002aef0: 7365 732c 206d 6167 5f6d 696e 3d2d 3430  ses, mag_min=-40
-0002af00: 2e30 2c20 6d61 675f 6d61 783d 3132 2e30  .0, mag_max=12.0
-0002af10: 293a 0a20 2020 2020 2020 2022 2222 436f  ):.        """Co
-0002af20: 6e73 7461 6e74 2d70 6861 7365 2063 6f6e  nstant-phase con
-0002af30: 746f 7572 7320 6f66 2074 6865 2066 756e  tours of the fun
-0002af40: 6374 696f 6e20 4763 6c20 3d20 476f 6c2f  ction Gcl = Gol/
-0002af50: 2831 2b47 6f6c 292c 2077 6865 7265 0a20  (1+Gol), where. 
-0002af60: 2020 2020 2020 2047 6f6c 2069 7320 616e         Gol is an
-0002af70: 206f 7065 6e2d 6c6f 6f70 2074 7261 6e73   open-loop trans
-0002af80: 6665 7220 6675 6e63 7469 6f6e 2c20 616e  fer function, an
-0002af90: 6420 4763 6c20 6973 2061 2063 6f72 7265  d Gcl is a corre
-0002afa0: 7370 6f6e 6469 6e67 0a20 2020 2020 2020  sponding.       
-0002afb0: 2063 6c6f 7365 642d 6c6f 6f70 2074 7261   closed-loop tra
-0002afc0: 6e73 6665 7220 6675 6e63 7469 6f6e 2e0a  nsfer function..
-0002afd0: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
-0002afe0: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
-0002aff0: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2070  ------.        p
-0002b000: 6861 7365 7320 3a20 6172 7261 792d 6c69  hases : array-li
-0002b010: 6b65 0a20 2020 2020 2020 2020 2020 2041  ke.            A
-0002b020: 7272 6179 206f 6620 7068 6173 6573 2069  rray of phases i
-0002b030: 6e20 6465 6772 6565 7320 6f66 2074 6865  n degrees of the
-0002b040: 204e 2d63 6972 636c 6573 0a20 2020 2020   N-circles.     
-0002b050: 2020 206d 6167 5f6d 696e 203a 2064 420a     mag_min : dB.
-0002b060: 2020 2020 2020 2020 2020 2020 4d69 6e69              Mini
-0002b070: 6d75 6d20 6d61 676e 6974 7564 6520 696e  mum magnitude in
-0002b080: 2064 4220 6f66 2074 6865 204e 2d63 6972   dB of the N-cir
-0002b090: 636c 6573 0a20 2020 2020 2020 206d 6167  cles.        mag
-0002b0a0: 5f6d 6178 203a 2064 420a 2020 2020 2020  _max : dB.      
-0002b0b0: 2020 2020 2020 4d61 7869 6d75 6d20 6d61        Maximum ma
-0002b0c0: 676e 6974 7564 6520 696e 2064 4220 6f66  gnitude in dB of
-0002b0d0: 2074 6865 204e 2d63 6972 636c 6573 0a0a   the N-circles..
-0002b0e0: 2020 2020 2020 2020 5265 7475 726e 730a          Returns.
-0002b0f0: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d0a          -------.
-0002b100: 2020 2020 2020 2020 636f 6e74 6f75 7273          contours
-0002b110: 203a 2063 6f6d 706c 6578 2061 7272 6179   : complex array
-0002b120: 0a20 2020 2020 2020 2020 2020 2041 7272  .            Arr
-0002b130: 6179 206f 6620 636f 6d70 6c65 7820 6e75  ay of complex nu
-0002b140: 6d62 6572 7320 636f 7272 6573 706f 6e64  mbers correspond
-0002b150: 696e 6720 746f 2074 6865 2063 6f6e 746f  ing to the conto
-0002b160: 7572 732e 0a20 2020 2020 2020 2022 2222  urs..        """
-0002b170: 0a20 2020 2020 2020 2023 2043 6f6e 7665  .        # Conve
-0002b180: 7274 2070 6861 7365 7320 616e 6420 6d61  rt phases and ma
-0002b190: 676e 6974 7564 6520 7261 6e67 6520 696e  gnitude range in
-0002b1a0: 746f 2061 2067 7269 6420 7375 6974 6162  to a grid suitab
-0002b1b0: 6c65 2066 6f72 0a20 2020 2020 2020 2023  le for.        #
-0002b1c0: 2062 7569 6c64 696e 6720 636f 6e74 6f75   building contou
-0002b1d0: 7273 0a20 2020 2020 2020 206e 7020 3d20  rs.        np = 
-0002b1e0: 696d 706f 7274 5f6d 6f64 756c 6528 226e  import_module("n
-0002b1f0: 756d 7079 2229 0a20 2020 2020 2020 206d  umpy").        m
-0002b200: 6167 7320 3d20 6e70 2e6c 696e 7370 6163  ags = np.linspac
-0002b210: 6528 3130 2a2a 286d 6167 5f6d 696e 2f32  e(10**(mag_min/2
-0002b220: 302e 3029 2c20 3130 2a2a 286d 6167 5f6d  0.0), 10**(mag_m
-0002b230: 6178 2f32 302e 3029 2c20 3230 3030 290a  ax/20.0), 2000).
-0002b240: 2020 2020 2020 2020 4763 6c5f 7068 6173          Gcl_phas
-0002b250: 6573 2c20 4763 6c5f 6d61 6773 203d 206e  es, Gcl_mags = n
-0002b260: 702e 6d65 7368 6772 6964 286e 702e 7261  p.meshgrid(np.ra
-0002b270: 6469 616e 7328 7068 6173 6573 292c 206d  dians(phases), m
-0002b280: 6167 7329 0a20 2020 2020 2020 2072 6574  ags).        ret
-0002b290: 7572 6e20 4e47 7269 644c 696e 6553 6572  urn NGridLineSer
-0002b2a0: 6965 732e 636c 6f73 6564 5f6c 6f6f 705f  ies.closed_loop_
-0002b2b0: 636f 6e74 6f75 7273 2847 636c 5f6d 6167  contours(Gcl_mag
-0002b2c0: 732c 2047 636c 5f70 6861 7365 7329 0a0a  s, Gcl_phases)..
-0002b2d0: 2020 2020 6465 6620 6765 745f 6461 7461      def get_data
-0002b2e0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0002b2f0: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
-0002b300: 6c65 2822 6e75 6d70 7922 290a 0a20 2020  le("numpy")..   
-0002b310: 2020 2020 2023 2044 6566 6175 6c74 2063       # Default c
-0002b320: 6861 7274 2073 697a 650a 2020 2020 2020  hart size.      
-0002b330: 2020 6f6c 5f70 6861 7365 5f6d 696e 203d    ol_phase_min =
-0002b340: 202d 3335 392e 3939 0a20 2020 2020 2020   -359.99.       
-0002b350: 206f 6c5f 7068 6173 655f 6d61 7820 3d20   ol_phase_max = 
-0002b360: 302e 300a 2020 2020 2020 2020 6f6c 5f6d  0.0.        ol_m
-0002b370: 6167 5f6d 696e 203d 202d 3430 2e30 0a20  ag_min = -40.0. 
-0002b380: 2020 2020 2020 206f 6c5f 6d61 675f 6d61         ol_mag_ma
-0002b390: 7820 3d20 6465 6661 756c 745f 6f6c 5f6d  x = default_ol_m
-0002b3a0: 6167 5f6d 6178 203d 2035 302e 300a 0a20  ag_max = 50.0.. 
-0002b3b0: 2020 2020 2020 2063 6c5f 6d61 6773 203d         cl_mags =
-0002b3c0: 2073 656c 662e 636c 5f6d 6167 730a 2020   self.cl_mags.  
-0002b3d0: 2020 2020 2020 636c 5f70 6861 7365 7320        cl_phases 
-0002b3e0: 3d20 7365 6c66 2e63 6c5f 7068 6173 6573  = self.cl_phases
-0002b3f0: 0a20 2020 2020 2020 206c 6162 656c 5f63  .        label_c
-0002b400: 6c5f 7068 6173 6573 203d 2073 656c 662e  l_phases = self.
-0002b410: 6c61 6265 6c5f 636c 5f70 6861 7365 730a  label_cl_phases.
-0002b420: 0a20 2020 2020 2020 2023 2046 696e 6420  .        # Find 
-0002b430: 6578 7465 6e74 206f 6620 696e 7465 7273  extent of inters
-0002b440: 6563 7469 6f6e 2074 6865 2063 7572 7265  ection the curre
-0002b450: 6e74 2064 6174 6173 6574 206f 7220 7669  nt dataset or vi
-0002b460: 6577 0a20 2020 2020 2020 206f 6c5f 7068  ew.        ol_ph
-0002b470: 6173 655f 6d69 6e2c 206f 6c5f 7068 6173  ase_min, ol_phas
-0002b480: 655f 6d61 7820 3d20 7365 6c66 2e5f 786c  e_max = self._xl
-0002b490: 696d 0a20 2020 2020 2020 206f 6c5f 6d61  im.        ol_ma
-0002b4a0: 675f 6d69 6e2c 206f 6c5f 6d61 675f 6d61  g_min, ol_mag_ma
-0002b4b0: 7820 3d20 7365 6c66 2e5f 796c 696d 0a0a  x = self._ylim..
-0002b4c0: 2020 2020 2020 2020 2320 4d2d 6369 7263          # M-circ
-0002b4d0: 6c65 206d 6167 6e69 7475 6465 732e 0a20  le magnitudes.. 
-0002b4e0: 2020 2020 2020 2069 6620 636c 5f6d 6167         if cl_mag
-0002b4f0: 7320 6973 204e 6f6e 653a 0a20 2020 2020  s is None:.     
-0002b500: 2020 2020 2020 2023 2044 6566 6175 6c74         # Default
-0002b510: 2063 6861 7274 206d 6167 6e69 7475 6465   chart magnitude
-0002b520: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
-0002b530: 5468 6520 6b65 7920 7365 7420 6f66 206d  The key set of m
-0002b540: 6167 6e69 7475 6465 7320 6172 6520 616c  agnitudes are al
-0002b550: 7761 7973 2067 656e 6572 6174 6564 2c20  ways generated, 
-0002b560: 7369 6e63 6520 7468 6973 0a20 2020 2020  since this.     
-0002b570: 2020 2020 2020 2023 2067 7561 7261 6e74         # guarant
-0002b580: 6565 7320 6120 7265 636f 676e 697a 6162  ees a recognizab
-0002b590: 6c65 204e 6963 686f 6c73 2063 6861 7274  le Nichols chart
-0002b5a0: 2067 7269 642e 0a20 2020 2020 2020 2020   grid..         
-0002b5b0: 2020 206b 6579 5f63 6c5f 6d61 6773 203d     key_cl_mags =
-0002b5c0: 206e 702e 6172 7261 7928 5b0a 2020 2020   np.array([.    
-0002b5d0: 2020 2020 2020 2020 2020 2020 2d34 302e              -40.
-0002b5e0: 302c 202d 3230 2e30 2c20 2d31 322e 302c  0, -20.0, -12.0,
-0002b5f0: 202d 362e 302c 202d 332e 302c 202d 312e   -6.0, -3.0, -1.
-0002b600: 302c 202d 302e 352c 0a20 2020 2020 2020  0, -0.5,.       
-0002b610: 2020 2020 2020 2020 2030 2e30 2c20 302e           0.0, 0.
-0002b620: 3235 2c20 302e 352c 2031 2e30 2c20 332e  25, 0.5, 1.0, 3.
-0002b630: 302c 2036 2e30 2c20 3132 2e30 0a20 2020  0, 6.0, 12.0.   
-0002b640: 2020 2020 2020 2020 205d 290a 0a20 2020           ])..   
-0002b650: 2020 2020 2020 2020 2023 2045 7874 656e           # Exten
-0002b660: 6420 7468 6520 7261 6e67 6520 6f66 206d  d the range of m
-0002b670: 6167 6e69 7475 6465 7320 6966 206e 6563  agnitudes if nec
-0002b680: 6573 7361 7279 2e20 5468 6520 6578 7465  essary. The exte
-0002b690: 6e64 6564 2061 7261 6e67 650a 2020 2020  nded arange.    
-0002b6a0: 2020 2020 2020 2020 2320 7769 6c6c 2065          # will e
-0002b6b0: 6e64 2075 7020 656d 7074 7920 6966 206e  nd up empty if n
-0002b6c0: 6f20 6578 7465 6e73 696f 6e20 6973 2072  o extension is r
-0002b6d0: 6571 7569 7265 642e 2041 7373 756d 6573  equired. Assumes
-0002b6e0: 2074 6861 740a 2020 2020 2020 2020 2020   that.          
-0002b6f0: 2020 2320 636c 6f73 6564 2d6c 6f6f 7020    # closed-loop 
-0002b700: 6d61 676e 6974 7564 6573 2061 7265 2061  magnitudes are a
-0002b710: 7070 726f 7869 6d61 7465 6c79 2061 6c69  pproximately ali
-0002b720: 676e 6564 2077 6974 6820 6f70 656e 2d6c  gned with open-l
-0002b730: 6f6f 700a 2020 2020 2020 2020 2020 2020  oop.            
-0002b740: 2320 6d61 676e 6974 7564 6573 2062 6579  # magnitudes bey
-0002b750: 6f6e 6420 7468 6520 7661 6c75 6520 6f66  ond the value of
-0002b760: 206e 702e 6d69 6e28 6b65 795f 636c 5f6d   np.min(key_cl_m
-0002b770: 6167 7329 0a20 2020 2020 2020 2020 2020  ags).           
-0002b780: 2063 6c5f 6d61 675f 7374 6570 203d 202d   cl_mag_step = -
-0002b790: 3230 2e30 2020 2320 6442 0a20 2020 2020  20.0  # dB.     
-0002b7a0: 2020 2020 2020 2065 7874 656e 6465 645f         extended_
-0002b7b0: 636c 5f6d 6167 7320 3d20 6e70 2e61 7261  cl_mags = np.ara
-0002b7c0: 6e67 6528 0a20 2020 2020 2020 2020 2020  nge(.           
-0002b7d0: 2020 2020 206e 702e 6d69 6e28 6b65 795f       np.min(key_
-0002b7e0: 636c 5f6d 6167 7329 2c20 6f6c 5f6d 6167  cl_mags), ol_mag
-0002b7f0: 5f6d 696e 202b 2063 6c5f 6d61 675f 7374  _min + cl_mag_st
-0002b800: 6570 2c20 636c 5f6d 6167 5f73 7465 7029  ep, cl_mag_step)
-0002b810: 0a20 2020 2020 2020 2020 2020 2063 6c5f  .            cl_
-0002b820: 6d61 6773 203d 206e 702e 636f 6e63 6174  mags = np.concat
-0002b830: 656e 6174 6528 2865 7874 656e 6465 645f  enate((extended_
-0002b840: 636c 5f6d 6167 732c 206b 6579 5f63 6c5f  cl_mags, key_cl_
-0002b850: 6d61 6773 2929 0a0a 2020 2020 2020 2020  mags))..        
-0002b860: 2320 6120 6d69 6e69 6d75 6d20 3336 3064  # a minimum 360d
-0002b870: 6567 2065 7874 656e 7420 636f 6e74 6169  eg extent contai
-0002b880: 6e69 6e67 2074 6865 2070 6861 7365 730a  ning the phases.
-0002b890: 2020 2020 2020 2020 7068 6173 655f 726f          phase_ro
-0002b8a0: 756e 645f 6d61 7820 3d20 3336 302e 302a  und_max = 360.0*
-0002b8b0: 6e70 2e63 6569 6c28 6f6c 5f70 6861 7365  np.ceil(ol_phase
-0002b8c0: 5f6d 6178 2f33 3630 2e30 290a 2020 2020  _max/360.0).    
-0002b8d0: 2020 2020 7068 6173 655f 726f 756e 645f      phase_round_
-0002b8e0: 6d69 6e20 3d20 6d69 6e28 7068 6173 655f  min = min(phase_
-0002b8f0: 726f 756e 645f 6d61 782d 3336 302c 0a20  round_max-360,. 
-0002b900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b910: 2020 2020 2020 2020 2020 2033 3630 2e30             360.0
-0002b920: 2a6e 702e 666c 6f6f 7228 6f6c 5f70 6861  *np.floor(ol_pha
-0002b930: 7365 5f6d 696e 2f33 3630 2e30 2929 0a0a  se_min/360.0))..
-0002b940: 2020 2020 2020 2020 2320 4e2d 6369 7263          # N-circ
-0002b950: 6c65 2070 6861 7365 7320 2873 686f 756c  le phases (shoul
-0002b960: 6420 6265 2069 6e20 7468 6520 7261 6e67  d be in the rang
-0002b970: 6520 2d33 3630 2074 6f20 3029 0a20 2020  e -360 to 0).   
-0002b980: 2020 2020 2069 6620 636c 5f70 6861 7365       if cl_phase
-0002b990: 7320 6973 204e 6f6e 653a 0a20 2020 2020  s is None:.     
-0002b9a0: 2020 2020 2020 2023 2061 696d 2066 6f72         # aim for
-0002b9b0: 2039 206c 696e 6573 2c20 6275 7420 616c   9 lines, but al
-0002b9c0: 7761 7973 2073 686f 7720 282d 3336 302b  ways show (-360+
-0002b9d0: 6570 732c 202d 3138 302c 202d 6570 7329  eps, -180, -eps)
-0002b9e0: 0a20 2020 2020 2020 2020 2020 2023 2073  .            # s
-0002b9f0: 6d61 6c6c 6573 7420 7370 6163 696e 6720  mallest spacing 
-0002ba00: 6973 2034 352c 2062 6967 6765 7374 2069  is 45, biggest i
-0002ba10: 7320 3138 300a 2020 2020 2020 2020 2020  s 180.          
-0002ba20: 2020 7068 6173 655f 7370 616e 203d 2070    phase_span = p
-0002ba30: 6861 7365 5f72 6f75 6e64 5f6d 6178 202d  hase_round_max -
-0002ba40: 2070 6861 7365 5f72 6f75 6e64 5f6d 696e   phase_round_min
-0002ba50: 0a20 2020 2020 2020 2020 2020 2073 7061  .            spa
-0002ba60: 6369 6e67 203d 206e 702e 636c 6970 2872  cing = np.clip(r
-0002ba70: 6f75 6e64 2870 6861 7365 5f73 7061 6e20  ound(phase_span 
-0002ba80: 2f20 3820 2f20 3435 2920 2a20 3435 2c20  / 8 / 45) * 45, 
-0002ba90: 3435 2c20 3138 3029 0a20 2020 2020 2020  45, 180).       
-0002baa0: 2020 2020 206b 6579 5f63 6c5f 7068 6173       key_cl_phas
-0002bab0: 6573 203d 206e 702e 6172 7261 7928 5b2d  es = np.array([-
-0002bac0: 302e 3235 2c20 2d33 3539 2e37 355d 290a  0.25, -359.75]).
-0002bad0: 2020 2020 2020 2020 2020 2020 6f74 6865              othe
-0002bae0: 725f 636c 5f70 6861 7365 7320 3d20 6e70  r_cl_phases = np
-0002baf0: 2e61 7261 6e67 6528 2d73 7061 6369 6e67  .arange(-spacing
-0002bb00: 2c20 2d33 3630 2e30 2c20 2d73 7061 6369  , -360.0, -spaci
-0002bb10: 6e67 290a 2020 2020 2020 2020 2020 2020  ng).            
-0002bb20: 636c 5f70 6861 7365 7320 3d20 6e70 2e75  cl_phases = np.u
-0002bb30: 6e69 7175 6528 6e70 2e63 6f6e 6361 7465  nique(np.concate
-0002bb40: 6e61 7465 2828 6b65 795f 636c 5f70 6861  nate((key_cl_pha
-0002bb50: 7365 732c 206f 7468 6572 5f63 6c5f 7068  ses, other_cl_ph
-0002bb60: 6173 6573 2929 290a 2020 2020 2020 2020  ases))).        
-0002bb70: 656c 6966 206e 6f74 2028 282d 3336 3020  elif not ((-360 
-0002bb80: 3c20 6e70 2e6d 696e 2863 6c5f 7068 6173  < np.min(cl_phas
-0002bb90: 6573 2929 2061 6e64 2028 6e70 2e6d 6178  es)) and (np.max
-0002bba0: 2863 6c5f 7068 6173 6573 2920 3c20 302e  (cl_phases) < 0.
-0002bbb0: 3029 293a 0a20 2020 2020 2020 2020 2020  0)):.           
-0002bbc0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0002bbd0: 7228 2763 6c5f 7068 6173 6573 206d 7573  r('cl_phases mus
-0002bbe0: 7420 6265 7477 6565 6e20 2d33 3630 2061  t between -360 a
-0002bbf0: 6e64 2030 2c20 6578 636c 7573 6976 6527  nd 0, exclusive'
-0002bc00: 290a 0a20 2020 2020 2020 2073 656c 662e  )..        self.
-0002bc10: 636c 5f6d 6167 7320 3d20 636c 5f6d 6167  cl_mags = cl_mag
-0002bc20: 730a 2020 2020 2020 2020 7365 6c66 2e63  s.        self.c
-0002bc30: 6c5f 7068 6173 6573 203d 2063 6c5f 7068  l_phases = cl_ph
-0002bc40: 6173 6573 0a0a 2020 2020 2020 2020 2320  ases..        # 
-0002bc50: 4669 6e64 2074 6865 204d 2d63 6f6e 746f  Find the M-conto
-0002bc60: 7572 730a 2020 2020 2020 2020 6d20 3d20  urs.        m = 
-0002bc70: 7365 6c66 2e6d 5f63 6972 636c 6573 280a  self.m_circles(.
-0002bc80: 2020 2020 2020 2020 2020 2020 636c 5f6d              cl_m
-0002bc90: 6167 732c 2070 6861 7365 5f6d 696e 3d6e  ags, phase_min=n
-0002bca0: 702e 6d69 6e28 636c 5f70 6861 7365 7329  p.min(cl_phases)
-0002bcb0: 2c20 7068 6173 655f 6d61 783d 6e70 2e6d  , phase_max=np.m
-0002bcc0: 6178 2863 6c5f 7068 6173 6573 2929 0a20  ax(cl_phases)). 
-0002bcd0: 2020 2020 2020 206d 5f6d 6167 203d 2032         m_mag = 2
-0002bce0: 302a 6e70 2e6c 6f67 3130 286e 702e 6162  0*np.log10(np.ab
-0002bcf0: 7328 6d29 290a 2020 2020 2020 2020 6d5f  s(m)).        m_
-0002bd00: 7068 6173 6520 3d20 6e70 2e6d 6f64 286e  phase = np.mod(n
-0002bd10: 702e 6465 6772 6565 7328 6e70 2e61 6e67  p.degrees(np.ang
-0002bd20: 6c65 286d 2929 2c20 2d33 3630 2e30 2920  le(m)), -360.0) 
-0002bd30: 2023 2055 6e77 7261 700a 0a20 2020 2020   # Unwrap..     
-0002bd40: 2020 2023 2046 696e 6420 7468 6520 4e2d     # Find the N-
-0002bd50: 636f 6e74 6f75 7273 0a20 2020 2020 2020  contours.       
-0002bd60: 206e 203d 2073 656c 662e 6e5f 6369 7263   n = self.n_circ
-0002bd70: 6c65 7328 636c 5f70 6861 7365 732c 206d  les(cl_phases, m
-0002bd80: 6167 5f6d 696e 3d6e 702e 6d69 6e28 636c  ag_min=np.min(cl
-0002bd90: 5f6d 6167 7329 2c20 6d61 675f 6d61 783d  _mags), mag_max=
-0002bda0: 6e70 2e6d 6178 2863 6c5f 6d61 6773 2929  np.max(cl_mags))
-0002bdb0: 0a20 2020 2020 2020 206e 5f6d 6167 203d  .        n_mag =
-0002bdc0: 2032 302a 6e70 2e6c 6f67 3130 286e 702e   20*np.log10(np.
-0002bdd0: 6162 7328 6e29 290a 2020 2020 2020 2020  abs(n)).        
-0002bde0: 6e5f 7068 6173 6520 3d20 6e70 2e6d 6f64  n_phase = np.mod
-0002bdf0: 286e 702e 6465 6772 6565 7328 6e70 2e61  (np.degrees(np.a
-0002be00: 6e67 6c65 286e 2929 2c20 2d33 3630 2e30  ngle(n)), -360.0
-0002be10: 2920 2023 2055 6e77 7261 700a 0a20 2020  )  # Unwrap..   
-0002be20: 2020 2020 2023 2050 6c6f 7420 7468 6520       # Plot the 
-0002be30: 636f 6e74 6f75 7273 2062 6568 696e 6420  contours behind 
-0002be40: 6f74 6865 7220 706c 6f74 2065 6c65 6d65  other plot eleme
-0002be50: 6e74 732e 0a20 2020 2020 2020 2023 2054  nts..        # T
-0002be60: 6865 2022 7068 6173 6520 6f66 6673 6574  he "phase offset
-0002be70: 2220 6973 2075 7365 6420 746f 2070 726f  " is used to pro
-0002be80: 6475 6365 2063 6f70 6965 7320 6f66 2074  duce copies of t
-0002be90: 6865 2063 6861 7274 2074 6861 7420 636f  he chart that co
-0002bea0: 7665 720a 2020 2020 2020 2020 2320 7468  ver.        # th
-0002beb0: 6520 656e 7469 7265 2072 616e 6765 206f  e entire range o
-0002bec0: 6620 7468 6520 706c 6f74 7465 6420 6461  f the plotted da
-0002bed0: 7461 2c20 7374 6172 7469 6e67 2066 726f  ta, starting fro
-0002bee0: 6d20 6120 6261 7365 2063 6861 7274 2063  m a base chart c
-0002bef0: 6f6d 7075 7465 640a 2020 2020 2020 2020  omputed.        
-0002bf00: 2320 6f76 6572 2074 6865 2072 616e 6765  # over the range
-0002bf10: 202d 3336 3020 3c20 7068 6173 6520 3c20   -360 < phase < 
-0002bf20: 302e 2047 6976 656e 2074 6865 2072 616e  0. Given the ran
-0002bf30: 6765 0a20 2020 2020 2020 2023 2074 6865  ge.        # the
-0002bf40: 2062 6173 6520 6368 6172 7420 6973 2063   base chart is c
-0002bf50: 6f6d 7075 7465 6420 6f76 6572 2c20 7468  omputed over, th
-0002bf60: 6520 7068 6173 6520 6f66 6673 6574 2073  e phase offset s
-0002bf70: 686f 756c 6420 6265 2030 0a20 2020 2020  hould be 0.     
-0002bf80: 2020 2023 2066 6f72 202d 3336 3020 3c20     # for -360 < 
-0002bf90: 6f6c 5f70 6861 7365 5f6d 696e 203c 2030  ol_phase_min < 0
-0002bfa0: 2e0a 2020 2020 2020 2020 7068 6173 655f  ..        phase_
-0002bfb0: 6f66 6673 6574 7320 3d20 3336 3020 2b20  offsets = 360 + 
-0002bfc0: 6e70 2e61 7261 6e67 6528 7068 6173 655f  np.arange(phase_
-0002bfd0: 726f 756e 645f 6d69 6e2c 2070 6861 7365  round_min, phase
-0002bfe0: 5f72 6f75 6e64 5f6d 6178 2c20 3336 302e  _round_max, 360.
-0002bff0: 3029 0a20 2020 2020 2020 2072 6574 7572  0).        retur
-0002c000: 6e20 6d5f 6d61 672c 206d 5f70 6861 7365  n m_mag, m_phase
-0002c010: 2c20 6e5f 6d61 672c 206e 5f70 6861 7365  , n_mag, n_phase
-0002c020: 2c20 7068 6173 655f 6f66 6673 6574 730a  , phase_offsets.
-0002c030: 0a0a 636c 6173 7320 4d43 6972 636c 6573  ..class MCircles
-0002c040: 5365 7269 6573 2847 7269 6442 6173 652c  Series(GridBase,
-0002c050: 2042 6173 6553 6572 6965 7329 3a0a 2020   BaseSeries):.  
-0002c060: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
-0002c070: 656c 662c 206d 6167 6e69 7475 6465 735f  elf, magnitudes_
-0002c080: 6462 2c20 6d61 676e 6974 7564 6573 2c20  db, magnitudes, 
-0002c090: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
-0002c0a0: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
-0002c0b0: 745f 5f28 2a2a 6b77 6172 6773 290a 2020  t__(**kwargs).  
-0002c0c0: 2020 2020 2020 7365 6c66 2e6d 6167 6e69        self.magni
-0002c0d0: 7475 6465 735f 6462 203d 2054 7570 6c65  tudes_db = Tuple
-0002c0e0: 282a 6d61 676e 6974 7564 6573 5f64 6229  (*magnitudes_db)
-0002c0f0: 0a20 2020 2020 2020 2073 656c 662e 6d61  .        self.ma
-0002c100: 676e 6974 7564 6573 203d 2073 656c 662e  gnitudes = self.
-0002c110: 5f65 7870 7220 3d20 5475 706c 6528 2a6d  _expr = Tuple(*m
-0002c120: 6167 6e69 7475 6465 7329 0a0a 2020 2020  agnitudes)..    
-0002c130: 6465 6620 6765 745f 6461 7461 2873 656c  def get_data(sel
-0002c140: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
-0002c150: 2020 2020 2020 2020 5265 7475 726e 730a          Returns.
-0002c160: 2020 2020 2020 2020 3d3d 3d3d 3d3d 3d0a          =======.
-0002c170: 0a20 2020 2020 2020 2064 6174 6120 3a20  .        data : 
-0002c180: 6c69 7374 0a20 2020 2020 2020 2020 2020  list.           
-0002c190: 2045 6163 6820 656c 656d 656e 7420 6f66   Each element of
-0002c1a0: 2074 6865 206c 6973 7420 6861 7320 7468   the list has th
-0002c1b0: 6520 666f 726d 3a0a 2020 2020 2020 2020  e form:.        
-0002c1c0: 2020 2020 6060 5b6d 6167 6e69 7475 6465      ``[magnitude
-0002c1d0: 5f64 622c 2078 5f63 6f6f 7264 732c 2079  _db, x_coords, y
-0002c1e0: 5f63 6f6f 7264 735d 6060 2e0a 2020 2020  _coords]``..    
-0002c1f0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0002c200: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
-0002c210: 6c65 2822 6e75 6d70 7922 290a 2020 2020  le("numpy").    
-0002c220: 2020 2020 6461 7461 203d 205b 5d0a 2020      data = [].  
-0002c230: 2020 2020 2020 6d61 676e 6974 7564 6573        magnitudes
-0002c240: 203d 2073 656c 662e 6d61 676e 6974 7564   = self.magnitud
-0002c250: 6573 0a20 2020 2020 2020 206d 6167 6e69  es.        magni
-0002c260: 7475 6465 735f 6462 203d 2073 656c 662e  tudes_db = self.
-0002c270: 6d61 676e 6974 7564 6573 5f64 620a 2020  magnitudes_db.  
-0002c280: 2020 2020 2020 6966 2073 656c 662e 6973        if self.is
-0002c290: 5f69 6e74 6572 6163 7469 7665 3a0a 2020  _interactive:.  
-0002c2a0: 2020 2020 2020 2020 2020 6d61 676e 6974            magnit
-0002c2b0: 7564 6573 203d 206d 6167 6e69 7475 6465  udes = magnitude
-0002c2c0: 732e 7375 6273 2873 656c 662e 7061 7261  s.subs(self.para
-0002c2d0: 6d73 290a 2020 2020 2020 2020 2020 2020  ms).            
-0002c2e0: 6d61 676e 6974 7564 6573 5f64 6220 3d20  magnitudes_db = 
-0002c2f0: 6d61 676e 6974 7564 6573 5f64 622e 7375  magnitudes_db.su
-0002c300: 6273 2873 656c 662e 7061 7261 6d73 290a  bs(self.params).
-0002c310: 2020 2020 2020 2020 6d61 676e 6974 7564          magnitud
-0002c320: 6573 203d 206e 702e 6172 7261 7928 6d61  es = np.array(ma
-0002c330: 676e 6974 7564 6573 2c20 6474 7970 653d  gnitudes, dtype=
-0002c340: 666c 6f61 7429 0a20 2020 2020 2020 206d  float).        m
-0002c350: 6167 6e69 7475 6465 735f 6462 203d 206e  agnitudes_db = n
-0002c360: 702e 6172 7261 7928 6d61 676e 6974 7564  p.array(magnitud
-0002c370: 6573 5f64 622c 2064 7479 7065 3d66 6c6f  es_db, dtype=flo
-0002c380: 6174 290a 0a20 2020 2020 2020 2074 6865  at)..        the
-0002c390: 7461 203d 206e 702e 6c69 6e73 7061 6365  ta = np.linspace
-0002c3a0: 2830 2c20 322a 6e70 2e70 692c 2034 3030  (0, 2*np.pi, 400
-0002c3b0: 290a 2020 2020 2020 2020 6374 203d 206e  ).        ct = n
-0002c3c0: 702e 636f 7328 7468 6574 6129 0a20 2020  p.cos(theta).   
-0002c3d0: 2020 2020 2073 7420 3d20 6e70 2e73 696e       st = np.sin
-0002c3e0: 2874 6865 7461 290a 2020 2020 2020 2020  (theta).        
-0002c3f0: 666f 7220 6d64 622c 206d 2069 6e20 7a69  for mdb, m in zi
-0002c400: 7028 6d61 676e 6974 7564 6573 5f64 622c  p(magnitudes_db,
-0002c410: 206d 6167 6e69 7475 6465 7329 3a0a 2020   magnitudes):.  
-0002c420: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
-0002c430: 206e 702e 6973 636c 6f73 6528 6d64 622c   np.isclose(mdb,
-0002c440: 2030 293a 0a20 2020 2020 2020 2020 2020   0):.           
-0002c450: 2020 2020 2072 203d 206d 202f 2028 3120       r = m / (1 
-0002c460: 2d20 6d2a 2a32 290a 2020 2020 2020 2020  - m**2).        
-0002c470: 2020 2020 2020 2020 7820 3d20 6d2a 2a32          x = m**2
-0002c480: 202f 2028 3120 2d20 6d2a 2a32 2920 2b20   / (1 - m**2) + 
-0002c490: 7220 2a20 6374 0a20 2020 2020 2020 2020  r * ct.         
-0002c4a0: 2020 2020 2020 2079 203d 2072 202a 2073         y = r * s
-0002c4b0: 740a 2020 2020 2020 2020 2020 2020 656c  t.            el
-0002c4c0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0002c4d0: 2020 2020 7820 3d20 5b2d 302e 355d 0a20      x = [-0.5]. 
-0002c4e0: 2020 2020 2020 2020 2020 2020 2020 2079                 y
-0002c4f0: 203d 205b 305d 0a20 2020 2020 2020 2020   = [0].         
-0002c500: 2020 2064 6174 612e 6170 7065 6e64 285b     data.append([
-0002c510: 6d64 622c 2078 2c20 795d 290a 2020 2020  mdb, x, y]).    
-0002c520: 2020 2020 7265 7475 726e 2064 6174 610a      return data.
+00007f20: 6172 6773 2c20 2a2a 6b77 6172 6773 290a  args, **kwargs).
+00007f30: 2020 2020 2020 2020 2320 6c69 7374 206f          # list o
+00007f40: 6620 6e75 6d65 7269 6361 6c20 6675 6e63  f numerical func
+00007f50: 7469 6f6e 7320 7265 7072 6573 656e 7469  tions representi
+00007f60: 6e67 2074 6865 2065 7870 7265 7373 696f  ng the expressio
+00007f70: 6e73 2074 6f20 6576 616c 7561 7465 0a20  ns to evaluate. 
+00007f80: 2020 2020 2020 2073 656c 662e 5f66 756e         self._fun
+00007f90: 6374 696f 6e73 203d 205b 5d0a 2020 2020  ctions = [].    
+00007fa0: 2020 2020 2320 7369 676e 6174 7572 6520      # signature 
+00007fb0: 6f66 2066 6f72 2074 6865 206e 756d 6572  of for the numer
+00007fc0: 6963 616c 2066 756e 6374 696f 6e73 0a20  ical functions. 
+00007fd0: 2020 2020 2020 2073 656c 662e 5f73 6967         self._sig
+00007fe0: 6e61 7475 7265 203d 205b 5d0a 2020 2020  nature = [].    
+00007ff0: 2020 2020 2320 736f 6d65 2065 7870 7265      # some expre
+00008000: 7373 696f 6e73 2064 6f6e 2774 206c 696b  ssions don't lik
+00008010: 6520 746f 2062 6520 6576 616c 7561 7465  e to be evaluate
+00008020: 6420 6f76 6572 2063 6f6d 706c 6578 2064  d over complex d
+00008030: 6174 612e 0a20 2020 2020 2020 2023 2069  ata..        # i
+00008040: 6620 7468 6174 2773 2074 6865 2063 6173  f that's the cas
+00008050: 652c 2073 6574 2074 6869 7320 746f 2054  e, set this to T
+00008060: 7275 650a 2020 2020 2020 2020 7365 6c66  rue.        self
+00008070: 2e5f 666f 7263 655f 7265 616c 5f65 7661  ._force_real_eva
+00008080: 6c20 3d20 6b77 6172 6773 2e67 6574 2822  l = kwargs.get("
+00008090: 666f 7263 655f 7265 616c 5f65 7661 6c22  force_real_eval"
+000080a0: 2c20 4e6f 6e65 290a 2020 2020 2020 2020  , None).        
+000080b0: 2320 6576 656e 7475 616c 6c79 2069 7420  # eventually it 
+000080c0: 7769 6c6c 2063 6f6e 7461 696e 2061 2064  will contain a d
+000080d0: 6963 7469 6f6e 6172 7920 7769 7468 2074  ictionary with t
+000080e0: 6865 2064 6973 6372 6574 697a 6564 2072  he discretized r
+000080f0: 616e 6765 730a 2020 2020 2020 2020 7365  anges.        se
+00008100: 6c66 2e5f 6469 7363 7265 7469 7a65 645f  lf._discretized_
+00008110: 646f 6d61 696e 203d 204e 6f6e 650a 2020  domain = None.  
+00008120: 2020 2020 2020 2320 4e4f 5445 3a20 636f        # NOTE: co
+00008130: 6e73 6964 6572 2061 2067 656e 6572 6963  nsider a generic
+00008140: 2073 756d 6d61 7469 6f6e 2c20 666f 7220   summation, for 
+00008150: 6578 616d 706c 653a 0a20 2020 2020 2020  example:.       
+00008160: 2023 2020 2073 203d 2053 756d 2863 6f73   #   s = Sum(cos
+00008170: 2870 6920 2a20 7829 2c20 2878 2c20 312c  (pi * x), (x, 1,
+00008180: 2079 2929 0a20 2020 2020 2020 2023 2054   y)).        # T
+00008190: 6869 7320 6765 7473 206c 616d 6264 6966  his gets lambdif
+000081a0: 6965 6420 746f 2073 6f6d 6574 6869 6e67  ied to something
+000081b0: 3a0a 2020 2020 2020 2020 2320 2020 7375  :.        #   su
+000081c0: 6d28 636f 7328 7069 2a78 2920 666f 7220  m(cos(pi*x) for 
+000081d0: 7820 696e 2072 616e 6765 2831 2c20 792b  x in range(1, y+
+000081e0: 3129 290a 2020 2020 2020 2020 2320 4865  1)).        # He
+000081f0: 6e63 652c 2079 206e 6565 6473 2074 6f20  nce, y needs to 
+00008200: 6265 2061 6e20 696e 7465 6765 722c 206f  be an integer, o
+00008210: 7468 6572 7769 7365 2069 7420 7261 6973  therwise it rais
+00008220: 6573 3a0a 2020 2020 2020 2020 2320 2020  es:.        #   
+00008230: 5479 7065 4572 726f 723a 2027 636f 6d70  TypeError: 'comp
+00008240: 6c65 7827 206f 626a 6563 7420 6361 6e6e  lex' object cann
+00008250: 6f74 2062 6520 696e 7465 7270 7265 7465  ot be interprete
+00008260: 6420 6173 2061 6e20 696e 7465 6765 720a  d as an integer.
+00008270: 2020 2020 2020 2020 2320 5468 6973 206c          # This l
+00008280: 6973 7420 7769 6c6c 2063 6f6e 7461 696e  ist will contain
+00008290: 7320 7379 6d62 6f6c 7320 7468 6174 2061  s symbols that a
+000082a0: 7265 2075 7070 6572 2062 6f75 6e64 2074  re upper bound t
+000082b0: 6f20 7375 6d6d 6174 696f 6e73 0a20 2020  o summations.   
+000082c0: 2020 2020 2023 206f 7220 7072 6f64 7563       # or produc
+000082d0: 7473 0a20 2020 2020 2020 2073 656c 662e  ts.        self.
+000082e0: 5f6e 6565 6473 5f74 6f5f 6265 5f69 6e74  _needs_to_be_int
+000082f0: 203d 205b 5d0a 2020 2020 2020 2020 2320   = [].        # 
+00008300: 6469 7363 7265 7469 7a65 2074 6865 2064  discretize the d
+00008310: 6f6d 6169 6e20 7573 696e 6720 6f6e 6c79  omain using only
+00008320: 2069 6e74 6567 6572 206e 756d 6265 7273   integer numbers
+00008330: 0a20 2020 2020 2020 2073 656c 662e 6f6e  .        self.on
+00008340: 6c79 5f69 6e74 6567 6572 7320 3d20 6b77  ly_integers = kw
+00008350: 6172 6773 2e67 6574 2822 6f6e 6c79 5f69  args.get("only_i
+00008360: 6e74 6567 6572 7322 2c20 4661 6c73 6529  ntegers", False)
+00008370: 0a20 2020 2020 2020 2069 6620 6861 7361  .        if hasa
+00008380: 7474 7228 7365 6c66 2c20 2261 6461 7074  ttr(self, "adapt
+00008390: 6976 6522 2920 616e 6420 7365 6c66 2e61  ive") and self.a
+000083a0: 6461 7074 6976 6520 616e 6420 7365 6c66  daptive and self
+000083b0: 2e6f 6e6c 795f 696e 7465 6765 7273 3a0a  .only_integers:.
+000083c0: 2020 2020 2020 2020 2020 2020 7761 726e              warn
+000083d0: 696e 6773 2e77 6172 6e28 0a20 2020 2020  ings.warn(.     
+000083e0: 2020 2020 2020 2020 2020 2022 6060 6f6e             "``on
+000083f0: 6c79 5f69 6e74 6567 6572 733d 5472 7565  ly_integers=True
+00008400: 6060 2069 7320 6e6f 7420 7375 7070 6f72  `` is not suppor
+00008410: 7465 6420 6279 2074 6865 2061 6461 7074  ted by the adapt
+00008420: 6976 6520 220a 2020 2020 2020 2020 2020  ive ".          
+00008430: 2020 2020 2020 2261 6c67 6f72 6974 686d        "algorithm
+00008440: 2e20 4175 746f 6d61 7469 6361 6c6c 7920  . Automatically 
+00008450: 7365 7474 696e 6720 6060 6164 6170 7469  setting ``adapti
+00008460: 7665 3d46 616c 7365 6060 2e22 0a20 2020  ve=False``.".   
+00008470: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00008480: 2020 2020 2020 2073 656c 662e 6164 6170         self.adap
+00008490: 7469 7665 203d 2046 616c 7365 0a20 2020  tive = False.   
+000084a0: 2020 2020 2023 2072 6570 7265 7365 6e74       # represent
+000084b0: 7320 7468 6520 6576 616c 7561 7469 6f6e  s the evaluation
+000084c0: 206d 6f64 756c 6573 2074 6f20 6265 2075   modules to be u
+000084d0: 7365 6420 6279 206c 616d 6264 6966 790a  sed by lambdify.
+000084e0: 2020 2020 2020 2020 7365 6c66 2e6d 6f64          self.mod
+000084f0: 756c 6573 203d 206b 7761 7267 732e 6765  ules = kwargs.ge
+00008500: 7428 226d 6f64 756c 6573 222c 204e 6f6e  t("modules", Non
+00008510: 6529 0a20 2020 2020 2020 2023 2049 6620  e).        # If 
+00008520: 5472 7565 2c20 7468 6520 6261 636b 656e  True, the backen
+00008530: 6420 7769 6c6c 2061 7474 656d 7074 2074  d will attempt t
+00008540: 6f20 7265 6e64 6572 2069 7420 6f6e 2061  o render it on a
+00008550: 2070 6f6c 6172 2d70 726f 6a65 6374 696f   polar-projectio
+00008560: 6e0a 2020 2020 2020 2020 2320 6178 6973  n.        # axis
+00008570: 2c20 6f72 2075 7369 6e67 2061 2070 6f6c  , or using a pol
+00008580: 6172 2064 6973 6372 6574 697a 6174 696f  ar discretizatio
+00008590: 6e20 6966 2061 2033 4420 706c 6f74 2069  n if a 3D plot i
+000085a0: 7320 7265 7175 6573 7465 640a 2020 2020  s requested.    
+000085b0: 2020 2020 7365 6c66 2e69 735f 706f 6c61      self.is_pola
+000085c0: 7220 3d20 6b77 6172 6773 2e67 6574 2822  r = kwargs.get("
+000085d0: 6973 5f70 6f6c 6172 222c 2046 616c 7365  is_polar", False
+000085e0: 290a 0a20 2020 2064 6566 205f 6372 6561  )..    def _crea
+000085f0: 7465 5f6c 616d 6264 615f 6675 6e63 2873  te_lambda_func(s
+00008600: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+00008610: 2243 7265 6174 6520 7468 6520 6c61 6d62  "Create the lamb
+00008620: 6461 2066 756e 6374 696f 6e73 2074 6f20  da functions to 
+00008630: 6265 2075 7365 6420 6279 2074 6865 2075  be used by the u
+00008640: 6e69 666f 726d 206d 6573 6869 6e67 0a20  niform meshing. 
+00008650: 2020 2020 2020 2073 7472 6174 6567 792e         strategy.
+00008660: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00008670: 2020 2020 2065 7870 7273 203d 2073 656c       exprs = sel
+00008680: 662e 6578 7072 2069 6620 6861 7361 7474  f.expr if hasatt
+00008690: 7228 7365 6c66 2e65 7870 722c 2022 5f5f  r(self.expr, "__
+000086a0: 6974 6572 5f5f 2229 2065 6c73 6520 5b73  iter__") else [s
+000086b0: 656c 662e 6578 7072 5d0a 2020 2020 2020  elf.expr].      
+000086c0: 2020 6966 206e 6f74 2061 6e79 2863 616c    if not any(cal
+000086d0: 6c61 626c 6528 6529 2066 6f72 2065 2069  lable(e) for e i
+000086e0: 6e20 6578 7072 7329 3a0a 2020 2020 2020  n exprs):.      
+000086f0: 2020 2020 2020 6673 203d 205f 6765 745f        fs = _get_
+00008700: 6672 6565 5f73 796d 626f 6c73 2865 7870  free_symbols(exp
+00008710: 7273 290a 2020 2020 2020 2020 2020 2020  rs).            
+00008720: 7365 6c66 2e5f 7369 676e 6174 7572 6520  self._signature 
+00008730: 3d20 736f 7274 6564 2866 732c 206b 6579  = sorted(fs, key
+00008740: 3d6c 616d 6264 6120 743a 2074 2e6e 616d  =lambda t: t.nam
+00008750: 6529 0a0a 2020 2020 2020 2020 2020 2020  e)..            
+00008760: 2320 4765 6e65 7261 7465 2061 206c 6973  # Generate a lis
+00008770: 7420 6f66 206c 616d 6264 6120 6675 6e63  t of lambda func
+00008780: 7469 6f6e 732c 2074 776f 2066 6f72 2065  tions, two for e
+00008790: 6163 6820 6578 7072 6573 7369 6f6e 3a0a  ach expression:.
+000087a0: 2020 2020 2020 2020 2020 2020 2320 312e              # 1.
+000087b0: 2074 6865 2064 6566 6175 6c74 206f 6e65   the default one
+000087c0: 2e0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+000087d0: 322e 2074 6865 2062 6163 6b75 7020 6f6e  2. the backup on
+000087e0: 652c 2069 6e20 6361 7365 206f 6620 6661  e, in case of fa
+000087f0: 696c 7572 6573 2077 6974 6820 7468 6520  ilures with the 
+00008800: 6465 6661 756c 7420 6f6e 652e 0a20 2020  default one..   
+00008810: 2020 2020 2020 2020 2073 656c 662e 5f66           self._f
+00008820: 756e 6374 696f 6e73 203d 205b 5d0a 2020  unctions = [].  
+00008830: 2020 2020 2020 2020 2020 666f 7220 6520            for e 
+00008840: 696e 2065 7870 7273 3a0a 2020 2020 2020  in exprs:.      
+00008850: 2020 2020 2020 2020 2020 2320 544f 444f            # TODO
+00008860: 3a20 7365 7420 6373 653d 5472 7565 206f  : set cse=True o
+00008870: 6e63 6520 7468 6973 2069 7373 7565 2069  nce this issue i
+00008880: 7320 736f 6c76 6564 3a0a 2020 2020 2020  s solved:.      
+00008890: 2020 2020 2020 2020 2020 2320 6874 7470            # http
+000088a0: 733a 2f2f 6769 7468 7562 2e63 6f6d 2f73  s://github.com/s
+000088b0: 796d 7079 2f73 796d 7079 2f69 7373 7565  ympy/sympy/issue
+000088c0: 732f 3234 3234 360a 2020 2020 2020 2020  s/24246.        
+000088d0: 2020 2020 2020 2020 7365 6c66 2e5f 6675          self._fu
+000088e0: 6e63 7469 6f6e 732e 6170 7065 6e64 285b  nctions.append([
+000088f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008900: 2020 2020 206c 616d 6264 6966 7928 7365       lambdify(se
+00008910: 6c66 2e5f 7369 676e 6174 7572 652c 2065  lf._signature, e
+00008920: 2c20 6d6f 6475 6c65 733d 7365 6c66 2e6d  , modules=self.m
+00008930: 6f64 756c 6573 292c 0a20 2020 2020 2020  odules),.       
+00008940: 2020 2020 2020 2020 2020 2020 206c 616d               lam
+00008950: 6264 6966 7928 7365 6c66 2e5f 7369 676e  bdify(self._sign
+00008960: 6174 7572 652c 2065 2c20 6d6f 6475 6c65  ature, e, module
+00008970: 733d 2273 796d 7079 222c 2064 756d 6d69  s="sympy", dummi
+00008980: 6679 3d54 7275 6529 2c0a 2020 2020 2020  fy=True),.      
+00008990: 2020 2020 2020 2020 2020 5d29 0a20 2020            ]).   
+000089a0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000089b0: 2020 2020 2020 2073 656c 662e 5f73 6967         self._sig
+000089c0: 6e61 7475 7265 203d 2073 6f72 7465 6428  nature = sorted(
+000089d0: 5b72 5b30 5d20 666f 7220 7220 696e 2073  [r[0] for r in s
+000089e0: 656c 662e 7261 6e67 6573 5d2c 206b 6579  elf.ranges], key
+000089f0: 3d6c 616d 6264 6120 743a 2074 2e6e 616d  =lambda t: t.nam
+00008a00: 6529 0a20 2020 2020 2020 2020 2020 2073  e).            s
+00008a10: 656c 662e 5f66 756e 6374 696f 6e73 203d  elf._functions =
+00008a20: 205b 2865 2c20 4e6f 6e65 2920 666f 7220   [(e, None) for 
+00008a30: 6520 696e 2065 7870 7273 5d0a 0a20 2020  e in exprs]..   
+00008a40: 2020 2020 2023 2064 6561 6c20 7769 7468       # deal with
+00008a50: 2073 796d 626f 6c69 6320 636f 6c6f 725f   symbolic color_
+00008a60: 6675 6e63 0a20 2020 2020 2020 2069 6620  func.        if 
+00008a70: 6973 696e 7374 616e 6365 2873 656c 662e  isinstance(self.
+00008a80: 636f 6c6f 725f 6675 6e63 2c20 4578 7072  color_func, Expr
+00008a90: 293a 0a20 2020 2020 2020 2020 2020 2073  ):.            s
+00008aa0: 656c 662e 636f 6c6f 725f 6675 6e63 203d  elf.color_func =
+00008ab0: 206c 616d 6264 6966 7928 7365 6c66 2e5f   lambdify(self._
+00008ac0: 7369 676e 6174 7572 652c 2073 656c 662e  signature, self.
+00008ad0: 636f 6c6f 725f 6675 6e63 290a 2020 2020  color_func).    
+00008ae0: 2020 2020 2020 2020 7365 6c66 2e5f 6576          self._ev
+00008af0: 616c 5f63 6f6c 6f72 5f66 756e 635f 7769  al_color_func_wi
+00008b00: 7468 5f73 6967 6e61 7475 7265 203d 2054  th_signature = T
+00008b10: 7275 650a 0a20 2020 2064 6566 205f 6372  rue..    def _cr
+00008b20: 6561 7465 5f64 6973 6372 6574 697a 6564  eate_discretized
+00008b30: 5f64 6f6d 6169 6e28 7365 6c66 293a 0a20  _domain(self):. 
+00008b40: 2020 2020 2020 2022 2222 4469 7363 7265         """Discre
+00008b50: 7469 7a65 2074 6865 2072 616e 6765 7320  tize the ranges 
+00008b60: 666f 7220 756e 6966 6f72 6d20 6d65 7368  for uniform mesh
+00008b70: 696e 6720 7374 7261 7465 6779 2e0a 2020  ing strategy..  
+00008b80: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00008b90: 2020 2320 4e4f 5445 3a20 7468 6520 676f    # NOTE: the go
+00008ba0: 616c 2069 7320 746f 2063 7265 6174 6520  al is to create 
+00008bb0: 6120 6469 6374 696f 6e61 7279 2073 746f  a dictionary sto
+00008bc0: 7265 6420 696e 0a20 2020 2020 2020 2023  red in.        #
+00008bd0: 2073 656c 662e 5f64 6973 6372 6574 697a   self._discretiz
+00008be0: 6564 5f64 6f6d 6169 6e2c 206d 6170 7069  ed_domain, mappi
+00008bf0: 6e67 2073 796d 626f 6c73 2074 6f20 6120  ng symbols to a 
+00008c00: 6e75 6d70 7920 6172 7261 790a 2020 2020  numpy array.    
+00008c10: 2020 2020 2320 7265 7072 6573 656e 7469      # representi
+00008c20: 6e67 2074 6865 2064 6973 6372 6574 697a  ng the discretiz
+00008c30: 6174 696f 6e0a 2020 2020 2020 2020 6469  ation.        di
+00008c40: 7363 725f 7379 6d62 6f6c 7320 3d20 5b5d  scr_symbols = []
+00008c50: 0a20 2020 2020 2020 2064 6973 6372 6574  .        discret
+00008c60: 697a 6174 696f 6e73 203d 205b 5d0a 0a20  izations = [].. 
+00008c70: 2020 2020 2020 2023 2063 7265 6174 6520         # create 
+00008c80: 6120 3144 2064 6973 6372 6574 697a 6174  a 1D discretizat
+00008c90: 696f 6e0a 2020 2020 2020 2020 666f 7220  ion.        for 
+00008ca0: 692c 2072 2069 6e20 656e 756d 6572 6174  i, r in enumerat
+00008cb0: 6528 7365 6c66 2e72 616e 6765 7329 3a0a  e(self.ranges):.
+00008cc0: 2020 2020 2020 2020 2020 2020 6469 7363              disc
+00008cd0: 725f 7379 6d62 6f6c 732e 6170 7065 6e64  r_symbols.append
+00008ce0: 2872 5b30 5d29 0a20 2020 2020 2020 2020  (r[0]).         
+00008cf0: 2020 2063 5f73 7461 7274 203d 2073 656c     c_start = sel
+00008d00: 662e 5f75 7064 6174 655f 7261 6e67 655f  f._update_range_
+00008d10: 7661 6c75 6528 725b 315d 290a 2020 2020  value(r[1]).    
+00008d20: 2020 2020 2020 2020 635f 656e 6420 3d20          c_end = 
+00008d30: 7365 6c66 2e5f 7570 6461 7465 5f72 616e  self._update_ran
+00008d40: 6765 5f76 616c 7565 2872 5b32 5d29 0a20  ge_value(r[2]). 
+00008d50: 2020 2020 2020 2020 2020 2073 7461 7274             start
+00008d60: 203d 2063 5f73 7461 7274 2e72 6561 6c20   = c_start.real 
+00008d70: 6966 2063 5f73 7461 7274 2e69 6d61 6720  if c_start.imag 
+00008d80: 3d3d 2063 5f65 6e64 2e69 6d61 6720 3d3d  == c_end.imag ==
+00008d90: 2030 2065 6c73 6520 635f 7374 6172 740a   0 else c_start.
+00008da0: 2020 2020 2020 2020 2020 2020 656e 6420              end 
+00008db0: 3d20 635f 656e 642e 7265 616c 2069 6620  = c_end.real if 
+00008dc0: 635f 7374 6172 742e 696d 6167 203d 3d20  c_start.imag == 
+00008dd0: 635f 656e 642e 696d 6167 203d 3d20 3020  c_end.imag == 0 
+00008de0: 656c 7365 2063 5f65 6e64 0a20 2020 2020  else c_end.     
+00008df0: 2020 2020 2020 206e 6565 6473 5f69 6e74         needs_int
+00008e00: 6567 6572 5f64 6973 6372 203d 2073 656c  eger_discr = sel
+00008e10: 662e 6f6e 6c79 5f69 6e74 6567 6572 7320  f.only_integers 
+00008e20: 6f72 2028 725b 305d 2069 6e20 7365 6c66  or (r[0] in self
+00008e30: 2e5f 6e65 6564 735f 746f 5f62 655f 696e  ._needs_to_be_in
+00008e40: 7429 0a20 2020 2020 2020 2020 2020 2064  t).            d
+00008e50: 203d 2042 6173 6553 6572 6965 732e 5f64   = BaseSeries._d
+00008e60: 6973 6372 6574 697a 6528 0a20 2020 2020  iscretize(.     
+00008e70: 2020 2020 2020 2020 2020 2073 7461 7274             start
+00008e80: 2c20 656e 642c 2073 656c 662e 6e5b 695d  , end, self.n[i]
+00008e90: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00008ea0: 2020 7363 616c 653d 7365 6c66 2e73 6361    scale=self.sca
+00008eb0: 6c65 735b 695d 2c0a 2020 2020 2020 2020  les[i],.        
+00008ec0: 2020 2020 2020 2020 6f6e 6c79 5f69 6e74          only_int
+00008ed0: 6567 6572 733d 6e65 6564 735f 696e 7465  egers=needs_inte
+00008ee0: 6765 725f 6469 7363 720a 2020 2020 2020  ger_discr.      
+00008ef0: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+00008f00: 2020 2020 2069 6620 280a 2020 2020 2020       if (.      
+00008f10: 2020 2020 2020 2020 2020 286e 6f74 2073            (not s
+00008f20: 656c 662e 5f66 6f72 6365 5f72 6561 6c5f  elf._force_real_
+00008f30: 6576 616c 2920 616e 640a 2020 2020 2020  eval) and.      
+00008f40: 2020 2020 2020 2020 2020 286e 6f74 206e            (not n
+00008f50: 6565 6473 5f69 6e74 6567 6572 5f64 6973  eeds_integer_dis
+00008f60: 6372 2920 616e 640a 2020 2020 2020 2020  cr) and.        
+00008f70: 2020 2020 2020 2020 2864 2e64 7479 7065          (d.dtype
+00008f80: 2021 3d20 2263 6f6d 706c 6578 2229 0a20   != "complex"). 
+00008f90: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
+00008fa0: 2020 2020 2020 2020 2020 2020 2020 6420                d 
+00008fb0: 3d20 6420 2b20 316a 202a 2063 5f73 7461  = d + 1j * c_sta
+00008fc0: 7274 2e69 6d61 670a 0a20 2020 2020 2020  rt.imag..       
+00008fd0: 2020 2020 2069 6620 6e65 6564 735f 696e       if needs_in
+00008fe0: 7465 6765 725f 6469 7363 723a 0a20 2020  teger_discr:.   
+00008ff0: 2020 2020 2020 2020 2020 2020 2064 203d               d =
+00009000: 2064 2e61 7374 7970 6528 696e 7429 0a0a   d.astype(int)..
+00009010: 2020 2020 2020 2020 2020 2020 6469 7363              disc
+00009020: 7265 7469 7a61 7469 6f6e 732e 6170 7065  retizations.appe
+00009030: 6e64 2864 290a 0a20 2020 2020 2020 2023  nd(d)..        #
+00009040: 2063 7265 6174 6520 3244 206f 7220 3344   create 2D or 3D
+00009050: 0a20 2020 2020 2020 2073 656c 662e 5f63  .        self._c
+00009060: 7265 6174 655f 6469 7363 7265 7469 7a65  reate_discretize
+00009070: 645f 646f 6d61 696e 5f68 656c 7065 7228  d_domain_helper(
+00009080: 6469 7363 725f 7379 6d62 6f6c 732c 2064  discr_symbols, d
+00009090: 6973 6372 6574 697a 6174 696f 6e73 290a  iscretizations).
+000090a0: 0a20 2020 2064 6566 205f 6372 6561 7465  .    def _create
+000090b0: 5f64 6973 6372 6574 697a 6564 5f64 6f6d  _discretized_dom
+000090c0: 6169 6e5f 6865 6c70 6572 2873 656c 662c  ain_helper(self,
+000090d0: 2064 6973 6372 5f73 796d 626f 6c73 2c20   discr_symbols, 
+000090e0: 6469 7363 7265 7469 7a61 7469 6f6e 7329  discretizations)
+000090f0: 3a0a 2020 2020 2020 2020 2222 2243 7265  :.        """Cre
+00009100: 6174 6520 3244 206f 7220 3344 2064 6973  ate 2D or 3D dis
+00009110: 6372 6574 697a 6564 2067 7269 6473 2e0a  cretized grids..
+00009120: 0a20 2020 2020 2020 2053 7562 636c 6173  .        Subclas
+00009130: 7365 7320 7368 6f75 6c64 206f 7665 7272  ses should overr
+00009140: 6964 6520 7468 6973 206d 6574 686f 6420  ide this method 
+00009150: 696e 206f 7264 6572 2074 6f20 696d 706c  in order to impl
+00009160: 656d 656e 7420 610a 2020 2020 2020 2020  ement a.        
+00009170: 6469 6666 6572 656e 7420 6265 6861 7669  different behavi
+00009180: 6f75 722e 0a20 2020 2020 2020 2022 2222  our..        """
+00009190: 0a20 2020 2020 2020 206e 7020 3d20 696d  .        np = im
+000091a0: 706f 7274 5f6d 6f64 756c 6528 276e 756d  port_module('num
+000091b0: 7079 2729 0a0a 2020 2020 2020 2020 2320  py')..        # 
+000091c0: 6469 7363 7265 7469 7a61 7469 6f6e 2073  discretization s
+000091d0: 7569 7461 626c 6520 666f 7220 3244 206c  uitable for 2D l
+000091e0: 696e 6520 706c 6f74 732c 2033 4420 7375  ine plots, 3D su
+000091f0: 7266 6163 6520 706c 6f74 732c 0a20 2020  rface plots,.   
+00009200: 2020 2020 2023 2063 6f6e 746f 7572 7320       # contours 
+00009210: 706c 6f74 732c 2076 6563 746f 7220 706c  plots, vector pl
+00009220: 6f74 730a 2020 2020 2020 2020 2320 4e4f  ots.        # NO
+00009230: 5445 3a20 7768 7920 696e 6465 7869 6e67  TE: why indexing
+00009240: 3d27 696a 273f 2042 6563 6175 7365 2069  ='ij'? Because i
+00009250: 7420 7072 6f64 7563 6573 2063 6f6e 7369  t produces consi
+00009260: 7374 656e 7420 7265 7375 6c74 7320 7769  stent results wi
+00009270: 7468 0a20 2020 2020 2020 2023 206e 702e  th.        # np.
+00009280: 6d67 7269 642e 2054 6869 7320 6973 2069  mgrid. This is i
+00009290: 6d70 6f72 7461 6e74 2061 7320 4d61 7961  mportant as Maya
+000092a0: 7669 2072 6571 7569 7265 7320 7468 6973  vi requires this
+000092b0: 2069 6e64 6578 696e 670a 2020 2020 2020   indexing.      
+000092c0: 2020 2320 746f 2063 6f72 7265 6374 6c79    # to correctly
+000092d0: 2063 6f6d 7075 7465 2033 4420 7374 7265   compute 3D stre
+000092e0: 616d 6c69 6e65 732e 2056 544b 2069 7320  amlines. VTK is 
+000092f0: 6162 6c65 2074 6f20 636f 6d70 7574 6520  able to compute 
+00009300: 7468 656d 0a20 2020 2020 2020 2023 206e  them.        # n
+00009310: 6f6e 6574 6865 6c65 7373 2c20 6275 7420  onetheless, but 
+00009320: 6974 2070 726f 6475 6365 7320 2273 7472  it produces "str
+00009330: 616e 6765 2220 7265 7375 6c74 7320 7769  ange" results wi
+00009340: 7468 2022 766f 6964 7322 2069 6e74 6f20  th "voids" into 
+00009350: 7468 650a 2020 2020 2020 2020 2320 6469  the.        # di
+00009360: 7363 7265 7469 7a61 7469 6f6e 2076 6f6c  scretization vol
+00009370: 756d 652e 2054 6869 7320 696e 6465 7869  ume. This indexi
+00009380: 6e67 2073 6f6c 7665 7320 7468 6520 7072  ng solves the pr
+00009390: 6f62 6c65 6d2e 0a20 2020 2020 2020 2023  oblem..        #
+000093a0: 2041 6c73 6f20 6e6f 7465 2074 6861 7420   Also note that 
+000093b0: 6d61 7470 6c6f 746c 6962 2032 4420 7374  matplotlib 2D st
+000093c0: 7265 616d 6c69 6e65 7320 7265 7175 6972  reamlines requir
+000093d0: 6573 2069 6e64 6578 696e 673d 2778 7927  es indexing='xy'
+000093e0: 2e0a 2020 2020 2020 2020 696e 6465 7869  ..        indexi
+000093f0: 6e67 203d 2022 7879 220a 2020 2020 2020  ng = "xy".      
+00009400: 2020 6966 2073 656c 662e 6973 5f33 4476    if self.is_3Dv
+00009410: 6563 746f 7220 6f72 2028 7365 6c66 2e69  ector or (self.i
+00009420: 735f 3344 7375 7266 6163 6520 616e 6420  s_3Dsurface and 
+00009430: 7365 6c66 2e69 735f 696d 706c 6963 6974  self.is_implicit
+00009440: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
+00009450: 6e64 6578 696e 6720 3d20 2269 6a22 0a20  ndexing = "ij". 
+00009460: 2020 2020 2020 206d 6573 6865 7320 3d20         meshes = 
+00009470: 6e70 2e6d 6573 6867 7269 6428 2a64 6973  np.meshgrid(*dis
+00009480: 6372 6574 697a 6174 696f 6e73 2c20 696e  cretizations, in
+00009490: 6465 7869 6e67 3d69 6e64 6578 696e 6729  dexing=indexing)
+000094a0: 0a20 2020 2020 2020 2073 656c 662e 5f64  .        self._d
+000094b0: 6973 6372 6574 697a 6564 5f64 6f6d 6169  iscretized_domai
+000094c0: 6e20 3d20 7b0a 2020 2020 2020 2020 2020  n = {.          
+000094d0: 2020 6b3a 2076 2066 6f72 206b 2c20 7620    k: v for k, v 
+000094e0: 696e 207a 6970 2864 6973 6372 5f73 796d  in zip(discr_sym
+000094f0: 626f 6c73 2c20 6d65 7368 6573 297d 0a0a  bols, meshes)}..
+00009500: 2020 2020 6465 6620 5f65 7661 6c75 6174      def _evaluat
+00009510: 6528 7365 6c66 2c20 6361 7374 5f74 6f5f  e(self, cast_to_
+00009520: 7265 616c 3d54 7275 6529 3a0a 2020 2020  real=True):.    
+00009530: 2020 2020 2222 2245 7661 6c75 6174 696f      """Evaluatio
+00009540: 6e20 6f66 2074 6865 2073 796d 626f 6c69  n of the symboli
+00009550: 6320 6578 7072 6573 7369 6f6e 2028 6f72  c expression (or
+00009560: 2065 7870 7265 7373 696f 6e73 2920 7769   expressions) wi
+00009570: 7468 2074 6865 0a20 2020 2020 2020 2075  th the.        u
+00009580: 6e69 666f 726d 206d 6573 6869 6e67 2073  niform meshing s
+00009590: 7472 6174 6567 792c 2062 6173 6564 206f  trategy, based o
+000095a0: 6e20 6375 7272 656e 7420 7661 6c75 6573  n current values
+000095b0: 206f 6620 7468 6520 7061 7261 6d65 7465   of the paramete
+000095c0: 7273 2e0a 2020 2020 2020 2020 2222 220a  rs..        """.
+000095d0: 2020 2020 2020 2020 6e70 203d 2069 6d70          np = imp
+000095e0: 6f72 745f 6d6f 6475 6c65 2827 6e75 6d70  ort_module('nump
+000095f0: 7927 290a 0a20 2020 2020 2020 2023 2063  y')..        # c
+00009600: 7265 6174 6520 6c61 6d62 6461 2066 756e  reate lambda fun
+00009610: 6374 696f 6e73 0a20 2020 2020 2020 2069  ctions.        i
+00009620: 6620 6e6f 7420 7365 6c66 2e5f 6675 6e63  f not self._func
+00009630: 7469 6f6e 733a 0a20 2020 2020 2020 2020  tions:.         
+00009640: 2020 2073 656c 662e 5f63 7265 6174 655f     self._create_
+00009650: 6c61 6d62 6461 5f66 756e 6328 290a 2020  lambda_func().  
+00009660: 2020 2020 2020 2320 6372 6561 7465 2028        # create (
+00009670: 6f72 2075 7064 6174 6529 2074 6865 2064  or update) the d
+00009680: 6973 6372 6574 697a 6564 2064 6f6d 6169  iscretized domai
+00009690: 6e0a 2020 2020 2020 2020 6966 2028 6e6f  n.        if (no
+000096a0: 7420 7365 6c66 2e5f 6469 7363 7265 7469  t self._discreti
+000096b0: 7a65 645f 646f 6d61 696e 2920 6f72 2073  zed_domain) or s
+000096c0: 656c 662e 5f69 6e74 6572 6163 7469 7665  elf._interactive
+000096d0: 5f72 616e 6765 733a 0a20 2020 2020 2020  _ranges:.       
+000096e0: 2020 2020 2073 656c 662e 5f63 7265 6174       self._creat
+000096f0: 655f 6469 7363 7265 7469 7a65 645f 646f  e_discretized_do
+00009700: 6d61 696e 2829 0a20 2020 2020 2020 2023  main().        #
+00009710: 2065 6e73 7572 6520 7468 6174 2064 6973   ensure that dis
+00009720: 6372 6574 697a 6564 2064 6f6d 6169 6e73  cretized domains
+00009730: 2061 7265 2072 6574 7572 6e65 6420 7769   are returned wi
+00009740: 7468 2074 6865 2070 726f 7065 7220 6f72  th the proper or
+00009750: 6465 720a 2020 2020 2020 2020 6469 7363  der.        disc
+00009760: 7220 3d20 5b73 656c 662e 5f64 6973 6372  r = [self._discr
+00009770: 6574 697a 6564 5f64 6f6d 6169 6e5b 735b  etized_domain[s[
+00009780: 305d 5d20 666f 7220 7320 696e 2073 656c  0]] for s in sel
+00009790: 662e 7261 6e67 6573 5d0a 0a20 2020 2020  f.ranges]..     
+000097a0: 2020 2061 7267 7320 3d20 7365 6c66 2e5f     args = self._
+000097b0: 6167 6772 6567 6174 655f 6172 6773 2829  aggregate_args()
+000097c0: 0a0a 2020 2020 2020 2020 7265 7375 6c74  ..        result
+000097d0: 7320 3d20 5b5d 0a20 2020 2020 2020 2066  s = [].        f
+000097e0: 6f72 2066 2069 6e20 7365 6c66 2e5f 6675  or f in self._fu
+000097f0: 6e63 7469 6f6e 733a 0a20 2020 2020 2020  nctions:.       
+00009800: 2020 2020 2072 203d 205f 756e 6966 6f72       r = _unifor
+00009810: 6d5f 6576 616c 282a 662c 202a 6172 6773  m_eval(*f, *args
+00009820: 2c20 6d6f 6475 6c65 733d 7365 6c66 2e6d  , modules=self.m
+00009830: 6f64 756c 6573 290a 2020 2020 2020 2020  odules).        
+00009840: 2020 2020 2320 7468 6520 6576 616c 7561      # the evalua
+00009850: 7469 6f6e 206d 6967 6874 2070 726f 6475  tion might produ
+00009860: 6365 2061 6e20 696e 742f 666c 6f61 742e  ce an int/float.
+00009870: 204e 6565 6420 7468 6973 2063 6f72 7265   Need this corre
+00009880: 6374 696f 6e2e 0a20 2020 2020 2020 2020  ction..         
+00009890: 2020 2072 203d 2073 656c 662e 5f63 6f72     r = self._cor
+000098a0: 7265 6374 5f73 6861 7065 286e 702e 6172  rect_shape(np.ar
+000098b0: 7261 7928 7229 2c20 6469 7363 725b 305d  ray(r), discr[0]
+000098c0: 290a 2020 2020 2020 2020 2020 2020 2320  ).            # 
+000098d0: 736f 6d65 7469 6d65 2074 6865 2065 7661  sometime the eva
+000098e0: 6c75 6174 696f 6e20 6973 2070 6572 666f  luation is perfo
+000098f0: 726d 6564 206f 7665 7220 6172 7261 7973  rmed over arrays
+00009900: 206f 6620 7479 7065 206f 626a 6563 742e   of type object.
+00009910: 0a20 2020 2020 2020 2020 2020 2023 2068  .            # h
+00009920: 656e 6365 2c20 6072 6573 756c 7460 206d  ence, `result` m
+00009930: 6967 6874 2062 6520 6f66 2074 7970 6520  ight be of type 
+00009940: 6f62 6a65 6374 2c20 7768 6963 6820 646f  object, which do
+00009950: 6e27 7420 776f 726b 2077 656c 6c0a 2020  n't work well.  
+00009960: 2020 2020 2020 2020 2020 2320 7769 7468            # with
+00009970: 206e 756d 7079 2072 6561 6c20 616e 6420   numpy real and 
+00009980: 696d 6167 2066 756e 6374 696f 6e73 2e0a  imag functions..
+00009990: 2020 2020 2020 2020 2020 2020 7220 3d20              r = 
+000099a0: 722e 6173 7479 7065 2863 6f6d 706c 6578  r.astype(complex
+000099b0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+000099c0: 7375 6c74 732e 6170 7065 6e64 2872 290a  sults.append(r).
+000099d0: 0a20 2020 2020 2020 2069 6620 6361 7374  .        if cast
+000099e0: 5f74 6f5f 7265 616c 3a0a 2020 2020 2020  _to_real:.      
+000099f0: 2020 2020 2020 6469 7363 7220 3d20 5b6e        discr = [n
+00009a00: 702e 7265 616c 2864 2e61 7374 7970 6528  p.real(d.astype(
+00009a10: 636f 6d70 6c65 7829 2920 666f 7220 6420  complex)) for d 
+00009a20: 696e 2064 6973 6372 5d0a 2020 2020 2020  in discr].      
+00009a30: 2020 7265 7475 726e 205b 2a64 6973 6372    return [*discr
+00009a40: 2c20 2a72 6573 756c 7473 5d0a 0a20 2020  , *results]..   
+00009a50: 2064 6566 205f 6167 6772 6567 6174 655f   def _aggregate_
+00009a60: 6172 6773 2873 656c 6629 3a0a 2020 2020  args(self):.    
+00009a70: 2020 2020 6172 6773 203d 205b 5d0a 2020      args = [].  
+00009a80: 2020 2020 2020 666f 7220 7320 696e 2073        for s in s
+00009a90: 656c 662e 5f73 6967 6e61 7475 7265 3a0a  elf._signature:.
+00009aa0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+00009ab0: 2069 6e20 7365 6c66 2e5f 7061 7261 6d73   in self._params
+00009ac0: 2e6b 6579 7328 293a 0a20 2020 2020 2020  .keys():.       
+00009ad0: 2020 2020 2020 2020 2061 7267 732e 6170           args.ap
+00009ae0: 7065 6e64 280a 2020 2020 2020 2020 2020  pend(.          
+00009af0: 2020 2020 2020 2020 2020 696e 7428 7365            int(se
+00009b00: 6c66 2e5f 7061 7261 6d73 5b73 5d29 2069  lf._params[s]) i
+00009b10: 6620 7320 696e 2073 656c 662e 5f6e 6565  f s in self._nee
+00009b20: 6473 5f74 6f5f 6265 5f69 6e74 2065 6c73  ds_to_be_int els
+00009b30: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00009b40: 2020 2020 2020 7365 6c66 2e5f 7061 7261        self._para
+00009b50: 6d73 5b73 5d20 6966 2073 656c 662e 5f66  ms[s] if self._f
+00009b60: 6f72 6365 5f72 6561 6c5f 6576 616c 0a20  orce_real_eval. 
+00009b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b80: 2020 2065 6c73 6520 636f 6d70 6c65 7828     else complex(
+00009b90: 7365 6c66 2e5f 7061 7261 6d73 5b73 5d29  self._params[s])
+00009ba0: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
+00009bb0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00009bc0: 2020 2020 6172 6773 2e61 7070 656e 6428      args.append(
+00009bd0: 7365 6c66 2e5f 6469 7363 7265 7469 7a65  self._discretize
+00009be0: 645f 646f 6d61 696e 5b73 5d29 0a20 2020  d_domain[s]).   
+00009bf0: 2020 2020 2072 6574 7572 6e20 6172 6773       return args
+00009c00: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00009c10: 2020 2020 6465 6620 6578 7072 2873 656c      def expr(sel
+00009c20: 6629 3a0a 2020 2020 2020 2020 2222 2252  f):.        """R
+00009c30: 6574 7572 6e20 7468 6520 6578 7072 6573  eturn the expres
+00009c40: 7369 6f6e 2028 6f72 2065 7870 7265 7373  sion (or express
+00009c50: 696f 6e73 2920 6f66 2074 6865 2073 6572  ions) of the ser
+00009c60: 6965 732e 2222 220a 2020 2020 2020 2020  ies.""".        
+00009c70: 7265 7475 726e 2073 656c 662e 5f65 7870  return self._exp
+00009c80: 720a 0a20 2020 2040 6578 7072 2e73 6574  r..    @expr.set
+00009c90: 7465 720a 2020 2020 6465 6620 6578 7072  ter.    def expr
+00009ca0: 2873 656c 662c 2065 293a 0a20 2020 2020  (self, e):.     
+00009cb0: 2020 2022 2222 5365 7420 7468 6520 6578     """Set the ex
+00009cc0: 7072 6573 7369 6f6e 2028 6f72 2065 7870  pression (or exp
+00009cd0: 7265 7373 696f 6e73 2920 6f66 2074 6865  ressions) of the
+00009ce0: 2073 6572 6965 732e 2222 220a 2020 2020   series.""".    
+00009cf0: 2020 2020 6973 5f69 7465 7220 3d20 6861      is_iter = ha
+00009d00: 7361 7474 7228 652c 2022 5f5f 6974 6572  sattr(e, "__iter
+00009d10: 5f5f 2229 0a20 2020 2020 2020 2069 735f  __").        is_
+00009d20: 6361 6c6c 6162 6c65 203d 2063 616c 6c61  callable = calla
+00009d30: 626c 6528 6529 2069 6620 6e6f 7420 6973  ble(e) if not is
+00009d40: 5f69 7465 7220 656c 7365 2061 6e79 2863  _iter else any(c
+00009d50: 616c 6c61 626c 6528 7429 2066 6f72 2074  allable(t) for t
+00009d60: 2069 6e20 6529 0a20 2020 2020 2020 2069   in e).        i
+00009d70: 6620 6973 5f63 616c 6c61 626c 653a 0a20  f is_callable:. 
+00009d80: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00009d90: 5f65 7870 7220 3d20 650a 2020 2020 2020  _expr = e.      
+00009da0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00009db0: 2020 2020 7365 6c66 2e5f 6578 7072 203d      self._expr =
+00009dc0: 2073 796d 7069 6679 2865 2920 6966 206e   sympify(e) if n
+00009dd0: 6f74 2069 735f 6974 6572 2065 6c73 6520  ot is_iter else 
+00009de0: 5475 706c 6528 2a65 290a 2020 2020 2020  Tuple(*e).      
+00009df0: 2020 2020 2020 7320 3d20 7365 7428 290a        s = set().
+00009e00: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00009e10: 6520 696e 2073 656c 662e 5f65 7870 722e  e in self._expr.
+00009e20: 6174 6f6d 7328 5375 6d2c 2050 726f 6475  atoms(Sum, Produ
+00009e30: 6374 293a 0a20 2020 2020 2020 2020 2020  ct):.           
+00009e40: 2020 2020 2066 6f72 2061 2069 6e20 652e       for a in e.
+00009e50: 6172 6773 5b31 3a5d 3a0a 2020 2020 2020  args[1:]:.      
+00009e60: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00009e70: 2069 7369 6e73 7461 6e63 6528 615b 2d31   isinstance(a[-1
+00009e80: 5d2c 2053 796d 626f 6c29 3a0a 2020 2020  ], Symbol):.    
+00009e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ea0: 2020 2020 732e 6164 6428 615b 2d31 5d29      s.add(a[-1])
+00009eb0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00009ec0: 662e 5f6e 6565 6473 5f74 6f5f 6265 5f69  f._needs_to_be_i
+00009ed0: 6e74 203d 206c 6973 7428 7329 0a0a 2020  nt = list(s)..  
+00009ee0: 2020 2020 2020 2020 2020 2320 6c69 7374            # list
+00009ef0: 206f 6620 7379 6d70 7920 6675 6e63 7469   of sympy functi
+00009f00: 6f6e 7320 7468 6174 2077 6865 6e20 6c61  ons that when la
+00009f10: 6d62 6469 6669 6564 2c20 7468 6520 636f  mbdified, the co
+00009f20: 7272 6573 706f 6e64 696e 670a 2020 2020  rresponding.    
+00009f30: 2020 2020 2020 2020 2320 6e75 6d70 7920          # numpy 
+00009f40: 6675 6e63 7469 6f6e 7320 646f 6e27 7420  functions don't 
+00009f50: 6c69 6b65 2063 6f6d 706c 6578 2d74 7970  like complex-typ
+00009f60: 6520 6172 6775 6d65 6e74 730a 2020 2020  e arguments.    
+00009f70: 2020 2020 2020 2020 7066 203d 205b 6365          pf = [ce
+00009f80: 696c 696e 672c 2066 6c6f 6f72 2c20 6174  iling, floor, at
+00009f90: 616e 322c 2066 7261 632c 207a 6574 612c  an2, frac, zeta,
+00009fa0: 2049 6e74 6567 7261 6c2c 2068 7970 6572   Integral, hyper
+00009fb0: 5d0a 2020 2020 2020 2020 2020 2020 6966  ].            if
+00009fc0: 2073 656c 662e 5f66 6f72 6365 5f72 6561   self._force_rea
+00009fd0: 6c5f 6576 616c 2069 7320 6e6f 7420 5472  l_eval is not Tr
+00009fe0: 7565 3a0a 2020 2020 2020 2020 2020 2020  ue:.            
+00009ff0: 2020 2020 6368 6563 6b5f 7265 7320 3d20      check_res = 
+0000a000: 5b73 656c 662e 5f65 7870 722e 6861 7328  [self._expr.has(
+0000a010: 6629 2066 6f72 2066 2069 6e20 7066 5d0a  f) for f in pf].
+0000a020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a030: 7365 6c66 2e5f 666f 7263 655f 7265 616c  self._force_real
+0000a040: 5f65 7661 6c20 3d20 616e 7928 6368 6563  _eval = any(chec
+0000a050: 6b5f 7265 7329 0a20 2020 2020 2020 2020  k_res).         
+0000a060: 2020 2020 2020 2069 6620 7365 6c66 2e5f         if self._
+0000a070: 666f 7263 655f 7265 616c 5f65 7661 6c20  force_real_eval 
+0000a080: 616e 6420 280a 2020 2020 2020 2020 2020  and (.          
+0000a090: 2020 2020 2020 2020 2020 2873 656c 662e            (self.
+0000a0a0: 6d6f 6475 6c65 7320 6973 204e 6f6e 6529  modules is None)
+0000a0b0: 206f 720a 2020 2020 2020 2020 2020 2020   or.            
+0000a0c0: 2020 2020 2020 2020 2869 7369 6e73 7461          (isinsta
+0000a0d0: 6e63 6528 7365 6c66 2e6d 6f64 756c 6573  nce(self.modules
+0000a0e0: 2c20 7374 7229 2061 6e64 2022 6e75 6d70  , str) and "nump
+0000a0f0: 7922 2069 6e20 7365 6c66 2e6d 6f64 756c  y" in self.modul
+0000a100: 6573 290a 2020 2020 2020 2020 2020 2020  es).            
+0000a110: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
+0000a120: 2020 2020 2020 2020 2020 2066 756e 6373             funcs
+0000a130: 203d 205b 6620 666f 7220 662c 2063 2069   = [f for f, c i
+0000a140: 6e20 7a69 7028 7066 2c20 6368 6563 6b5f  n zip(pf, check_
+0000a150: 7265 7329 2069 6620 635d 0a20 2020 2020  res) if c].     
+0000a160: 2020 2020 2020 2020 2020 2020 2020 2077                 w
+0000a170: 6172 6e69 6e67 732e 7761 726e 280a 2020  arnings.warn(.  
+0000a180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a190: 2020 2020 2020 224e 756d 5079 2069 7320        "NumPy is 
+0000a1a0: 756e 6162 6c65 2074 6f20 6576 616c 7561  unable to evalua
+0000a1b0: 7465 2077 6974 6820 636f 6d70 6c65 7820  te with complex 
+0000a1c0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0000a1d0: 2020 2020 2020 2020 2020 226e 756d 6265            "numbe
+0000a1e0: 7273 2073 6f6d 6520 6f66 2074 6865 2066  rs some of the f
+0000a1f0: 756e 6374 696f 6e73 2069 6e63 6c75 6465  unctions include
+0000a200: 6420 696e 2074 6869 7320 220a 2020 2020  d in this ".    
+0000a210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a220: 2020 2020 2273 796d 626f 6c69 6320 6578      "symbolic ex
+0000a230: 7072 6573 7369 6f6e 3a20 2573 2e20 2220  pression: %s. " 
+0000a240: 2520 6675 6e63 7320 2b0a 2020 2020 2020  % funcs +.      
+0000a250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a260: 2020 2248 656e 6365 2c20 7468 6520 6576    "Hence, the ev
+0000a270: 616c 7561 7469 6f6e 2077 696c 6c20 7573  aluation will us
+0000a280: 6520 7265 616c 206e 756d 6265 7273 2e20  e real numbers. 
+0000a290: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0000a2a0: 2020 2020 2020 2020 2020 2249 6620 796f            "If yo
+0000a2b0: 7520 6265 6c69 6576 6520 7468 6520 7265  u believe the re
+0000a2c0: 7375 6c74 696e 6720 706c 6f74 2069 7320  sulting plot is 
+0000a2d0: 696e 636f 7272 6563 742c 2022 0a20 2020  incorrect, ".   
+0000a2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a2f0: 2020 2020 2022 6368 616e 6765 2074 6865       "change the
+0000a300: 2065 7661 6c75 6174 696f 6e20 6d6f 6475   evaluation modu
+0000a310: 6c65 2062 7920 7365 7474 696e 6720 7468  le by setting th
+0000a320: 6520 220a 2020 2020 2020 2020 2020 2020  e ".            
+0000a330: 2020 2020 2020 2020 2020 2020 2260 6d6f              "`mo
+0000a340: 6475 6c65 7360 206b 6579 776f 7264 2061  dules` keyword a
+0000a350: 7267 756d 656e 742e 2229 0a20 2020 2020  rgument.").     
+0000a360: 2020 2020 2020 2069 6620 7365 6c66 2e5f         if self._
+0000a370: 6675 6e63 7469 6f6e 733a 0a20 2020 2020  functions:.     
+0000a380: 2020 2020 2020 2020 2020 2023 2075 7064             # upd
+0000a390: 6174 6520 6c61 6d62 6461 2066 756e 6374  ate lambda funct
+0000a3a0: 696f 6e73 0a20 2020 2020 2020 2020 2020  ions.           
+0000a3b0: 2020 2020 2073 656c 662e 5f63 7265 6174       self._creat
+0000a3c0: 655f 6c61 6d62 6461 5f66 756e 6328 290a  e_lambda_func().
+0000a3d0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+0000a3e0: 2020 2064 6566 206e 2873 656c 6629 3a0a     def n(self):.
+0000a3f0: 2020 2020 2020 2020 2222 2252 6574 7572          """Retur
+0000a400: 6e73 2061 206c 6973 7420 5b6e 312c 206e  ns a list [n1, n
+0000a410: 322c 206e 335d 206f 6620 6e75 6d62 6572  2, n3] of number
+0000a420: 7320 6f66 2064 6973 6372 6174 697a 6174  s of discratizat
+0000a430: 696f 6e20 706f 696e 7473 2e0a 2020 2020  ion points..    
+0000a440: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0000a450: 7265 7475 726e 2073 656c 662e 5f6e 0a0a  return self._n..
+0000a460: 2020 2020 406e 2e73 6574 7465 720a 2020      @n.setter.  
+0000a470: 2020 6465 6620 6e28 7365 6c66 2c20 7629    def n(self, v)
+0000a480: 3a0a 2020 2020 2020 2020 7375 7065 7228  :.        super(
+0000a490: 292e 6e20 3d20 760a 2020 2020 2020 2020  ).n = v.        
+0000a4a0: 6966 2073 656c 662e 5f64 6973 6372 6574  if self._discret
+0000a4b0: 697a 6564 5f64 6f6d 6169 6e3a 0a20 2020  ized_domain:.   
+0000a4c0: 2020 2020 2020 2020 2023 2075 7064 6174           # updat
+0000a4d0: 6520 7468 6520 6469 7363 7265 7469 7a65  e the discretize
+0000a4e0: 6420 646f 6d61 696e 0a20 2020 2020 2020  d domain.       
+0000a4f0: 2020 2020 2073 656c 662e 5f63 7265 6174       self._creat
+0000a500: 655f 6469 7363 7265 7469 7a65 645f 646f  e_discretized_do
+0000a510: 6d61 696e 2829 0a0a 2020 2020 6465 6620  main()..    def 
+0000a520: 5f70 6f73 745f 696e 6974 2873 656c 6629  _post_init(self)
+0000a530: 3a0a 2020 2020 2020 2020 6578 7072 7320  :.        exprs 
+0000a540: 3d20 7365 6c66 2e65 7870 7220 6966 2068  = self.expr if h
+0000a550: 6173 6174 7472 2873 656c 662e 6578 7072  asattr(self.expr
+0000a560: 2c20 225f 5f69 7465 725f 5f22 2920 656c  , "__iter__") el
+0000a570: 7365 205b 7365 6c66 2e65 7870 725d 0a20  se [self.expr]. 
+0000a580: 2020 2020 2020 2069 6620 616e 7928 6361         if any(ca
+0000a590: 6c6c 6162 6c65 2865 2920 666f 7220 6520  llable(e) for e 
+0000a5a0: 696e 2065 7870 7273 2920 616e 6420 7365  in exprs) and se
+0000a5b0: 6c66 2e70 6172 616d 733a 0a20 2020 2020  lf.params:.     
+0000a5c0: 2020 2020 2020 2072 6169 7365 2054 7970         raise Typ
+0000a5d0: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
+0000a5e0: 2020 2020 2020 2020 2260 7061 7261 6d73          "`params
+0000a5f0: 6020 7761 7320 7072 6f76 6964 6564 2c20  ` was provided, 
+0000a600: 6865 6e63 6520 616e 2069 6e74 6572 6163  hence an interac
+0000a610: 7469 7665 2070 6c6f 7420 220a 2020 2020  tive plot ".    
+0000a620: 2020 2020 2020 2020 2020 2020 2269 7320              "is 
+0000a630: 6578 7065 6374 6564 2e20 486f 7765 7665  expected. Howeve
+0000a640: 722c 2069 6e74 6572 6163 7469 7665 2070  r, interactive p
+0000a650: 6c6f 7473 2064 6f20 6e6f 7420 7375 7070  lots do not supp
+0000a660: 6f72 7420 220a 2020 2020 2020 2020 2020  ort ".          
+0000a670: 2020 2020 2020 2275 7365 722d 7072 6f76        "user-prov
+0000a680: 6964 6564 206e 756d 6572 6963 616c 2066  ided numerical f
+0000a690: 756e 6374 696f 6e73 2e22 290a 0a20 2020  unctions.")..   
+0000a6a0: 2020 2020 2023 2069 6620 7468 6520 6578       # if the ex
+0000a6b0: 7072 6573 7369 6f6e 7320 6973 2061 206c  pressions is a l
+0000a6c0: 616d 6264 6120 6675 6e63 7469 6f6e 2061  ambda function a
+0000a6d0: 6e64 206e 6f20 6c61 6265 6c20 6861 7320  nd no label has 
+0000a6e0: 6265 656e 0a20 2020 2020 2020 2023 2070  been.        # p
+0000a6f0: 726f 7669 6465 642c 2074 6865 6e20 6974  rovided, then it
+0000a700: 7320 6265 7474 6572 2074 6f20 646f 2074  s better to do t
+0000a710: 6865 2066 6f6c 6c6f 7769 6e67 2069 6e20  he following in 
+0000a720: 6f72 6465 7220 746f 2061 766f 6964 0a20  order to avoid. 
+0000a730: 2020 2020 2020 2023 2073 7570 7269 7365         # suprise
+0000a740: 7320 6f6e 2074 6865 2062 6163 6b65 6e64  s on the backend
+0000a750: 0a20 2020 2020 2020 2069 6620 616e 7928  .        if any(
+0000a760: 6361 6c6c 6162 6c65 2865 2920 666f 7220  callable(e) for 
+0000a770: 6520 696e 2065 7870 7273 293a 0a20 2020  e in exprs):.   
+0000a780: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+0000a790: 2e5f 6c61 6265 6c20 3d3d 2073 7472 2873  ._label == str(s
+0000a7a0: 656c 662e 6578 7072 293a 0a20 2020 2020  elf.expr):.     
+0000a7b0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000a7c0: 6c61 6265 6c20 3d20 2222 0a0a 2020 2020  label = ""..    
+0000a7d0: 2020 2020 7365 6c66 2e5f 6368 6563 6b5f      self._check_
+0000a7e0: 6673 2829 0a0a 2020 2020 2020 2020 6966  fs()..        if
+0000a7f0: 2068 6173 6174 7472 2873 656c 662c 2022   hasattr(self, "
+0000a800: 6164 6170 7469 7665 2229 2061 6e64 2073  adaptive") and s
+0000a810: 656c 662e 6164 6170 7469 7665 2061 6e64  elf.adaptive and
+0000a820: 2073 656c 662e 7061 7261 6d73 3a0a 2020   self.params:.  
+0000a830: 2020 2020 2020 2020 2020 7761 726e 696e            warnin
+0000a840: 6773 2e77 6172 6e28 0a20 2020 2020 2020  gs.warn(.       
+0000a850: 2020 2020 2020 2020 2022 6070 6172 616d           "`param
+0000a860: 7360 2077 6173 2070 726f 7669 6465 642c  s` was provided,
+0000a870: 2068 656e 6365 2061 6e20 696e 7465 7261   hence an intera
+0000a880: 6374 6976 6520 706c 6f74 2022 0a20 2020  ctive plot ".   
+0000a890: 2020 2020 2020 2020 2020 2020 2022 6973               "is
+0000a8a0: 2065 7870 6563 7465 642e 2048 6f77 6576   expected. Howev
+0000a8b0: 6572 2c20 696e 7465 7261 6374 6976 6520  er, interactive 
+0000a8c0: 706c 6f74 7320 646f 206e 6f74 2073 7570  plots do not sup
+0000a8d0: 706f 7274 2022 0a20 2020 2020 2020 2020  port ".         
+0000a8e0: 2020 2020 2020 2022 6164 6170 7469 7665         "adaptive
+0000a8f0: 2065 7661 6c75 6174 696f 6e2e 2041 7574   evaluation. Aut
+0000a900: 6f6d 6174 6963 616c 6c79 2073 7769 7463  omatically switc
+0000a910: 6865 6420 746f 2022 0a20 2020 2020 2020  hed to ".       
+0000a920: 2020 2020 2020 2020 2022 6164 6170 7469           "adapti
+0000a930: 7665 3d46 616c 7365 2e22 290a 2020 2020  ve=False.").    
+0000a940: 2020 2020 2020 2020 7365 6c66 2e61 6461          self.ada
+0000a950: 7074 6976 6520 3d20 4661 6c73 650a 0a0a  ptive = False...
+0000a960: 6465 6620 5f64 6574 6563 745f 706f 6c65  def _detect_pole
+0000a970: 735f 6e75 6d65 7269 6361 6c5f 6865 6c70  s_numerical_help
+0000a980: 6572 280a 2020 2020 782c 2079 2c20 6570  er(.    x, y, ep
+0000a990: 733d 302e 3031 2c20 6578 7072 3d4e 6f6e  s=0.01, expr=Non
+0000a9a0: 652c 2073 796d 623d 4e6f 6e65 2c20 7379  e, symb=None, sy
+0000a9b0: 6d62 6f6c 6963 3d46 616c 7365 0a29 3a0a  mbolic=False.):.
+0000a9c0: 2020 2020 2222 2243 6f6d 7075 7465 2074      """Compute t
+0000a9d0: 6865 2073 7465 6570 6e65 7373 206f 6620  he steepness of 
+0000a9e0: 6561 6368 2073 6567 6d65 6e74 2e20 4966  each segment. If
+0000a9f0: 2069 7427 7320 6772 6561 7465 7220 7468   it's greater th
+0000aa00: 616e 2061 0a20 2020 2074 6872 6573 686f  an a.    thresho
+0000aa10: 6c64 2c20 7365 7420 7468 6520 7269 6768  ld, set the righ
+0000aa20: 742d 706f 696e 7420 792d 7661 6c75 6520  t-point y-value 
+0000aa30: 6e6f 6e20 4e61 4e20 616e 6420 7265 636f  non NaN and reco
+0000aa40: 7264 2074 6865 0a20 2020 2063 6f72 7265  rd the.    corre
+0000aa50: 7370 6f6e 6469 6e67 2078 2d6c 6f63 6174  sponding x-locat
+0000aa60: 696f 6e20 666f 7220 6675 7274 6865 7220  ion for further 
+0000aa70: 7072 6f63 6573 7369 6e67 2e0a 0a20 2020  processing...   
+0000aa80: 2052 6574 7572 6e73 0a20 2020 203d 3d3d   Returns.    ===
+0000aa90: 3d3d 3d3d 0a20 2020 2078 203a 206e 702e  ====.    x : np.
+0000aaa0: 6e64 6172 7261 790a 2020 2020 2020 2020  ndarray.        
+0000aab0: 556e 6368 616e 6765 6420 782d 6461 7461  Unchanged x-data
+0000aac0: 2e0a 2020 2020 7979 203a 206e 702e 6e64  ..    yy : np.nd
+0000aad0: 6172 7261 790a 2020 2020 2020 2020 4d6f  array.        Mo
+0000aae0: 6469 6669 6564 2079 2d64 6174 6120 7769  dified y-data wi
+0000aaf0: 7468 204e 614e 2076 616c 7565 732e 0a20  th NaN values.. 
+0000ab00: 2020 2022 2222 0a20 2020 206e 7020 3d20     """.    np = 
+0000ab10: 696d 706f 7274 5f6d 6f64 756c 6528 276e  import_module('n
+0000ab20: 756d 7079 2729 0a0a 2020 2020 7979 203d  umpy')..    yy =
+0000ab30: 2079 2e63 6f70 7928 290a 2020 2020 7468   y.copy().    th
+0000ab40: 7265 7368 6f6c 6420 3d20 6e70 2e70 6920  reshold = np.pi 
+0000ab50: 2f20 3220 2d20 6570 730a 2020 2020 666f  / 2 - eps.    fo
+0000ab60: 7220 6920 696e 2072 616e 6765 286c 656e  r i in range(len
+0000ab70: 2878 2920 2d20 3129 3a0a 2020 2020 2020  (x) - 1):.      
+0000ab80: 2020 6478 203d 2078 5b69 202b 2031 5d20    dx = x[i + 1] 
+0000ab90: 2d20 785b 695d 0a20 2020 2020 2020 2064  - x[i].        d
+0000aba0: 7920 3d20 6162 7328 795b 6920 2b20 315d  y = abs(y[i + 1]
+0000abb0: 202d 2079 5b69 5d29 0a20 2020 2020 2020   - y[i]).       
+0000abc0: 2061 6e67 6c65 203d 206e 702e 6172 6374   angle = np.arct
+0000abd0: 616e 2864 7920 2f20 6478 290a 2020 2020  an(dy / dx).    
+0000abe0: 2020 2020 6966 2061 6273 2861 6e67 6c65      if abs(angle
+0000abf0: 2920 3e3d 2074 6872 6573 686f 6c64 3a0a  ) >= threshold:.
+0000ac00: 2020 2020 2020 2020 2020 2020 7979 5b69              yy[i
+0000ac10: 202b 2031 5d20 3d20 6e70 2e6e 616e 0a0a   + 1] = np.nan..
+0000ac20: 2020 2020 7265 7475 726e 2078 2c20 7979      return x, yy
+0000ac30: 0a0a 0a64 6566 205f 6465 7465 6374 5f70  ...def _detect_p
+0000ac40: 6f6c 6573 5f73 796d 626f 6c69 635f 6865  oles_symbolic_he
+0000ac50: 6c70 6572 2865 7870 722c 2073 796d 622c  lper(expr, symb,
+0000ac60: 2073 7461 7274 2c20 656e 6429 3a0a 2020   start, end):.  
+0000ac70: 2020 2222 2241 7474 656d 7074 7320 746f    """Attempts to
+0000ac80: 2063 6f6d 7075 7465 2073 796d 626f 6c69   compute symboli
+0000ac90: 6320 6469 7363 6f6e 7469 6e75 6974 6965  c discontinuitie
+0000aca0: 732e 0a0a 2020 2020 5265 7475 726e 730a  s...    Returns.
+0000acb0: 2020 2020 3d3d 3d3d 3d3d 3d0a 2020 2020      =======.    
+0000acc0: 706f 6c65 203a 206c 6973 740a 2020 2020  pole : list.    
+0000acd0: 2020 2020 4c69 7374 206f 6620 7379 6d62      List of symb
+0000ace0: 6f6c 6963 2070 6f6c 6573 2c20 706f 7373  olic poles, poss
+0000acf0: 6962 696c 7920 656d 7074 792e 0a20 2020  ibily empty..   
+0000ad00: 2022 2222 0a20 2020 2070 6f6c 6573 203d   """.    poles =
+0000ad10: 205b 5d0a 2020 2020 696e 7465 7276 616c   [].    interval
+0000ad20: 203d 2049 6e74 6572 7661 6c28 6e73 696d   = Interval(nsim
+0000ad30: 706c 6966 7928 7374 6172 7429 2c20 6e73  plify(start), ns
+0000ad40: 696d 706c 6966 7928 656e 6429 290a 2020  implify(end)).  
+0000ad50: 2020 7265 7320 3d20 636f 6e74 696e 756f    res = continuo
+0000ad60: 7573 5f64 6f6d 6169 6e28 6578 7072 2c20  us_domain(expr, 
+0000ad70: 7379 6d62 2c20 696e 7465 7276 616c 290a  symb, interval).
+0000ad80: 2020 2020 7265 7320 3d20 7265 732e 7369      res = res.si
+0000ad90: 6d70 6c69 6679 2829 0a20 2020 2069 6620  mplify().    if 
+0000ada0: 7265 7320 3d3d 2069 6e74 6572 7661 6c3a  res == interval:
+0000adb0: 0a20 2020 2020 2020 2070 6173 730a 2020  .        pass.  
+0000adc0: 2020 656c 6966 2028 6973 696e 7374 616e    elif (isinstan
+0000add0: 6365 2872 6573 2c20 556e 696f 6e29 2061  ce(res, Union) a
+0000ade0: 6e64 0a20 2020 2020 2020 2061 6c6c 2869  nd.        all(i
+0000adf0: 7369 6e73 7461 6e63 6528 742c 2049 6e74  sinstance(t, Int
+0000ae00: 6572 7661 6c29 2066 6f72 2074 2069 6e20  erval) for t in 
+0000ae10: 7265 732e 6172 6773 2929 3a0a 2020 2020  res.args)):.    
+0000ae20: 2020 2020 706f 6c65 7320 3d20 5b5d 0a20      poles = []. 
+0000ae30: 2020 2020 2020 2066 6f72 2073 2069 6e20         for s in 
+0000ae40: 7265 732e 6172 6773 3a0a 2020 2020 2020  res.args:.      
+0000ae50: 2020 2020 2020 6966 2073 2e6c 6566 745f        if s.left_
+0000ae60: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
+0000ae70: 2020 2020 2020 706f 6c65 732e 6170 7065        poles.appe
+0000ae80: 6e64 2873 2e6c 6566 7429 0a20 2020 2020  nd(s.left).     
+0000ae90: 2020 2020 2020 2069 6620 732e 7269 6768         if s.righ
+0000aea0: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
+0000aeb0: 2020 2020 2020 2020 706f 6c65 732e 6170          poles.ap
+0000aec0: 7065 6e64 2873 2e72 6967 6874 290a 2020  pend(s.right).  
+0000aed0: 2020 2020 2020 706f 6c65 7320 3d20 6c69        poles = li
+0000aee0: 7374 2873 6574 2870 6f6c 6573 2929 0a20  st(set(poles)). 
+0000aef0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000af00: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+0000af10: 7228 0a20 2020 2020 2020 2020 2020 2066  r(.            f
+0000af20: 2243 6f75 6c64 206e 6f74 2070 6172 7365  "Could not parse
+0000af30: 2074 6865 2066 6f6c 6c6f 7769 6e67 206f   the following o
+0000af40: 626a 6563 743a 207b 7265 737d 202e 5c6e  bject: {res} .\n
+0000af50: 220a 2020 2020 2020 2020 2020 2020 2250  ".            "P
+0000af60: 6c65 6173 652c 2073 7562 6d69 7420 7468  lease, submit th
+0000af70: 6973 2061 7320 6120 6275 672e 2043 6f6e  is as a bug. Con
+0000af80: 7369 6465 7220 616c 736f 2074 6f20 7365  sider also to se
+0000af90: 7420 220a 2020 2020 2020 2020 2020 2020  t ".            
+0000afa0: 2260 6465 7465 6374 5f70 6f6c 6573 3d54  "`detect_poles=T
+0000afb0: 7275 6560 2e22 0a20 2020 2020 2020 2029  rue`.".        )
+0000afc0: 0a20 2020 2072 6574 7572 6e20 706f 6c65  .    return pole
+0000afd0: 730a 0a0a 6465 6620 5f63 6865 636b 5f73  s...def _check_s
+0000afe0: 7465 7073 2873 7465 7073 293a 0a20 2020  teps(steps):.   
+0000aff0: 2069 6620 6973 696e 7374 616e 6365 2873   if isinstance(s
+0000b000: 7465 7073 2c20 7374 7229 3a0a 2020 2020  teps, str):.    
+0000b010: 2020 2020 7374 6570 7320 3d20 7374 6570      steps = step
+0000b020: 732e 6c6f 7765 7228 290a 2020 2020 706f  s.lower().    po
+0000b030: 7373 6962 6c65 5f76 616c 7565 7320 3d20  ssible_values = 
+0000b040: 5b22 7072 6522 2c20 2270 6f73 7422 2c20  ["pre", "post", 
+0000b050: 226d 6964 222c 2054 7275 652c 2046 616c  "mid", True, Fal
+0000b060: 7365 2c20 4e6f 6e65 5d0a 2020 2020 6966  se, None].    if
+0000b070: 206e 6f74 2028 7374 6570 7320 696e 2070   not (steps in p
+0000b080: 6f73 7369 626c 655f 7661 6c75 6573 293a  ossible_values):
+0000b090: 0a20 2020 2020 2020 2077 6172 6e69 6e67  .        warning
+0000b0a0: 732e 7761 726e 280a 2020 2020 2020 2020  s.warn(.        
+0000b0b0: 2020 2020 2260 6073 7465 7073 6060 206e      "``steps`` n
+0000b0c0: 6f74 2072 6563 6f67 6e69 7a65 642e 2050  ot recognized. P
+0000b0d0: 6f73 7369 626c 6520 7661 6c75 6573 2061  ossible values a
+0000b0e0: 7265 3a20 2220 2520 706f 7373 6962 6c65  re: " % possible
+0000b0f0: 5f76 616c 7565 730a 2020 2020 2020 2020  _values.        
+0000b100: 290a 2020 2020 7265 7475 726e 2073 7465  ).    return ste
+0000b110: 7073 0a0a 0a63 6c61 7373 204c 696e 6532  ps...class Line2
+0000b120: 4442 6173 6553 6572 6965 7328 4261 7365  DBaseSeries(Base
+0000b130: 5365 7269 6573 293a 0a20 2020 2022 2222  Series):.    """
+0000b140: 4120 6261 7365 2063 6c61 7373 2066 6f72  A base class for
+0000b150: 2032 4420 6c69 6e65 732e 2222 220a 0a20   2D lines.""".. 
+0000b160: 2020 2069 735f 3244 6c69 6e65 203d 2054     is_2Dline = T
+0000b170: 7275 650a 2020 2020 5f4e 203d 2031 3030  rue.    _N = 100
+0000b180: 300a 2020 2020 5f61 6c6c 6f77 6564 5f6b  0.    _allowed_k
+0000b190: 6579 7320 3d20 5b0a 2020 2020 2020 2020  eys = [.        
+0000b1a0: 2273 7465 7073 222c 2022 7363 6174 7465  "steps", "scatte
+0000b1b0: 7222 2c20 2269 735f 6669 6c6c 6564 222c  r", "is_filled",
+0000b1c0: 2022 6669 6c6c 222c 2022 6c69 6e65 5f63   "fill", "line_c
+0000b1d0: 6f6c 6f72 222c 2022 6465 7465 6374 5f70  olor", "detect_p
+0000b1e0: 6f6c 6573 222c 0a20 2020 2020 2020 2022  oles",.        "
+0000b1f0: 6570 7322 2c20 2269 735f 706f 6c61 7222  eps", "is_polar"
+0000b200: 2c20 2275 6e77 7261 7022 2c20 2265 7863  , "unwrap", "exc
+0000b210: 6c75 6465 222c 0a20 2020 205d 0a0a 2020  lude",.    ]..  
+0000b220: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+0000b230: 656c 662c 202a 6172 6773 2c20 2a2a 6b77  elf, *args, **kw
+0000b240: 6172 6773 293a 0a20 2020 2020 2020 2073  args):.        s
+0000b250: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
+0000b260: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
+0000b270: 0a20 2020 2020 2020 2023 206d 6f64 6966  .        # modif
+0000b280: 7920 7468 6520 636f 6d70 7574 6564 2063  y the computed c
+0000b290: 6f6f 7264 696e 6174 6573 2069 6e20 6f72  oordinates in or
+0000b2a0: 6465 7220 746f 206f 6274 6169 6e20 6120  der to obtain a 
+0000b2b0: 7374 6570 2d6c 696b 6520 706c 6f74 0a20  step-like plot. 
+0000b2c0: 2020 2020 2020 2073 656c 662e 7374 6570         self.step
+0000b2d0: 7320 3d20 5f63 6865 636b 5f73 7465 7073  s = _check_steps
+0000b2e0: 286b 7761 7267 732e 6765 7428 2273 7465  (kwargs.get("ste
+0000b2f0: 7073 222c 2046 616c 7365 2929 0a20 2020  ps", False)).   
+0000b300: 2020 2020 2023 2077 6865 7468 6572 2074       # whether t
+0000b310: 6f20 6372 6561 7465 2073 6361 7474 6572  o create scatter
+0000b320: 206f 7220 6120 636f 6e74 696e 756f 7573   or a continuous
+0000b330: 206c 696e 650a 2020 2020 2020 2020 7365   line.        se
+0000b340: 6c66 2e69 735f 706f 696e 7420 3d20 6b77  lf.is_point = kw
+0000b350: 6172 6773 2e67 6574 2822 7363 6174 7465  args.get("scatte
+0000b360: 7222 2c20 6b77 6172 6773 2e67 6574 2822  r", kwargs.get("
+0000b370: 6973 5f70 6f69 6e74 222c 2046 616c 7365  is_point", False
+0000b380: 2929 0a20 2020 2020 2020 2023 2077 6865  )).        # whe
+0000b390: 7468 6572 2073 6361 7474 6572 2773 206d  ther scatter's m
+0000b3a0: 6172 6b65 7273 2061 7265 2066 696c 6c65  arkers are fille
+0000b3b0: 6420 6f72 2076 6f69 640a 2020 2020 2020  d or void.      
+0000b3c0: 2020 7365 6c66 2e69 735f 6669 6c6c 6564    self.is_filled
+0000b3d0: 203d 206b 7761 7267 732e 6765 7428 2269   = kwargs.get("i
+0000b3e0: 735f 6669 6c6c 6564 222c 206b 7761 7267  s_filled", kwarg
+0000b3f0: 732e 6765 7428 2266 696c 6c22 2c20 5472  s.get("fill", Tr
+0000b400: 7565 2929 0a20 2020 2020 2020 2023 2077  ue)).        # w
+0000b410: 6865 7468 6572 2074 6f20 7573 6520 6120  hether to use a 
+0000b420: 636f 6c6f 726d 6170 206f 7220 6120 736f  colormap or a so
+0000b430: 6c69 6420 6c69 6e65 2063 6f6c 6f72 0a20  lid line color. 
+0000b440: 2020 2020 2020 2073 656c 662e 7573 655f         self.use_
+0000b450: 636d 203d 206b 7761 7267 732e 6765 7428  cm = kwargs.get(
+0000b460: 2275 7365 5f63 6d22 2c20 4661 6c73 6529  "use_cm", False)
+0000b470: 0a20 2020 2020 2020 2023 2066 6f72 2062  .        # for b
+0000b480: 6163 6b2d 636f 6d70 6174 6962 696c 6974  ack-compatibilit
+0000b490: 7920 7769 7468 206f 6c64 2073 796d 7079  y with old sympy
+0000b4a0: 2e70 6c6f 7474 696e 670a 2020 2020 2020  .plotting.      
+0000b4b0: 2020 7365 6c66 2e6c 696e 655f 636f 6c6f    self.line_colo
+0000b4c0: 7220 3d20 6b77 6172 6773 2e67 6574 2822  r = kwargs.get("
+0000b4d0: 6c69 6e65 5f63 6f6c 6f72 222c 204e 6f6e  line_color", Non
+0000b4e0: 6529 0a20 2020 2020 2020 2023 2077 6865  e).        # whe
+0000b4f0: 7468 6572 2074 6f20 6465 7465 6374 2072  ther to detect r
+0000b500: 6f6f 7473 206f 6620 6465 6e6f 6d69 6e61  oots of denomina
+0000b510: 746f 720a 2020 2020 2020 2020 7365 6c66  tor.        self
+0000b520: 2e64 6574 6563 745f 706f 6c65 7320 3d20  .detect_poles = 
+0000b530: 6b77 6172 6773 2e67 6574 2822 6465 7465  kwargs.get("dete
+0000b540: 6374 5f70 6f6c 6573 222c 2046 616c 7365  ct_poles", False
+0000b550: 290a 2020 2020 2020 2020 2320 6120 7061  ).        # a pa
+0000b560: 7261 6d65 7465 7220 746f 2063 6f6e 7472  rameter to contr
+0000b570: 6f6c 2074 6865 2064 6574 6563 745f 706f  ol the detect_po
+0000b580: 6c65 7320 616c 676f 7269 7468 6d0a 2020  les algorithm.  
+0000b590: 2020 2020 2020 7365 6c66 2e65 7073 203d        self.eps =
+0000b5a0: 206b 7761 7267 732e 6765 7428 2265 7073   kwargs.get("eps
+0000b5b0: 222c 2030 2e30 3129 0a20 2020 2020 2020  ", 0.01).       
+0000b5c0: 2023 2077 6865 6e20 6465 7465 6374 5f70   # when detect_p
+0000b5d0: 6f6c 6573 3d22 7379 6d62 6f6c 6963 222c  oles="symbolic",
+0000b5e0: 2073 746f 7265 7320 7468 6520 6c6f 6361   stores the loca
+0000b5f0: 7469 6f6e 206f 6620 706f 6c65 7320 736f  tion of poles so
+0000b600: 2074 6861 740a 2020 2020 2020 2020 2320   that.        # 
+0000b610: 7468 6579 2063 616e 2062 6520 6170 7072  they can be appr
+0000b620: 6f70 7269 6174 656c 7920 7265 6e64 6572  opriately render
+0000b630: 6564 0a20 2020 2020 2020 2073 656c 662e  ed.        self.
+0000b640: 706f 6c65 735f 6c6f 6361 7469 6f6e 7320  poles_locations 
+0000b650: 3d20 5b5d 0a20 2020 2020 2020 2023 2077  = [].        # w
+0000b660: 6865 7468 6572 2074 6f20 636f 6e76 6572  hether to conver
+0000b670: 2074 6865 2063 6f6d 7075 7465 6420 636f   the computed co
+0000b680: 6f72 6469 6e61 7465 7320 746f 2070 6f6c  ordinates to pol
+0000b690: 6172 2063 6f6f 7264 696e 6174 6573 0a20  ar coordinates. 
+0000b6a0: 2020 2020 2020 2073 656c 662e 6973 5f70         self.is_p
+0000b6b0: 6f6c 6172 203d 206b 7761 7267 732e 6765  olar = kwargs.ge
+0000b6c0: 7428 2269 735f 706f 6c61 7222 2c20 4661  t("is_polar", Fa
+0000b6d0: 6c73 6529 0a20 2020 2020 2020 2023 2077  lse).        # w
+0000b6e0: 6865 7468 6572 2074 6f20 7573 6520 6e75  hether to use nu
+0000b6f0: 6d70 792e 756e 7772 6170 2829 0a20 2020  mpy.unwrap().   
+0000b700: 2020 2020 2073 656c 662e 756e 7772 6170       self.unwrap
+0000b710: 203d 206b 7761 7267 732e 6765 7428 2275   = kwargs.get("u
+0000b720: 6e77 7261 7022 2c20 4661 6c73 6529 0a20  nwrap", False). 
+0000b730: 2020 2020 2020 2023 206c 6973 7420 6f66         # list of
+0000b740: 2078 2d63 6f6f 7264 696e 6174 6573 2074   x-coordinates t
+0000b750: 6f20 6265 2065 7863 6c75 6465 6420 6672  o be excluded fr
+0000b760: 6f6d 2065 7661 6c75 6174 696f 6e0a 2020  om evaluation.  
+0000b770: 2020 2020 2020 6578 636c 7564 6520 3d20        exclude = 
+0000b780: 6b77 6172 6773 2e67 6574 2822 6578 636c  kwargs.get("excl
+0000b790: 7564 6522 2c20 5b5d 290a 2020 2020 2020  ude", []).      
+0000b7a0: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
+0000b7b0: 6578 636c 7564 652c 2053 6574 293a 0a20  exclude, Set):. 
+0000b7c0: 2020 2020 2020 2020 2020 2065 7863 6c75             exclu
+0000b7d0: 6465 203d 206c 6973 7428 6578 7472 6163  de = list(extrac
+0000b7e0: 745f 736f 6c75 7469 6f6e 2865 7863 6c75  t_solution(exclu
+0000b7f0: 6465 2c20 6e3d 3130 3029 290a 2020 2020  de, n=100)).    
+0000b800: 2020 2020 6966 206e 6f74 2068 6173 6174      if not hasat
+0000b810: 7472 2865 7863 6c75 6465 2c20 225f 5f69  tr(exclude, "__i
+0000b820: 7465 725f 5f22 293a 0a20 2020 2020 2020  ter__"):.       
+0000b830: 2020 2020 2065 7863 6c75 6465 203d 205b       exclude = [
+0000b840: 6578 636c 7564 655d 0a20 2020 2020 2020  exclude].       
+0000b850: 2065 7863 6c75 6465 203d 205b 666c 6f61   exclude = [floa
+0000b860: 7428 6529 2066 6f72 2065 2069 6e20 6578  t(e) for e in ex
+0000b870: 636c 7564 655d 0a20 2020 2020 2020 2073  clude].        s
+0000b880: 656c 662e 6578 636c 7564 6520 3d20 736f  elf.exclude = so
+0000b890: 7274 6564 2865 7863 6c75 6465 290a 0a20  rted(exclude).. 
+0000b8a0: 2020 2064 6566 2067 6574 5f64 6174 6128     def get_data(
+0000b8b0: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+0000b8c0: 2222 5265 7475 726e 2063 6f6f 7264 696e  ""Return coordin
+0000b8d0: 6174 6573 2066 6f72 2070 6c6f 7474 696e  ates for plottin
+0000b8e0: 6720 7468 6520 6c69 6e65 2e0a 0a20 2020  g the line...   
+0000b8f0: 2020 2020 2052 6574 7572 6e73 0a20 2020       Returns.   
+0000b900: 2020 2020 203d 3d3d 3d3d 3d3d 0a0a 2020       =======..  
+0000b910: 2020 2020 2020 783a 206e 702e 6e64 6172        x: np.ndar
+0000b920: 7261 790a 2020 2020 2020 2020 2020 2020  ray.            
+0000b930: 782d 636f 6f72 6469 6e61 7465 730a 2020  x-coordinates.  
+0000b940: 2020 2020 2020 793a 206e 702e 6e64 6172        y: np.ndar
+0000b950: 7261 790a 2020 2020 2020 2020 2020 2020  ray.            
+0000b960: 792d 636f 6f72 6469 6e61 7465 730a 2020  y-coordinates.  
+0000b970: 2020 2020 2020 7a3a 206e 702e 6e64 6172        z: np.ndar
+0000b980: 7261 7920 286f 7074 696f 6e61 6c29 0a20  ray (optional). 
+0000b990: 2020 2020 2020 2020 2020 207a 2d63 6f6f             z-coo
+0000b9a0: 7264 696e 6174 6573 2069 6e20 6361 7365  rdinates in case
+0000b9b0: 206f 6620 5061 7261 6d65 7472 6963 3344   of Parametric3D
+0000b9c0: 4c69 6e65 5365 7269 6573 0a20 2020 2020  LineSeries.     
+0000b9d0: 2020 2070 6172 616d 203a 206e 702e 6e64     param : np.nd
+0000b9e0: 6172 7261 7920 286f 7074 696f 6e61 6c29  array (optional)
+0000b9f0: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
+0000ba00: 2070 6172 616d 6574 6572 2069 6e20 6361   parameter in ca
+0000ba10: 7365 206f 6620 5061 7261 6d65 7472 6963  se of Parametric
+0000ba20: 3244 4c69 6e65 5365 7269 6573 2c0a 2020  2DLineSeries,.  
+0000ba30: 2020 2020 2020 2020 2020 5061 7261 6d65            Parame
+0000ba40: 7472 6963 3344 4c69 6e65 5365 7269 6573  tric3DLineSeries
+0000ba50: 206f 7220 4162 7341 7267 4c69 6e65 5365   or AbsArgLineSe
+0000ba60: 7269 6573 2e0a 2020 2020 2020 2020 2222  ries..        ""
+0000ba70: 220a 2020 2020 2020 2020 6e70 203d 2069  ".        np = i
+0000ba80: 6d70 6f72 745f 6d6f 6475 6c65 2827 6e75  mport_module('nu
+0000ba90: 6d70 7927 290a 2020 2020 2020 2020 706f  mpy').        po
+0000baa0: 696e 7473 203d 2073 656c 662e 5f67 6574  ints = self._get
+0000bab0: 5f64 6174 615f 6865 6c70 6572 2829 0a0a  _data_helper()..
+0000bac0: 2020 2020 2020 2020 6966 2028 0a20 2020          if (.   
+0000bad0: 2020 2020 2020 2020 2069 7369 6e73 7461           isinsta
+0000bae0: 6e63 6528 7365 6c66 2c20 4c69 6e65 4f76  nce(self, LineOv
+0000baf0: 6572 3144 5261 6e67 6553 6572 6965 7329  er1DRangeSeries)
+0000bb00: 2061 6e64 0a20 2020 2020 2020 2020 2020   and.           
+0000bb10: 2028 7365 6c66 2e64 6574 6563 745f 706f   (self.detect_po
+0000bb20: 6c65 7320 3d3d 2022 7379 6d62 6f6c 6963  les == "symbolic
+0000bb30: 2229 0a20 2020 2020 2020 2029 3a0a 2020  ").        ):.  
+0000bb40: 2020 2020 2020 2020 2020 706f 6c65 7320            poles 
+0000bb50: 3d20 5f64 6574 6563 745f 706f 6c65 735f  = _detect_poles_
+0000bb60: 7379 6d62 6f6c 6963 5f68 656c 7065 7228  symbolic_helper(
+0000bb70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000bb80: 2073 656c 662e 6578 7072 2e73 7562 7328   self.expr.subs(
+0000bb90: 7365 6c66 2e70 6172 616d 7329 2c20 2a73  self.params), *s
+0000bba0: 656c 662e 7261 6e67 6573 5b30 5d29 0a20  elf.ranges[0]). 
+0000bbb0: 2020 2020 2020 2020 2020 2070 6f6c 6573             poles
+0000bbc0: 203d 206e 702e 6172 7261 7928 5b66 6c6f   = np.array([flo
+0000bbd0: 6174 2874 2920 666f 7220 7420 696e 2070  at(t) for t in p
+0000bbe0: 6f6c 6573 5d29 0a20 2020 2020 2020 2020  oles]).         
+0000bbf0: 2020 2074 203d 206c 616d 6264 6120 782c     t = lambda x,
+0000bc00: 2074 7261 6e73 666f 726d 3a20 7820 6966   transform: x if
+0000bc10: 2074 7261 6e73 666f 726d 2069 7320 4e6f   transform is No
+0000bc20: 6e65 2065 6c73 6520 7472 616e 7366 6f72  ne else transfor
+0000bc30: 6d28 7829 0a20 2020 2020 2020 2020 2020  m(x).           
+0000bc40: 2073 656c 662e 706f 6c65 735f 6c6f 6361   self.poles_loca
+0000bc50: 7469 6f6e 7320 3d20 7428 6e70 2e61 7272  tions = t(np.arr
+0000bc60: 6179 2870 6f6c 6573 292c 2073 656c 662e  ay(poles), self.
+0000bc70: 5f74 7829 0a0a 2020 2020 2020 2020 2320  _tx)..        # 
+0000bc80: 706f 7374 7072 6f63 6573 7369 6e67 0a20  postprocessing. 
+0000bc90: 2020 2020 2020 2070 6f69 6e74 7320 3d20         points = 
+0000bca0: 7365 6c66 2e5f 6170 706c 795f 7472 616e  self._apply_tran
+0000bcb0: 7366 6f72 6d28 2a70 6f69 6e74 7329 0a0a  sform(*points)..
+0000bcc0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000bcd0: 6973 5f32 446c 696e 6520 616e 6420 7365  is_2Dline and se
+0000bce0: 6c66 2e64 6574 6563 745f 706f 6c65 733a  lf.detect_poles:
+0000bcf0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000bd00: 6c65 6e28 706f 696e 7473 2920 3d3d 2032  len(points) == 2
+0000bd10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000bd20: 2020 782c 2079 203d 2070 6f69 6e74 730a    x, y = points.
+0000bd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bd40: 782c 2079 203d 205f 6465 7465 6374 5f70  x, y = _detect_p
+0000bd50: 6f6c 6573 5f6e 756d 6572 6963 616c 5f68  oles_numerical_h
+0000bd60: 656c 7065 7228 0a20 2020 2020 2020 2020  elper(.         
+0000bd70: 2020 2020 2020 2020 2020 2078 2c20 792c             x, y,
+0000bd80: 2073 656c 662e 6570 7329 0a20 2020 2020   self.eps).     
+0000bd90: 2020 2020 2020 2020 2020 2070 6f69 6e74             point
+0000bda0: 7320 3d20 2878 2c20 7929 0a20 2020 2020  s = (x, y).     
+0000bdb0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000bdc0: 2020 2020 2020 2020 2020 2020 2078 2c20               x, 
+0000bdd0: 792c 2070 203d 2070 6f69 6e74 730a 2020  y, p = points.  
+0000bde0: 2020 2020 2020 2020 2020 2020 2020 782c                x,
+0000bdf0: 2079 203d 205f 6465 7465 6374 5f70 6f6c   y = _detect_pol
+0000be00: 6573 5f6e 756d 6572 6963 616c 5f68 656c  es_numerical_hel
+0000be10: 7065 7228 782c 2079 2c20 7365 6c66 2e65  per(x, y, self.e
+0000be20: 7073 290a 2020 2020 2020 2020 2020 2020  ps).            
+0000be30: 2020 2020 706f 696e 7473 203d 2028 782c      points = (x,
+0000be40: 2079 2c20 7029 0a0a 2020 2020 2020 2020   y, p)..        
+0000be50: 6966 2073 656c 662e 756e 7772 6170 3a0a  if self.unwrap:.
+0000be60: 2020 2020 2020 2020 2020 2020 6b77 203d              kw =
+0000be70: 207b 7d0a 2020 2020 2020 2020 2020 2020   {}.            
+0000be80: 6966 2073 656c 662e 756e 7772 6170 2069  if self.unwrap i
+0000be90: 7320 6e6f 7420 5472 7565 3a0a 2020 2020  s not True:.    
+0000bea0: 2020 2020 2020 2020 2020 2020 6b77 203d              kw =
+0000beb0: 2073 656c 662e 756e 7772 6170 0a20 2020   self.unwrap.   
+0000bec0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+0000bed0: 2e69 735f 3244 6c69 6e65 3a0a 2020 2020  .is_2Dline:.    
+0000bee0: 2020 2020 2020 2020 2020 2020 6966 206c              if l
+0000bef0: 656e 2870 6f69 6e74 7329 203d 3d20 323a  en(points) == 2:
+0000bf00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000bf10: 2020 2020 2078 2c20 7920 3d20 706f 696e       x, y = poin
+0000bf20: 7473 0a20 2020 2020 2020 2020 2020 2020  ts.             
+0000bf30: 2020 2020 2020 2079 203d 206e 702e 756e         y = np.un
+0000bf40: 7772 6170 2879 2c20 2a2a 6b77 290a 2020  wrap(y, **kw).  
+0000bf50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bf60: 2020 706f 696e 7473 203d 2028 782c 2079    points = (x, y
+0000bf70: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000bf80: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000bf90: 2020 2020 2020 2020 2020 2020 782c 2079              x, y
+0000bfa0: 2c20 7020 3d20 706f 696e 7473 0a20 2020  , p = points.   
+0000bfb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bfc0: 2079 203d 206e 702e 756e 7772 6170 2879   y = np.unwrap(y
+0000bfd0: 2c20 2a2a 6b77 290a 2020 2020 2020 2020  , **kw).        
+0000bfe0: 2020 2020 2020 2020 2020 2020 706f 696e              poin
+0000bff0: 7473 203d 2028 782c 2079 2c20 7029 0a0a  ts = (x, y, p)..
+0000c000: 2020 2020 2020 2020 6966 2028 7365 6c66          if (self
+0000c010: 2e73 7465 7073 2069 7320 5472 7565 2920  .steps is True) 
+0000c020: 6f72 2028 7365 6c66 2e73 7465 7073 203d  or (self.steps =
+0000c030: 3d20 2270 7265 2229 3a0a 2020 2020 2020  = "pre"):.      
+0000c040: 2020 2020 2020 706f 696e 7473 203d 2070        points = p
+0000c050: 7473 5f74 6f5f 7072 6573 7465 7028 2a70  ts_to_prestep(*p
+0000c060: 6f69 6e74 7329 0a20 2020 2020 2020 2065  oints).        e
+0000c070: 6c69 6620 7365 6c66 2e73 7465 7073 203d  lif self.steps =
+0000c080: 3d20 2270 6f73 7422 3a0a 2020 2020 2020  = "post":.      
+0000c090: 2020 2020 2020 706f 696e 7473 203d 2070        points = p
+0000c0a0: 7473 5f74 6f5f 706f 7374 7374 6570 282a  ts_to_poststep(*
+0000c0b0: 706f 696e 7473 290a 2020 2020 2020 2020  points).        
+0000c0c0: 656c 6966 2073 656c 662e 7374 6570 7320  elif self.steps 
+0000c0d0: 3d3d 2022 6d69 6422 3a0a 2020 2020 2020  == "mid":.      
+0000c0e0: 2020 2020 2020 706f 696e 7473 203d 2070        points = p
+0000c0f0: 7473 5f74 6f5f 6d69 6473 7465 7028 2a70  ts_to_midstep(*p
+0000c100: 6f69 6e74 7329 0a0a 2020 2020 2020 2020  oints)..        
+0000c110: 706f 696e 7473 203d 2073 656c 662e 5f69  points = self._i
+0000c120: 6e73 6572 745f 6578 636c 7573 696f 6e73  nsert_exclusions
+0000c130: 2870 6f69 6e74 7329 0a20 2020 2020 2020  (points).       
+0000c140: 2072 6574 7572 6e20 706f 696e 7473 0a0a   return points..
+0000c150: 2020 2020 6465 6620 5f69 6e73 6572 745f      def _insert_
+0000c160: 6578 636c 7573 696f 6e73 2873 656c 662c  exclusions(self,
+0000c170: 2070 6f69 6e74 7329 3a0a 2020 2020 2020   points):.      
+0000c180: 2020 2222 2241 6464 204e 614e 2074 6f20    """Add NaN to 
+0000c190: 6561 6368 206f 6620 7468 6520 6578 636c  each of the excl
+0000c1a0: 7573 696f 6e20 706f 696e 742e 2050 7261  usion point. Pra
+0000c1b0: 6374 6963 616c 6c79 2c20 7468 6973 2061  ctically, this a
+0000c1c0: 6464 7320 610a 2020 2020 2020 2020 4e61  dds a.        Na
+0000c1d0: 4e20 746f 2074 6865 2065 786c 7573 696f  N to the exlusio
+0000c1e0: 6e20 706f 696e 742c 2070 6c75 7320 7477  n point, plus tw
+0000c1f0: 6f20 6f74 6865 7220 6e65 6172 6279 2070  o other nearby p
+0000c200: 6f69 6e74 7320 6576 616c 7561 7465 6420  oints evaluated 
+0000c210: 7769 7468 0a20 2020 2020 2020 2074 6865  with.        the
+0000c220: 206e 756d 6572 6963 616c 2066 756e 6374   numerical funct
+0000c230: 696f 6e73 2061 7373 6f63 6961 7465 6420  ions associated 
+0000c240: 746f 2074 6869 7320 6461 7461 2073 6572  to this data ser
+0000c250: 6965 732e 0a20 2020 2020 2020 2054 6865  ies..        The
+0000c260: 7365 206e 6561 7262 7920 706f 696e 7473  se nearby points
+0000c270: 2061 7265 2069 6d70 6f72 7461 6e74 2077   are important w
+0000c280: 6865 6e20 7468 6520 6e75 6d62 6572 206f  hen the number o
+0000c290: 6620 6469 7363 7265 7469 7a61 7469 6f6e  f discretization
+0000c2a0: 0a20 2020 2020 2020 2070 6f69 6e74 7320  .        points 
+0000c2b0: 6973 206c 6f77 2c20 6f72 2074 6865 2073  is low, or the s
+0000c2c0: 6361 6c65 2069 7320 6c6f 6761 7269 7468  cale is logarith
+0000c2d0: 6d2e 0a0a 2020 2020 2020 2020 4e4f 5445  m...        NOTE
+0000c2e0: 3a20 6974 2077 6f75 6c64 2062 6520 6561  : it would be ea
+0000c2f0: 7369 6572 2074 6f20 6a75 7374 2061 6464  sier to just add
+0000c300: 2065 7863 6c75 7369 6f6e 2070 6f69 6e74   exclusion point
+0000c310: 7320 746f 2074 6865 0a20 2020 2020 2020  s to the.       
+0000c320: 2064 6973 6372 6574 697a 6564 2064 6f6d   discretized dom
+0000c330: 6169 6e20 6265 666f 7265 2065 7661 6c75  ain before evalu
+0000c340: 6174 696f 6e2c 2074 6865 6e20 6166 7465  ation, then afte
+0000c350: 7220 6576 616c 7561 7469 6f6e 2061 6464  r evaluation add
+0000c360: 204e 614e 0a20 2020 2020 2020 2074 6f20   NaN.        to 
+0000c370: 7468 6520 6578 636c 7573 696f 6e20 706f  the exclusion po
+0000c380: 696e 7473 2e20 4275 7420 7468 6174 2773  ints. But that's
+0000c390: 206f 6e6c 7920 776f 726b 2077 6974 6820   only work with 
+0000c3a0: 6164 6170 7469 7665 3d46 616c 7365 2e0a  adaptive=False..
+0000c3b0: 2020 2020 2020 2020 5468 6520 666f 6c6c          The foll
+0000c3c0: 6f77 696e 6720 6170 7072 6f61 6368 2077  owing approach w
+0000c3d0: 6f72 6b20 6576 656e 2077 6974 6820 6164  ork even with ad
+0000c3e0: 6170 7469 7665 3d54 7275 652e 0a20 2020  aptive=True..   
+0000c3f0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000c400: 2069 6620 6c65 6e28 7365 6c66 2e65 7863   if len(self.exc
+0000c410: 6c75 6465 2920 3d3d 2030 3a0a 2020 2020  lude) == 0:.    
+0000c420: 2020 2020 2020 2020 7265 7475 726e 2070          return p
+0000c430: 6f69 6e74 730a 0a20 2020 2020 2020 206e  oints..        n
+0000c440: 7020 3d20 696d 706f 7274 5f6d 6f64 756c  p = import_modul
+0000c450: 6528 226e 756d 7079 2229 0a20 2020 2020  e("numpy").     
+0000c460: 2020 2070 6f69 6e74 7320 3d20 6c69 7374     points = list
+0000c470: 2870 6f69 6e74 7329 0a20 2020 2020 2020  (points).       
+0000c480: 206e 203d 206c 656e 2870 6f69 6e74 7329   n = len(points)
+0000c490: 0a20 2020 2020 2020 2023 2069 6e64 6578  .        # index
+0000c4a0: 206f 6620 7468 6520 782d 636f 6f72 6469   of the x-coordi
+0000c4b0: 6e61 7465 2028 666f 7220 3264 2070 6c6f  nate (for 2d plo
+0000c4c0: 7473 2920 6f72 2070 6172 616d 6574 6572  ts) or parameter
+0000c4d0: 2028 666f 7220 3264 2f33 640a 2020 2020   (for 2d/3d.    
+0000c4e0: 2020 2020 2320 7061 7261 6d65 7472 6963      # parametric
+0000c4f0: 2070 6c6f 7473 290a 2020 2020 2020 2020   plots).        
+0000c500: 6b20 3d20 6e20 2d20 310a 2020 2020 2020  k = n - 1.      
+0000c510: 2020 6966 206e 203d 3d20 323a 0a20 2020    if n == 2:.   
+0000c520: 2020 2020 2020 2020 206b 203d 2030 0a20           k = 0. 
+0000c530: 2020 2020 2020 2023 2069 6e64 6563 6573         # indeces
+0000c540: 206f 6620 7468 6520 6f74 6865 7220 636f   of the other co
+0000c550: 6f72 6469 6e61 7465 730a 2020 2020 2020  ordinates.      
+0000c560: 2020 6a5f 696e 6465 6365 7320 3d20 736f    j_indeces = so
+0000c570: 7274 6564 2873 6574 2872 616e 6765 286e  rted(set(range(n
+0000c580: 2929 2e64 6966 6665 7265 6e63 6528 5b6b  )).difference([k
+0000c590: 5d29 290a 2020 2020 2020 2020 2320 544f  ])).        # TO
+0000c5a0: 444f 3a20 666f 7220 6e6f 772c 2049 2061  DO: for now, I a
+0000c5b0: 7373 756d 6520 7468 6174 206e 756d 7079  ssume that numpy
+0000c5c0: 2066 756e 6374 696f 6e73 2061 7265 2067   functions are g
+0000c5d0: 6f69 6e67 2074 6f20 7375 6363 6565 640a  oing to succeed.
+0000c5e0: 2020 2020 2020 2020 6675 6e63 7320 3d20          funcs = 
+0000c5f0: 5b66 5b30 5d20 666f 7220 6620 696e 2073  [f[0] for f in s
+0000c600: 656c 662e 5f66 756e 6374 696f 6e73 5d0a  elf._functions].
+0000c610: 0a20 2020 2020 2020 2066 6f72 2065 2069  .        for e i
+0000c620: 6e20 7365 6c66 2e65 7863 6c75 6465 3a0a  n self.exclude:.
+0000c630: 2020 2020 2020 2020 2020 2020 7265 7320              res 
+0000c640: 3d20 706f 696e 7473 5b6b 5d20 2d20 6520  = points[k] - e 
+0000c650: 3e3d 2030 0a20 2020 2020 2020 2020 2020  >= 0.           
+0000c660: 2023 2069 6620 7265 7320 636f 6e74 6169   # if res contai
+0000c670: 6e73 2062 6f74 6820 5472 7565 2061 6e64  ns both True and
+0000c680: 2046 616c 7365 2c20 6965 2c20 6966 2065   False, ie, if e
+0000c690: 2069 7320 666f 756e 640a 2020 2020 2020   is found.      
+0000c6a0: 2020 2020 2020 6966 2061 6e79 2872 6573        if any(res
+0000c6b0: 2920 616e 6420 616e 7928 7e72 6573 293a  ) and any(~res):
+0000c6c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c6d0: 2069 6478 203d 206e 702e 6e61 6e61 7267   idx = np.nanarg
+0000c6e0: 6d61 7828 7265 7329 0a20 2020 2020 2020  max(res).       
+0000c6f0: 2020 2020 2020 2020 2023 2073 656c 6563           # selec
+0000c700: 7420 7468 6520 7072 6576 696f 7573 2070  t the previous p
+0000c710: 6f69 6e74 2077 6974 6820 7265 7370 6563  oint with respec
+0000c720: 7420 746f 2065 0a20 2020 2020 2020 2020  t to e.         
+0000c730: 2020 2020 2020 2069 6478 202d 3d20 310a         idx -= 1.
+0000c740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c750: 2320 544f 444f 3a20 7768 6174 2069 6620  # TODO: what if 
+0000c760: 706f 696e 7473 5b6b 5d5b 6964 785d 3d3d  points[k][idx]==
+0000c770: 6520 6f72 2070 6f69 6e74 735b 6b5d 5b69  e or points[k][i
+0000c780: 6478 2b31 5d3d 3d65 3f0a 0a20 2020 2020  dx+1]==e?..     
+0000c790: 2020 2020 2020 2020 2020 2069 6620 6964             if id
+0000c7a0: 7820 3e20 3020 616e 6420 6964 7820 3c20  x > 0 and idx < 
+0000c7b0: 6c65 6e28 706f 696e 7473 5b6b 5d29 202d  len(points[k]) -
+0000c7c0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+0000c7d0: 2020 2020 2020 2020 6465 6c74 615f 7072          delta_pr
+0000c7e0: 6576 203d 2061 6273 2865 202d 2070 6f69  ev = abs(e - poi
+0000c7f0: 6e74 735b 6b5d 5b69 6478 5d29 0a20 2020  nts[k][idx]).   
+0000c800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c810: 2064 656c 7461 5f70 6f73 7420 3d20 6162   delta_post = ab
+0000c820: 7328 6520 2d20 706f 696e 7473 5b6b 5d5b  s(e - points[k][
+0000c830: 6964 7820 2b20 315d 290a 2020 2020 2020  idx + 1]).      
+0000c840: 2020 2020 2020 2020 2020 2020 2020 6465                de
+0000c850: 6c74 6120 3d20 6d69 6e28 6465 6c74 615f  lta = min(delta_
+0000c860: 7072 6576 2c20 6465 6c74 615f 706f 7374  prev, delta_post
+0000c870: 2920 2f20 3130 300a 2020 2020 2020 2020  ) / 100.        
+0000c880: 2020 2020 2020 2020 2020 2020 7072 6576              prev
+0000c890: 203d 2065 202d 2064 656c 7461 0a20 2020   = e - delta.   
+0000c8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8b0: 2070 6f73 7420 3d20 6520 2b20 6465 6c74   post = e + delt
+0000c8c0: 610a 0a20 2020 2020 2020 2020 2020 2020  a..             
+0000c8d0: 2020 2020 2020 2023 2061 6464 2070 6f69         # add poi
+0000c8e0: 6e74 7320 746f 2074 6865 2078 2d63 6f6f  nts to the x-coo
+0000c8f0: 7264 206f 7220 7468 6520 7061 7261 6d65  rd or the parame
+0000c900: 7465 720a 2020 2020 2020 2020 2020 2020  ter.            
+0000c910: 2020 2020 2020 2020 706f 696e 7473 5b6b          points[k
+0000c920: 5d20 3d20 6e70 2e63 6f6e 6361 7465 6e61  ] = np.concatena
+0000c930: 7465 280a 2020 2020 2020 2020 2020 2020  te(.            
+0000c940: 2020 2020 2020 2020 2020 2020 2870 6f69              (poi
+0000c950: 6e74 735b 6b5d 5b3a 6964 785d 2c20 5b70  nts[k][:idx], [p
+0000c960: 7265 762c 2065 2c20 706f 7374 5d2c 2070  rev, e, post], p
+0000c970: 6f69 6e74 735b 6b5d 5b69 6478 2b31 3a5d  oints[k][idx+1:]
+0000c980: 2929 0a0a 2020 2020 2020 2020 2020 2020  ))..            
+0000c990: 2020 2020 2020 2020 2320 6164 6420 706f          # add po
+0000c9a0: 696e 7473 2074 6f20 7468 6520 6f74 6865  ints to the othe
+0000c9b0: 7220 636f 6f72 6469 6e61 7465 730a 2020  r coordinates.  
+0000c9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c9d0: 2020 6320 3d20 300a 2020 2020 2020 2020    c = 0.        
+0000c9e0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+0000c9f0: 6a20 696e 206a 5f69 6e64 6563 6573 3a0a  j in j_indeces:.
+0000ca00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca10: 2020 2020 2020 2020 7661 6c75 6573 203d          values =
+0000ca20: 2066 756e 6373 5b63 5d28 6e70 2e61 7272   funcs[c](np.arr
+0000ca30: 6179 285b 7072 6576 2c20 706f 7374 5d29  ay([prev, post])
+0000ca40: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000ca50: 2020 2020 2020 2020 2020 6320 2b3d 2031            c += 1
+0000ca60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ca70: 2020 2020 2020 2020 2070 6f69 6e74 735b           points[
+0000ca80: 6a5d 203d 206e 702e 636f 6e63 6174 656e  j] = np.concaten
+0000ca90: 6174 6528 0a20 2020 2020 2020 2020 2020  ate(.           
+0000caa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cab0: 2028 706f 696e 7473 5b6a 5d5b 3a69 6478   (points[j][:idx
+0000cac0: 5d2c 205b 7661 6c75 6573 5b30 5d2c 206e  ], [values[0], n
+0000cad0: 702e 6e61 6e2c 2076 616c 7565 735b 315d  p.nan, values[1]
+0000cae0: 5d2c 2070 6f69 6e74 735b 6a5d 5b69 6478  ], points[j][idx
+0000caf0: 2b31 3a5d 2929 0a20 2020 2020 2020 2072  +1:])).        r
+0000cb00: 6574 7572 6e20 706f 696e 7473 0a0a 2020  eturn points..  
+0000cb10: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+0000cb20: 6465 6620 7661 7228 7365 6c66 293a 0a20  def var(self):. 
+0000cb30: 2020 2020 2020 2072 6574 7572 6e20 4e6f         return No
+0000cb40: 6e65 2069 6620 6e6f 7420 7365 6c66 2e72  ne if not self.r
+0000cb50: 616e 6765 7320 656c 7365 2073 656c 662e  anges else self.
+0000cb60: 7261 6e67 6573 5b30 5d5b 305d 0a0a 2020  ranges[0][0]..  
+0000cb70: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+0000cb80: 6465 6620 7374 6172 7428 7365 6c66 293a  def start(self):
+0000cb90: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
+0000cba0: 7365 6c66 2e72 616e 6765 733a 0a20 2020  self.ranges:.   
+0000cbb0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000cbc0: 4e6f 6e65 0a20 2020 2020 2020 2074 7279  None.        try
+0000cbd0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000cbe0: 7475 726e 2073 656c 662e 5f63 6173 7428  turn self._cast(
+0000cbf0: 7365 6c66 2e72 616e 6765 735b 305d 5b31  self.ranges[0][1
+0000cc00: 5d29 0a20 2020 2020 2020 2065 7863 6570  ]).        excep
+0000cc10: 7420 4578 6365 7074 696f 6e3a 0a20 2020  t Exception:.   
+0000cc20: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000cc30: 7365 6c66 2e72 616e 6765 735b 305d 5b31  self.ranges[0][1
+0000cc40: 5d0a 0a20 2020 2040 7072 6f70 6572 7479  ]..    @property
+0000cc50: 0a20 2020 2064 6566 2065 6e64 2873 656c  .    def end(sel
+0000cc60: 6629 3a0a 2020 2020 2020 2020 6966 206e  f):.        if n
+0000cc70: 6f74 2073 656c 662e 7261 6e67 6573 3a0a  ot self.ranges:.
+0000cc80: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000cc90: 726e 204e 6f6e 650a 2020 2020 2020 2020  rn None.        
+0000cca0: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
+0000ccb0: 2072 6574 7572 6e20 7365 6c66 2e5f 6361   return self._ca
+0000ccc0: 7374 2873 656c 662e 7261 6e67 6573 5b30  st(self.ranges[0
+0000ccd0: 5d5b 325d 290a 2020 2020 2020 2020 6578  ][2]).        ex
+0000cce0: 6365 7074 2045 7863 6570 7469 6f6e 3a0a  cept Exception:.
+0000ccf0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000cd00: 726e 2073 656c 662e 7261 6e67 6573 5b30  rn self.ranges[0
+0000cd10: 5d5b 325d 0a0a 2020 2020 4070 726f 7065  ][2]..    @prope
+0000cd20: 7274 790a 2020 2020 6465 6620 6c69 6e65  rty.    def line
+0000cd30: 5f63 6f6c 6f72 2873 656c 6629 3a0a 2020  _color(self):.  
+0000cd40: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0000cd50: 662e 5f6c 696e 655f 636f 6c6f 720a 0a20  f._line_color.. 
+0000cd60: 2020 2040 6c69 6e65 5f63 6f6c 6f72 2e73     @line_color.s
+0000cd70: 6574 7465 720a 2020 2020 6465 6620 6c69  etter.    def li
+0000cd80: 6e65 5f63 6f6c 6f72 2873 656c 662c 2076  ne_color(self, v
+0000cd90: 616c 293a 0a20 2020 2020 2020 2073 656c  al):.        sel
+0000cda0: 662e 5f6c 696e 655f 7375 7266 6163 655f  f._line_surface_
+0000cdb0: 636f 6c6f 7228 225f 6c69 6e65 5f63 6f6c  color("_line_col
+0000cdc0: 6f72 222c 2076 616c 290a 0a0a 636c 6173  or", val)...clas
+0000cdd0: 7320 4c69 7374 3244 5365 7269 6573 284c  s List2DSeries(L
+0000cde0: 696e 6532 4442 6173 6553 6572 6965 7329  ine2DBaseSeries)
+0000cdf0: 3a0a 2020 2020 2222 2252 6570 7265 7365  :.    """Represe
+0000ce00: 6e74 6174 696f 6e20 666f 7220 6120 6c69  ntation for a li
+0000ce10: 6e65 2063 6f6e 7369 7374 696e 6720 6f66  ne consisting of
+0000ce20: 206c 6973 7420 6f66 2070 6f69 6e74 732e   list of points.
+0000ce30: 2222 220a 0a20 2020 2064 6566 205f 5f69  """..    def __i
+0000ce40: 6e69 745f 5f28 7365 6c66 2c20 6c69 7374  nit__(self, list
+0000ce50: 5f78 2c20 6c69 7374 5f79 2c20 6c61 6265  _x, list_y, labe
+0000ce60: 6c3d 2222 2c20 2a2a 6b77 6172 6773 293a  l="", **kwargs):
+0000ce70: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
+0000ce80: 2e5f 5f69 6e69 745f 5f28 6c61 6265 6c3d  .__init__(label=
+0000ce90: 6c61 6265 6c2c 202a 2a6b 7761 7267 7329  label, **kwargs)
+0000cea0: 0a20 2020 2020 2020 206e 7020 3d20 696d  .        np = im
+0000ceb0: 706f 7274 5f6d 6f64 756c 6528 276e 756d  port_module('num
+0000cec0: 7079 2729 0a20 2020 2020 2020 2069 6620  py').        if 
+0000ced0: 6c65 6e28 6c69 7374 5f78 2920 213d 206c  len(list_x) != l
+0000cee0: 656e 286c 6973 745f 7929 3a0a 2020 2020  en(list_y):.    
+0000cef0: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+0000cf00: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
+0000cf10: 2020 2020 2020 2020 2020 2254 6865 2074            "The t
+0000cf20: 776f 206c 6973 7473 206f 6620 636f 6f72  wo lists of coor
+0000cf30: 6469 6e61 7465 7320 6d75 7374 2068 6176  dinates must hav
+0000cf40: 6520 7468 6520 7361 6d65 2022 0a20 2020  e the same ".   
+0000cf50: 2020 2020 2020 2020 2020 2020 2022 6e75               "nu
+0000cf60: 6d62 6572 206f 6620 656c 656d 656e 7473  mber of elements
+0000cf70: 2e5c 6e52 6563 6569 7665 643a 206c 656e  .\nReceived: len
+0000cf80: 286c 6973 745f 7829 203d 2025 7320 220a  (list_x) = %s ".
+0000cf90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cfa0: 2261 6e64 206c 656e 286c 6973 745f 7929  "and len(list_y)
+0000cfb0: 203d 2025 7322 2025 2028 6c65 6e28 6c69   = %s" % (len(li
+0000cfc0: 7374 5f78 292c 206c 656e 286c 6973 745f  st_x), len(list_
+0000cfd0: 7929 290a 2020 2020 2020 2020 2020 2020  y)).            
+0000cfe0: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+0000cff0: 626c 6f63 6b5f 6c61 6d62 6461 5f66 756e  block_lambda_fun
+0000d000: 6374 696f 6e73 286c 6973 745f 782c 206c  ctions(list_x, l
+0000d010: 6973 745f 7929 0a20 2020 2020 2020 2063  ist_y).        c
+0000d020: 6865 636b 203d 206c 616d 6264 6120 6c3a  heck = lambda l:
+0000d030: 205b 6973 696e 7374 616e 6365 2874 2c20   [isinstance(t, 
+0000d040: 4578 7072 2920 616e 6420 286e 6f74 2074  Expr) and (not t
+0000d050: 2e69 735f 6e75 6d62 6572 2920 666f 7220  .is_number) for 
+0000d060: 7420 696e 206c 5d0a 2020 2020 2020 2020  t in l].        
+0000d070: 6966 2061 6e79 2863 6865 636b 286c 6973  if any(check(lis
+0000d080: 745f 7829 202b 2063 6865 636b 286c 6973  t_x) + check(lis
+0000d090: 745f 7929 2920 6f72 2073 656c 662e 7061  t_y)) or self.pa
+0000d0a0: 7261 6d73 3a0a 2020 2020 2020 2020 2020  rams:.          
+0000d0b0: 2020 6966 206e 6f74 2073 656c 662e 7061    if not self.pa
+0000d0c0: 7261 6d73 3a0a 2020 2020 2020 2020 2020  rams:.          
+0000d0d0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+0000d0e0: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
+0000d0f0: 2020 2020 2020 2020 2020 2020 2253 6f6d              "Som
+0000d100: 6520 6f72 2061 6c6c 2065 6c65 6d65 6e74  e or all element
+0000d110: 7320 6f66 2074 6865 2070 726f 7669 6465  s of the provide
+0000d120: 6420 6c69 7374 7320 220a 2020 2020 2020  d lists ".      
+0000d130: 2020 2020 2020 2020 2020 2020 2020 2261                "a
+0000d140: 7265 2073 796d 626f 6c69 6320 6578 7072  re symbolic expr
+0000d150: 6573 7369 6f6e 732c 2062 7574 2074 6865  essions, but the
+0000d160: 2060 6070 6172 616d 7360 6020 6469 6374   ``params`` dict
+0000d170: 696f 6e61 7279 2022 0a20 2020 2020 2020  ionary ".       
+0000d180: 2020 2020 2020 2020 2020 2020 2022 7761               "wa
+0000d190: 7320 6e6f 7420 7072 6f76 6964 6564 3a20  s not provided: 
+0000d1a0: 7468 6f73 6520 656c 656d 656e 7473 2063  those elements c
+0000d1b0: 616e 2774 2062 6520 6576 616c 7561 7465  an't be evaluate
+0000d1c0: 642e 2229 0a20 2020 2020 2020 2020 2020  d.").           
+0000d1d0: 2073 656c 662e 6c69 7374 5f78 203d 2054   self.list_x = T
+0000d1e0: 7570 6c65 282a 6c69 7374 5f78 290a 2020  uple(*list_x).  
+0000d1f0: 2020 2020 2020 2020 2020 7365 6c66 2e6c            self.l
+0000d200: 6973 745f 7920 3d20 5475 706c 6528 2a6c  ist_y = Tuple(*l
+0000d210: 6973 745f 7929 0a20 2020 2020 2020 2065  ist_y).        e
+0000d220: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000d230: 2073 656c 662e 6c69 7374 5f78 203d 206e   self.list_x = n
+0000d240: 702e 6172 7261 7928 6c69 7374 5f78 2c20  p.array(list_x, 
+0000d250: 6474 7970 653d 6e70 2e66 6c6f 6174 3634  dtype=np.float64
+0000d260: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+0000d270: 6c66 2e6c 6973 745f 7920 3d20 6e70 2e61  lf.list_y = np.a
+0000d280: 7272 6179 286c 6973 745f 792c 2064 7479  rray(list_y, dty
+0000d290: 7065 3d6e 702e 666c 6f61 7436 3429 0a0a  pe=np.float64)..
+0000d2a0: 2020 2020 2020 2020 7365 6c66 2e5f 6578          self._ex
+0000d2b0: 7072 203d 2028 7365 6c66 2e6c 6973 745f  pr = (self.list_
+0000d2c0: 782c 2073 656c 662e 6c69 7374 5f79 290a  x, self.list_y).
+0000d2d0: 2020 2020 2020 2020 6966 206e 6f74 2061          if not a
+0000d2e0: 6e79 2869 7369 6e73 7461 6e63 6528 742c  ny(isinstance(t,
+0000d2f0: 206e 702e 6e64 6172 7261 7929 2066 6f72   np.ndarray) for
+0000d300: 2074 2069 6e20 5b73 656c 662e 6c69 7374   t in [self.list
+0000d310: 5f78 2c20 7365 6c66 2e6c 6973 745f 795d  _x, self.list_y]
+0000d320: 293a 0a20 2020 2020 2020 2020 2020 2073  ):.            s
+0000d330: 656c 662e 5f63 6865 636b 5f66 7328 290a  elf._check_fs().
+0000d340: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+0000d350: 2e75 7365 5f63 6d20 616e 6420 7365 6c66  .use_cm and self
+0000d360: 2e63 6f6c 6f72 5f66 756e 633a 0a20 2020  .color_func:.   
+0000d370: 2020 2020 2020 2020 2073 656c 662e 6973           self.is
+0000d380: 5f70 6172 616d 6574 7269 6320 3d20 5472  _parametric = Tr
+0000d390: 7565 0a20 2020 2020 2020 2020 2020 2069  ue.            i
+0000d3a0: 6620 6973 696e 7374 616e 6365 2873 656c  f isinstance(sel
+0000d3b0: 662e 636f 6c6f 725f 6675 6e63 2c20 4578  f.color_func, Ex
+0000d3c0: 7072 293a 0a20 2020 2020 2020 2020 2020  pr):.           
+0000d3d0: 2020 2020 2072 6169 7365 2054 7970 6545       raise TypeE
+0000d3e0: 7272 6f72 280a 2020 2020 2020 2020 2020  rror(.          
+0000d3f0: 2020 2020 2020 2020 2020 2225 7320 646f            "%s do
+0000d400: 6e27 7420 7375 7070 6f72 7420 7379 6d62  n't support symb
+0000d410: 6f6c 6963 2022 2025 2073 656c 662e 5f5f  olic " % self.__
+0000d420: 636c 6173 735f 5f2e 5f5f 6e61 6d65 5f5f  class__.__name__
+0000d430: 202b 0a20 2020 2020 2020 2020 2020 2020   +.             
+0000d440: 2020 2020 2020 2022 6578 7072 6573 7369         "expressi
+0000d450: 6f6e 2066 6f72 2060 636f 6c6f 725f 6675  on for `color_fu
+0000d460: 6e63 602e 2229 0a0a 2020 2020 6465 6620  nc`.")..    def 
+0000d470: 5f5f 7374 725f 5f28 7365 6c66 293a 0a20  __str__(self):. 
+0000d480: 2020 2020 2020 2070 7265 203d 2022 3244         pre = "2D
+0000d490: 2220 6966 2073 656c 662e 6973 5f32 446c  " if self.is_2Dl
+0000d4a0: 696e 6520 656c 7365 2022 3344 220a 2020  ine else "3D".  
+0000d4b0: 2020 2020 2020 7265 7475 726e 2070 7265        return pre
+0000d4c0: 202b 2022 206c 6973 7420 706c 6f74 220a   + " list plot".
+0000d4d0: 0a20 2020 2064 6566 205f 6765 745f 6461  .    def _get_da
+0000d4e0: 7461 5f68 656c 7065 7228 7365 6c66 293a  ta_helper(self):
+0000d4f0: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
+0000d500: 726e 7320 636f 6f72 6469 6e61 7465 7320  rns coordinates 
+0000d510: 7468 6174 206e 6565 6473 2074 6f20 6265  that needs to be
+0000d520: 2070 6f73 7470 726f 6365 7373 6564 2e22   postprocessed."
+0000d530: 2222 0a20 2020 2020 2020 206c 782c 206c  "".        lx, l
+0000d540: 7920 3d20 7365 6c66 2e6c 6973 745f 782c  y = self.list_x,
+0000d550: 2073 656c 662e 6c69 7374 5f79 0a0a 2020   self.list_y..  
+0000d560: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
+0000d570: 662e 6973 5f69 6e74 6572 6163 7469 7665  f.is_interactive
+0000d580: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000d590: 7475 726e 2073 656c 662e 5f65 7661 6c5f  turn self._eval_
+0000d5a0: 636f 6c6f 725f 6675 6e63 5f61 6e64 5f72  color_func_and_r
+0000d5b0: 6574 7572 6e28 6c78 2c20 6c79 290a 0a20  eturn(lx, ly).. 
+0000d5c0: 2020 2020 2020 206e 7020 3d20 696d 706f         np = impo
+0000d5d0: 7274 5f6d 6f64 756c 6528 276e 756d 7079  rt_module('numpy
+0000d5e0: 2729 0a20 2020 2020 2020 206c 7820 3d20  ').        lx = 
+0000d5f0: 6e70 2e61 7272 6179 285b 742e 6576 616c  np.array([t.eval
+0000d600: 6628 7375 6273 3d73 656c 662e 7061 7261  f(subs=self.para
+0000d610: 6d73 2920 666f 7220 7420 696e 206c 785d  ms) for t in lx]
+0000d620: 2c20 6474 7970 653d 666c 6f61 7429 0a20  , dtype=float). 
+0000d630: 2020 2020 2020 206c 7920 3d20 6e70 2e61         ly = np.a
+0000d640: 7272 6179 285b 742e 6576 616c 6628 7375  rray([t.evalf(su
+0000d650: 6273 3d73 656c 662e 7061 7261 6d73 2920  bs=self.params) 
+0000d660: 666f 7220 7420 696e 206c 795d 2c20 6474  for t in ly], dt
+0000d670: 7970 653d 666c 6f61 7429 0a20 2020 2020  ype=float).     
+0000d680: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+0000d690: 6576 616c 5f63 6f6c 6f72 5f66 756e 635f  eval_color_func_
+0000d6a0: 616e 645f 7265 7475 726e 286c 782c 206c  and_return(lx, l
+0000d6b0: 7929 0a0a 2020 2020 6465 6620 5f65 7661  y)..    def _eva
+0000d6c0: 6c5f 636f 6c6f 725f 6675 6e63 5f61 6e64  l_color_func_and
+0000d6d0: 5f72 6574 7572 6e28 7365 6c66 2c20 2a64  _return(self, *d
+0000d6e0: 6174 6129 3a0a 2020 2020 2020 2020 6966  ata):.        if
+0000d6f0: 2073 656c 662e 7573 655f 636d 2061 6e64   self.use_cm and
+0000d700: 2063 616c 6c61 626c 6528 7365 6c66 2e63   callable(self.c
+0000d710: 6f6c 6f72 5f66 756e 6329 3a0a 2020 2020  olor_func):.    
+0000d720: 2020 2020 2020 2020 7265 7475 726e 205b          return [
+0000d730: 2a64 6174 612c 2073 656c 662e 6576 616c  *data, self.eval
+0000d740: 5f63 6f6c 6f72 5f66 756e 6328 2a64 6174  _color_func(*dat
+0000d750: 6129 5d0a 2020 2020 2020 2020 7265 7475  a)].        retu
+0000d760: 726e 2064 6174 610a 0a0a 636c 6173 7320  rn data...class 
+0000d770: 4c69 7374 3344 5365 7269 6573 284c 6973  List3DSeries(Lis
+0000d780: 7432 4453 6572 6965 7329 3a0a 2020 2020  t2DSeries):.    
+0000d790: 6973 5f32 446c 696e 6520 3d20 4661 6c73  is_2Dline = Fals
+0000d7a0: 650a 2020 2020 6973 5f33 446c 696e 6520  e.    is_3Dline 
+0000d7b0: 3d20 5472 7565 0a0a 2020 2020 6465 6620  = True..    def 
+0000d7c0: 5f5f 696e 6974 5f5f 2873 656c 662c 206c  __init__(self, l
+0000d7d0: 6973 745f 782c 206c 6973 745f 792c 206c  ist_x, list_y, l
+0000d7e0: 6973 745f 7a2c 206c 6162 656c 3d22 222c  ist_z, label="",
+0000d7f0: 202a 2a6b 7761 7267 7329 3a0a 2020 2020   **kwargs):.    
+0000d800: 2020 2020 2320 544f 444f 3a20 7468 6973      # TODO: this
+0000d810: 2063 616e 2064 6566 696e 6974 656c 7920   can definitely 
+0000d820: 6265 2064 6f6e 6520 6265 7474 6572 0a20  be done better. 
+0000d830: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+0000d840: 5f69 6e69 745f 5f28 6c69 7374 5f78 2c20  _init__(list_x, 
+0000d850: 6c69 7374 5f79 2c20 6c61 6265 6c2c 202a  list_y, label, *
+0000d860: 2a6b 7761 7267 7329 0a20 2020 2020 2020  *kwargs).       
+0000d870: 206e 7020 3d20 696d 706f 7274 5f6d 6f64   np = import_mod
+0000d880: 756c 6528 276e 756d 7079 2729 0a20 2020  ule('numpy').   
+0000d890: 2020 2020 2069 6620 6c65 6e28 6c69 7374       if len(list
+0000d8a0: 5f7a 2920 213d 206c 656e 286c 6973 745f  _z) != len(list_
+0000d8b0: 7829 3a0a 2020 2020 2020 2020 2020 2020  x):.            
+0000d8c0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+0000d8d0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000d8e0: 2020 2254 6865 2074 6872 6565 206c 6973    "The three lis
+0000d8f0: 7473 206f 6620 636f 6f72 6469 6e61 7465  ts of coordinate
+0000d900: 7320 6d75 7374 2068 6176 6520 7468 6520  s must have the 
+0000d910: 7361 6d65 2022 0a20 2020 2020 2020 2020  same ".         
+0000d920: 2020 2020 2020 2022 6e75 6d62 6572 206f         "number o
+0000d930: 6620 656c 656d 656e 7473 2e5c 6e22 0a20  f elements.\n". 
+0000d940: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000d950: 5265 6365 6976 6564 3a20 6c65 6e28 6c69  Received: len(li
+0000d960: 7374 5f78 2920 3d20 6c65 6e28 6c69 7374  st_x) = len(list
+0000d970: 5f79 2920 3d20 7b7d 2022 2e66 6f72 6d61  _y) = {} ".forma
+0000d980: 7428 6c65 6e28 6c69 7374 5f78 2929 202b  t(len(list_x)) +
+0000d990: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d9a0: 2022 616e 6420 6c65 6e28 6c69 7374 5f7a   "and len(list_z
+0000d9b0: 2920 3d20 7b7d 222e 666f 726d 6174 286c  ) = {}".format(l
+0000d9c0: 656e 286c 6973 745f 7a29 290a 2020 2020  en(list_z)).    
+0000d9d0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000d9e0: 2020 7365 6c66 2e5f 626c 6f63 6b5f 6c61    self._block_la
+0000d9f0: 6d62 6461 5f66 756e 6374 696f 6e73 286c  mbda_functions(l
+0000da00: 6973 745f 7a29 0a20 2020 2020 2020 2063  ist_z).        c
+0000da10: 6865 636b 203d 206c 616d 6264 6120 6c3a  heck = lambda l:
+0000da20: 205b 6973 696e 7374 616e 6365 2874 2c20   [isinstance(t, 
+0000da30: 4578 7072 2920 616e 6420 286e 6f74 2074  Expr) and (not t
+0000da40: 2e69 735f 6e75 6d62 6572 2920 666f 7220  .is_number) for 
+0000da50: 7420 696e 206c 5d0a 2020 2020 2020 2020  t in l].        
+0000da60: 6966 2061 6e79 2863 6865 636b 286c 6973  if any(check(lis
+0000da70: 745f 7a29 293a 0a20 2020 2020 2020 2020  t_z)):.         
+0000da80: 2020 2069 6620 6e6f 7420 7365 6c66 2e70     if not self.p
+0000da90: 6172 616d 733a 0a20 2020 2020 2020 2020  arams:.         
+0000daa0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+0000dab0: 7565 4572 726f 7228 0a20 2020 2020 2020  ueError(.       
+0000dac0: 2020 2020 2020 2020 2020 2020 2022 536f               "So
+0000dad0: 6d65 206f 7220 616c 6c20 656c 656d 656e  me or all elemen
+0000dae0: 7473 206f 6620 7468 6520 7072 6f76 6964  ts of the provid
+0000daf0: 6564 206c 6973 7473 2022 0a20 2020 2020  ed lists ".     
+0000db00: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000db10: 6172 6520 7379 6d62 6f6c 6963 2065 7870  are symbolic exp
+0000db20: 7265 7373 696f 6e73 2c20 6275 7420 7468  ressions, but th
+0000db30: 6520 6060 7061 7261 6d73 6060 2064 6963  e ``params`` dic
+0000db40: 7469 6f6e 6172 7920 220a 2020 2020 2020  tionary ".      
+0000db50: 2020 2020 2020 2020 2020 2020 2020 2277                "w
+0000db60: 6173 206e 6f74 2070 726f 7669 6465 643a  as not provided:
+0000db70: 2074 686f 7365 2065 6c65 6d65 6e74 7320   those elements 
+0000db80: 6361 6e27 7420 6265 2065 7661 6c75 6174  can't be evaluat
+0000db90: 6564 2e22 290a 2020 2020 2020 2020 2020  ed.").          
+0000dba0: 2020 7365 6c66 2e6c 6973 745f 7a20 3d20    self.list_z = 
+0000dbb0: 5475 706c 6528 2a6c 6973 745f 7a29 0a20  Tuple(*list_z). 
+0000dbc0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000dbd0: 5f63 6865 636b 5f66 7328 290a 2020 2020  _check_fs().    
+0000dbe0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000dbf0: 2020 2020 2020 7365 6c66 2e6c 6973 745f        self.list_
+0000dc00: 7a20 3d20 6e70 2e61 7272 6179 286c 6973  z = np.array(lis
+0000dc10: 745f 7a2c 2064 7479 7065 3d6e 702e 666c  t_z, dtype=np.fl
+0000dc20: 6f61 7436 3429 0a0a 2020 2020 2020 2020  oat64)..        
+0000dc30: 7365 6c66 2e5f 6578 7072 203d 2028 7365  self._expr = (se
+0000dc40: 6c66 2e6c 6973 745f 782c 2073 656c 662e  lf.list_x, self.
+0000dc50: 6c69 7374 5f79 2c20 7365 6c66 2e6c 6973  list_y, self.lis
+0000dc60: 745f 7a29 0a0a 2020 2020 6465 6620 5f67  t_z)..    def _g
+0000dc70: 6574 5f64 6174 615f 6865 6c70 6572 2873  et_data_helper(s
+0000dc80: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+0000dc90: 2252 6574 7572 6e73 2063 6f6f 7264 696e  "Returns coordin
+0000dca0: 6174 6573 2074 6861 7420 6e65 6564 7320  ates that needs 
+0000dcb0: 746f 2062 6520 706f 7374 7072 6f63 6573  to be postproces
+0000dcc0: 7365 642e 2222 220a 2020 2020 2020 2020  sed.""".        
+0000dcd0: 6c78 2c20 6c79 2c20 6c7a 203d 2073 656c  lx, ly, lz = sel
+0000dce0: 662e 6c69 7374 5f78 2c20 7365 6c66 2e6c  f.list_x, self.l
+0000dcf0: 6973 745f 792c 2073 656c 662e 6c69 7374  ist_y, self.list
+0000dd00: 5f7a 0a0a 2020 2020 2020 2020 6966 206e  _z..        if n
+0000dd10: 6f74 2073 656c 662e 6973 5f69 6e74 6572  ot self.is_inter
+0000dd20: 6163 7469 7665 3a0a 2020 2020 2020 2020  active:.        
+0000dd30: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0000dd40: 5f65 7661 6c5f 636f 6c6f 725f 6675 6e63  _eval_color_func
+0000dd50: 5f61 6e64 5f72 6574 7572 6e28 6c78 2c20  _and_return(lx, 
+0000dd60: 6c79 2c20 6c7a 290a 0a20 2020 2020 2020  ly, lz)..       
+0000dd70: 206e 7020 3d20 696d 706f 7274 5f6d 6f64   np = import_mod
+0000dd80: 756c 6528 276e 756d 7079 2729 0a20 2020  ule('numpy').   
+0000dd90: 2020 2020 206c 7820 3d20 6e70 2e61 7272       lx = np.arr
+0000dda0: 6179 285b 742e 6576 616c 6628 7375 6273  ay([t.evalf(subs
+0000ddb0: 3d73 656c 662e 7061 7261 6d73 2920 666f  =self.params) fo
+0000ddc0: 7220 7420 696e 206c 785d 2c20 6474 7970  r t in lx], dtyp
+0000ddd0: 653d 666c 6f61 7429 0a20 2020 2020 2020  e=float).       
+0000dde0: 206c 7920 3d20 6e70 2e61 7272 6179 285b   ly = np.array([
+0000ddf0: 742e 6576 616c 6628 7375 6273 3d73 656c  t.evalf(subs=sel
+0000de00: 662e 7061 7261 6d73 2920 666f 7220 7420  f.params) for t 
+0000de10: 696e 206c 795d 2c20 6474 7970 653d 666c  in ly], dtype=fl
+0000de20: 6f61 7429 0a20 2020 2020 2020 206c 7a20  oat).        lz 
+0000de30: 3d20 6e70 2e61 7272 6179 285b 742e 6576  = np.array([t.ev
+0000de40: 616c 6628 7375 6273 3d73 656c 662e 7061  alf(subs=self.pa
+0000de50: 7261 6d73 2920 666f 7220 7420 696e 206c  rams) for t in l
+0000de60: 7a5d 2c20 6474 7970 653d 666c 6f61 7429  z], dtype=float)
+0000de70: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000de80: 7365 6c66 2e5f 6576 616c 5f63 6f6c 6f72  self._eval_color
+0000de90: 5f66 756e 635f 616e 645f 7265 7475 726e  _func_and_return
+0000dea0: 286c 782c 206c 792c 206c 7a29 0a0a 0a63  (lx, ly, lz)...c
+0000deb0: 6c61 7373 204c 696e 654f 7665 7231 4452  lass LineOver1DR
+0000dec0: 616e 6765 5365 7269 6573 280a 2020 2020  angeSeries(.    
+0000ded0: 436f 6d6d 6f6e 4164 6170 7469 7665 4576  CommonAdaptiveEv
+0000dee0: 616c 7561 7469 6f6e 2c20 436f 6d6d 6f6e  aluation, Common
+0000def0: 556e 6966 6f72 6d45 7661 6c75 6174 696f  UniformEvaluatio
+0000df00: 6e2c 204c 696e 6532 4442 6173 6553 6572  n, Line2DBaseSer
+0000df10: 6965 730a 293a 0a20 2020 2022 2222 5265  ies.):.    """Re
+0000df20: 7072 6573 656e 7461 7469 6f6e 2066 6f72  presentation for
+0000df30: 2061 206c 696e 6520 636f 6e73 6973 7469   a line consisti
+0000df40: 6e67 206f 6620 6120 5379 6d50 7920 6578  ng of a SymPy ex
+0000df50: 7072 6573 7369 6f6e 206f 7665 7220 610a  pression over a.
+0000df60: 2020 2020 7265 616c 2072 616e 6765 2e22      real range."
+0000df70: 2222 0a0a 2020 2020 5f61 6c6c 6f77 6564  ""..    _allowed
+0000df80: 5f6b 6579 7320 3d20 5b0a 2020 2020 2020  _keys = [.      
+0000df90: 2020 2261 6273 6172 6722 2c20 2269 735f    "absarg", "is_
+0000dfa0: 636f 6d70 6c65 7822 2c20 2269 735f 706f  complex", "is_po
+0000dfb0: 6c61 7222 0a20 2020 205d 0a0a 2020 2020  lar".    ]..    
+0000dfc0: 6465 6620 5f5f 6e65 775f 5f28 636c 732c  def __new__(cls,
+0000dfd0: 202a 6172 6773 2c20 2a2a 6b77 6172 6773   *args, **kwargs
+0000dfe0: 293a 0a20 2020 2020 2020 2069 6620 6b77  ):.        if kw
+0000dff0: 6172 6773 2e67 6574 2822 6162 7361 7267  args.get("absarg
+0000e000: 222c 2046 616c 7365 293a 0a20 2020 2020  ", False):.     
+0000e010: 2020 2020 2020 2072 6574 7572 6e20 7375         return su
+0000e020: 7065 7228 292e 5f5f 6e65 775f 5f28 4162  per().__new__(Ab
+0000e030: 7341 7267 4c69 6e65 5365 7269 6573 290a  sArgLineSeries).
+0000e040: 2020 2020 2020 2020 6366 203d 206b 7761          cf = kwa
+0000e050: 7267 732e 6765 7428 2263 6f6c 6f72 5f66  rgs.get("color_f
+0000e060: 756e 6322 2c20 4e6f 6e65 290a 2020 2020  unc", None).    
+0000e070: 2020 2020 6c63 203d 206b 7761 7267 732e      lc = kwargs.
+0000e080: 6765 7428 226c 696e 655f 636f 6c6f 7222  get("line_color"
+0000e090: 2c20 4e6f 6e65 290a 2020 2020 2020 2020  , None).        
+0000e0a0: 6966 2028 6361 6c6c 6162 6c65 2863 6629  if (callable(cf)
+0000e0b0: 206f 7220 6361 6c6c 6162 6c65 286c 6329   or callable(lc)
+0000e0c0: 206f 7220 6973 696e 7374 616e 6365 2863   or isinstance(c
+0000e0d0: 662c 2045 7870 7229 293a 0a20 2020 2020  f, Expr)):.     
+0000e0e0: 2020 2020 2020 2072 6574 7572 6e20 7375         return su
+0000e0f0: 7065 7228 292e 5f5f 6e65 775f 5f28 436f  per().__new__(Co
+0000e100: 6c6f 7265 644c 696e 654f 7665 7231 4452  loredLineOver1DR
+0000e110: 616e 6765 5365 7269 6573 290a 2020 2020  angeSeries).    
+0000e120: 2020 2020 7265 7475 726e 206f 626a 6563      return objec
+0000e130: 742e 5f5f 6e65 775f 5f28 636c 7329 0a0a  t.__new__(cls)..
+0000e140: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+0000e150: 2873 656c 662c 2065 7870 722c 2076 6172  (self, expr, var
+0000e160: 5f73 7461 7274 5f65 6e64 2c20 6c61 6265  _start_end, labe
+0000e170: 6c3d 2222 2c20 2a2a 6b77 6172 6773 293a  l="", **kwargs):
+0000e180: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
+0000e190: 2e5f 5f69 6e69 745f 5f28 2a2a 6b77 6172  .__init__(**kwar
+0000e1a0: 6773 290a 2020 2020 2020 2020 7365 6c66  gs).        self
+0000e1b0: 2e65 7870 7220 3d20 6578 7072 2069 6620  .expr = expr if 
+0000e1c0: 6361 6c6c 6162 6c65 2865 7870 7229 2065  callable(expr) e
+0000e1d0: 6c73 6520 7379 6d70 6966 7928 6578 7072  lse sympify(expr
+0000e1e0: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+0000e1f0: 6c61 6265 6c20 3d20 7374 7228 7365 6c66  label = str(self
+0000e200: 2e65 7870 7229 2069 6620 6c61 6265 6c20  .expr) if label 
+0000e210: 6973 204e 6f6e 6520 656c 7365 206c 6162  is None else lab
+0000e220: 656c 0a20 2020 2020 2020 2073 656c 662e  el.        self.
+0000e230: 5f6c 6174 6578 5f6c 6162 656c 203d 206c  _latex_label = l
+0000e240: 6174 6578 2873 656c 662e 6578 7072 2920  atex(self.expr) 
+0000e250: 6966 206c 6162 656c 2069 7320 4e6f 6e65  if label is None
+0000e260: 2065 6c73 6520 6c61 6265 6c0a 2020 2020   else label.    
+0000e270: 2020 2020 7365 6c66 2e72 616e 6765 7320      self.ranges 
+0000e280: 3d20 5b76 6172 5f73 7461 7274 5f65 6e64  = [var_start_end
+0000e290: 5d0a 2020 2020 2020 2020 2320 7468 6973  ].        # this
+0000e2a0: 2069 7320 7573 6564 2074 6f20 6361 7374   is used to cast
+0000e2b0: 2074 6865 2076 616c 7565 7320 6f66 2072   the values of r
+0000e2c0: 616e 6765 7320 7768 656e 2073 656c 662e  anges when self.
+0000e2d0: 7374 6172 742f 7365 6c66 2e65 6e64 0a20  start/self.end. 
+0000e2e0: 2020 2020 2020 2023 2061 7265 2063 616c         # are cal
+0000e2f0: 6c65 642e 2055 7365 6420 666f 7220 6261  led. Used for ba
+0000e300: 636b 2d63 6f6d 7061 7469 6269 6c69 7479  ck-compatibility
+0000e310: 2077 6974 6820 6f6c 6420 7379 6d70 792e   with old sympy.
+0000e320: 706c 6f74 7469 6e67 2c0a 2020 2020 2020  plotting,.      
+0000e330: 2020 2320 6974 2069 7320 6e6f 7720 6469    # it is now di
+0000e340: 6666 6963 756c 7420 746f 2072 656d 6f76  fficult to remov
+0000e350: 652e 0a20 2020 2020 2020 2073 656c 662e  e..        self.
+0000e360: 5f63 6173 7420 3d20 636f 6d70 6c65 780a  _cast = complex.
+0000e370: 2020 2020 2020 2020 2320 666f 7220 636f          # for co
+0000e380: 6d70 6c65 782d 7265 6c61 7465 6420 6461  mplex-related da
+0000e390: 7461 2073 6572 6965 732c 2074 6869 7320  ta series, this 
+0000e3a0: 6465 7465 726d 696e 6573 2077 6861 7420  determines what 
+0000e3b0: 6461 7461 2074 6f20 7265 7475 726e 0a20  data to return. 
+0000e3c0: 2020 2020 2020 2023 206f 6e20 7468 6520         # on the 
+0000e3d0: 792d 6178 6973 0a20 2020 2020 2020 2073  y-axis.        s
+0000e3e0: 656c 662e 5f72 6574 7572 6e20 3d20 6b77  elf._return = kw
+0000e3f0: 6172 6773 2e67 6574 2822 7265 7475 726e  args.get("return
+0000e400: 222c 204e 6f6e 6529 0a20 2020 2020 2020  ", None).       
+0000e410: 2073 656c 662e 5f70 6f73 745f 696e 6974   self._post_init
+0000e420: 2829 0a0a 2020 2020 2020 2020 6966 206e  ()..        if n
+0000e430: 6f74 2073 656c 662e 5f69 6e74 6572 6163  ot self._interac
+0000e440: 7469 7665 5f72 616e 6765 733a 0a20 2020  tive_ranges:.   
+0000e450: 2020 2020 2020 2020 2023 204e 4f54 453a           # NOTE:
+0000e460: 2074 6865 2066 6f6c 6c6f 7769 6e67 2063   the following c
+0000e470: 6865 636b 2069 7320 6f6e 6c79 2070 6f73  heck is only pos
+0000e480: 7369 626c 6520 7768 656e 2074 6865 206d  sible when the m
+0000e490: 696e 696d 756d 2061 6e64 0a20 2020 2020  inimum and.     
+0000e4a0: 2020 2020 2020 2023 206d 6178 696d 756d         # maximum
+0000e4b0: 2076 616c 7565 7320 6f66 2061 2070 6c6f   values of a plo
+0000e4c0: 7474 696e 6720 7261 6e67 6520 6172 6520  tting range are 
+0000e4d0: 6e75 6d65 7269 630a 2020 2020 2020 2020  numeric.        
+0000e4e0: 2020 2020 7374 6172 742c 2065 6e64 203d      start, end =
+0000e4f0: 205b 636f 6d70 6c65 7828 7429 2066 6f72   [complex(t) for
+0000e500: 2074 2069 6e20 7365 6c66 2e72 616e 6765   t in self.range
+0000e510: 735b 305d 5b31 3a5d 5d0a 2020 2020 2020  s[0][1:]].      
+0000e520: 2020 2020 2020 6966 2069 6d28 7374 6172        if im(star
+0000e530: 7429 2021 3d20 696d 2865 6e64 293a 0a20  t) != im(end):. 
+0000e540: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000e550: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+0000e560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e570: 2020 2020 2022 2573 2072 6571 7569 7265       "%s require
+0000e580: 7320 7468 6520 696d 6167 696e 6172 7920  s the imaginary 
+0000e590: 2220 2520 7365 6c66 2e5f 5f63 6c61 7373  " % self.__class
+0000e5a0: 5f5f 2e5f 5f6e 616d 655f 5f20 2b0a 2020  __.__name__ +.  
+0000e5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e5c0: 2020 2270 6172 7420 6f66 2074 6865 2073    "part of the s
+0000e5d0: 7461 7274 2061 6e64 2065 6e64 2076 616c  tart and end val
+0000e5e0: 7565 7320 6f66 2074 6865 2072 616e 6765  ues of the range
+0000e5f0: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
+0000e600: 2020 2020 2020 2022 746f 2062 6520 7468         "to be th
+0000e610: 6520 7361 6d65 2e22 290a 0a20 2020 2064  e same.")..    d
+0000e620: 6566 205f 5f73 7472 5f5f 2873 656c 6629  ef __str__(self)
+0000e630: 3a0a 2020 2020 2020 2020 6465 6620 6628  :.        def f(
+0000e640: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
+0000e650: 6966 2069 7369 6e73 7461 6e63 6528 742c  if isinstance(t,
+0000e660: 2063 6f6d 706c 6578 293a 0a20 2020 2020   complex):.     
+0000e670: 2020 2020 2020 2020 2020 2069 6620 742e             if t.
+0000e680: 696d 6167 2021 3d20 303a 0a20 2020 2020  imag != 0:.     
+0000e690: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000e6a0: 6574 7572 6e20 740a 2020 2020 2020 2020  eturn t.        
+0000e6b0: 2020 2020 2020 2020 7265 7475 726e 2074          return t
+0000e6c0: 2e72 6561 6c0a 2020 2020 2020 2020 2020  .real.          
+0000e6d0: 2020 7265 7475 726e 2074 0a20 2020 2020    return t.     
+0000e6e0: 2020 2070 7265 203d 2022 696e 7465 7261     pre = "intera
+0000e6f0: 6374 6976 6520 2220 6966 2073 656c 662e  ctive " if self.
+0000e700: 6973 5f69 6e74 6572 6163 7469 7665 2065  is_interactive e
+0000e710: 6c73 6520 2222 0a20 2020 2020 2020 2070  lse "".        p
+0000e720: 6f73 7420 3d20 2222 0a20 2020 2020 2020  ost = "".       
+0000e730: 2069 6620 7365 6c66 2e69 735f 696e 7465   if self.is_inte
+0000e740: 7261 6374 6976 653a 0a20 2020 2020 2020  ractive:.       
+0000e750: 2020 2020 2070 6f73 7420 3d20 2220 616e       post = " an
+0000e760: 6420 7061 7261 6d65 7465 7273 2022 202b  d parameters " +
+0000e770: 2073 7472 2874 7570 6c65 2873 656c 662e   str(tuple(self.
+0000e780: 7061 7261 6d73 2e6b 6579 7328 2929 290a  params.keys())).
+0000e790: 2020 2020 2020 2020 7772 6170 7065 7220          wrapper 
+0000e7a0: 3d20 5f67 6574 5f77 7261 7070 6572 5f66  = _get_wrapper_f
+0000e7b0: 6f72 5f65 7870 7228 7365 6c66 2e5f 7265  or_expr(self._re
+0000e7c0: 7475 726e 290a 2020 2020 2020 2020 7265  turn).        re
+0000e7d0: 7475 726e 2070 7265 202b 2022 6361 7274  turn pre + "cart
+0000e7e0: 6573 6961 6e20 6c69 6e65 3a20 2573 2066  esian line: %s f
+0000e7f0: 6f72 2025 7320 6f76 6572 2025 7322 2025  or %s over %s" %
+0000e800: 2028 0a20 2020 2020 2020 2020 2020 2077   (.            w
+0000e810: 7261 7070 6572 2025 2073 656c 662e 6578  rapper % self.ex
+0000e820: 7072 2c0a 2020 2020 2020 2020 2020 2020  pr,.            
+0000e830: 7374 7228 7365 6c66 2e76 6172 292c 0a20  str(self.var),. 
+0000e840: 2020 2020 2020 2020 2020 2073 7472 2828             str((
+0000e850: 6628 7365 6c66 2e73 7461 7274 292c 2066  f(self.start), f
+0000e860: 2873 656c 662e 656e 6429 2929 2c0a 2020  (self.end))),.  
+0000e870: 2020 2020 2020 2920 2b20 706f 7374 0a0a        ) + post..
+0000e880: 2020 2020 6465 6620 5f61 6461 7074 6976      def _adaptiv
+0000e890: 655f 7361 6d70 6c69 6e67 2873 656c 6629  e_sampling(self)
+0000e8a0: 3a0a 2020 2020 2020 2020 6e70 203d 2069  :.        np = i
+0000e8b0: 6d70 6f72 745f 6d6f 6475 6c65 2827 6e75  mport_module('nu
+0000e8c0: 6d70 7927 290a 0a20 2020 2020 2020 2064  mpy')..        d
+0000e8d0: 6566 2066 756e 6328 662c 2069 6d61 672c  ef func(f, imag,
+0000e8e0: 2078 293a 0a20 2020 2020 2020 2020 2020   x):.           
+0000e8f0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+0000e900: 2020 2020 2020 7720 3d20 636f 6d70 6c65        w = comple
+0000e910: 7828 6628 7820 2b20 316a 202a 2069 6d61  x(f(x + 1j * ima
+0000e920: 6729 290a 2020 2020 2020 2020 2020 2020  g)).            
+0000e930: 2020 2020 7265 7475 726e 2077 2e72 6561      return w.rea
+0000e940: 6c2c 2077 2e69 6d61 670a 2020 2020 2020  l, w.imag.      
+0000e950: 2020 2020 2020 6578 6365 7074 2028 5a65        except (Ze
+0000e960: 726f 4469 7669 7369 6f6e 4572 726f 722c  roDivisionError,
+0000e970: 204f 7665 7266 6c6f 7745 7272 6f72 293a   OverflowError):
+0000e980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e990: 2072 6574 7572 6e20 6e70 2e6e 616e 2c20   return np.nan, 
+0000e9a0: 6e70 2e6e 616e 0a0a 2020 2020 2020 2020  np.nan..        
+0000e9b0: 6461 7461 203d 205f 6164 6170 7469 7665  data = _adaptive
+0000e9c0: 5f65 7661 6c28 0a20 2020 2020 2020 2020  _eval(.         
+0000e9d0: 2020 2066 756e 632c 205b 7365 6c66 2e76     func, [self.v
+0000e9e0: 6172 5d2c 2073 656c 662e 6578 7072 2c0a  ar], self.expr,.
+0000e9f0: 2020 2020 2020 2020 2020 2020 5b63 6f6d              [com
+0000ea00: 706c 6578 2873 656c 662e 7374 6172 7429  plex(self.start)
+0000ea10: 2e72 6561 6c2c 2063 6f6d 706c 6578 2873  .real, complex(s
+0000ea20: 656c 662e 656e 6429 2e72 6561 6c5d 2c0a  elf.end).real],.
+0000ea30: 2020 2020 2020 2020 2020 2020 636f 6d70              comp
+0000ea40: 6c65 7828 7365 6c66 2e73 7461 7274 292e  lex(self.start).
+0000ea50: 696d 6167 2c0a 2020 2020 2020 2020 2020  imag,.          
+0000ea60: 2020 6d6f 6475 6c65 733d 7365 6c66 2e6d    modules=self.m
+0000ea70: 6f64 756c 6573 2c0a 2020 2020 2020 2020  odules,.        
+0000ea80: 2020 2020 6164 6170 7469 7665 5f67 6f61      adaptive_goa
+0000ea90: 6c3d 7365 6c66 2e61 6461 7074 6976 655f  l=self.adaptive_
+0000eaa0: 676f 616c 2c0a 2020 2020 2020 2020 2020  goal,.          
+0000eab0: 2020 6c6f 7373 5f66 6e3d 7365 6c66 2e6c    loss_fn=self.l
+0000eac0: 6f73 735f 666e 290a 2020 2020 2020 2020  oss_fn).        
+0000ead0: 7265 7475 726e 2064 6174 615b 3a2c 2030  return data[:, 0
+0000eae0: 5d2c 2064 6174 615b 3a2c 2031 5d2c 2064  ], data[:, 1], d
+0000eaf0: 6174 615b 3a2c 2032 5d0a 0a20 2020 2064  ata[:, 2]..    d
+0000eb00: 6566 205f 756e 6966 6f72 6d5f 7361 6d70  ef _uniform_samp
+0000eb10: 6c69 6e67 2873 656c 6629 3a0a 2020 2020  ling(self):.    
+0000eb20: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
+0000eb30: 6d6f 6475 6c65 2827 6e75 6d70 7927 290a  module('numpy').
+0000eb40: 0a20 2020 2020 2020 2078 2c20 7265 7375  .        x, resu
+0000eb50: 6c74 203d 2073 656c 662e 5f65 7661 6c75  lt = self._evalu
+0000eb60: 6174 6528 290a 2020 2020 2020 2020 5f72  ate().        _r
+0000eb70: 652c 205f 696d 203d 206e 702e 7265 616c  e, _im = np.real
+0000eb80: 2872 6573 756c 7429 2c20 6e70 2e69 6d61  (result), np.ima
+0000eb90: 6728 7265 7375 6c74 290a 2020 2020 2020  g(result).      
+0000eba0: 2020 5f72 6520 3d20 7365 6c66 2e5f 636f    _re = self._co
+0000ebb0: 7272 6563 745f 7368 6170 6528 5f72 652c  rrect_shape(_re,
+0000ebc0: 2078 290a 2020 2020 2020 2020 5f69 6d20   x).        _im 
+0000ebd0: 3d20 7365 6c66 2e5f 636f 7272 6563 745f  = self._correct_
+0000ebe0: 7368 6170 6528 5f69 6d2c 2078 290a 2020  shape(_im, x).  
+0000ebf0: 2020 2020 2020 7265 7475 726e 2078 2c20        return x, 
+0000ec00: 5f72 652c 205f 696d 0a0a 2020 2020 6465  _re, _im..    de
+0000ec10: 6620 5f67 6574 5f72 6561 6c5f 696d 6167  f _get_real_imag
+0000ec20: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0000ec30: 2222 2220 4279 2065 7661 6c75 6174 696e  """ By evaluatin
+0000ec40: 6720 7468 6520 6675 6e63 7469 6f6e 206f  g the function o
+0000ec50: 7665 7220 6120 636f 6d70 6c65 7820 7261  ver a complex ra
+0000ec60: 6e67 6520 6974 2073 686f 756c 640a 2020  nge it should.  
+0000ec70: 2020 2020 2020 7265 7475 726e 2063 6f6d        return com
+0000ec80: 706c 6578 2076 616c 7565 732e 2054 6865  plex values. The
+0000ec90: 2069 6d61 6769 6e61 7279 2070 6172 7420   imaginary part 
+0000eca0: 6361 6e20 6265 2075 7365 6420 746f 206d  can be used to m
+0000ecb0: 6173 6b20 6f75 7420 7468 650a 2020 2020  ask out the.    
+0000ecc0: 2020 2020 756e 7761 6e74 6564 2076 616c      unwanted val
+0000ecd0: 7565 732e 0a20 2020 2020 2020 2022 2222  ues..        """
+0000ece0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+0000ecf0: 2e61 6461 7074 6976 653a 0a20 2020 2020  .adaptive:.     
+0000ed00: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000ed10: 6c66 2e5f 6164 6170 7469 7665 5f73 616d  lf._adaptive_sam
+0000ed20: 706c 696e 6728 290a 2020 2020 2020 2020  pling().        
+0000ed30: 7265 7475 726e 2073 656c 662e 5f75 6e69  return self._uni
+0000ed40: 666f 726d 5f73 616d 706c 696e 6728 290a  form_sampling().
+0000ed50: 0a20 2020 2064 6566 205f 6765 745f 6461  .    def _get_da
+0000ed60: 7461 5f68 656c 7065 7228 7365 6c66 293a  ta_helper(self):
+0000ed70: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
+0000ed80: 726e 7320 636f 6f72 6469 6e61 7465 7320  rns coordinates 
+0000ed90: 7468 6174 206e 6565 6473 2074 6f20 6265  that needs to be
+0000eda0: 2070 6f73 7470 726f 6365 7373 6564 2e0a   postprocessed..
+0000edb0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000edc0: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
+0000edd0: 6d6f 6475 6c65 2827 6e75 6d70 7927 290a  module('numpy').
+0000ede0: 0a20 2020 2020 2020 2078 2c20 5f72 652c  .        x, _re,
+0000edf0: 205f 696d 203d 2073 656c 662e 5f67 6574   _im = self._get
+0000ee00: 5f72 6561 6c5f 696d 6167 2829 0a0a 2020  _real_imag()..  
+0000ee10: 2020 2020 2020 6966 2073 656c 662e 5f72        if self._r
+0000ee20: 6574 7572 6e20 6973 204e 6f6e 653a 0a20  eturn is None:. 
+0000ee30: 2020 2020 2020 2020 2020 2023 2054 6865             # The
+0000ee40: 2065 7661 6c75 6174 696f 6e20 636f 756c   evaluation coul
+0000ee50: 6420 7072 6f64 7563 6520 636f 6d70 6c65  d produce comple
+0000ee60: 7820 6e75 6d62 6572 732e 2053 6574 2072  x numbers. Set r
+0000ee70: 6561 6c20 656c 656d 656e 7473 0a20 2020  eal elements.   
+0000ee80: 2020 2020 2020 2020 2023 2074 6f20 4e61           # to Na
+0000ee90: 4e20 7768 6572 6520 7468 6572 6520 6172  N where there ar
+0000eea0: 6520 6e6f 6e2d 7a65 726f 2069 6d61 6769  e non-zero imagi
+0000eeb0: 6e61 7279 2065 6c65 6d65 6e74 730a 2020  nary elements.  
+0000eec0: 2020 2020 2020 2020 2020 5f72 655b 6e70            _re[np
+0000eed0: 2e69 6e76 6572 7428 6e70 2e69 7363 6c6f  .invert(np.isclo
+0000eee0: 7365 285f 696d 2c20 6e70 2e7a 6572 6f73  se(_im, np.zeros
+0000eef0: 5f6c 696b 6528 5f69 6d29 2929 5d20 3d20  _like(_im)))] = 
+0000ef00: 6e70 2e6e 616e 0a20 2020 2020 2020 2065  np.nan.        e
+0000ef10: 6c69 6620 7365 6c66 2e5f 7265 7475 726e  lif self._return
+0000ef20: 203d 3d20 2272 6561 6c22 3a0a 2020 2020   == "real":.    
+0000ef30: 2020 2020 2020 2020 7061 7373 0a20 2020          pass.   
+0000ef40: 2020 2020 2065 6c69 6620 7365 6c66 2e5f       elif self._
+0000ef50: 7265 7475 726e 203d 3d20 2269 6d61 6722  return == "imag"
+0000ef60: 3a0a 2020 2020 2020 2020 2020 2020 5f72  :.            _r
+0000ef70: 6520 3d20 5f69 6d0a 2020 2020 2020 2020  e = _im.        
+0000ef80: 656c 6966 2073 656c 662e 5f72 6574 7572  elif self._retur
+0000ef90: 6e20 3d3d 2022 6162 7322 3a0a 2020 2020  n == "abs":.    
+0000efa0: 2020 2020 2020 2020 5f72 6520 3d20 6e70          _re = np
+0000efb0: 2e73 7172 7428 5f72 652a 2a32 202b 205f  .sqrt(_re**2 + _
+0000efc0: 696d 2a2a 3229 0a20 2020 2020 2020 2065  im**2).        e
+0000efd0: 6c69 6620 7365 6c66 2e5f 7265 7475 726e  lif self._return
+0000efe0: 203d 3d20 2261 7267 223a 0a20 2020 2020   == "arg":.     
+0000eff0: 2020 2020 2020 205f 7265 203d 206e 702e         _re = np.
+0000f000: 6172 6374 616e 3228 5f69 6d2c 205f 7265  arctan2(_im, _re
+0000f010: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+0000f020: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000f030: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
+0000f040: 2020 2020 2020 2020 2020 2020 2020 2260                "`
+0000f050: 5f72 6574 7572 6e60 206e 6f74 2072 6563  _return` not rec
+0000f060: 6f67 6e69 7a65 642e 2052 6563 6569 7665  ognized. Receive
+0000f070: 643a 2025 7322 2025 2073 656c 662e 5f72  d: %s" % self._r
+0000f080: 6574 7572 6e29 0a0a 2020 2020 2020 2020  eturn)..        
+0000f090: 7265 7475 726e 2078 2c20 5f72 650a 0a0a  return x, _re...
+0000f0a0: 636c 6173 7320 436f 6c6f 7265 644c 696e  class ColoredLin
+0000f0b0: 654f 7665 7231 4452 616e 6765 5365 7269  eOver1DRangeSeri
+0000f0c0: 6573 284c 696e 654f 7665 7231 4452 616e  es(LineOver1DRan
+0000f0d0: 6765 5365 7269 6573 293a 0a20 2020 2022  geSeries):.    "
+0000f0e0: 2222 5265 7072 6573 656e 7473 2061 2032  ""Represents a 2
+0000f0f0: 4420 6c69 6e65 2073 6572 6965 7320 696e  D line series in
+0000f100: 2077 6869 6368 2060 636f 6c6f 725f 6675   which `color_fu
+0000f110: 6e63 6020 6973 2061 2063 616c 6c61 626c  nc` is a callabl
+0000f120: 652e 0a20 2020 2022 2222 0a20 2020 2069  e..    """.    i
+0000f130: 735f 7061 7261 6d65 7472 6963 203d 2054  s_parametric = T
+0000f140: 7275 650a 0a20 2020 2064 6566 205f 5f69  rue..    def __i
+0000f150: 6e69 745f 5f28 7365 6c66 2c20 2a61 7267  nit__(self, *arg
+0000f160: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
+0000f170: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
+0000f180: 696e 6974 5f5f 282a 6172 6773 2c20 2a2a  init__(*args, **
+0000f190: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
+0000f1a0: 7365 6c66 2e75 7365 5f63 6d20 3d20 6b77  self.use_cm = kw
+0000f1b0: 6172 6773 2e67 6574 2822 7573 655f 636d  args.get("use_cm
+0000f1c0: 222c 2054 7275 6529 0a0a 2020 2020 6465  ", True)..    de
+0000f1d0: 6620 5f67 6574 5f64 6174 615f 6865 6c70  f _get_data_help
+0000f1e0: 6572 2873 656c 6629 3a0a 2020 2020 2020  er(self):.      
+0000f1f0: 2020 2222 2252 6574 7572 6e73 2063 6f6f    """Returns coo
+0000f200: 7264 696e 6174 6573 2074 6861 7420 6e65  rdinates that ne
+0000f210: 6564 7320 746f 2062 6520 706f 7374 7072  eds to be postpr
+0000f220: 6f63 6573 7365 642e 0a20 2020 2020 2020  ocessed..       
+0000f230: 2044 6570 656e 6469 6e67 206f 6e20 7468   Depending on th
+0000f240: 6520 6061 6461 7074 6976 6560 206f 7074  e `adaptive` opt
+0000f250: 696f 6e2c 2074 6869 7320 6675 6e63 7469  ion, this functi
+0000f260: 6f6e 2077 696c 6c20 6569 7468 6572 2075  on will either u
+0000f270: 7365 2061 6e0a 2020 2020 2020 2020 6164  se an.        ad
+0000f280: 6170 7469 7665 2061 6c67 6f72 6974 686d  aptive algorithm
+0000f290: 206f 7220 6974 2077 696c 6c20 756e 6966   or it will unif
+0000f2a0: 6f72 6d6c 7920 7361 6d70 6c65 2074 6865  ormly sample the
+0000f2b0: 2065 7870 7265 7373 696f 6e20 6f76 6572   expression over
+0000f2c0: 2074 6865 0a20 2020 2020 2020 2070 726f   the.        pro
+0000f2d0: 7669 6465 6420 7261 6e67 652e 0a20 2020  vided range..   
+0000f2e0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000f2f0: 2078 2c20 7920 3d20 7375 7065 7228 292e   x, y = super().
+0000f300: 5f67 6574 5f64 6174 615f 6865 6c70 6572  _get_data_helper
+0000f310: 2829 0a20 2020 2020 2020 2072 6574 7572  ().        retur
+0000f320: 6e20 782c 2079 2c20 7365 6c66 2e65 7661  n x, y, self.eva
+0000f330: 6c5f 636f 6c6f 725f 6675 6e63 2878 2c20  l_color_func(x, 
+0000f340: 7929 0a0a 0a63 6c61 7373 2041 6273 4172  y)...class AbsAr
+0000f350: 674c 696e 6553 6572 6965 7328 4c69 6e65  gLineSeries(Line
+0000f360: 4f76 6572 3144 5261 6e67 6553 6572 6965  Over1DRangeSerie
+0000f370: 7329 3a0a 2020 2020 2222 2252 6570 7265  s):.    """Repre
+0000f380: 7365 6e74 7320 7468 6520 6162 736f 6c75  sents the absolu
+0000f390: 7465 2076 616c 7565 206f 6620 6120 636f  te value of a co
+0000f3a0: 6d70 6c65 7820 6675 6e63 7469 6f6e 2063  mplex function c
+0000f3b0: 6f6c 6f72 6564 2062 7920 6974 730a 2020  olored by its.  
+0000f3c0: 2020 6172 6775 6d65 6e74 206f 7665 7220    argument over 
+0000f3d0: 6120 636f 6d70 6c65 7820 7261 6e67 6520  a complex range 
+0000f3e0: 2861 202b 2049 2a62 2c20 6320 2b20 4920  (a + I*b, c + I 
+0000f3f0: 2a20 6229 2e0a 2020 2020 4e6f 7465 2074  * b)..    Note t
+0000f400: 6861 7420 7468 6520 696d 6167 696e 6172  hat the imaginar
+0000f410: 7920 7061 7274 206f 6620 7468 6520 7374  y part of the st
+0000f420: 6172 7420 616e 6420 656e 6420 6d75 7374  art and end must
+0000f430: 2062 6520 7468 6520 7361 6d65 2e0a 2020   be the same..  
+0000f440: 2020 2222 220a 0a20 2020 2069 735f 7061    """..    is_pa
+0000f450: 7261 6d65 7472 6963 203d 2054 7275 650a  rametric = True.
+0000f460: 2020 2020 6973 5f63 6f6d 706c 6578 203d      is_complex =
+0000f470: 2054 7275 650a 0a20 2020 2064 6566 205f   True..    def _
+0000f480: 5f6e 6577 5f5f 2863 6c73 2c20 2a61 7267  _new__(cls, *arg
+0000f490: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
+0000f4a0: 2020 2020 2020 7265 7475 726e 206f 626a        return obj
+0000f4b0: 6563 742e 5f5f 6e65 775f 5f28 636c 7329  ect.__new__(cls)
+0000f4c0: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
+0000f4d0: 5f5f 2873 656c 662c 202a 6172 6773 2c20  __(self, *args, 
+0000f4e0: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
+0000f4f0: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
+0000f500: 745f 5f28 2a61 7267 732c 202a 2a6b 7761  t__(*args, **kwa
+0000f510: 7267 7329 0a20 2020 2020 2020 2073 656c  rgs).        sel
+0000f520: 662e 7573 655f 636d 203d 206b 7761 7267  f.use_cm = kwarg
+0000f530: 732e 6765 7428 2275 7365 5f63 6d22 2c20  s.get("use_cm", 
+0000f540: 5472 7565 290a 0a20 2020 2064 6566 205f  True)..    def _
+0000f550: 5f73 7472 5f5f 2873 656c 6629 3a0a 2020  _str__(self):.  
+0000f560: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0000f570: 662e 5f73 7472 5f68 656c 7065 7228 2263  f._str_helper("c
+0000f580: 6172 7465 7369 616e 2061 6273 2d61 7267  artesian abs-arg
+0000f590: 206c 696e 653a 2025 7320 666f 7220 2573   line: %s for %s
+0000f5a0: 206f 7665 7220 2573 2220 2520 280a 2020   over %s" % (.  
+0000f5b0: 2020 2020 2020 2020 2020 7374 7228 7365            str(se
+0000f5c0: 6c66 2e65 7870 7229 2c0a 2020 2020 2020  lf.expr),.      
+0000f5d0: 2020 2020 2020 7374 7228 7365 6c66 2e76        str(self.v
+0000f5e0: 6172 292c 0a20 2020 2020 2020 2020 2020  ar),.           
+0000f5f0: 2073 7472 2828 7365 6c66 2e73 7461 7274   str((self.start
+0000f600: 2c20 7365 6c66 2e65 6e64 2929 2929 0a0a  , self.end))))..
+0000f610: 2020 2020 6465 6620 5f67 6574 5f64 6174      def _get_dat
+0000f620: 615f 6865 6c70 6572 2873 656c 6629 3a0a  a_helper(self):.
+0000f630: 2020 2020 2020 2020 2222 2252 6574 7572          """Retur
+0000f640: 6e73 2063 6f6f 7264 696e 6174 6573 2074  ns coordinates t
+0000f650: 6861 7420 6e65 6564 7320 746f 2062 6520  hat needs to be 
+0000f660: 706f 7374 7072 6f63 6573 7365 642e 0a20  postprocessed.. 
+0000f670: 2020 2020 2020 2044 6570 656e 6469 6e67         Depending
+0000f680: 206f 6e20 7468 6520 6061 6461 7074 6976   on the `adaptiv
+0000f690: 6560 206f 7074 696f 6e2c 2074 6869 7320  e` option, this 
+0000f6a0: 6675 6e63 7469 6f6e 2077 696c 6c20 6569  function will ei
+0000f6b0: 7468 6572 2075 7365 2061 6e0a 2020 2020  ther use an.    
+0000f6c0: 2020 2020 6164 6170 7469 7665 2061 6c67      adaptive alg
+0000f6d0: 6f72 6974 686d 206f 7220 6974 2077 696c  orithm or it wil
+0000f6e0: 6c20 756e 6966 6f72 6d6c 7920 7361 6d70  l uniformly samp
+0000f6f0: 6c65 2074 6865 2065 7870 7265 7373 696f  le the expressio
+0000f700: 6e20 6f76 6572 2074 6865 0a20 2020 2020  n over the.     
+0000f710: 2020 2070 726f 7669 6465 6420 7261 6e67     provided rang
+0000f720: 652e 0a20 2020 2020 2020 2022 2222 0a20  e..        """. 
+0000f730: 2020 2020 2020 206e 7020 3d20 696d 706f         np = impo
+0000f740: 7274 5f6d 6f64 756c 6528 276e 756d 7079  rt_module('numpy
+0000f750: 2729 0a0a 2020 2020 2020 2020 782c 205f  ')..        x, _
+0000f760: 7265 2c20 5f69 6d20 3d20 7365 6c66 2e5f  re, _im = self._
+0000f770: 6765 745f 7265 616c 5f69 6d61 6728 290a  get_real_imag().
+0000f780: 2020 2020 2020 2020 5f61 6273 203d 206e          _abs = n
+0000f790: 702e 7371 7274 285f 7265 2a2a 3220 2b20  p.sqrt(_re**2 + 
+0000f7a0: 5f69 6d2a 2a32 290a 2020 2020 2020 2020  _im**2).        
+0000f7b0: 5f61 6e67 6c65 203d 206e 702e 6172 6374  _angle = np.arct
+0000f7c0: 616e 3228 5f69 6d2c 205f 7265 290a 2020  an2(_im, _re).  
+0000f7d0: 2020 2020 2020 7265 7475 726e 2078 2c20        return x, 
+0000f7e0: 5f61 6273 2c20 5f61 6e67 6c65 0a0a 0a63  _abs, _angle...c
+0000f7f0: 6c61 7373 2050 6172 616d 6574 7269 634c  lass ParametricL
+0000f800: 696e 6542 6173 6553 6572 6965 7328 0a20  ineBaseSeries(. 
+0000f810: 2020 2043 6f6d 6d6f 6e41 6461 7074 6976     CommonAdaptiv
+0000f820: 6545 7661 6c75 6174 696f 6e2c 2043 6f6d  eEvaluation, Com
+0000f830: 6d6f 6e55 6e69 666f 726d 4576 616c 7561  monUniformEvalua
+0000f840: 7469 6f6e 2c20 4c69 6e65 3244 4261 7365  tion, Line2DBase
+0000f850: 5365 7269 6573 0a29 3a0a 2020 2020 6973  Series.):.    is
+0000f860: 5f70 6172 616d 6574 7269 6320 3d20 5472  _parametric = Tr
+0000f870: 7565 0a0a 2020 2020 6465 6620 5f73 6574  ue..    def _set
+0000f880: 5f70 6172 616d 6574 7269 635f 6c69 6e65  _parametric_line
+0000f890: 5f6c 6162 656c 2873 656c 662c 206c 6162  _label(self, lab
+0000f8a0: 656c 293a 0a20 2020 2020 2020 2022 2222  el):.        """
+0000f8b0: 4c6f 6769 6320 746f 2073 6574 2074 6865  Logic to set the
+0000f8c0: 2063 6f72 7265 6374 206c 6162 656c 2074   correct label t
+0000f8d0: 6f20 6265 2073 686f 776e 206f 6e20 7468  o be shown on th
+0000f8e0: 6520 706c 6f74 2e0a 2020 2020 2020 2020  e plot..        
+0000f8f0: 4966 2060 7573 655f 636d 3d54 7275 6560  If `use_cm=True`
+0000f900: 2074 6865 7265 2077 696c 6c20 6265 2061   there will be a
+0000f910: 2063 6f6c 6f72 6261 722c 2073 6f20 7765   colorbar, so we
+0000f920: 2073 686f 7720 7468 6520 7061 7261 6d65   show the parame
+0000f930: 7465 722e 0a20 2020 2020 2020 2049 6620  ter..        If 
+0000f940: 6075 7365 5f63 6d3d 4661 6c73 6560 2c20  `use_cm=False`, 
+0000f950: 7468 6572 6520 6d69 6768 7420 6265 2061  there might be a
+0000f960: 206c 6567 656e 642c 2073 6f20 7765 2073   legend, so we s
+0000f970: 686f 7720 7468 6520 6578 7072 6573 7369  how the expressi
+0000f980: 6f6e 732e 0a0a 2020 2020 2020 2020 5061  ons...        Pa
+0000f990: 7261 6d65 7465 7273 0a20 2020 2020 2020  rameters.       
+0000f9a0: 203d 3d3d 3d3d 3d3d 3d3d 3d0a 2020 2020   ==========.    
+0000f9b0: 2020 2020 6c61 6265 6c20 3a20 7374 720a      label : str.
+0000f9c0: 2020 2020 2020 2020 2020 2020 6c61 6265              labe
+0000f9d0: 6c20 7061 7373 6564 2069 6e20 6279 2074  l passed in by t
+0000f9e0: 6865 2070 7265 2d70 726f 6365 7373 6f72  he pre-processor
+0000f9f0: 206f 7220 7468 6520 7573 6572 0a20 2020   or the user.   
+0000fa00: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000fa10: 2073 656c 662e 5f6c 6162 656c 203d 2073   self._label = s
+0000fa20: 7472 2873 656c 662e 7661 7229 2069 6620  tr(self.var) if 
+0000fa30: 6c61 6265 6c20 6973 204e 6f6e 6520 656c  label is None el
+0000fa40: 7365 206c 6162 656c 0a20 2020 2020 2020  se label.       
+0000fa50: 2073 656c 662e 5f6c 6174 6578 5f6c 6162   self._latex_lab
+0000fa60: 656c 203d 206c 6174 6578 2873 656c 662e  el = latex(self.
+0000fa70: 7661 7229 2069 6620 6c61 6265 6c20 6973  var) if label is
+0000fa80: 204e 6f6e 6520 656c 7365 206c 6162 656c   None else label
+0000fa90: 0a20 2020 2020 2020 2069 6620 2873 656c  .        if (sel
+0000faa0: 662e 7573 655f 636d 2069 7320 4661 6c73  f.use_cm is Fals
+0000fab0: 6529 2061 6e64 2028 7365 6c66 2e5f 6c61  e) and (self._la
+0000fac0: 6265 6c20 3d3d 2073 7472 2873 656c 662e  bel == str(self.
+0000fad0: 7661 7229 293a 0a20 2020 2020 2020 2020  var)):.         
+0000fae0: 2020 2073 656c 662e 5f6c 6162 656c 203d     self._label =
+0000faf0: 2073 7472 2873 656c 662e 6578 7072 290a   str(self.expr).
+0000fb00: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000fb10: 2e5f 6c61 7465 785f 6c61 6265 6c20 3d20  ._latex_label = 
+0000fb20: 6c61 7465 7828 7365 6c66 2e65 7870 7229  latex(self.expr)
+0000fb30: 0a20 2020 2020 2020 2023 2069 6620 7468  .        # if th
+0000fb40: 6520 6578 7072 6573 7369 6f6e 7320 6973  e expressions is
+0000fb50: 2061 206c 616d 6264 6120 6675 6e63 7469   a lambda functi
+0000fb60: 6f6e 2061 6e64 2075 7365 5f63 6d3d 4661  on and use_cm=Fa
+0000fb70: 6c73 6520 616e 6420 6e6f 206c 6162 656c  lse and no label
+0000fb80: 0a20 2020 2020 2020 2023 2068 6173 2062  .        # has b
+0000fb90: 6565 6e20 7072 6f76 6964 6564 2c20 7468  een provided, th
+0000fba0: 656e 2069 7473 2062 6574 7465 7220 746f  en its better to
+0000fbb0: 2064 6f20 7468 6520 666f 6c6c 6f77 696e   do the followin
+0000fbc0: 6720 696e 206f 7264 6572 2074 6f0a 2020  g in order to.  
+0000fbd0: 2020 2020 2020 2320 6176 6f69 6420 7375        # avoid su
+0000fbe0: 7072 6973 6573 206f 6e20 7468 6520 6261  prises on the ba
+0000fbf0: 636b 656e 640a 2020 2020 2020 2020 6966  ckend.        if
+0000fc00: 2061 6e79 2863 616c 6c61 626c 6528 6529   any(callable(e)
+0000fc10: 2066 6f72 2065 2069 6e20 7365 6c66 2e65   for e in self.e
+0000fc20: 7870 7229 2061 6e64 2028 6e6f 7420 7365  xpr) and (not se
+0000fc30: 6c66 2e75 7365 5f63 6d29 3a0a 2020 2020  lf.use_cm):.    
+0000fc40: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000fc50: 5f6c 6162 656c 203d 3d20 7374 7228 7365  _label == str(se
+0000fc60: 6c66 2e65 7870 7229 3a0a 2020 2020 2020  lf.expr):.      
+0000fc70: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+0000fc80: 6c61 6265 6c20 3d20 2222 0a0a 2020 2020  label = ""..    
+0000fc90: 6465 6620 5f61 6461 7074 6976 655f 7361  def _adaptive_sa
+0000fca0: 6d70 6c69 6e67 2873 656c 6629 3a0a 2020  mpling(self):.  
+0000fcb0: 2020 2020 2020 6e70 203d 2069 6d70 6f72        np = impor
+0000fcc0: 745f 6d6f 6475 6c65 2827 6e75 6d70 7927  t_module('numpy'
+0000fcd0: 290a 0a20 2020 2020 2020 2064 6566 2066  )..        def f
+0000fce0: 756e 6328 662c 2069 735f 3244 6c69 6e65  unc(f, is_2Dline
+0000fcf0: 2c20 7829 3a0a 2020 2020 2020 2020 2020  , x):.          
+0000fd00: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+0000fd10: 2020 2020 2020 2077 203d 205b 636f 6d70         w = [comp
+0000fd20: 6c65 7828 7429 2066 6f72 2074 2069 6e20  lex(t) for t in 
+0000fd30: 6628 636f 6d70 6c65 7828 7829 295d 0a20  f(complex(x))]. 
+0000fd40: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000fd50: 6574 7572 6e20 5b74 2e72 6561 6c20 6966  eturn [t.real if
+0000fd60: 206e 702e 6973 636c 6f73 6528 742e 696d   np.isclose(t.im
+0000fd70: 6167 2c20 3029 2065 6c73 6520 6e70 2e6e  ag, 0) else np.n
+0000fd80: 616e 2066 6f72 2074 2069 6e20 775d 0a20  an for t in w]. 
+0000fd90: 2020 2020 2020 2020 2020 2065 7863 6570             excep
+0000fda0: 7420 285a 6572 6f44 6976 6973 696f 6e45  t (ZeroDivisionE
+0000fdb0: 7272 6f72 2c20 4f76 6572 666c 6f77 4572  rror, OverflowEr
+0000fdc0: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
+0000fdd0: 2020 2020 2020 7265 7475 726e 205b 6e70        return [np
+0000fde0: 2e6e 616e 2066 6f72 2074 2069 6e20 7261  .nan for t in ra
+0000fdf0: 6e67 6528 3220 6966 2069 735f 3244 6c69  nge(2 if is_2Dli
+0000fe00: 6e65 2065 6c73 6520 3329 5d0a 0a20 2020  ne else 3)]..   
+0000fe10: 2020 2020 2069 6620 616c 6c28 6e6f 7420       if all(not 
+0000fe20: 6361 6c6c 6162 6c65 2865 2920 666f 7220  callable(e) for 
+0000fe30: 6520 696e 2073 656c 662e 6578 7072 293a  e in self.expr):
+0000fe40: 0a20 2020 2020 2020 2020 2020 2065 7870  .            exp
+0000fe50: 7220 3d20 5475 706c 6528 7365 6c66 2e65  r = Tuple(self.e
+0000fe60: 7870 725f 782c 2073 656c 662e 6578 7072  xpr_x, self.expr
+0000fe70: 5f79 290a 2020 2020 2020 2020 2020 2020  _y).            
+0000fe80: 6966 206e 6f74 2073 656c 662e 6973 5f32  if not self.is_2
+0000fe90: 446c 696e 653a 0a20 2020 2020 2020 2020  Dline:.         
+0000fea0: 2020 2020 2020 2065 7870 7220 3d20 5475         expr = Tu
+0000feb0: 706c 6528 7365 6c66 2e65 7870 725f 782c  ple(self.expr_x,
+0000fec0: 2073 656c 662e 6578 7072 5f79 2c20 7365   self.expr_y, se
+0000fed0: 6c66 2e65 7870 725f 7a29 0a20 2020 2020  lf.expr_z).     
+0000fee0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000fef0: 2020 2020 2023 2065 7870 7220 6973 2075       # expr is u
+0000ff00: 7365 722d 7072 6f76 6964 6564 206c 616d  ser-provided lam
+0000ff10: 6264 6120 6675 6e63 7469 6f6e 730a 2020  bda functions.  
+0000ff20: 2020 2020 2020 2020 2020 6578 7072 203d            expr =
+0000ff30: 206c 616d 6264 6120 783a 2028 7365 6c66   lambda x: (self
+0000ff40: 2e65 7870 725f 7828 7829 2c20 7365 6c66  .expr_x(x), self
+0000ff50: 2e65 7870 725f 7928 7829 290a 2020 2020  .expr_y(x)).    
+0000ff60: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+0000ff70: 656c 662e 6973 5f32 446c 696e 653a 0a20  elf.is_2Dline:. 
+0000ff80: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000ff90: 7870 7220 3d20 6c61 6d62 6461 2078 3a20  xpr = lambda x: 
+0000ffa0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000ffb0: 2020 2020 2020 7365 6c66 2e65 7870 725f        self.expr_
+0000ffc0: 7828 7829 2c20 7365 6c66 2e65 7870 725f  x(x), self.expr_
+0000ffd0: 7928 7829 2c20 7365 6c66 2e65 7870 725f  y(x), self.expr_
+0000ffe0: 7a28 7829 290a 0a20 2020 2020 2020 2064  z(x))..        d
+0000fff0: 6174 6120 3d20 5f61 6461 7074 6976 655f  ata = _adaptive_
+00010000: 6576 616c 280a 2020 2020 2020 2020 2020  eval(.          
+00010010: 2020 6675 6e63 2c20 5b73 656c 662e 7661    func, [self.va
+00010020: 725d 2c20 6578 7072 2c0a 2020 2020 2020  r], expr,.      
+00010030: 2020 2020 2020 5b66 6c6f 6174 2873 656c        [float(sel
+00010040: 662e 7374 6172 7429 2c20 666c 6f61 7428  f.start), float(
+00010050: 7365 6c66 2e65 6e64 295d 2c0a 2020 2020  self.end)],.    
+00010060: 2020 2020 2020 2020 7365 6c66 2e69 735f          self.is_
+00010070: 3244 6c69 6e65 2c0a 2020 2020 2020 2020  2Dline,.        
+00010080: 2020 2020 6d6f 6475 6c65 733d 7365 6c66      modules=self
+00010090: 2e6d 6f64 756c 6573 2c0a 2020 2020 2020  .modules,.      
+000100a0: 2020 2020 2020 6164 6170 7469 7665 5f67        adaptive_g
+000100b0: 6f61 6c3d 7365 6c66 2e61 6461 7074 6976  oal=self.adaptiv
+000100c0: 655f 676f 616c 2c0a 2020 2020 2020 2020  e_goal,.        
+000100d0: 2020 2020 6c6f 7373 5f66 6e3d 7365 6c66      loss_fn=self
+000100e0: 2e6c 6f73 735f 666e 290a 0a20 2020 2020  .loss_fn)..     
+000100f0: 2020 2069 6620 7365 6c66 2e69 735f 3244     if self.is_2D
+00010100: 6c69 6e65 3a0a 2020 2020 2020 2020 2020  line:.          
+00010110: 2020 7265 7475 726e 2064 6174 615b 3a2c    return data[:,
+00010120: 2031 5d2c 2064 6174 615b 3a2c 2032 5d2c   1], data[:, 2],
+00010130: 2064 6174 615b 3a2c 2030 5d0a 2020 2020   data[:, 0].    
+00010140: 2020 2020 7265 7475 726e 2064 6174 615b      return data[
+00010150: 3a2c 2031 5d2c 2064 6174 615b 3a2c 2032  :, 1], data[:, 2
+00010160: 5d2c 2064 6174 615b 3a2c 2033 5d2c 2064  ], data[:, 3], d
+00010170: 6174 615b 3a2c 2030 5d0a 0a20 2020 2064  ata[:, 0]..    d
+00010180: 6566 2067 6574 5f6c 6162 656c 2873 656c  ef get_label(sel
+00010190: 662c 2075 7365 5f6c 6174 6578 3d46 616c  f, use_latex=Fal
+000101a0: 7365 2c20 7772 6170 7065 723d 2224 2573  se, wrapper="$%s
+000101b0: 2422 293a 0a20 2020 2020 2020 2023 2070  $"):.        # p
+000101c0: 6172 616d 6574 7269 6320 6c69 6e65 7320  arametric lines 
+000101d0: 7265 7475 726e 7320 7468 6520 7265 7072  returns the repr
+000101e0: 6573 656e 7461 7469 6f6e 206f 6620 7468  esentation of th
+000101f0: 6520 7061 7261 6d65 7465 7220 746f 2062  e parameter to b
+00010200: 650a 2020 2020 2020 2020 2320 7368 6f77  e.        # show
+00010210: 6e20 6f6e 2074 6865 2063 6f6c 6f72 6261  n on the colorba
+00010220: 7220 6966 2060 7573 655f 636d 3d54 7275  r if `use_cm=Tru
+00010230: 6560 2c20 6f74 6865 7277 6973 6520 6974  e`, otherwise it
+00010240: 2072 6574 7572 6e73 2074 6865 0a20 2020   returns the.   
+00010250: 2020 2020 2023 2072 6570 7265 7365 6e74       # represent
+00010260: 6174 696f 6e20 6f66 2074 6865 2065 7870  ation of the exp
+00010270: 7265 7373 696f 6e20 746f 2062 6520 706c  ression to be pl
+00010280: 6163 6564 206f 6e20 7468 6520 6c65 6765  aced on the lege
+00010290: 6e64 2e0a 2020 2020 2020 2020 6966 2073  nd..        if s
+000102a0: 656c 662e 7573 655f 636d 3a0a 2020 2020  elf.use_cm:.    
+000102b0: 2020 2020 2020 2020 6966 2073 7472 2873          if str(s
+000102c0: 656c 662e 7661 7229 203d 3d20 7365 6c66  elf.var) == self
+000102d0: 2e5f 6c61 6265 6c3a 0a20 2020 2020 2020  ._label:.       
+000102e0: 2020 2020 2020 2020 2069 6620 7573 655f           if use_
+000102f0: 6c61 7465 783a 0a20 2020 2020 2020 2020  latex:.         
+00010300: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00010310: 6e20 7365 6c66 2e5f 6765 745f 7772 6170  n self._get_wrap
+00010320: 7065 645f 6c61 6265 6c28 6c61 7465 7828  ped_label(latex(
+00010330: 7365 6c66 2e76 6172 292c 2077 7261 7070  self.var), wrapp
+00010340: 6572 290a 2020 2020 2020 2020 2020 2020  er).            
+00010350: 2020 2020 7265 7475 726e 2073 7472 2873      return str(s
+00010360: 656c 662e 7661 7229 0a20 2020 2020 2020  elf.var).       
+00010370: 2020 2020 2023 2068 6572 6520 7468 6520       # here the 
+00010380: 7573 6572 2068 6173 2070 726f 7669 6465  user has provide
+00010390: 6420 6120 6375 7374 6f6d 206c 6162 656c  d a custom label
+000103a0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+000103b0: 7572 6e20 7365 6c66 2e5f 6c61 6265 6c0a  urn self._label.
+000103c0: 2020 2020 2020 2020 6966 2075 7365 5f6c          if use_l
+000103d0: 6174 6578 3a0a 2020 2020 2020 2020 2020  atex:.          
+000103e0: 2020 6966 2073 656c 662e 5f6c 6162 656c    if self._label
+000103f0: 2021 3d20 7374 7228 7365 6c66 2e65 7870   != str(self.exp
+00010400: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+00010410: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00010420: 5f6c 6174 6578 5f6c 6162 656c 0a20 2020  _latex_label.   
+00010430: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00010440: 7365 6c66 2e5f 6765 745f 7772 6170 7065  self._get_wrappe
+00010450: 645f 6c61 6265 6c28 7365 6c66 2e5f 6c61  d_label(self._la
+00010460: 7465 785f 6c61 6265 6c2c 2077 7261 7070  tex_label, wrapp
+00010470: 6572 290a 2020 2020 2020 2020 7265 7475  er).        retu
+00010480: 726e 2073 656c 662e 5f6c 6162 656c 0a0a  rn self._label..
+00010490: 2020 2020 6465 6620 5f67 6574 5f64 6174      def _get_dat
+000104a0: 615f 6865 6c70 6572 2873 656c 6629 3a0a  a_helper(self):.
+000104b0: 2020 2020 2020 2020 2222 2252 6574 7572          """Retur
+000104c0: 6e73 2063 6f6f 7264 696e 6174 6573 2074  ns coordinates t
+000104d0: 6861 7420 6e65 6564 7320 746f 2062 6520  hat needs to be 
+000104e0: 706f 7374 7072 6f63 6573 7365 642e 0a20  postprocessed.. 
+000104f0: 2020 2020 2020 2044 6570 656e 6469 6e67         Depending
+00010500: 206f 6e20 7468 6520 6061 6461 7074 6976   on the `adaptiv
+00010510: 6560 206f 7074 696f 6e2c 2074 6869 7320  e` option, this 
+00010520: 6675 6e63 7469 6f6e 2077 696c 6c20 6569  function will ei
+00010530: 7468 6572 2075 7365 2061 6e0a 2020 2020  ther use an.    
+00010540: 2020 2020 6164 6170 7469 7665 2061 6c67      adaptive alg
+00010550: 6f72 6974 686d 206f 7220 6974 2077 696c  orithm or it wil
+00010560: 6c20 756e 6966 6f72 6d6c 7920 7361 6d70  l uniformly samp
+00010570: 6c65 2074 6865 2065 7870 7265 7373 696f  le the expressio
+00010580: 6e20 6f76 6572 2074 6865 0a20 2020 2020  n over the.     
+00010590: 2020 2070 726f 7669 6465 6420 7261 6e67     provided rang
+000105a0: 652e 0a20 2020 2020 2020 2022 2222 0a20  e..        """. 
+000105b0: 2020 2020 2020 2069 6620 7365 6c66 2e61         if self.a
+000105c0: 6461 7074 6976 653a 0a20 2020 2020 2020  daptive:.       
+000105d0: 2020 2020 2063 6f6f 7264 7320 3d20 7365       coords = se
+000105e0: 6c66 2e5f 6164 6170 7469 7665 5f73 616d  lf._adaptive_sam
+000105f0: 706c 696e 6728 290a 2020 2020 2020 2020  pling().        
+00010600: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00010610: 2020 636f 6f72 6473 203d 2073 656c 662e    coords = self.
+00010620: 5f75 6e69 666f 726d 5f73 616d 706c 696e  _uniform_samplin
+00010630: 6728 290a 0a20 2020 2020 2020 2069 6620  g()..        if 
+00010640: 7365 6c66 2e69 735f 3244 6c69 6e65 2061  self.is_2Dline a
+00010650: 6e64 2073 656c 662e 6973 5f70 6f6c 6172  nd self.is_polar
+00010660: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+00010670: 7768 656e 2070 6c6f 745f 706f 6c61 7220  when plot_polar 
+00010680: 6973 2065 7865 6375 7465 6420 7769 7468  is executed with
+00010690: 2070 6f6c 6172 5f61 7869 733d 5472 7565   polar_axis=True
+000106a0: 0a20 2020 2020 2020 2020 2020 206e 7020  .            np 
+000106b0: 3d20 696d 706f 7274 5f6d 6f64 756c 6528  = import_module(
+000106c0: 276e 756d 7079 2729 0a20 2020 2020 2020  'numpy').       
+000106d0: 2020 2020 2078 2c20 792c 205f 203d 2063       x, y, _ = c
+000106e0: 6f6f 7264 730a 2020 2020 2020 2020 2020  oords.          
+000106f0: 2020 7220 3d20 6e70 2e73 7172 7428 782a    r = np.sqrt(x*
+00010700: 2a32 202b 2079 2a2a 3229 0a20 2020 2020  *2 + y**2).     
+00010710: 2020 2020 2020 2074 203d 206e 702e 6172         t = np.ar
+00010720: 6374 616e 3228 792c 2078 290a 2020 2020  ctan2(y, x).    
+00010730: 2020 2020 2020 2020 636f 6f72 6473 203d          coords =
+00010740: 205b 742c 2072 2c20 636f 6f72 6473 5b2d   [t, r, coords[-
+00010750: 315d 5d0a 0a20 2020 2020 2020 2069 6620  1]]..        if 
+00010760: 6361 6c6c 6162 6c65 2873 656c 662e 636f  callable(self.co
+00010770: 6c6f 725f 6675 6e63 293a 0a20 2020 2020  lor_func):.     
+00010780: 2020 2020 2020 2063 6f6f 7264 7320 3d20         coords = 
+00010790: 6c69 7374 2863 6f6f 7264 7329 0a20 2020  list(coords).   
+000107a0: 2020 2020 2020 2020 2063 6f6f 7264 735b           coords[
+000107b0: 2d31 5d20 3d20 7365 6c66 2e65 7661 6c5f  -1] = self.eval_
+000107c0: 636f 6c6f 725f 6675 6e63 282a 636f 6f72  color_func(*coor
+000107d0: 6473 290a 0a20 2020 2020 2020 2072 6574  ds)..        ret
+000107e0: 7572 6e20 636f 6f72 6473 0a0a 2020 2020  urn coords..    
+000107f0: 6465 6620 5f75 6e69 666f 726d 5f73 616d  def _uniform_sam
+00010800: 706c 696e 6728 7365 6c66 293a 0a20 2020  pling(self):.   
+00010810: 2020 2020 2022 2222 5265 7475 726e 7320       """Returns 
+00010820: 636f 6f72 6469 6e61 7465 7320 7468 6174  coordinates that
+00010830: 206e 6565 6473 2074 6f20 6265 2070 6f73   needs to be pos
+00010840: 7470 726f 6365 7373 6564 2e22 2222 0a20  tprocessed.""". 
+00010850: 2020 2020 2020 206e 7020 3d20 696d 706f         np = impo
+00010860: 7274 5f6d 6f64 756c 6528 276e 756d 7079  rt_module('numpy
+00010870: 2729 0a0a 2020 2020 2020 2020 7265 7375  ')..        resu
+00010880: 6c74 7320 3d20 7365 6c66 2e5f 6576 616c  lts = self._eval
+00010890: 7561 7465 2829 0a20 2020 2020 2020 2066  uate().        f
+000108a0: 6f72 2069 2c20 7220 696e 2065 6e75 6d65  or i, r in enume
+000108b0: 7261 7465 2872 6573 756c 7473 293a 0a20  rate(results):. 
+000108c0: 2020 2020 2020 2020 2020 205f 7265 2c20             _re, 
+000108d0: 5f69 6d20 3d20 6e70 2e72 6561 6c28 7229  _im = np.real(r)
+000108e0: 2c20 6e70 2e69 6d61 6728 7229 0a20 2020  , np.imag(r).   
+000108f0: 2020 2020 2020 2020 205f 7265 5b6e 702e           _re[np.
+00010900: 696e 7665 7274 286e 702e 6973 636c 6f73  invert(np.isclos
+00010910: 6528 5f69 6d2c 206e 702e 7a65 726f 735f  e(_im, np.zeros_
+00010920: 6c69 6b65 285f 696d 2929 295d 203d 206e  like(_im)))] = n
+00010930: 702e 6e61 6e0a 2020 2020 2020 2020 2020  p.nan.          
+00010940: 2020 7265 7375 6c74 735b 695d 203d 205f    results[i] = _
+00010950: 7265 0a0a 2020 2020 2020 2020 7265 7475  re..        retu
+00010960: 726e 205b 2a72 6573 756c 7473 5b31 3a5d  rn [*results[1:]
+00010970: 2c20 7265 7375 6c74 735b 305d 5d0a 0a0a  , results[0]]...
+00010980: 636c 6173 7320 5061 7261 6d65 7472 6963  class Parametric
+00010990: 3244 4c69 6e65 5365 7269 6573 2850 6172  2DLineSeries(Par
+000109a0: 616d 6574 7269 634c 696e 6542 6173 6553  ametricLineBaseS
+000109b0: 6572 6965 7329 3a0a 2020 2020 2222 2252  eries):.    """R
+000109c0: 6570 7265 7365 6e74 6174 696f 6e20 666f  epresentation fo
+000109d0: 7220 6120 6c69 6e65 2063 6f6e 7369 7374  r a line consist
+000109e0: 696e 6720 6f66 2074 776f 2070 6172 616d  ing of two param
+000109f0: 6574 7269 6320 7379 6d70 7920 6578 7072  etric sympy expr
+00010a00: 6573 7369 6f6e 730a 2020 2020 6f76 6572  essions.    over
+00010a10: 2061 2072 616e 6765 2e22 2222 0a0a 2020   a range."""..  
+00010a20: 2020 6973 5f70 6172 616d 6574 7269 6320    is_parametric 
+00010a30: 3d20 5472 7565 0a0a 2020 2020 6465 6620  = True..    def 
+00010a40: 5f5f 696e 6974 5f5f 2873 656c 662c 2065  __init__(self, e
+00010a50: 7870 725f 782c 2065 7870 725f 792c 2076  xpr_x, expr_y, v
+00010a60: 6172 5f73 7461 7274 5f65 6e64 2c20 6c61  ar_start_end, la
+00010a70: 6265 6c3d 2222 2c20 2a2a 6b77 6172 6773  bel="", **kwargs
+00010a80: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
+00010a90: 2829 2e5f 5f69 6e69 745f 5f28 2a2a 6b77  ().__init__(**kw
+00010aa0: 6172 6773 290a 2020 2020 2020 2020 7365  args).        se
+00010ab0: 6c66 2e65 7870 725f 7820 3d20 6578 7072  lf.expr_x = expr
+00010ac0: 5f78 2069 6620 6361 6c6c 6162 6c65 2865  _x if callable(e
+00010ad0: 7870 725f 7829 2065 6c73 6520 7379 6d70  xpr_x) else symp
+00010ae0: 6966 7928 6578 7072 5f78 290a 2020 2020  ify(expr_x).    
+00010af0: 2020 2020 7365 6c66 2e65 7870 725f 7920      self.expr_y 
+00010b00: 3d20 6578 7072 5f79 2069 6620 6361 6c6c  = expr_y if call
+00010b10: 6162 6c65 2865 7870 725f 7929 2065 6c73  able(expr_y) els
+00010b20: 6520 7379 6d70 6966 7928 6578 7072 5f79  e sympify(expr_y
+00010b30: 290a 2020 2020 2020 2020 7365 6c66 2e65  ).        self.e
+00010b40: 7870 7220 3d20 2873 656c 662e 6578 7072  xpr = (self.expr
+00010b50: 5f78 2c20 7365 6c66 2e65 7870 725f 7929  _x, self.expr_y)
+00010b60: 0a20 2020 2020 2020 2073 656c 662e 7261  .        self.ra
+00010b70: 6e67 6573 203d 205b 7661 725f 7374 6172  nges = [var_star
+00010b80: 745f 656e 645d 0a20 2020 2020 2020 2073  t_end].        s
+00010b90: 656c 662e 5f63 6173 7420 3d20 666c 6f61  elf._cast = floa
+00010ba0: 740a 2020 2020 2020 2020 7365 6c66 2e75  t.        self.u
+00010bb0: 7365 5f63 6d20 3d20 6b77 6172 6773 2e67  se_cm = kwargs.g
+00010bc0: 6574 2822 7573 655f 636d 222c 2054 7275  et("use_cm", Tru
+00010bd0: 6529 0a20 2020 2020 2020 2073 656c 662e  e).        self.
+00010be0: 5f73 6574 5f70 6172 616d 6574 7269 635f  _set_parametric_
+00010bf0: 6c69 6e65 5f6c 6162 656c 286c 6162 656c  line_label(label
+00010c00: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+00010c10: 706f 7374 5f69 6e69 7428 290a 0a20 2020  post_init()..   
+00010c20: 2064 6566 205f 5f73 7472 5f5f 2873 656c   def __str__(sel
+00010c30: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+00010c40: 726e 2073 656c 662e 5f73 7472 5f68 656c  rn self._str_hel
+00010c50: 7065 7228 0a20 2020 2020 2020 2020 2020  per(.           
+00010c60: 2022 7061 7261 6d65 7472 6963 2063 6172   "parametric car
+00010c70: 7465 7369 616e 206c 696e 653a 2028 2573  tesian line: (%s
+00010c80: 2c20 2573 2920 666f 7220 2573 206f 7665  , %s) for %s ove
+00010c90: 7220 2573 2220 2520 280a 2020 2020 2020  r %s" % (.      
+00010ca0: 2020 2020 2020 2020 2020 7374 7228 7365            str(se
+00010cb0: 6c66 2e65 7870 725f 7829 2c0a 2020 2020  lf.expr_x),.    
+00010cc0: 2020 2020 2020 2020 2020 2020 7374 7228              str(
+00010cd0: 7365 6c66 2e65 7870 725f 7929 2c0a 2020  self.expr_y),.  
+00010ce0: 2020 2020 2020 2020 2020 2020 2020 7374                st
+00010cf0: 7228 7365 6c66 2e76 6172 292c 0a20 2020  r(self.var),.   
+00010d00: 2020 2020 2020 2020 2020 2020 2073 7472               str
+00010d10: 2828 7365 6c66 2e73 7461 7274 2c20 7365  ((self.start, se
+00010d20: 6c66 2e65 6e64 2929 0a20 2020 2020 2020  lf.end)).       
+00010d30: 2020 2020 2029 0a20 2020 2020 2020 2029       ).        )
+00010d40: 0a0a 0a63 6c61 7373 2050 6172 616d 6574  ...class Paramet
+00010d50: 7269 6333 444c 696e 6553 6572 6965 7328  ric3DLineSeries(
+00010d60: 5061 7261 6d65 7472 6963 4c69 6e65 4261  ParametricLineBa
+00010d70: 7365 5365 7269 6573 293a 0a20 2020 2022  seSeries):.    "
+00010d80: 2222 5265 7072 6573 656e 7461 7469 6f6e  ""Representation
+00010d90: 2066 6f72 2061 2033 4420 6c69 6e65 2063   for a 3D line c
+00010da0: 6f6e 7369 7374 696e 6720 6f66 2074 6872  onsisting of thr
+00010db0: 6565 2070 6172 616d 6574 7269 6320 7379  ee parametric sy
+00010dc0: 6d70 790a 2020 2020 6578 7072 6573 7369  mpy.    expressi
+00010dd0: 6f6e 7320 616e 6420 6120 7261 6e67 652e  ons and a range.
+00010de0: 2222 220a 0a20 2020 2069 735f 3244 6c69  """..    is_2Dli
+00010df0: 6e65 203d 2046 616c 7365 0a20 2020 2069  ne = False.    i
+00010e00: 735f 3344 6c69 6e65 203d 2054 7275 650a  s_3Dline = True.
+00010e10: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+00010e20: 5f28 0a20 2020 2020 2020 2073 656c 662c  _(.        self,
+00010e30: 2065 7870 725f 782c 2065 7870 725f 792c   expr_x, expr_y,
+00010e40: 2065 7870 725f 7a2c 2076 6172 5f73 7461   expr_z, var_sta
+00010e50: 7274 5f65 6e64 2c20 6c61 6265 6c3d 2222  rt_end, label=""
+00010e60: 2c20 2a2a 6b77 6172 6773 0a20 2020 2029  , **kwargs.    )
+00010e70: 3a0a 2020 2020 2020 2020 7375 7065 7228  :.        super(
+00010e80: 292e 5f5f 696e 6974 5f5f 282a 2a6b 7761  ).__init__(**kwa
+00010e90: 7267 7329 0a20 2020 2020 2020 2073 656c  rgs).        sel
+00010ea0: 662e 6578 7072 5f78 203d 2065 7870 725f  f.expr_x = expr_
+00010eb0: 7820 6966 2063 616c 6c61 626c 6528 6578  x if callable(ex
+00010ec0: 7072 5f78 2920 656c 7365 2073 796d 7069  pr_x) else sympi
+00010ed0: 6679 2865 7870 725f 7829 0a20 2020 2020  fy(expr_x).     
+00010ee0: 2020 2073 656c 662e 6578 7072 5f79 203d     self.expr_y =
+00010ef0: 2065 7870 725f 7920 6966 2063 616c 6c61   expr_y if calla
+00010f00: 626c 6528 6578 7072 5f79 2920 656c 7365  ble(expr_y) else
+00010f10: 2073 796d 7069 6679 2865 7870 725f 7929   sympify(expr_y)
+00010f20: 0a20 2020 2020 2020 2073 656c 662e 6578  .        self.ex
+00010f30: 7072 5f7a 203d 2065 7870 725f 7a20 6966  pr_z = expr_z if
+00010f40: 2063 616c 6c61 626c 6528 6578 7072 5f7a   callable(expr_z
+00010f50: 2920 656c 7365 2073 796d 7069 6679 2865  ) else sympify(e
+00010f60: 7870 725f 7a29 0a20 2020 2020 2020 2073  xpr_z).        s
+00010f70: 656c 662e 6578 7072 203d 2028 7365 6c66  elf.expr = (self
+00010f80: 2e65 7870 725f 782c 2073 656c 662e 6578  .expr_x, self.ex
+00010f90: 7072 5f79 2c20 7365 6c66 2e65 7870 725f  pr_y, self.expr_
+00010fa0: 7a29 0a20 2020 2020 2020 2073 656c 662e  z).        self.
+00010fb0: 7261 6e67 6573 203d 205b 7661 725f 7374  ranges = [var_st
+00010fc0: 6172 745f 656e 645d 0a20 2020 2020 2020  art_end].       
+00010fd0: 2073 656c 662e 5f63 6173 7420 3d20 666c   self._cast = fl
+00010fe0: 6f61 740a 2020 2020 2020 2020 7365 6c66  oat.        self
+00010ff0: 2e75 7365 5f63 6d20 3d20 6b77 6172 6773  .use_cm = kwargs
+00011000: 2e67 6574 2822 7573 655f 636d 222c 2054  .get("use_cm", T
+00011010: 7275 6529 0a20 2020 2020 2020 2073 656c  rue).        sel
+00011020: 662e 5f73 6574 5f70 6172 616d 6574 7269  f._set_parametri
+00011030: 635f 6c69 6e65 5f6c 6162 656c 286c 6162  c_line_label(lab
+00011040: 656c 290a 2020 2020 2020 2020 7365 6c66  el).        self
+00011050: 2e5f 706f 7374 5f69 6e69 7428 290a 0a20  ._post_init().. 
+00011060: 2020 2064 6566 205f 5f73 7472 5f5f 2873     def __str__(s
+00011070: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00011080: 7475 726e 2073 656c 662e 5f73 7472 5f68  turn self._str_h
+00011090: 656c 7065 7228 0a20 2020 2020 2020 2020  elper(.         
+000110a0: 2020 2022 3344 2070 6172 616d 6574 7269     "3D parametri
+000110b0: 6320 6361 7274 6573 6961 6e20 6c69 6e65  c cartesian line
+000110c0: 3a20 2825 732c 2025 732c 2025 7329 2066  : (%s, %s, %s) f
+000110d0: 6f72 2025 7320 6f76 6572 2025 7322 2025  or %s over %s" %
+000110e0: 2028 0a20 2020 2020 2020 2020 2020 2073   (.            s
+000110f0: 7472 2873 656c 662e 6578 7072 5f78 292c  tr(self.expr_x),
+00011100: 0a20 2020 2020 2020 2020 2020 2073 7472  .            str
+00011110: 2873 656c 662e 6578 7072 5f79 292c 0a20  (self.expr_y),. 
+00011120: 2020 2020 2020 2020 2020 2073 7472 2873             str(s
+00011130: 656c 662e 6578 7072 5f7a 292c 0a20 2020  elf.expr_z),.   
+00011140: 2020 2020 2020 2020 2073 7472 2873 656c           str(sel
+00011150: 662e 7661 7229 2c0a 2020 2020 2020 2020  f.var),.        
+00011160: 2020 2020 7374 7228 2873 656c 662e 7374      str((self.st
+00011170: 6172 742c 2073 656c 662e 656e 6429 290a  art, self.end)).
+00011180: 2020 2020 2020 2020 2929 0a0a 0a63 6c61          ))...cla
+00011190: 7373 2053 7572 6661 6365 4261 7365 5365  ss SurfaceBaseSe
+000111a0: 7269 6573 2842 6173 6553 6572 6965 7329  ries(BaseSeries)
+000111b0: 3a0a 2020 2020 2222 2241 2062 6173 6520  :.    """A base 
+000111c0: 636c 6173 7320 666f 7220 3344 2073 7572  class for 3D sur
+000111d0: 6661 6365 732e 2222 220a 0a20 2020 2069  faces."""..    i
+000111e0: 735f 3344 7375 7266 6163 6520 3d20 5472  s_3Dsurface = Tr
+000111f0: 7565 0a20 2020 205f 616c 6c6f 7765 645f  ue.    _allowed_
+00011200: 6b65 7973 203d 205b 2273 7572 6661 6365  keys = ["surface
+00011210: 5f63 6f6c 6f72 222c 2022 6973 5f70 6f6c  _color", "is_pol
+00011220: 6172 225d 0a0a 2020 2020 6465 6620 5f5f  ar"]..    def __
+00011230: 696e 6974 5f5f 2873 656c 662c 202a 6172  init__(self, *ar
+00011240: 6773 2c20 2a2a 6b77 6172 6773 293a 0a20  gs, **kwargs):. 
+00011250: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+00011260: 5f69 6e69 745f 5f28 2a2a 6b77 6172 6773  _init__(**kwargs
+00011270: 290a 2020 2020 2020 2020 2320 4e4f 5445  ).        # NOTE
+00011280: 3a20 7768 7920 7368 6f75 6c64 2053 7572  : why should Sur
+00011290: 6661 6365 4f76 6572 3244 5261 6e67 6553  faceOver2DRangeS
+000112a0: 6572 6965 7320 7375 7070 6f72 7420 6973  eries support is
+000112b0: 2070 6f6c 6172 3f0a 2020 2020 2020 2020   polar?.        
+000112c0: 2320 4166 7465 7220 616c 6c2c 2074 6865  # After all, the
+000112d0: 2073 616d 6520 7265 7375 6c74 2063 616e   same result can
+000112e0: 2062 6520 6163 6869 6576 6520 7769 7468   be achieve with
+000112f0: 0a20 2020 2020 2020 2023 2050 6172 616d  .        # Param
+00011300: 6574 7269 6353 7572 6661 6365 5365 7269  etricSurfaceSeri
+00011310: 6573 2e20 466f 7220 6578 616d 706c 653a  es. For example:
+00011320: 0a20 2020 2020 2020 2023 2073 696e 2872  .        # sin(r
+00011330: 2920 666f 7220 2872 2c20 302c 2032 202a  ) for (r, 0, 2 *
+00011340: 2070 6929 2061 6e64 2028 7468 6574 612c   pi) and (theta,
+00011350: 2030 2c20 7069 2f32 2920 6361 6e20 6265   0, pi/2) can be
+00011360: 2070 6172 616d 6574 6572 697a 6564 0a20   parameterized. 
+00011370: 2020 2020 2020 2023 2061 7320 2872 202a         # as (r *
+00011380: 2063 6f73 2874 6865 7461 292c 2072 202a   cos(theta), r *
+00011390: 2073 696e 2874 6865 7461 292c 2073 696e   sin(theta), sin
+000113a0: 2874 2929 2066 6f72 2028 722c 2030 2c20  (t)) for (r, 0, 
+000113b0: 3220 2a20 7069 2920 616e 640a 2020 2020  2 * pi) and.    
+000113c0: 2020 2020 2320 2874 6865 7461 2c20 302c      # (theta, 0,
+000113d0: 2070 692f 3229 2e0a 2020 2020 2020 2020   pi/2)..        
+000113e0: 2320 4265 6361 7573 6520 6974 2069 7320  # Because it is 
+000113f0: 6661 7374 6572 2074 6f20 6576 616c 7561  faster to evalua
+00011400: 7465 2028 696d 706f 7274 616e 7420 666f  te (important fo
+00011410: 7220 696e 7465 7261 6374 6976 6520 706c  r interactive pl
+00011420: 6f74 7329 2e0a 2020 2020 2020 2020 7365  ots)..        se
+00011430: 6c66 2e69 735f 706f 6c61 7220 3d20 6b77  lf.is_polar = kw
+00011440: 6172 6773 2e67 6574 2822 6973 5f70 6f6c  args.get("is_pol
+00011450: 6172 222c 2046 616c 7365 290a 2020 2020  ar", False).    
+00011460: 2020 2020 7365 6c66 2e73 7572 6661 6365      self.surface
+00011470: 5f63 6f6c 6f72 203d 206b 7761 7267 732e  _color = kwargs.
+00011480: 6765 7428 2273 7572 6661 6365 5f63 6f6c  get("surface_col
+00011490: 6f72 222c 204e 6f6e 6529 0a20 2020 2020  or", None).     
+000114a0: 2020 2073 656c 662e 636f 6c6f 725f 6675     self.color_fu
+000114b0: 6e63 203d 206b 7761 7267 732e 6765 7428  nc = kwargs.get(
+000114c0: 2263 6f6c 6f72 5f66 756e 6322 2c20 6c61  "color_func", la
+000114d0: 6d62 6461 2078 2c20 792c 207a 3a20 7a29  mbda x, y, z: z)
+000114e0: 0a20 2020 2020 2020 2069 6620 6361 6c6c  .        if call
+000114f0: 6162 6c65 2873 656c 662e 7375 7266 6163  able(self.surfac
+00011500: 655f 636f 6c6f 7229 3a0a 2020 2020 2020  e_color):.      
+00011510: 2020 2020 2020 7365 6c66 2e63 6f6c 6f72        self.color
+00011520: 5f66 756e 6320 3d20 7365 6c66 2e73 7572  _func = self.sur
+00011530: 6661 6365 5f63 6f6c 6f72 0a20 2020 2020  face_color.     
+00011540: 2020 2020 2020 2073 656c 662e 7375 7266         self.surf
+00011550: 6163 655f 636f 6c6f 7220 3d20 4e6f 6e65  ace_color = None
+00011560: 0a0a 2020 2020 6465 6620 5f73 6574 5f73  ..    def _set_s
+00011570: 7572 6661 6365 5f6c 6162 656c 2873 656c  urface_label(sel
+00011580: 662c 206c 6162 656c 293a 0a20 2020 2020  f, label):.     
+00011590: 2020 2065 7870 7273 203d 2073 656c 662e     exprs = self.
+000115a0: 6578 7072 0a20 2020 2020 2020 2073 656c  expr.        sel
+000115b0: 662e 5f6c 6162 656c 203d 2073 7472 2865  f._label = str(e
+000115c0: 7870 7273 2920 6966 206c 6162 656c 2069  xprs) if label i
+000115d0: 7320 4e6f 6e65 2065 6c73 6520 6c61 6265  s None else labe
+000115e0: 6c0a 2020 2020 2020 2020 7365 6c66 2e5f  l.        self._
+000115f0: 6c61 7465 785f 6c61 6265 6c20 3d20 6c61  latex_label = la
+00011600: 7465 7828 6578 7072 7329 2069 6620 6c61  tex(exprs) if la
+00011610: 6265 6c20 6973 204e 6f6e 6520 656c 7365  bel is None else
+00011620: 206c 6162 656c 0a20 2020 2020 2020 2023   label.        #
+00011630: 2069 6620 7468 6520 6578 7072 6573 7369   if the expressi
+00011640: 6f6e 7320 6973 2061 206c 616d 6264 6120  ons is a lambda 
+00011650: 6675 6e63 7469 6f6e 2061 6e64 206e 6f20  function and no 
+00011660: 6c61 6265 6c0a 2020 2020 2020 2020 2320  label.        # 
+00011670: 6861 7320 6265 656e 2070 726f 7669 6465  has been provide
+00011680: 642c 2074 6865 6e20 6974 7320 6265 7474  d, then its bett
+00011690: 6572 2074 6f20 646f 2074 6865 2066 6f6c  er to do the fol
+000116a0: 6c6f 7769 6e67 2074 6f20 6176 6f69 640a  lowing to avoid.
+000116b0: 2020 2020 2020 2020 2320 7375 7072 6973          # supris
+000116c0: 6573 206f 6e20 7468 6520 6261 636b 656e  es on the backen
+000116d0: 640a 2020 2020 2020 2020 6973 5f6c 616d  d.        is_lam
+000116e0: 6264 6120 3d20 2863 616c 6c61 626c 6528  bda = (callable(
+000116f0: 6578 7072 7329 2069 6620 6e6f 7420 6861  exprs) if not ha
+00011700: 7361 7474 7228 6578 7072 732c 2022 5f5f  sattr(exprs, "__
+00011710: 6974 6572 5f5f 2229 0a20 2020 2020 2020  iter__").       
+00011720: 2020 2020 2065 6c73 6520 616e 7928 6361       else any(ca
+00011730: 6c6c 6162 6c65 2865 2920 666f 7220 6520  llable(e) for e 
+00011740: 696e 2065 7870 7273 2929 0a20 2020 2020  in exprs)).     
+00011750: 2020 2069 6620 6973 5f6c 616d 6264 6120     if is_lambda 
+00011760: 616e 6420 2873 656c 662e 5f6c 6162 656c  and (self._label
+00011770: 203d 3d20 7374 7228 6578 7072 7329 293a   == str(exprs)):
+00011780: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00011790: 662e 5f6c 6162 656c 203d 2022 220a 2020  f._label = "".  
+000117a0: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+000117b0: 6c61 7465 785f 6c61 6265 6c20 3d20 2222  latex_label = ""
+000117c0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+000117d0: 2020 2020 6465 6620 7375 7266 6163 655f      def surface_
+000117e0: 636f 6c6f 7228 7365 6c66 293a 0a20 2020  color(self):.   
+000117f0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00011800: 2e5f 7375 7266 6163 655f 636f 6c6f 720a  ._surface_color.
+00011810: 0a20 2020 2040 7375 7266 6163 655f 636f  .    @surface_co
+00011820: 6c6f 722e 7365 7474 6572 0a20 2020 2064  lor.setter.    d
+00011830: 6566 2073 7572 6661 6365 5f63 6f6c 6f72  ef surface_color
+00011840: 2873 656c 662c 2076 616c 293a 0a20 2020  (self, val):.   
+00011850: 2020 2020 2073 656c 662e 5f6c 696e 655f       self._line_
+00011860: 7375 7266 6163 655f 636f 6c6f 7228 225f  surface_color("_
+00011870: 7375 7266 6163 655f 636f 6c6f 7222 2c20  surface_color", 
+00011880: 7661 6c29 0a0a 0a63 6c61 7373 2053 7572  val)...class Sur
+00011890: 6661 6365 4f76 6572 3244 5261 6e67 6553  faceOver2DRangeS
+000118a0: 6572 6965 7328 0a20 2020 2043 6f6d 6d6f  eries(.    Commo
+000118b0: 6e41 6461 7074 6976 6545 7661 6c75 6174  nAdaptiveEvaluat
+000118c0: 696f 6e2c 2043 6f6d 6d6f 6e55 6e69 666f  ion, CommonUnifo
+000118d0: 726d 4576 616c 7561 7469 6f6e 2c20 5375  rmEvaluation, Su
+000118e0: 7266 6163 6542 6173 6553 6572 6965 730a  rfaceBaseSeries.
+000118f0: 293a 0a20 2020 2022 2222 5265 7072 6573  ):.    """Repres
+00011900: 656e 7461 7469 6f6e 2066 6f72 2061 2033  entation for a 3
+00011910: 4420 7375 7266 6163 6520 636f 6e73 6973  D surface consis
+00011920: 7469 6e67 206f 6620 6120 7379 6d70 7920  ting of a sympy 
+00011930: 6578 7072 6573 7369 6f6e 2061 6e64 2032  expression and 2
+00011940: 440a 2020 2020 7261 6e67 652e 2222 220a  D.    range.""".
+00011950: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+00011960: 5f28 0a20 2020 2020 2020 2073 656c 662c  _(.        self,
+00011970: 2065 7870 722c 2076 6172 5f73 7461 7274   expr, var_start
+00011980: 5f65 6e64 5f78 2c20 7661 725f 7374 6172  _end_x, var_star
+00011990: 745f 656e 645f 792c 206c 6162 656c 3d22  t_end_y, label="
+000119a0: 222c 202a 2a6b 7761 7267 730a 2020 2020  ", **kwargs.    
+000119b0: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
+000119c0: 2829 2e5f 5f69 6e69 745f 5f28 2a2a 6b77  ().__init__(**kw
+000119d0: 6172 6773 290a 2020 2020 2020 2020 7365  args).        se
+000119e0: 6c66 2e65 7870 7220 3d20 6578 7072 2069  lf.expr = expr i
+000119f0: 6620 6361 6c6c 6162 6c65 2865 7870 7229  f callable(expr)
+00011a00: 2065 6c73 6520 7379 6d70 6966 7928 6578   else sympify(ex
+00011a10: 7072 290a 2020 2020 2020 2020 7365 6c66  pr).        self
+00011a20: 2e72 616e 6765 7320 3d20 5b76 6172 5f73  .ranges = [var_s
+00011a30: 7461 7274 5f65 6e64 5f78 2c20 7661 725f  tart_end_x, var_
+00011a40: 7374 6172 745f 656e 645f 795d 0a20 2020  start_end_y].   
+00011a50: 2020 2020 2073 656c 662e 5f73 6574 5f73       self._set_s
+00011a60: 7572 6661 6365 5f6c 6162 656c 286c 6162  urface_label(lab
+00011a70: 656c 290a 2020 2020 2020 2020 7365 6c66  el).        self
+00011a80: 2e5f 706f 7374 5f69 6e69 7428 290a 0a20  ._post_init().. 
+00011a90: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00011aa0: 2064 6566 2076 6172 5f78 2873 656c 6629   def var_x(self)
+00011ab0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00011ac0: 2073 656c 662e 7261 6e67 6573 5b30 5d5b   self.ranges[0][
+00011ad0: 305d 0a0a 2020 2020 4070 726f 7065 7274  0]..    @propert
+00011ae0: 790a 2020 2020 6465 6620 7661 725f 7928  y.    def var_y(
+00011af0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+00011b00: 6574 7572 6e20 7365 6c66 2e72 616e 6765  eturn self.range
+00011b10: 735b 315d 5b30 5d0a 0a20 2020 2040 7072  s[1][0]..    @pr
+00011b20: 6f70 6572 7479 0a20 2020 2064 6566 2073  operty.    def s
+00011b30: 7461 7274 5f78 2873 656c 6629 3a0a 2020  tart_x(self):.  
+00011b40: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+00011b50: 2020 2020 2020 2072 6574 7572 6e20 666c         return fl
+00011b60: 6f61 7428 7365 6c66 2e72 616e 6765 735b  oat(self.ranges[
+00011b70: 305d 5b31 5d29 0a20 2020 2020 2020 2065  0][1]).        e
+00011b80: 7863 6570 7420 4578 6365 7074 696f 6e3a  xcept Exception:
+00011b90: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00011ba0: 7572 6e20 7365 6c66 2e72 616e 6765 735b  urn self.ranges[
+00011bb0: 305d 5b31 5d0a 0a20 2020 2040 7072 6f70  0][1]..    @prop
+00011bc0: 6572 7479 0a20 2020 2064 6566 2065 6e64  erty.    def end
+00011bd0: 5f78 2873 656c 6629 3a0a 2020 2020 2020  _x(self):.      
+00011be0: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+00011bf0: 2020 2072 6574 7572 6e20 666c 6f61 7428     return float(
+00011c00: 7365 6c66 2e72 616e 6765 735b 305d 5b32  self.ranges[0][2
+00011c10: 5d29 0a20 2020 2020 2020 2065 7863 6570  ]).        excep
+00011c20: 7420 4578 6365 7074 696f 6e3a 0a20 2020  t Exception:.   
+00011c30: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00011c40: 7365 6c66 2e72 616e 6765 735b 305d 5b32  self.ranges[0][2
+00011c50: 5d0a 0a20 2020 2040 7072 6f70 6572 7479  ]..    @property
+00011c60: 0a20 2020 2064 6566 2073 7461 7274 5f79  .    def start_y
+00011c70: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00011c80: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
+00011c90: 2072 6574 7572 6e20 666c 6f61 7428 7365   return float(se
+00011ca0: 6c66 2e72 616e 6765 735b 315d 5b31 5d29  lf.ranges[1][1])
+00011cb0: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
+00011cc0: 4578 6365 7074 696f 6e3a 0a20 2020 2020  Exception:.     
+00011cd0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00011ce0: 6c66 2e72 616e 6765 735b 315d 5b31 5d0a  lf.ranges[1][1].
+00011cf0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+00011d00: 2020 2064 6566 2065 6e64 5f79 2873 656c     def end_y(sel
+00011d10: 6629 3a0a 2020 2020 2020 2020 7472 793a  f):.        try:
+00011d20: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00011d30: 7572 6e20 666c 6f61 7428 7365 6c66 2e72  urn float(self.r
+00011d40: 616e 6765 735b 315d 5b32 5d29 0a20 2020  anges[1][2]).   
+00011d50: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
+00011d60: 7074 696f 6e3a 0a20 2020 2020 2020 2020  ption:.         
+00011d70: 2020 2072 6574 7572 6e20 7365 6c66 2e72     return self.r
+00011d80: 616e 6765 735b 315d 5b32 5d0a 0a20 2020  anges[1][2]..   
+00011d90: 2064 6566 205f 5f73 7472 5f5f 2873 656c   def __str__(sel
+00011da0: 6629 3a0a 2020 2020 2020 2020 7365 7269  f):.        seri
+00011db0: 6573 5f74 7970 6520 3d20 2263 6172 7465  es_type = "carte
+00011dc0: 7369 616e 2073 7572 6661 6365 2220 6966  sian surface" if
+00011dd0: 2073 656c 662e 6973 5f33 4473 7572 6661   self.is_3Dsurfa
+00011de0: 6365 2065 6c73 6520 2263 6f6e 746f 7572  ce else "contour
+00011df0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
+00011e00: 2073 656c 662e 5f73 7472 5f68 656c 7065   self._str_helpe
+00011e10: 7228 0a20 2020 2020 2020 2020 2020 2073  r(.            s
+00011e20: 6572 6965 735f 7479 7065 202b 2022 3a20  eries_type + ": 
+00011e30: 2573 2066 6f72 2220 2220 2573 206f 7665  %s for" " %s ove
+00011e40: 7220 2573 2061 6e64 2025 7320 6f76 6572  r %s and %s over
+00011e50: 2025 7322 2025 2028 0a20 2020 2020 2020   %s" % (.       
+00011e60: 2020 2020 2020 2020 2073 7472 2873 656c           str(sel
+00011e70: 662e 6578 7072 292c 0a20 2020 2020 2020  f.expr),.       
+00011e80: 2020 2020 2020 2020 2073 7472 2873 656c           str(sel
+00011e90: 662e 7661 725f 7829 2c20 7374 7228 2873  f.var_x), str((s
+00011ea0: 656c 662e 7374 6172 745f 782c 2073 656c  elf.start_x, sel
+00011eb0: 662e 656e 645f 7829 292c 0a20 2020 2020  f.end_x)),.     
+00011ec0: 2020 2020 2020 2020 2020 2073 7472 2873             str(s
+00011ed0: 656c 662e 7661 725f 7929 2c20 7374 7228  elf.var_y), str(
+00011ee0: 2873 656c 662e 7374 6172 745f 792c 2073  (self.start_y, s
+00011ef0: 656c 662e 656e 645f 7929 292c 0a20 2020  elf.end_y)),.   
+00011f00: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00011f10: 2020 2029 0a0a 2020 2020 6465 6620 5f61     )..    def _a
+00011f20: 6461 7074 6976 655f 7361 6d70 6c69 6e67  daptive_sampling
+00011f30: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00011f40: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
+00011f50: 6c65 2827 6e75 6d70 7927 290a 0a20 2020  le('numpy')..   
+00011f60: 2020 2020 2064 6566 2066 756e 6328 662c       def func(f,
+00011f70: 2078 7929 3a0a 2020 2020 2020 2020 2020   xy):.          
+00011f80: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+00011f90: 2020 2020 2020 2077 203d 2066 282a 5b63         w = f(*[c
+00011fa0: 6f6d 706c 6578 2874 2920 666f 7220 7420  omplex(t) for t 
+00011fb0: 696e 2078 795d 290a 2020 2020 2020 2020  in xy]).        
+00011fc0: 2020 2020 2020 2020 7265 7475 726e 2077          return w
+00011fd0: 2e72 6561 6c20 6966 206e 702e 6973 636c  .real if np.iscl
+00011fe0: 6f73 6528 772e 696d 6167 2c20 3029 2065  ose(w.imag, 0) e
+00011ff0: 6c73 6520 6e70 2e6e 616e 0a20 2020 2020  lse np.nan.     
+00012000: 2020 2020 2020 2065 7863 6570 7420 285a         except (Z
+00012010: 6572 6f44 6976 6973 696f 6e45 7272 6f72  eroDivisionError
+00012020: 2c20 4f76 6572 666c 6f77 4572 726f 7229  , OverflowError)
+00012030: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00012040: 2020 7265 7475 726e 206e 702e 6e61 6e0a    return np.nan.
+00012050: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00012060: 5f61 6461 7074 6976 655f 6576 616c 280a  _adaptive_eval(.
+00012070: 2020 2020 2020 2020 2020 2020 6675 6e63              func
+00012080: 2c20 5b73 656c 662e 7661 725f 782c 2073  , [self.var_x, s
+00012090: 656c 662e 7661 725f 795d 2c20 7365 6c66  elf.var_y], self
+000120a0: 2e65 7870 722c 0a20 2020 2020 2020 2020  .expr,.         
+000120b0: 2020 205b 2873 656c 662e 7374 6172 745f     [(self.start_
+000120c0: 782c 2073 656c 662e 656e 645f 7829 2c20  x, self.end_x), 
+000120d0: 2873 656c 662e 7374 6172 745f 792c 2073  (self.start_y, s
+000120e0: 656c 662e 656e 645f 7929 5d2c 0a20 2020  elf.end_y)],.   
+000120f0: 2020 2020 2020 2020 206d 6f64 756c 6573           modules
+00012100: 3d73 656c 662e 6d6f 6475 6c65 732c 0a20  =self.modules,. 
+00012110: 2020 2020 2020 2020 2020 2061 6461 7074             adapt
+00012120: 6976 655f 676f 616c 3d73 656c 662e 6164  ive_goal=self.ad
+00012130: 6170 7469 7665 5f67 6f61 6c2c 0a20 2020  aptive_goal,.   
+00012140: 2020 2020 2020 2020 206c 6f73 735f 666e           loss_fn
+00012150: 3d73 656c 662e 6c6f 7373 5f66 6e29 0a0a  =self.loss_fn)..
+00012160: 2020 2020 6465 6620 5f75 6e69 666f 726d      def _uniform
+00012170: 5f73 616d 706c 696e 6728 7365 6c66 293a  _sampling(self):
+00012180: 0a20 2020 2020 2020 206e 7020 3d20 696d  .        np = im
+00012190: 706f 7274 5f6d 6f64 756c 6528 276e 756d  port_module('num
+000121a0: 7079 2729 0a0a 2020 2020 2020 2020 7265  py')..        re
+000121b0: 7375 6c74 7320 3d20 7365 6c66 2e5f 6576  sults = self._ev
+000121c0: 616c 7561 7465 2829 0a20 2020 2020 2020  aluate().       
+000121d0: 2066 6f72 2069 2c20 7220 696e 2065 6e75   for i, r in enu
+000121e0: 6d65 7261 7465 2872 6573 756c 7473 293a  merate(results):
+000121f0: 0a20 2020 2020 2020 2020 2020 205f 7265  .            _re
+00012200: 2c20 5f69 6d20 3d20 6e70 2e72 6561 6c28  , _im = np.real(
+00012210: 7229 2c20 6e70 2e69 6d61 6728 7229 0a20  r), np.imag(r). 
+00012220: 2020 2020 2020 2020 2020 205f 7265 5b6e             _re[n
+00012230: 702e 696e 7665 7274 286e 702e 6973 636c  p.invert(np.iscl
+00012240: 6f73 6528 5f69 6d2c 206e 702e 7a65 726f  ose(_im, np.zero
+00012250: 735f 6c69 6b65 285f 696d 2929 295d 203d  s_like(_im)))] =
+00012260: 206e 702e 6e61 6e0a 2020 2020 2020 2020   np.nan.        
+00012270: 2020 2020 7265 7375 6c74 735b 695d 203d      results[i] =
+00012280: 205f 7265 0a0a 2020 2020 2020 2020 7265   _re..        re
+00012290: 7475 726e 2072 6573 756c 7473 0a0a 2020  turn results..  
+000122a0: 2020 6465 6620 6765 745f 6461 7461 2873    def get_data(s
+000122b0: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+000122c0: 2252 6574 7572 6e20 6172 7261 7973 206f  "Return arrays o
+000122d0: 6620 636f 6f72 6469 6e61 7465 7320 666f  f coordinates fo
+000122e0: 7220 706c 6f74 7469 6e67 2e20 4465 7065  r plotting. Depe
+000122f0: 6e64 696e 6720 6f6e 2074 6865 0a20 2020  nding on the.   
+00012300: 2020 2020 2060 6164 6170 7469 7665 6020       `adaptive` 
+00012310: 6f70 7469 6f6e 2c20 7468 6973 2066 756e  option, this fun
+00012320: 6374 696f 6e20 7769 6c6c 2065 6974 6865  ction will eithe
+00012330: 7220 7573 6520 616e 2061 6461 7074 6976  r use an adaptiv
+00012340: 6520 616c 676f 7269 7468 6d0a 2020 2020  e algorithm.    
+00012350: 2020 2020 6f72 2069 7420 7769 6c6c 2075      or it will u
+00012360: 6e69 666f 726d 6c79 2073 616d 706c 6520  niformly sample 
+00012370: 7468 6520 6578 7072 6573 7369 6f6e 206f  the expression o
+00012380: 7665 7220 7468 6520 7072 6f76 6964 6564  ver the provided
+00012390: 2072 616e 6765 2e0a 0a20 2020 2020 2020   range...       
+000123a0: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
+000123b0: 203d 3d3d 3d3d 3d3d 0a0a 2020 2020 2020   =======..      
+000123c0: 2020 6d65 7368 5f78 203a 206e 702e 6e64    mesh_x : np.nd
+000123d0: 6172 7261 7920 5b6e 3220 7820 6e31 5d0a  array [n2 x n1].
+000123e0: 2020 2020 2020 2020 2020 2020 5265 616c              Real
+000123f0: 2044 6973 6372 6574 697a 6564 2078 2d64   Discretized x-d
+00012400: 6f6d 6169 6e2e 0a0a 2020 2020 2020 2020  omain...        
+00012410: 6d65 7368 5f79 203a 206e 702e 6e64 6172  mesh_y : np.ndar
+00012420: 7261 7920 5b6e 3220 7820 6e31 5d0a 2020  ray [n2 x n1].  
+00012430: 2020 2020 2020 2020 2020 5265 616c 2044            Real D
+00012440: 6973 6372 6574 697a 6564 2079 2d64 6f6d  iscretized y-dom
+00012450: 6169 6e2e 0a0a 2020 2020 2020 2020 7a20  ain...        z 
+00012460: 3a20 6e70 2e6e 6461 7272 6179 205b 6e32  : np.ndarray [n2
+00012470: 2078 206e 315d 0a20 2020 2020 2020 2020   x n1].         
+00012480: 2020 2052 6573 756c 7473 206f 6620 7468     Results of th
+00012490: 6520 6576 616c 7561 7469 6f6e 2e0a 2020  e evaluation..  
+000124a0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+000124b0: 2020 6e70 203d 2069 6d70 6f72 745f 6d6f    np = import_mo
+000124c0: 6475 6c65 2827 6e75 6d70 7927 290a 0a20  dule('numpy').. 
+000124d0: 2020 2020 2020 2069 6620 7365 6c66 2e61         if self.a
+000124e0: 6461 7074 6976 653a 0a20 2020 2020 2020  daptive:.       
+000124f0: 2020 2020 2072 6573 203d 2073 656c 662e       res = self.
+00012500: 5f61 6461 7074 6976 655f 7361 6d70 6c69  _adaptive_sampli
+00012510: 6e67 2829 0a20 2020 2020 2020 2065 6c73  ng().        els
+00012520: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+00012530: 6573 203d 2073 656c 662e 5f75 6e69 666f  es = self._unifo
+00012540: 726d 5f73 616d 706c 696e 6728 290a 0a20  rm_sampling().. 
+00012550: 2020 2020 2020 2078 2c20 792c 207a 203d         x, y, z =
+00012560: 2072 6573 0a20 2020 2020 2020 2069 6620   res.        if 
+00012570: 7365 6c66 2e69 735f 706f 6c61 7220 616e  self.is_polar an
+00012580: 6420 7365 6c66 2e69 735f 3344 7375 7266  d self.is_3Dsurf
+00012590: 6163 653a 0a20 2020 2020 2020 2020 2020  ace:.           
+000125a0: 2072 203d 2078 2e63 6f70 7928 290a 2020   r = x.copy().  
+000125b0: 2020 2020 2020 2020 2020 7820 3d20 7220            x = r 
+000125c0: 2a20 6e70 2e63 6f73 2879 290a 2020 2020  * np.cos(y).    
+000125d0: 2020 2020 2020 2020 7920 3d20 7220 2a20          y = r * 
+000125e0: 6e70 2e73 696e 2879 290a 0a20 2020 2020  np.sin(y)..     
+000125f0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+00012600: 6170 706c 795f 7472 616e 7366 6f72 6d28  apply_transform(
+00012610: 782c 2079 2c20 7a29 0a0a 0a63 6c61 7373  x, y, z)...class
+00012620: 2050 6172 616d 6574 7269 6353 7572 6661   ParametricSurfa
+00012630: 6365 5365 7269 6573 280a 2020 2020 436f  ceSeries(.    Co
+00012640: 6d6d 6f6e 556e 6966 6f72 6d45 7661 6c75  mmonUniformEvalu
+00012650: 6174 696f 6e2c 2053 7572 6661 6365 4261  ation, SurfaceBa
+00012660: 7365 5365 7269 6573 0a29 3a0a 2020 2020  seSeries.):.    
+00012670: 2222 2252 6570 7265 7365 6e74 6174 696f  """Representatio
+00012680: 6e20 666f 7220 6120 3344 2073 7572 6661  n for a 3D surfa
+00012690: 6365 2063 6f6e 7369 7374 696e 6720 6f66  ce consisting of
+000126a0: 2074 6872 6565 2070 6172 616d 6574 7269   three parametri
+000126b0: 6320 7379 6d70 790a 2020 2020 6578 7072  c sympy.    expr
+000126c0: 6573 7369 6f6e 7320 616e 6420 6120 7261  essions and a ra
+000126d0: 6e67 652e 2222 220a 0a20 2020 2069 735f  nge."""..    is_
+000126e0: 7061 7261 6d65 7472 6963 203d 2054 7275  parametric = Tru
+000126f0: 650a 0a20 2020 2064 6566 205f 5f69 6e69  e..    def __ini
+00012700: 745f 5f28 0a20 2020 2020 2020 2073 656c  t__(.        sel
+00012710: 662c 2065 7870 725f 782c 2065 7870 725f  f, expr_x, expr_
+00012720: 792c 2065 7870 725f 7a2c 0a20 2020 2020  y, expr_z,.     
+00012730: 2020 2076 6172 5f73 7461 7274 5f65 6e64     var_start_end
+00012740: 5f75 2c20 7661 725f 7374 6172 745f 656e  _u, var_start_en
+00012750: 645f 762c 206c 6162 656c 3d22 222c 202a  d_v, label="", *
+00012760: 2a6b 7761 7267 730a 2020 2020 293a 0a20  *kwargs.    ):. 
+00012770: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+00012780: 5f69 6e69 745f 5f28 2a2a 6b77 6172 6773  _init__(**kwargs
+00012790: 290a 2020 2020 2020 2020 7365 6c66 2e65  ).        self.e
+000127a0: 7870 725f 7820 3d20 6578 7072 5f78 2069  xpr_x = expr_x i
+000127b0: 6620 6361 6c6c 6162 6c65 2865 7870 725f  f callable(expr_
+000127c0: 7829 2065 6c73 6520 7379 6d70 6966 7928  x) else sympify(
+000127d0: 6578 7072 5f78 290a 2020 2020 2020 2020  expr_x).        
+000127e0: 7365 6c66 2e65 7870 725f 7920 3d20 6578  self.expr_y = ex
+000127f0: 7072 5f79 2069 6620 6361 6c6c 6162 6c65  pr_y if callable
+00012800: 2865 7870 725f 7929 2065 6c73 6520 7379  (expr_y) else sy
+00012810: 6d70 6966 7928 6578 7072 5f79 290a 2020  mpify(expr_y).  
+00012820: 2020 2020 2020 7365 6c66 2e65 7870 725f        self.expr_
+00012830: 7a20 3d20 6578 7072 5f7a 2069 6620 6361  z = expr_z if ca
+00012840: 6c6c 6162 6c65 2865 7870 725f 7a29 2065  llable(expr_z) e
+00012850: 6c73 6520 7379 6d70 6966 7928 6578 7072  lse sympify(expr
+00012860: 5f7a 290a 2020 2020 2020 2020 7365 6c66  _z).        self
+00012870: 2e65 7870 7220 3d20 2873 656c 662e 6578  .expr = (self.ex
+00012880: 7072 5f78 2c20 7365 6c66 2e65 7870 725f  pr_x, self.expr_
+00012890: 792c 2073 656c 662e 6578 7072 5f7a 290a  y, self.expr_z).
+000128a0: 2020 2020 2020 2020 7365 6c66 2e72 616e          self.ran
+000128b0: 6765 7320 3d20 5b76 6172 5f73 7461 7274  ges = [var_start
+000128c0: 5f65 6e64 5f75 2c20 7661 725f 7374 6172  _end_u, var_star
+000128d0: 745f 656e 645f 765d 0a20 2020 2020 2020  t_end_v].       
+000128e0: 2073 656c 662e 636f 6c6f 725f 6675 6e63   self.color_func
+000128f0: 203d 206b 7761 7267 732e 6765 7428 2263   = kwargs.get("c
+00012900: 6f6c 6f72 5f66 756e 6322 2c20 6c61 6d62  olor_func", lamb
+00012910: 6461 2078 2c20 792c 207a 2c20 752c 2076  da x, y, z, u, v
+00012920: 3a20 7a29 0a20 2020 2020 2020 2073 656c  : z).        sel
+00012930: 662e 5f73 6574 5f73 7572 6661 6365 5f6c  f._set_surface_l
+00012940: 6162 656c 286c 6162 656c 290a 2020 2020  abel(label).    
+00012950: 2020 2020 7365 6c66 2e5f 706f 7374 5f69      self._post_i
+00012960: 6e69 7428 290a 0a20 2020 2040 7072 6f70  nit()..    @prop
+00012970: 6572 7479 0a20 2020 2064 6566 2076 6172  erty.    def var
+00012980: 5f75 2873 656c 6629 3a0a 2020 2020 2020  _u(self):.      
+00012990: 2020 7265 7475 726e 2073 656c 662e 7261    return self.ra
+000129a0: 6e67 6573 5b30 5d5b 305d 0a0a 2020 2020  nges[0][0]..    
+000129b0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+000129c0: 6620 7661 725f 7628 7365 6c66 293a 0a20  f var_v(self):. 
+000129d0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+000129e0: 6c66 2e72 616e 6765 735b 315d 5b30 5d0a  lf.ranges[1][0].
+000129f0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+00012a00: 2020 2064 6566 2073 7461 7274 5f75 2873     def start_u(s
+00012a10: 656c 6629 3a0a 2020 2020 2020 2020 7472  elf):.        tr
+00012a20: 793a 0a20 2020 2020 2020 2020 2020 2072  y:.            r
+00012a30: 6574 7572 6e20 666c 6f61 7428 7365 6c66  eturn float(self
+00012a40: 2e72 616e 6765 735b 305d 5b31 5d29 0a20  .ranges[0][1]). 
+00012a50: 2020 2020 2020 2065 7863 6570 7420 4578         except Ex
+00012a60: 6365 7074 696f 6e3a 0a20 2020 2020 2020  ception:.       
+00012a70: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00012a80: 2e72 616e 6765 735b 305d 5b31 5d0a 0a20  .ranges[0][1].. 
+00012a90: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00012aa0: 2064 6566 2065 6e64 5f75 2873 656c 6629   def end_u(self)
+00012ab0: 3a0a 2020 2020 2020 2020 7472 793a 0a20  :.        try:. 
+00012ac0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00012ad0: 6e20 666c 6f61 7428 7365 6c66 2e72 616e  n float(self.ran
+00012ae0: 6765 735b 305d 5b32 5d29 0a20 2020 2020  ges[0][2]).     
+00012af0: 2020 2065 7863 6570 7420 4578 6365 7074     except Except
+00012b00: 696f 6e3a 0a20 2020 2020 2020 2020 2020  ion:.           
+00012b10: 2072 6574 7572 6e20 7365 6c66 2e72 616e   return self.ran
+00012b20: 6765 735b 305d 5b32 5d0a 0a20 2020 2040  ges[0][2]..    @
+00012b30: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00012b40: 2073 7461 7274 5f76 2873 656c 6629 3a0a   start_v(self):.
+00012b50: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+00012b60: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00012b70: 666c 6f61 7428 7365 6c66 2e72 616e 6765  float(self.range
+00012b80: 735b 315d 5b31 5d29 0a20 2020 2020 2020  s[1][1]).       
+00012b90: 2065 7863 6570 7420 4578 6365 7074 696f   except Exceptio
+00012ba0: 6e3a 0a20 2020 2020 2020 2020 2020 2072  n:.            r
+00012bb0: 6574 7572 6e20 7365 6c66 2e72 616e 6765  eturn self.range
+00012bc0: 735b 315d 5b31 5d0a 0a20 2020 2040 7072  s[1][1]..    @pr
+00012bd0: 6f70 6572 7479 0a20 2020 2064 6566 2065  operty.    def e
+00012be0: 6e64 5f76 2873 656c 6629 3a0a 2020 2020  nd_v(self):.    
+00012bf0: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+00012c00: 2020 2020 2072 6574 7572 6e20 666c 6f61       return floa
+00012c10: 7428 7365 6c66 2e72 616e 6765 735b 315d  t(self.ranges[1]
+00012c20: 5b32 5d29 0a20 2020 2020 2020 2065 7863  [2]).        exc
+00012c30: 6570 7420 4578 6365 7074 696f 6e3a 0a20  ept Exception:. 
+00012c40: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00012c50: 6e20 7365 6c66 2e72 616e 6765 735b 315d  n self.ranges[1]
+00012c60: 5b32 5d0a 0a20 2020 2064 6566 205f 5f73  [2]..    def __s
+00012c70: 7472 5f5f 2873 656c 6629 3a0a 2020 2020  tr__(self):.    
+00012c80: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00012c90: 5f73 7472 5f68 656c 7065 7228 0a20 2020  _str_helper(.   
+00012ca0: 2020 2020 2020 2020 2022 7061 7261 6d65           "parame
+00012cb0: 7472 6963 2063 6172 7465 7369 616e 2073  tric cartesian s
+00012cc0: 7572 6661 6365 3a20 2825 732c 2025 732c  urface: (%s, %s,
+00012cd0: 2025 7329 2066 6f72 220a 2020 2020 2020   %s) for".      
+00012ce0: 2020 2020 2020 2220 2573 206f 7665 7220        " %s over 
+00012cf0: 2573 2061 6e64 2025 7320 6f76 6572 2025  %s and %s over %
+00012d00: 7322 2025 2028 0a20 2020 2020 2020 2020  s" % (.         
+00012d10: 2020 2020 2020 2073 7472 2873 656c 662e         str(self.
+00012d20: 6578 7072 5f78 292c 2073 7472 2873 656c  expr_x), str(sel
+00012d30: 662e 6578 7072 5f79 292c 2073 7472 2873  f.expr_y), str(s
+00012d40: 656c 662e 6578 7072 5f7a 292c 0a20 2020  elf.expr_z),.   
+00012d50: 2020 2020 2020 2020 2020 2020 2073 7472               str
+00012d60: 2873 656c 662e 7661 725f 7529 2c20 7374  (self.var_u), st
+00012d70: 7228 2873 656c 662e 7374 6172 745f 752c  r((self.start_u,
+00012d80: 2073 656c 662e 656e 645f 7529 292c 0a20   self.end_u)),. 
+00012d90: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00012da0: 7472 2873 656c 662e 7661 725f 7629 2c20  tr(self.var_v), 
+00012db0: 7374 7228 2873 656c 662e 7374 6172 745f  str((self.start_
+00012dc0: 762c 2073 656c 662e 656e 645f 7629 292c  v, self.end_v)),
+00012dd0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+00012de0: 2020 2020 2020 2029 0a0a 2020 2020 6465         )..    de
+00012df0: 6620 6765 745f 6461 7461 2873 656c 6629  f get_data(self)
+00012e00: 3a0a 2020 2020 2020 2020 2222 2252 6574  :.        """Ret
+00012e10: 7572 6e20 6172 7261 7973 206f 6620 636f  urn arrays of co
+00012e20: 6f72 6469 6e61 7465 7320 666f 7220 706c  ordinates for pl
+00012e30: 6f74 7469 6e67 2e20 4465 7065 6e64 696e  otting. Dependin
+00012e40: 6720 6f6e 2074 6865 0a20 2020 2020 2020  g on the.       
+00012e50: 2060 6164 6170 7469 7665 6020 6f70 7469   `adaptive` opti
+00012e60: 6f6e 2c20 7468 6973 2066 756e 6374 696f  on, this functio
+00012e70: 6e20 7769 6c6c 2065 6974 6865 7220 7573  n will either us
+00012e80: 6520 616e 2061 6461 7074 6976 6520 616c  e an adaptive al
+00012e90: 676f 7269 7468 6d0a 2020 2020 2020 2020  gorithm.        
+00012ea0: 6f72 2069 7420 7769 6c6c 2075 6e69 666f  or it will unifo
+00012eb0: 726d 6c79 2073 616d 706c 6520 7468 6520  rmly sample the 
+00012ec0: 6578 7072 6573 7369 6f6e 206f 7665 7220  expression over 
+00012ed0: 7468 6520 7072 6f76 6964 6564 2072 616e  the provided ran
+00012ee0: 6765 2e0a 0a20 2020 2020 2020 2052 6574  ge...        Ret
+00012ef0: 7572 6e73 0a20 2020 2020 2020 203d 3d3d  urns.        ===
+00012f00: 3d3d 3d3d 0a0a 2020 2020 2020 2020 7820  ====..        x 
+00012f10: 3a20 6e70 2e6e 6461 7272 6179 205b 6e32  : np.ndarray [n2
+00012f20: 2078 206e 315d 0a20 2020 2020 2020 2020   x n1].         
+00012f30: 2020 2078 2d63 6f6f 7264 696e 6174 6573     x-coordinates
+00012f40: 2e0a 2020 2020 2020 2020 7920 3a20 6e70  ..        y : np
+00012f50: 2e6e 6461 7272 6179 205b 6e32 2078 206e  .ndarray [n2 x n
+00012f60: 315d 0a20 2020 2020 2020 2020 2020 2079  1].            y
+00012f70: 2d63 6f6f 7264 696e 6174 6573 2e0a 2020  -coordinates..  
+00012f80: 2020 2020 2020 7a20 3a20 6e70 2e6e 6461        z : np.nda
+00012f90: 7272 6179 205b 6e32 2078 206e 315d 0a20  rray [n2 x n1]. 
+00012fa0: 2020 2020 2020 2020 2020 207a 2d63 6f6f             z-coo
+00012fb0: 7264 696e 6174 6573 2e0a 2020 2020 2020  rdinates..      
+00012fc0: 2020 6d65 7368 5f75 203a 206e 702e 6e64    mesh_u : np.nd
+00012fd0: 6172 7261 7920 5b6e 3220 7820 6e31 5d0a  array [n2 x n1].
+00012fe0: 2020 2020 2020 2020 2020 2020 4469 7363              Disc
+00012ff0: 7265 7469 7a65 6420 7520 7261 6e67 652e  retized u range.
+00013000: 0a20 2020 2020 2020 206d 6573 685f 7620  .        mesh_v 
+00013010: 3a20 6e70 2e6e 6461 7272 6179 205b 6e32  : np.ndarray [n2
+00013020: 2078 206e 315d 0a20 2020 2020 2020 2020   x n1].         
+00013030: 2020 2044 6973 6372 6574 697a 6564 2076     Discretized v
+00013040: 2072 616e 6765 2e0a 2020 2020 2020 2020   range..        
+00013050: 2222 220a 2020 2020 2020 2020 6e70 203d  """.        np =
+00013060: 2069 6d70 6f72 745f 6d6f 6475 6c65 2827   import_module('
+00013070: 6e75 6d70 7927 290a 0a20 2020 2020 2020  numpy')..       
+00013080: 2072 6573 756c 7473 203d 2073 656c 662e   results = self.
+00013090: 5f65 7661 6c75 6174 6528 290a 2020 2020  _evaluate().    
+000130a0: 2020 2020 666f 7220 692c 2072 2069 6e20      for i, r in 
+000130b0: 656e 756d 6572 6174 6528 7265 7375 6c74  enumerate(result
+000130c0: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+000130d0: 5f72 652c 205f 696d 203d 206e 702e 7265  _re, _im = np.re
+000130e0: 616c 2872 292c 206e 702e 696d 6167 2872  al(r), np.imag(r
+000130f0: 290a 2020 2020 2020 2020 2020 2020 5f72  ).            _r
+00013100: 655b 6e70 2e69 6e76 6572 7428 6e70 2e69  e[np.invert(np.i
+00013110: 7363 6c6f 7365 285f 696d 2c20 6e70 2e7a  sclose(_im, np.z
+00013120: 6572 6f73 5f6c 696b 6528 5f69 6d29 2929  eros_like(_im)))
+00013130: 5d20 3d20 6e70 2e6e 616e 0a20 2020 2020  ] = np.nan.     
+00013140: 2020 2020 2020 2072 6573 756c 7473 5b69         results[i
+00013150: 5d20 3d20 5f72 650a 0a20 2020 2020 2020  ] = _re..       
+00013160: 2072 6574 7572 6e20 7365 6c66 2e5f 6170   return self._ap
+00013170: 706c 795f 7472 616e 7366 6f72 6d28 2a72  ply_transform(*r
+00013180: 6573 756c 7473 5b32 3a5d 2c20 2a72 6573  esults[2:], *res
+00013190: 756c 7473 5b3a 325d 290a 0a0a 636c 6173  ults[:2])...clas
+000131a0: 7320 436f 6e74 6f75 7253 6572 6965 7328  s ContourSeries(
+000131b0: 5375 7266 6163 654f 7665 7232 4452 616e  SurfaceOver2DRan
+000131c0: 6765 5365 7269 6573 293a 0a20 2020 2022  geSeries):.    "
+000131d0: 2222 5265 7072 6573 656e 7461 7469 6f6e  ""Representation
+000131e0: 2066 6f72 2061 2063 6f6e 746f 7572 2070   for a contour p
+000131f0: 6c6f 742e 2222 220a 0a20 2020 2069 735f  lot."""..    is_
+00013200: 3344 7375 7266 6163 6520 3d20 4661 6c73  3Dsurface = Fals
+00013210: 650a 2020 2020 6973 5f63 6f6e 746f 7572  e.    is_contour
+00013220: 203d 2054 7275 650a 2020 2020 5f61 6c6c   = True.    _all
+00013230: 6f77 6564 5f6b 6579 7320 3d20 5b0a 2020  owed_keys = [.  
+00013240: 2020 2020 2020 2263 6f6e 746f 7572 5f6b        "contour_k
+00013250: 7722 2c20 2269 735f 6669 6c6c 6564 222c  w", "is_filled",
+00013260: 2022 6669 6c6c 222c 2022 636c 6162 656c   "fill", "clabel
+00013270: 7322 5d0a 0a20 2020 2064 6566 205f 5f69  s"]..    def __i
+00013280: 6e69 745f 5f28 7365 6c66 2c20 2a61 7267  nit__(self, *arg
+00013290: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
+000132a0: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
+000132b0: 696e 6974 5f5f 282a 6172 6773 2c20 2a2a  init__(*args, **
+000132c0: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
+000132d0: 7365 6c66 2e69 735f 6669 6c6c 6564 203d  self.is_filled =
+000132e0: 206b 7761 7267 732e 6765 7428 2269 735f   kwargs.get("is_
+000132f0: 6669 6c6c 6564 222c 206b 7761 7267 732e  filled", kwargs.
+00013300: 6765 7428 2266 696c 6c22 2c20 5472 7565  get("fill", True
+00013310: 2929 0a20 2020 2020 2020 2073 656c 662e  )).        self.
+00013320: 7368 6f77 5f63 6c61 6265 6c73 203d 206b  show_clabels = k
+00013330: 7761 7267 732e 6765 7428 2263 6c61 6265  wargs.get("clabe
+00013340: 6c73 222c 2054 7275 6529 0a0a 2020 2020  ls", True)..    
+00013350: 2020 2020 2320 4e4f 5445 3a20 636f 6e74      # NOTE: cont
+00013360: 6f75 7220 706c 6f74 7320 6172 6520 7573  our plots are us
+00013370: 6564 2062 7920 706c 6f74 5f63 6f6e 746f  ed by plot_conto
+00013380: 7572 2c20 706c 6f74 5f76 6563 746f 7220  ur, plot_vector 
+00013390: 616e 640a 2020 2020 2020 2020 2320 706c  and.        # pl
+000133a0: 6f74 5f63 6f6d 706c 6578 5f76 6563 746f  ot_complex_vecto
+000133b0: 722e 2042 7920 696d 706c 656d 656e 7469  r. By implementi
+000133c0: 6e67 2063 6f6e 746f 7572 5f6b 7720 7765  ng contour_kw we
+000133d0: 2061 7265 2061 626c 6520 746f 0a20 2020   are able to.   
+000133e0: 2020 2020 2023 2071 7569 636b 6c79 2074       # quickly t
+000133f0: 6172 6765 7420 7468 6520 636f 6e74 6f75  arget the contou
+00013400: 7220 706c 6f74 2e0a 2020 2020 2020 2020  r plot..        
+00013410: 7365 6c66 2e72 656e 6465 7269 6e67 5f6b  self.rendering_k
+00013420: 7720 3d20 6b77 6172 6773 2e67 6574 280a  w = kwargs.get(.
+00013430: 2020 2020 2020 2020 2020 2020 2263 6f6e              "con
+00013440: 746f 7572 5f6b 7722 2c20 6b77 6172 6773  tour_kw", kwargs
+00013450: 2e67 6574 2822 7265 6e64 6572 696e 675f  .get("rendering_
+00013460: 6b77 222c 2064 6963 7428 2929 290a 0a0a  kw", dict()))...
+00013470: 636c 6173 7320 496d 706c 6963 6974 5365  class ImplicitSe
+00013480: 7269 6573 280a 2020 2020 436f 6d6d 6f6e  ries(.    Common
+00013490: 556e 6966 6f72 6d45 7661 6c75 6174 696f  UniformEvaluatio
+000134a0: 6e2c 2042 6173 6553 6572 6965 730a 293a  n, BaseSeries.):
+000134b0: 0a20 2020 2022 2222 5265 7072 6573 656e  .    """Represen
+000134c0: 7461 7469 6f6e 2066 6f72 2049 6d70 6c69  tation for Impli
+000134d0: 6369 7420 706c 6f74 0a0a 2020 2020 5265  cit plot..    Re
+000134e0: 6665 7265 6e63 6573 0a20 2020 203d 3d3d  ferences.    ===
+000134f0: 3d3d 3d3d 3d3d 3d0a 0a20 2020 202e 2e20  =======..    .. 
+00013500: 5b31 5d20 4a65 6666 7265 7920 416c 6c65  [1] Jeffrey Alle
+00013510: 6e20 5475 7070 6572 2e20 5265 6c69 6162  n Tupper. Reliab
+00013520: 6c65 2054 776f 2d44 696d 656e 7369 6f6e  le Two-Dimension
+00013530: 616c 2047 7261 7068 696e 6720 4d65 7468  al Graphing Meth
+00013540: 6f64 7320 666f 720a 2020 2020 4d61 7468  ods for.    Math
+00013550: 656d 6174 6963 616c 2046 6f72 6d75 6c61  ematical Formula
+00013560: 6520 7769 7468 2054 776f 2046 7265 6520  e with Two Free 
+00013570: 5661 7269 6162 6c65 732e 0a0a 2020 2020  Variables...    
+00013580: 2e2e 205b 325d 204a 6566 6672 6579 2041  .. [2] Jeffrey A
+00013590: 6c6c 656e 2054 7570 7065 722e 2047 7261  llen Tupper. Gra
+000135a0: 7068 696e 6720 4571 7561 7469 6f6e 7320  phing Equations 
+000135b0: 7769 7468 2047 656e 6572 616c 697a 6564  with Generalized
+000135c0: 2049 6e74 6572 7661 6c0a 2020 2020 4172   Interval.    Ar
+000135d0: 6974 686d 6574 6963 2e20 4d61 7374 6572  ithmetic. Master
+000135e0: 2773 2074 6865 7369 732e 2055 6e69 7665  's thesis. Unive
+000135f0: 7273 6974 7920 6f66 2054 6f72 6f6e 746f  rsity of Toronto
+00013600: 2c20 3139 3936 0a20 2020 2022 2222 0a0a  , 1996.    """..
+00013610: 2020 2020 6973 5f69 6d70 6c69 6369 7420      is_implicit 
+00013620: 3d20 5472 7565 0a20 2020 2075 7365 5f63  = True.    use_c
+00013630: 6d20 3d20 4661 6c73 650a 2020 2020 5f61  m = False.    _a
+00013640: 6c6c 6f77 6564 5f6b 6579 7320 3d20 5b22  llowed_keys = ["
+00013650: 6164 6170 7469 7665 222c 2022 6465 7074  adaptive", "dept
+00013660: 6822 2c20 2263 6f6c 6f72 225d 0a20 2020  h", "color"].   
+00013670: 205f 4e20 3d20 3130 300a 0a20 2020 2064   _N = 100..    d
+00013680: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+00013690: 2c20 6578 7072 2c20 7661 725f 7374 6172  , expr, var_star
+000136a0: 745f 656e 645f 782c 2076 6172 5f73 7461  t_end_x, var_sta
+000136b0: 7274 5f65 6e64 5f79 2c20 6c61 6265 6c3d  rt_end_y, label=
+000136c0: 2222 2c20 2a2a 6b77 6172 6773 293a 0a20  "", **kwargs):. 
+000136d0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+000136e0: 5f69 6e69 745f 5f28 2a2a 6b77 6172 6773  _init__(**kwargs
+000136f0: 290a 2020 2020 2020 2020 7365 6c66 2e61  ).        self.a
+00013700: 6461 7074 6976 6520 3d20 6b77 6172 6773  daptive = kwargs
+00013710: 2e67 6574 2822 6164 6170 7469 7665 222c  .get("adaptive",
+00013720: 2046 616c 7365 290a 2020 2020 2020 2020   False).        
+00013730: 7365 6c66 2e65 7870 7220 3d20 6578 7072  self.expr = expr
+00013740: 0a20 2020 2020 2020 2073 656c 662e 5f6c  .        self._l
+00013750: 6162 656c 203d 2073 7472 2865 7870 7229  abel = str(expr)
+00013760: 2069 6620 6c61 6265 6c20 6973 204e 6f6e   if label is Non
+00013770: 6520 656c 7365 206c 6162 656c 0a20 2020  e else label.   
+00013780: 2020 2020 2073 656c 662e 5f6c 6174 6578       self._latex
+00013790: 5f6c 6162 656c 203d 206c 6174 6578 2865  _label = latex(e
+000137a0: 7870 7229 2069 6620 6c61 6265 6c20 6973  xpr) if label is
+000137b0: 204e 6f6e 6520 656c 7365 206c 6162 656c   None else label
+000137c0: 0a20 2020 2020 2020 2073 656c 662e 7261  .        self.ra
+000137d0: 6e67 6573 203d 205b 7661 725f 7374 6172  nges = [var_star
+000137e0: 745f 656e 645f 782c 2076 6172 5f73 7461  t_end_x, var_sta
+000137f0: 7274 5f65 6e64 5f79 5d0a 2020 2020 2020  rt_end_y].      
+00013800: 2020 7365 6c66 2e76 6172 5f78 2c20 7365    self.var_x, se
+00013810: 6c66 2e73 7461 7274 5f78 2c20 7365 6c66  lf.start_x, self
+00013820: 2e65 6e64 5f78 203d 2073 656c 662e 7261  .end_x = self.ra
+00013830: 6e67 6573 5b30 5d0a 2020 2020 2020 2020  nges[0].        
+00013840: 7365 6c66 2e76 6172 5f79 2c20 7365 6c66  self.var_y, self
+00013850: 2e73 7461 7274 5f79 2c20 7365 6c66 2e65  .start_y, self.e
+00013860: 6e64 5f79 203d 2073 656c 662e 7261 6e67  nd_y = self.rang
+00013870: 6573 5b31 5d0a 2020 2020 2020 2020 7365  es[1].        se
+00013880: 6c66 2e5f 636f 6c6f 7220 3d20 6b77 6172  lf._color = kwar
+00013890: 6773 2e67 6574 2822 636f 6c6f 7222 2c20  gs.get("color", 
+000138a0: 6b77 6172 6773 2e67 6574 2822 6c69 6e65  kwargs.get("line
+000138b0: 5f63 6f6c 6f72 222c 204e 6f6e 6529 290a  _color", None)).
+000138c0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+000138d0: 2e69 735f 696e 7465 7261 6374 6976 6520  .is_interactive 
+000138e0: 616e 6420 7365 6c66 2e61 6461 7074 6976  and self.adaptiv
+000138f0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+00013900: 6169 7365 204e 6f74 496d 706c 656d 656e  aise NotImplemen
+00013910: 7465 6445 7272 6f72 2822 496e 7465 7261  tedError("Intera
+00013920: 6374 6976 6520 706c 6f74 2077 6974 6820  ctive plot with 
+00013930: 6061 6461 7074 6976 653d 5472 7565 6020  `adaptive=True` 
+00013940: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+00013950: 2020 2269 7320 6e6f 7420 7375 7070 6f72    "is not suppor
+00013960: 7465 642e 2229 0a0a 2020 2020 2020 2020  ted.")..        
+00013970: 2320 4368 6563 6b20 7768 6574 6865 7220  # Check whether 
+00013980: 7468 6520 6465 7074 6820 6973 2067 7265  the depth is gre
+00013990: 6174 6572 2074 6861 6e20 3420 6f72 206c  ater than 4 or l
+000139a0: 6573 7320 7468 616e 2030 2e0a 2020 2020  ess than 0..    
+000139b0: 2020 2020 6465 7074 6820 3d20 6b77 6172      depth = kwar
+000139c0: 6773 2e67 6574 2822 6465 7074 6822 2c20  gs.get("depth", 
+000139d0: 3029 0a20 2020 2020 2020 2069 6620 6465  0).        if de
+000139e0: 7074 6820 3e20 343a 0a20 2020 2020 2020  pth > 4:.       
+000139f0: 2020 2020 2064 6570 7468 203d 2034 0a20       depth = 4. 
+00013a00: 2020 2020 2020 2065 6c69 6620 6465 7074         elif dept
+00013a10: 6820 3c20 303a 0a20 2020 2020 2020 2020  h < 0:.         
+00013a20: 2020 2064 6570 7468 203d 2030 0a20 2020     depth = 0.   
+00013a30: 2020 2020 2073 656c 662e 6465 7074 6820       self.depth 
+00013a40: 3d20 3420 2b20 6465 7074 680a 2020 2020  = 4 + depth.    
+00013a50: 2020 2020 7365 6c66 2e5f 706f 7374 5f69      self._post_i
+00013a60: 6e69 7428 290a 0a20 2020 2040 7072 6f70  nit()..    @prop
+00013a70: 6572 7479 0a20 2020 2064 6566 2065 7870  erty.    def exp
+00013a80: 7228 7365 6c66 293a 0a20 2020 2020 2020  r(self):.       
+00013a90: 2069 6620 7365 6c66 2e61 6461 7074 6976   if self.adaptiv
+00013aa0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+00013ab0: 6574 7572 6e20 7365 6c66 2e5f 6164 6170  eturn self._adap
+00013ac0: 7469 7665 5f65 7870 720a 2020 2020 2020  tive_expr.      
+00013ad0: 2020 7265 7475 726e 2073 656c 662e 5f6e    return self._n
+00013ae0: 6f6e 5f61 6461 7074 6976 655f 6578 7072  on_adaptive_expr
+00013af0: 0a0a 2020 2020 4065 7870 722e 7365 7474  ..    @expr.sett
+00013b00: 6572 0a20 2020 2064 6566 2065 7870 7228  er.    def expr(
+00013b10: 7365 6c66 2c20 6578 7072 293a 0a20 2020  self, expr):.   
+00013b20: 2020 2020 2073 656c 662e 5f62 6c6f 636b       self._block
+00013b30: 5f6c 616d 6264 615f 6675 6e63 7469 6f6e  _lambda_function
+00013b40: 7328 6578 7072 290a 2020 2020 2020 2020  s(expr).        
+00013b50: 2320 7468 6573 6520 6172 6520 6e65 6564  # these are need
+00013b60: 6564 2066 6f72 2061 6461 7074 6976 6520  ed for adaptive 
+00013b70: 6576 616c 7561 7469 6f6e 0a20 2020 2020  evaluation.     
+00013b80: 2020 2065 7870 722c 2068 6173 5f65 7175     expr, has_equ
+00013b90: 616c 6974 7920 3d20 7365 6c66 2e5f 6861  ality = self._ha
+00013ba0: 735f 6571 7561 6c69 7479 2873 796d 7069  s_equality(sympi
+00013bb0: 6679 2865 7870 7229 290a 2020 2020 2020  fy(expr)).      
+00013bc0: 2020 7365 6c66 2e5f 6164 6170 7469 7665    self._adaptive
+00013bd0: 5f65 7870 7220 3d20 6578 7072 0a20 2020  _expr = expr.   
+00013be0: 2020 2020 2073 656c 662e 6861 735f 6571       self.has_eq
+00013bf0: 7561 6c69 7479 203d 2068 6173 5f65 7175  uality = has_equ
+00013c00: 616c 6974 790a 2020 2020 2020 2020 7365  ality.        se
+00013c10: 6c66 2e5f 6c61 6265 6c20 3d20 7374 7228  lf._label = str(
+00013c20: 6578 7072 290a 2020 2020 2020 2020 7365  expr).        se
+00013c30: 6c66 2e5f 6c61 7465 785f 6c61 6265 6c20  lf._latex_label 
+00013c40: 3d20 6c61 7465 7828 6578 7072 290a 0a20  = latex(expr).. 
+00013c50: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+00013c60: 616e 6365 2865 7870 722c 2028 426f 6f6c  ance(expr, (Bool
+00013c70: 6561 6e46 756e 6374 696f 6e2c 204e 6529  eanFunction, Ne)
+00013c80: 2920 616e 6420 286e 6f74 2073 656c 662e  ) and (not self.
+00013c90: 6164 6170 7469 7665 293a 0a20 2020 2020  adaptive):.     
+00013ca0: 2020 2020 2020 2073 656c 662e 6164 6170         self.adap
+00013cb0: 7469 7665 203d 2054 7275 650a 2020 2020  tive = True.    
+00013cc0: 2020 2020 2020 2020 6d73 6720 3d20 2263          msg = "c
+00013cd0: 6f6e 7461 696e 7320 426f 6f6c 6561 6e20  ontains Boolean 
+00013ce0: 6675 6e63 7469 6f6e 732e 2022 0a20 2020  functions. ".   
+00013cf0: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
+00013d00: 7374 616e 6365 2865 7870 722c 204e 6529  stance(expr, Ne)
+00013d10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00013d20: 2020 6d73 6720 3d20 2269 7320 616e 2075    msg = "is an u
+00013d30: 6e65 7175 616c 6974 792e 2022 0a20 2020  nequality. ".   
+00013d40: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
+00013d50: 732e 7761 726e 2866 2254 6865 2070 726f  s.warn(f"The pro
+00013d60: 7669 6465 6420 6578 7072 6573 7369 6f6e  vided expression
+00013d70: 207b 6d73 677d 220a 2020 2020 2020 2020   {msg}".        
+00013d80: 2020 2020 2020 2020 2249 6e20 6f72 6465          "In orde
+00013d90: 7220 746f 2070 6c6f 7420 7468 6520 6578  r to plot the ex
+00013da0: 7072 6573 7369 6f6e 2c20 7468 6520 616c  pression, the al
+00013db0: 676f 7269 7468 6d20 220a 2020 2020 2020  gorithm ".      
+00013dc0: 2020 2020 2020 2020 2020 2261 7574 6f6d            "autom
+00013dd0: 6174 6963 616c 6c79 2073 7769 7463 6865  atically switche
+00013de0: 6420 746f 2061 6e20 6164 6170 7469 7665  d to an adaptive
+00013df0: 2073 616d 706c 696e 672e 222c 0a20 2020   sampling.",.   
+00013e00: 2020 2020 2020 2020 2020 2020 2073 7461               sta
+00013e10: 636b 6c65 7665 6c3d 3129 0a0a 2020 2020  cklevel=1)..    
+00013e20: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+00013e30: 6528 6578 7072 2c20 426f 6f6c 6561 6e46  e(expr, BooleanF
+00013e40: 756e 6374 696f 6e29 3a0a 2020 2020 2020  unction):.      
+00013e50: 2020 2020 2020 7365 6c66 2e5f 6e6f 6e5f        self._non_
+00013e60: 6164 6170 7469 7665 5f65 7870 7220 3d20  adaptive_expr = 
+00013e70: 4e6f 6e65 0a20 2020 2020 2020 2020 2020  None.           
+00013e80: 2073 656c 662e 5f69 735f 6571 7561 6c69   self._is_equali
+00013e90: 7479 203d 2046 616c 7365 0a20 2020 2020  ty = False.     
+00013ea0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00013eb0: 2020 2020 2023 2074 6865 7365 2061 7265       # these are
+00013ec0: 206e 6565 6465 6420 666f 7220 756e 6966   needed for unif
+00013ed0: 6f72 6d20 6d65 7368 696e 6720 6576 616c  orm meshing eval
+00013ee0: 7561 7469 6f6e 0a20 2020 2020 2020 2020  uation.         
+00013ef0: 2020 2065 7870 722c 2069 735f 6571 7561     expr, is_equa
+00013f00: 6c69 7479 203d 2073 656c 662e 5f70 7265  lity = self._pre
+00013f10: 7072 6f63 6573 735f 6d65 7368 6772 6964  process_meshgrid
+00013f20: 5f65 7870 7265 7373 696f 6e28 0a20 2020  _expression(.   
+00013f30: 2020 2020 2020 2020 2020 2020 2065 7870               exp
+00013f40: 722c 2073 656c 662e 6164 6170 7469 7665  r, self.adaptive
+00013f50: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+00013f60: 6c66 2e5f 6e6f 6e5f 6164 6170 7469 7665  lf._non_adaptive
+00013f70: 5f65 7870 7220 3d20 6578 7072 0a20 2020  _expr = expr.   
+00013f80: 2020 2020 2020 2020 2073 656c 662e 5f69           self._i
+00013f90: 735f 6571 7561 6c69 7479 203d 2069 735f  s_equality = is_
+00013fa0: 6571 7561 6c69 7479 0a0a 2020 2020 4070  equality..    @p
+00013fb0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+00013fc0: 6c69 6e65 5f63 6f6c 6f72 2873 656c 6629  line_color(self)
+00013fd0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00013fe0: 2073 656c 662e 5f63 6f6c 6f72 0a0a 2020   self._color..  
+00013ff0: 2020 406c 696e 655f 636f 6c6f 722e 7365    @line_color.se
+00014000: 7474 6572 0a20 2020 2064 6566 206c 696e  tter.    def lin
+00014010: 655f 636f 6c6f 7228 7365 6c66 2c20 7629  e_color(self, v)
+00014020: 3a0a 2020 2020 2020 2020 7365 6c66 2e5f  :.        self._
+00014030: 636f 6c6f 7220 3d20 760a 0a20 2020 2063  color = v..    c
+00014040: 6f6c 6f72 203d 206c 696e 655f 636f 6c6f  olor = line_colo
+00014050: 720a 0a20 2020 2064 6566 205f 6861 735f  r..    def _has_
+00014060: 6571 7561 6c69 7479 2873 656c 662c 2065  equality(self, e
+00014070: 7870 7229 3a0a 2020 2020 2020 2020 2320  xpr):.        # 
+00014080: 5265 7072 6573 656e 7473 2077 6865 7468  Represents wheth
+00014090: 6572 2074 6865 2065 7870 7265 7373 696f  er the expressio
+000140a0: 6e20 636f 6e74 6169 6e73 2061 6e20 4571  n contains an Eq
+000140b0: 7561 6c69 7479 2c20 4772 6561 7465 7254  uality, GreaterT
+000140c0: 6861 6e0a 2020 2020 2020 2020 2320 6f72  han.        # or
+000140d0: 204c 6573 7354 6861 6e0a 2020 2020 2020   LessThan.      
+000140e0: 2020 6861 735f 6571 7561 6c69 7479 203d    has_equality =
+000140f0: 2046 616c 7365 0a0a 2020 2020 2020 2020   False..        
+00014100: 6465 6620 6172 675f 6578 7061 6e64 2862  def arg_expand(b
+00014110: 6f6f 6c5f 6578 7072 293a 0a20 2020 2020  ool_expr):.     
+00014120: 2020 2020 2020 2022 2222 5265 6375 7273         """Recurs
+00014130: 6976 656c 7920 6578 7061 6e64 7320 7468  ively expands th
+00014140: 6520 6172 6775 6d65 6e74 7320 6f66 2061  e arguments of a
+00014150: 6e20 426f 6f6c 6561 6e20 4675 6e63 7469  n Boolean Functi
+00014160: 6f6e 2222 220a 2020 2020 2020 2020 2020  on""".          
+00014170: 2020 666f 7220 6172 6720 696e 2062 6f6f    for arg in boo
+00014180: 6c5f 6578 7072 2e61 7267 733a 0a20 2020  l_expr.args:.   
+00014190: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+000141a0: 6973 696e 7374 616e 6365 2861 7267 2c20  isinstance(arg, 
+000141b0: 426f 6f6c 6561 6e46 756e 6374 696f 6e29  BooleanFunction)
+000141c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000141d0: 2020 2020 2020 6172 675f 6578 7061 6e64        arg_expand
+000141e0: 2861 7267 290a 2020 2020 2020 2020 2020  (arg).          
+000141f0: 2020 2020 2020 656c 6966 2069 7369 6e73        elif isins
+00014200: 7461 6e63 6528 6172 672c 2052 656c 6174  tance(arg, Relat
+00014210: 696f 6e61 6c29 3a0a 2020 2020 2020 2020  ional):.        
+00014220: 2020 2020 2020 2020 2020 2020 6172 675f              arg_
+00014230: 6c69 7374 2e61 7070 656e 6428 6172 6729  list.append(arg)
+00014240: 0a0a 2020 2020 2020 2020 6172 675f 6c69  ..        arg_li
+00014250: 7374 203d 205b 5d0a 2020 2020 2020 2020  st = [].        
+00014260: 6966 2069 7369 6e73 7461 6e63 6528 6578  if isinstance(ex
+00014270: 7072 2c20 426f 6f6c 6561 6e46 756e 6374  pr, BooleanFunct
+00014280: 696f 6e29 3a0a 2020 2020 2020 2020 2020  ion):.          
+00014290: 2020 6172 675f 6578 7061 6e64 2865 7870    arg_expand(exp
+000142a0: 7229 0a20 2020 2020 2020 2020 2020 2023  r).            #
+000142b0: 2043 6865 636b 2077 6865 7468 6572 2074   Check whether t
+000142c0: 6865 7265 2069 7320 616e 2065 7175 616c  here is an equal
+000142d0: 6974 7920 696e 2074 6865 2065 7870 7265  ity in the expre
+000142e0: 7373 696f 6e20 7072 6f76 6964 6564 2e0a  ssion provided..
+000142f0: 2020 2020 2020 2020 2020 2020 6966 2061              if a
+00014300: 6e79 2869 7369 6e73 7461 6e63 6528 652c  ny(isinstance(e,
+00014310: 2028 4571 7561 6c69 7479 2c20 4772 6561   (Equality, Grea
+00014320: 7465 7254 6861 6e2c 204c 6573 7354 6861  terThan, LessTha
+00014330: 6e29 2920 666f 7220 6520 696e 2061 7267  n)) for e in arg
+00014340: 5f6c 6973 7429 3a0a 2020 2020 2020 2020  _list):.        
+00014350: 2020 2020 2020 2020 6861 735f 6571 7561          has_equa
+00014360: 6c69 7479 203d 2054 7275 650a 2020 2020  lity = True.    
+00014370: 2020 2020 656c 6966 206e 6f74 2069 7369      elif not isi
+00014380: 6e73 7461 6e63 6528 6578 7072 2c20 5265  nstance(expr, Re
+00014390: 6c61 7469 6f6e 616c 293a 0a20 2020 2020  lational):.     
+000143a0: 2020 2020 2020 2065 7870 7220 3d20 4571         expr = Eq
+000143b0: 7561 6c69 7479 2865 7870 722c 2030 290a  uality(expr, 0).
+000143c0: 2020 2020 2020 2020 2020 2020 6861 735f              has_
+000143d0: 6571 7561 6c69 7479 203d 2054 7275 650a  equality = True.
+000143e0: 2020 2020 2020 2020 656c 6966 2069 7369          elif isi
+000143f0: 6e73 7461 6e63 6528 6578 7072 2c20 2845  nstance(expr, (E
+00014400: 7175 616c 6974 792c 2047 7265 6174 6572  quality, Greater
+00014410: 5468 616e 2c20 4c65 7373 5468 616e 2929  Than, LessThan))
+00014420: 3a0a 2020 2020 2020 2020 2020 2020 6861  :.            ha
+00014430: 735f 6571 7561 6c69 7479 203d 2054 7275  s_equality = Tru
+00014440: 650a 0a20 2020 2020 2020 2072 6574 7572  e..        retur
+00014450: 6e20 6578 7072 2c20 6861 735f 6571 7561  n expr, has_equa
+00014460: 6c69 7479 0a0a 2020 2020 6465 6620 5f5f  lity..    def __
+00014470: 7374 725f 5f28 7365 6c66 293a 0a20 2020  str__(self):.   
+00014480: 2020 2020 2066 203d 206c 616d 6264 6120       f = lambda 
+00014490: 743a 2066 6c6f 6174 2874 2920 6966 206c  t: float(t) if l
+000144a0: 656e 2874 2e66 7265 655f 7379 6d62 6f6c  en(t.free_symbol
+000144b0: 7329 203d 3d20 3020 656c 7365 2074 0a0a  s) == 0 else t..
+000144c0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+000144d0: 656c 662e 5f73 7472 5f68 656c 7065 7228  elf._str_helper(
+000144e0: 0a20 2020 2020 2020 2020 2020 2022 496d  .            "Im
+000144f0: 706c 6963 6974 2065 7870 7265 7373 696f  plicit expressio
+00014500: 6e3a 2025 7320 666f 7220 2573 206f 7665  n: %s for %s ove
+00014510: 7220 2573 2061 6e64 2025 7320 6f76 6572  r %s and %s over
+00014520: 2025 7322 2920 2520 280a 2020 2020 2020   %s") % (.      
+00014530: 2020 2020 2020 7374 7228 7365 6c66 2e5f        str(self._
+00014540: 6164 6170 7469 7665 5f65 7870 7229 2c0a  adaptive_expr),.
+00014550: 2020 2020 2020 2020 2020 2020 7374 7228              str(
+00014560: 7365 6c66 2e76 6172 5f78 292c 0a20 2020  self.var_x),.   
+00014570: 2020 2020 2020 2020 2073 7472 2828 6628           str((f(
+00014580: 7365 6c66 2e73 7461 7274 5f78 292c 2066  self.start_x), f
+00014590: 2873 656c 662e 656e 645f 7829 2929 2c0a  (self.end_x))),.
+000145a0: 2020 2020 2020 2020 2020 2020 7374 7228              str(
+000145b0: 7365 6c66 2e76 6172 5f79 292c 0a20 2020  self.var_y),.   
+000145c0: 2020 2020 2020 2020 2073 7472 2828 6628           str((f(
+000145d0: 7365 6c66 2e73 7461 7274 5f79 292c 2066  self.start_y), f
+000145e0: 2873 656c 662e 656e 645f 7929 2929 2c0a  (self.end_y))),.
+000145f0: 2020 2020 2020 2020 290a 0a20 2020 2064          )..    d
+00014600: 6566 2067 6574 5f64 6174 6128 7365 6c66  ef get_data(self
+00014610: 293a 0a20 2020 2020 2020 2022 2222 5265  ):.        """Re
+00014620: 7475 726e 7320 6e75 6d65 7269 6361 6c20  turns numerical 
+00014630: 6461 7461 2e0a 0a20 2020 2020 2020 2052  data...        R
+00014640: 6574 7572 6e73 0a20 2020 2020 2020 203d  eturns.        =
+00014650: 3d3d 3d3d 3d3d 0a0a 2020 2020 2020 2020  ======..        
+00014660: 4966 2074 6865 2073 6572 6965 7320 6973  If the series is
+00014670: 2065 7661 6c75 6174 6564 2077 6974 6820   evaluated with 
+00014680: 7468 6520 6061 6461 7074 6976 653d 5472  the `adaptive=Tr
+00014690: 7565 6020 6974 2072 6574 7572 6e73 3a0a  ue` it returns:.
+000146a0: 0a20 2020 2020 2020 2069 6e74 6572 7661  .        interva
+000146b0: 6c5f 6c69 7374 203a 206c 6973 740a 2020  l_list : list.  
+000146c0: 2020 2020 2020 2020 2020 4c69 7374 206f            List o
+000146d0: 6620 626f 756e 6469 6e67 2072 6563 7461  f bounding recta
+000146e0: 6e67 756c 6172 2069 6e74 6572 7661 6c73  ngular intervals
+000146f0: 2074 6f20 6265 2070 6f73 7470 726f 6365   to be postproce
+00014700: 7373 6564 2061 6e64 0a20 2020 2020 2020  ssed and.       
+00014710: 2020 2020 2065 7665 6e74 7561 6c6c 7920       eventually 
+00014720: 7573 6564 2077 6974 6820 4d61 7470 6c6f  used with Matplo
+00014730: 746c 6962 2773 2060 6066 696c 6c60 6020  tlib's ``fill`` 
+00014740: 636f 6d6d 616e 642e 0a20 2020 2020 2020  command..       
+00014750: 2064 756d 6d79 203a 2073 7472 0a20 2020   dummy : str.   
+00014760: 2020 2020 2020 2020 2041 2073 7472 696e           A strin
+00014770: 6720 636f 6e74 6169 6e69 6e67 2060 6022  g containing ``"
+00014780: 6669 6c6c 2260 602e 0a0a 2020 2020 2020  fill"``...      
+00014790: 2020 4f74 6865 7277 6973 652c 2069 7420    Otherwise, it 
+000147a0: 7265 7475 726e 7320 3244 206e 756d 7079  returns 2D numpy
+000147b0: 2061 7272 6179 7320 746f 2062 6520 7573   arrays to be us
+000147c0: 6564 2077 6974 6820 4d61 7470 6c6f 746c  ed with Matplotl
+000147d0: 6962 2773 0a20 2020 2020 2020 2060 6063  ib's.        ``c
+000147e0: 6f6e 746f 7572 6060 206f 7220 6060 636f  ontour`` or ``co
+000147f0: 6e74 6f75 7266 6060 2063 6f6d 6d61 6e64  ntourf`` command
+00014800: 733a 0a0a 2020 2020 2020 2020 785f 6172  s:..        x_ar
+00014810: 7261 7920 3a20 6e70 2e6e 6461 7272 6179  ray : np.ndarray
+00014820: 0a20 2020 2020 2020 2079 5f61 7272 6179  .        y_array
+00014830: 203a 206e 702e 6e64 6172 7261 790a 2020   : np.ndarray.  
+00014840: 2020 2020 2020 7a5f 6172 7261 7920 3a20        z_array : 
+00014850: 6e70 2e6e 6461 7272 6179 0a20 2020 2020  np.ndarray.     
+00014860: 2020 2070 6c6f 745f 7479 7065 203a 2073     plot_type : s
+00014870: 7472 0a20 2020 2020 2020 2020 2020 2041  tr.            A
+00014880: 2073 7472 696e 6720 7370 6563 6966 7969   string specifyi
+00014890: 6e67 2077 6869 6368 2070 6c6f 7420 636f  ng which plot co
+000148a0: 6d6d 616e 6420 746f 2075 7365 2c20 6060  mmand to use, ``
+000148b0: 2263 6f6e 746f 7572 2260 600a 2020 2020  "contour"``.    
+000148c0: 2020 2020 2020 2020 6f72 2060 6022 636f          or ``"co
+000148d0: 6e74 6f75 7266 2260 602e 0a20 2020 2020  ntourf"``..     
+000148e0: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+000148f0: 6620 7365 6c66 2e61 6461 7074 6976 653a  f self.adaptive:
+00014900: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
+00014910: 6120 3d20 7365 6c66 2e5f 6164 6170 7469  a = self._adapti
+00014920: 7665 5f65 7661 6c28 290a 2020 2020 2020  ve_eval().      
+00014930: 2020 2020 2020 6966 2064 6174 6120 6973        if data is
+00014940: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00014950: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00014960: 6e20 6461 7461 0a20 2020 2020 2020 2072  n data.        r
+00014970: 6574 7572 6e20 7365 6c66 2e5f 6765 745f  eturn self._get_
+00014980: 6d65 7368 6573 5f67 7269 6428 290a 0a20  meshes_grid().. 
+00014990: 2020 2064 6566 205f 6164 6170 7469 7665     def _adaptive
+000149a0: 5f65 7661 6c28 7365 6c66 293a 0a20 2020  _eval(self):.   
+000149b0: 2020 2020 2069 6d70 6f72 7420 7379 6d70       import symp
+000149c0: 792e 706c 6f74 7469 6e67 2e69 6e74 6572  y.plotting.inter
+000149d0: 7661 6c6d 6174 682e 6c69 625f 696e 7465  valmath.lib_inte
+000149e0: 7276 616c 2061 7320 6c69 0a0a 2020 2020  rval as li..    
+000149f0: 2020 2020 7573 6572 5f66 756e 6374 696f      user_functio
+00014a00: 6e73 203d 207b 7d0a 2020 2020 2020 2020  ns = {}.        
+00014a10: 7072 696e 7465 7220 3d20 496e 7465 7276  printer = Interv
+00014a20: 616c 4d61 7468 5072 696e 7465 7228 7b0a  alMathPrinter({.
+00014a30: 2020 2020 2020 2020 2020 2020 2766 756c              'ful
+00014a40: 6c79 5f71 7561 6c69 6669 6564 5f6d 6f64  ly_qualified_mod
+00014a50: 756c 6573 273a 2046 616c 7365 2c20 2769  ules': False, 'i
+00014a60: 6e6c 696e 6527 3a20 5472 7565 2c0a 2020  nline': True,.  
+00014a70: 2020 2020 2020 2020 2020 2761 6c6c 6f77            'allow
+00014a80: 5f75 6e6b 6e6f 776e 5f66 756e 6374 696f  _unknown_functio
+00014a90: 6e73 273a 2054 7275 652c 0a20 2020 2020  ns': True,.     
+00014aa0: 2020 2020 2020 2027 7573 6572 5f66 756e         'user_fun
+00014ab0: 6374 696f 6e73 273a 2075 7365 725f 6675  ctions': user_fu
+00014ac0: 6e63 7469 6f6e 737d 290a 0a20 2020 2020  nctions})..     
+00014ad0: 2020 206b 6579 7320 3d20 5b74 2066 6f72     keys = [t for
+00014ae0: 2074 2069 6e20 6469 7228 6c69 2920 6966   t in dir(li) if
+00014af0: 2028 225f 5f22 206e 6f74 2069 6e20 7429   ("__" not in t)
+00014b00: 2061 6e64 2028 7420 6e6f 7420 696e 205b   and (t not in [
+00014b10: 2269 6d70 6f72 745f 6d6f 6475 6c65 222c  "import_module",
+00014b20: 2022 696e 7465 7276 616c 225d 295d 0a20   "interval"])]. 
+00014b30: 2020 2020 2020 2076 616c 7320 3d20 5b67         vals = [g
+00014b40: 6574 6174 7472 286c 692c 206b 2920 666f  etattr(li, k) fo
+00014b50: 7220 6b20 696e 206b 6579 735d 0a20 2020  r k in keys].   
+00014b60: 2020 2020 2064 203d 207b 6b3a 2076 2066       d = {k: v f
+00014b70: 6f72 206b 2c20 7620 696e 207a 6970 286b  or k, v in zip(k
+00014b80: 6579 732c 2076 616c 7329 7d0a 2020 2020  eys, vals)}.    
+00014b90: 2020 2020 6675 6e63 203d 206c 616d 6264      func = lambd
+00014ba0: 6966 7928 2873 656c 662e 7661 725f 782c  ify((self.var_x,
+00014bb0: 2073 656c 662e 7661 725f 7929 2c20 7365   self.var_y), se
+00014bc0: 6c66 2e65 7870 722c 206d 6f64 756c 6573  lf.expr, modules
+00014bd0: 3d5b 645d 2c20 7072 696e 7465 723d 7072  =[d], printer=pr
+00014be0: 696e 7465 7229 0a20 2020 2020 2020 2064  inter).        d
+00014bf0: 6174 6120 3d20 4e6f 6e65 0a0a 2020 2020  ata = None..    
+00014c00: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+00014c10: 2020 2020 2064 6174 6120 3d20 7365 6c66       data = self
+00014c20: 2e5f 6765 745f 7261 7374 6572 5f69 6e74  ._get_raster_int
+00014c30: 6572 7661 6c28 6675 6e63 290a 2020 2020  erval(func).    
+00014c40: 2020 2020 6578 6365 7074 204e 616d 6545      except NameE
+00014c50: 7272 6f72 2061 7320 6572 723a 0a20 2020  rror as err:.   
+00014c60: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
+00014c70: 732e 7761 726e 280a 2020 2020 2020 2020  s.warn(.        
+00014c80: 2020 2020 2020 2020 2241 6461 7074 6976          "Adaptiv
+00014c90: 6520 6d65 7368 696e 6720 636f 756c 6420  e meshing could 
+00014ca0: 6e6f 7420 6265 2061 7070 6c69 6564 2074  not be applied t
+00014cb0: 6f20 7468 6522 0a20 2020 2020 2020 2020  o the".         
+00014cc0: 2020 2020 2020 2022 2065 7870 7265 7373         " express
+00014cd0: 696f 6e2c 2061 7320 736f 6d65 2066 756e  ion, as some fun
+00014ce0: 6374 696f 6e73 2061 7265 206e 6f74 2079  ctions are not y
+00014cf0: 6574 2069 6d70 6c65 6d65 6e74 6564 220a  et implemented".
+00014d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014d10: 2220 696e 2074 6865 2069 6e74 6572 7661  " in the interva
+00014d20: 6c20 6d61 7468 206d 6f64 756c 653a 5c6e  l math module:\n
+00014d30: 5c6e 220a 2020 2020 2020 2020 2020 2020  \n".            
+00014d40: 2020 2020 224e 616d 6545 7272 6f72 3a20      "NameError: 
+00014d50: 2573 5c6e 5c6e 2220 2520 6572 7220 2b0a  %s\n\n" % err +.
+00014d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014d70: 2250 726f 6365 6564 696e 6720 7769 7468  "Proceeding with
+00014d80: 2075 6e69 666f 726d 206d 6573 6869 6e67   uniform meshing
+00014d90: 2e22 0a20 2020 2020 2020 2020 2020 2020  .".             
+00014da0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+00014db0: 2073 656c 662e 6164 6170 7469 7665 203d   self.adaptive =
+00014dc0: 2046 616c 7365 0a20 2020 2020 2020 2065   False.        e
+00014dd0: 7863 6570 7420 2841 7474 7269 6275 7465  xcept (Attribute
+00014de0: 4572 726f 722c 2054 7970 6545 7272 6f72  Error, TypeError
+00014df0: 293a 0a20 2020 2020 2020 2020 2020 2023  ):.            #
+00014e00: 2058 5858 3a20 4174 7472 6962 7574 6545   XXX: AttributeE
+00014e10: 7272 6f72 2822 276c 6973 7427 206f 626a  rror("'list' obj
+00014e20: 6563 7420 6861 7320 6e6f 2061 7474 7269  ect has no attri
+00014e30: 6275 7465 2027 6973 5f72 6561 6c27 2229  bute 'is_real'")
+00014e40: 0a20 2020 2020 2020 2020 2020 2023 2054  .            # T
+00014e50: 6861 7420 6e65 6564 7320 6669 7869 6e67  hat needs fixing
+00014e60: 2073 6f6d 6568 6f77 202d 2077 6520 7368   somehow - we sh
+00014e70: 6f75 6c64 6e27 7420 6265 2063 6174 6368  ouldn't be catch
+00014e80: 696e 670a 2020 2020 2020 2020 2020 2020  ing.            
+00014e90: 2320 4174 7472 6962 7574 6545 7272 6f72  # AttributeError
+00014ea0: 2068 6572 652e 0a20 2020 2020 2020 2020   here..         
+00014eb0: 2020 2077 6172 6e69 6e67 732e 7761 726e     warnings.warn
+00014ec0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00014ed0: 2020 2241 6461 7074 6976 6520 6d65 7368    "Adaptive mesh
+00014ee0: 696e 6720 636f 756c 6420 6e6f 7420 6265  ing could not be
+00014ef0: 2061 7070 6c69 6564 2074 6f20 7468 6522   applied to the"
+00014f00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014f10: 2022 2065 7870 7265 7373 696f 6e2e 2055   " expression. U
+00014f20: 7369 6e67 2075 6e69 666f 726d 206d 6573  sing uniform mes
+00014f30: 6869 6e67 2e22 290a 2020 2020 2020 2020  hing.").        
+00014f40: 2020 2020 7365 6c66 2e61 6461 7074 6976      self.adaptiv
+00014f50: 6520 3d20 4661 6c73 650a 0a20 2020 2020  e = False..     
+00014f60: 2020 2072 6574 7572 6e20 6461 7461 0a0a     return data..
+00014f70: 2020 2020 6465 6620 5f67 6574 5f72 6173      def _get_ras
+00014f80: 7465 725f 696e 7465 7276 616c 2873 656c  ter_interval(sel
+00014f90: 662c 2066 756e 6329 3a0a 2020 2020 2020  f, func):.      
+00014fa0: 2020 2222 2255 7365 7320 696e 7465 7276    """Uses interv
+00014fb0: 616c 206d 6174 6820 746f 2061 6461 7074  al math to adapt
+00014fc0: 6976 656c 7920 6d65 7368 2061 6e64 206f  ively mesh and o
+00014fd0: 6274 6169 6e20 7468 6520 706c 6f74 2222  btain the plot""
+00014fe0: 220a 2020 2020 2020 2020 6e70 203d 2069  ".        np = i
+00014ff0: 6d70 6f72 745f 6d6f 6475 6c65 2827 6e75  mport_module('nu
+00015000: 6d70 7927 290a 0a20 2020 2020 2020 206b  mpy')..        k
+00015010: 203d 2073 656c 662e 6465 7074 680a 2020   = self.depth.  
+00015020: 2020 2020 2020 696e 7465 7276 616c 5f6c        interval_l
+00015030: 6973 7420 3d20 5b5d 0a20 2020 2020 2020  ist = [].       
+00015040: 2073 782c 2073 7920 3d20 5b66 6c6f 6174   sx, sy = [float
+00015050: 2874 2920 666f 7220 7420 696e 205b 7365  (t) for t in [se
+00015060: 6c66 2e73 7461 7274 5f78 2c20 7365 6c66  lf.start_x, self
+00015070: 2e73 7461 7274 5f79 5d5d 0a20 2020 2020  .start_y]].     
+00015080: 2020 2065 782c 2065 7920 3d20 5b66 6c6f     ex, ey = [flo
+00015090: 6174 2874 2920 666f 7220 7420 696e 205b  at(t) for t in [
+000150a0: 7365 6c66 2e65 6e64 5f78 2c20 7365 6c66  self.end_x, self
+000150b0: 2e65 6e64 5f79 5d5d 0a20 2020 2020 2020  .end_y]].       
+000150c0: 2023 2043 7265 6174 6520 696e 6974 6961   # Create initia
+000150d0: 6c20 3332 2064 6976 6973 696f 6e73 0a20  l 32 divisions. 
+000150e0: 2020 2020 2020 2078 7361 6d70 6c65 203d         xsample =
+000150f0: 206e 702e 6c69 6e73 7061 6365 2873 782c   np.linspace(sx,
+00015100: 2065 782c 2033 3329 0a20 2020 2020 2020   ex, 33).       
+00015110: 2079 7361 6d70 6c65 203d 206e 702e 6c69   ysample = np.li
+00015120: 6e73 7061 6365 2873 792c 2065 792c 2033  nspace(sy, ey, 3
+00015130: 3329 0a0a 2020 2020 2020 2020 2320 4164  3)..        # Ad
+00015140: 6420 6120 736d 616c 6c20 6a69 7474 6572  d a small jitter
+00015150: 2073 6f20 7468 6174 2074 6865 7265 2061   so that there a
+00015160: 7265 206e 6f20 6661 6c73 6520 706f 7369  re no false posi
+00015170: 7469 7665 7320 666f 7220 6571 7561 6c69  tives for equali
+00015180: 7479 2e0a 2020 2020 2020 2020 2320 4578  ty..        # Ex
+00015190: 3a20 793d 3d78 2062 6563 6f6d 6573 2054  : y==x becomes T
+000151a0: 7275 6520 666f 7220 7820 696e 7465 7276  rue for x interv
+000151b0: 616c 2831 2c20 3229 2061 6e64 2079 2069  al(1, 2) and y i
+000151c0: 6e74 6572 7661 6c28 312c 2032 290a 2020  nterval(1, 2).  
+000151d0: 2020 2020 2020 2320 7768 6963 6820 7769        # which wi
+000151e0: 6c6c 2064 7261 7720 6120 7265 6374 616e  ll draw a rectan
+000151f0: 676c 652e 0a20 2020 2020 2020 206a 6974  gle..        jit
+00015200: 7465 7278 203d 2028 0a20 2020 2020 2020  terx = (.       
+00015210: 2020 2020 2028 6e70 2e72 616e 646f 6d2e       (np.random.
+00015220: 7261 6e64 286c 656e 2878 7361 6d70 6c65  rand(len(xsample
+00015230: 2929 202a 2032 202d 2031 290a 2020 2020  )) * 2 - 1).    
+00015240: 2020 2020 2020 2020 2a20 2865 7820 2d20          * (ex - 
+00015250: 7378 290a 2020 2020 2020 2020 2020 2020  sx).            
+00015260: 2f20 3220 2a2a 2032 300a 2020 2020 2020  / 2 ** 20.      
+00015270: 2020 290a 2020 2020 2020 2020 6a69 7474    ).        jitt
+00015280: 6572 7920 3d20 280a 2020 2020 2020 2020  ery = (.        
+00015290: 2020 2020 286e 702e 7261 6e64 6f6d 2e72      (np.random.r
+000152a0: 616e 6428 6c65 6e28 7973 616d 706c 6529  and(len(ysample)
+000152b0: 2920 2a20 3220 2d20 3129 0a20 2020 2020  ) * 2 - 1).     
+000152c0: 2020 2020 2020 202a 2028 6579 202d 2073         * (ey - s
+000152d0: 7929 0a20 2020 2020 2020 2020 2020 202f  y).            /
+000152e0: 2032 202a 2a20 3230 0a20 2020 2020 2020   2 ** 20.       
+000152f0: 2029 0a20 2020 2020 2020 2078 7361 6d70   ).        xsamp
+00015300: 6c65 202b 3d20 6a69 7474 6572 780a 2020  le += jitterx.  
+00015310: 2020 2020 2020 7973 616d 706c 6520 2b3d        ysample +=
+00015320: 206a 6974 7465 7279 0a0a 2020 2020 2020   jittery..      
+00015330: 2020 7869 6e74 6572 203d 205b 696e 7465    xinter = [inte
+00015340: 7276 616c 2878 312c 2078 3229 2066 6f72  rval(x1, x2) for
+00015350: 2078 312c 2078 3220 696e 207a 6970 2878   x1, x2 in zip(x
+00015360: 7361 6d70 6c65 5b3a 2d31 5d2c 2078 7361  sample[:-1], xsa
+00015370: 6d70 6c65 5b31 3a5d 295d 0a20 2020 2020  mple[1:])].     
+00015380: 2020 2079 696e 7465 7220 3d20 5b69 6e74     yinter = [int
+00015390: 6572 7661 6c28 7931 2c20 7932 2920 666f  erval(y1, y2) fo
+000153a0: 7220 7931 2c20 7932 2069 6e20 7a69 7028  r y1, y2 in zip(
+000153b0: 7973 616d 706c 655b 3a2d 315d 2c20 7973  ysample[:-1], ys
+000153c0: 616d 706c 655b 313a 5d29 5d0a 2020 2020  ample[1:])].    
+000153d0: 2020 2020 696e 7465 7276 616c 5f6c 6973      interval_lis
+000153e0: 7420 3d20 5b5b 782c 2079 5d20 666f 7220  t = [[x, y] for 
+000153f0: 7820 696e 2078 696e 7465 7220 666f 7220  x in xinter for 
+00015400: 7920 696e 2079 696e 7465 725d 0a20 2020  y in yinter].   
+00015410: 2020 2020 2070 6c6f 745f 6c69 7374 203d       plot_list =
+00015420: 205b 5d0a 0a20 2020 2020 2020 2023 2072   []..        # r
+00015430: 6563 7572 7369 7665 2063 616c 6c20 7265  ecursive call re
+00015440: 6669 6e65 7069 7865 6c73 2077 6869 6368  finepixels which
+00015450: 2073 7562 6469 7669 6465 7320 7468 6520   subdivides the 
+00015460: 696e 7465 7276 616c 7320 7768 6963 6820  intervals which 
+00015470: 6172 650a 2020 2020 2020 2020 2320 6e65  are.        # ne
+00015480: 6974 6865 7220 5472 7565 206e 6f72 2046  ither True nor F
+00015490: 616c 7365 2061 6363 6f72 6469 6e67 2074  alse according t
+000154a0: 6f20 7468 6520 6578 7072 6573 7369 6f6e  o the expression
+000154b0: 2e0a 2020 2020 2020 2020 6465 6620 7265  ..        def re
+000154c0: 6669 6e65 5f70 6978 656c 7328 696e 7465  fine_pixels(inte
+000154d0: 7276 616c 5f6c 6973 7429 3a0a 2020 2020  rval_list):.    
+000154e0: 2020 2020 2020 2020 2222 2245 7661 6c75          """Evalu
+000154f0: 6174 6573 2074 6865 2069 6e74 6572 7661  ates the interva
+00015500: 6c73 2061 6e64 2073 7562 6469 7669 6465  ls and subdivide
+00015510: 7320 7468 6520 696e 7465 7276 616c 2069  s the interval i
+00015520: 6620 7468 650a 2020 2020 2020 2020 2020  f the.          
+00015530: 2020 6578 7072 6573 7369 6f6e 2069 7320    expression is 
+00015540: 7061 7274 6961 6c6c 7920 7361 7469 7366  partially satisf
+00015550: 6965 642e 2222 220a 2020 2020 2020 2020  ied.""".        
+00015560: 2020 2020 7465 6d70 5f69 6e74 6572 7661      temp_interva
+00015570: 6c5f 6c69 7374 203d 205b 5d0a 2020 2020  l_list = [].    
+00015580: 2020 2020 2020 2020 706c 6f74 5f6c 6973          plot_lis
+00015590: 7420 3d20 5b5d 0a20 2020 2020 2020 2020  t = [].         
+000155a0: 2020 2066 6f72 2069 6e74 6572 7661 6c73     for intervals
+000155b0: 2069 6e20 696e 7465 7276 616c 5f6c 6973   in interval_lis
+000155c0: 743a 0a0a 2020 2020 2020 2020 2020 2020  t:..            
+000155d0: 2020 2020 2320 436f 6e76 6572 7420 7468      # Convert th
+000155e0: 6520 6172 7261 7920 696e 6469 6365 7320  e array indices 
+000155f0: 746f 2078 2061 6e64 2079 2076 616c 7565  to x and y value
+00015600: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+00015610: 2020 696e 7465 7276 616c 7820 3d20 696e    intervalx = in
+00015620: 7465 7276 616c 735b 305d 0a20 2020 2020  tervals[0].     
+00015630: 2020 2020 2020 2020 2020 2069 6e74 6572             inter
+00015640: 7661 6c79 203d 2069 6e74 6572 7661 6c73  valy = intervals
+00015650: 5b31 5d0a 2020 2020 2020 2020 2020 2020  [1].            
+00015660: 2020 2020 6675 6e63 5f65 7661 6c20 3d20      func_eval = 
+00015670: 6675 6e63 2869 6e74 6572 7661 6c78 2c20  func(intervalx, 
+00015680: 696e 7465 7276 616c 7929 0a20 2020 2020  intervaly).     
+00015690: 2020 2020 2020 2020 2020 2023 2054 6865             # The
+000156a0: 2065 7870 7265 7373 696f 6e20 6973 2076   expression is v
+000156b0: 616c 6964 2069 6e20 7468 6520 696e 7465  alid in the inte
+000156c0: 7276 616c 2e20 4368 616e 6765 2074 6865  rval. Change the
+000156d0: 2063 6f6e 746f 7572 0a20 2020 2020 2020   contour.       
+000156e0: 2020 2020 2020 2020 2023 2061 7272 6179           # array
+000156f0: 2076 616c 7565 7320 746f 2031 2e0a 2020   values to 1..  
+00015700: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00015710: 2066 756e 635f 6576 616c 5b31 5d20 6973   func_eval[1] is
+00015720: 2046 616c 7365 206f 7220 6675 6e63 5f65   False or func_e
+00015730: 7661 6c5b 305d 2069 7320 4661 6c73 653a  val[0] is False:
+00015740: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015750: 2020 2020 2070 6173 730a 2020 2020 2020       pass.      
+00015760: 2020 2020 2020 2020 2020 656c 6966 2066            elif f
+00015770: 756e 635f 6576 616c 203d 3d20 2854 7275  unc_eval == (Tru
+00015780: 652c 2054 7275 6529 3a0a 2020 2020 2020  e, True):.      
+00015790: 2020 2020 2020 2020 2020 2020 2020 706c                pl
+000157a0: 6f74 5f6c 6973 742e 6170 7065 6e64 285b  ot_list.append([
+000157b0: 696e 7465 7276 616c 782c 2069 6e74 6572  intervalx, inter
+000157c0: 7661 6c79 5d29 0a20 2020 2020 2020 2020  valy]).         
+000157d0: 2020 2020 2020 2065 6c69 6620 6675 6e63         elif func
+000157e0: 5f65 7661 6c5b 315d 2069 7320 4e6f 6e65  _eval[1] is None
+000157f0: 206f 7220 6675 6e63 5f65 7661 6c5b 305d   or func_eval[0]
+00015800: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00015810: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00015820: 5375 6264 6976 6964 650a 2020 2020 2020  Subdivide.      
+00015830: 2020 2020 2020 2020 2020 2020 2020 6176                av
+00015840: 6778 203d 2069 6e74 6572 7661 6c78 2e6d  gx = intervalx.m
+00015850: 6964 0a20 2020 2020 2020 2020 2020 2020  id.             
+00015860: 2020 2020 2020 2061 7667 7920 3d20 696e         avgy = in
+00015870: 7465 7276 616c 792e 6d69 640a 2020 2020  tervaly.mid.    
+00015880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015890: 6120 3d20 696e 7465 7276 616c 2869 6e74  a = interval(int
+000158a0: 6572 7661 6c78 2e73 7461 7274 2c20 6176  ervalx.start, av
+000158b0: 6778 290a 2020 2020 2020 2020 2020 2020  gx).            
+000158c0: 2020 2020 2020 2020 6220 3d20 696e 7465          b = inte
+000158d0: 7276 616c 2861 7667 782c 2069 6e74 6572  rval(avgx, inter
+000158e0: 7661 6c78 2e65 6e64 290a 2020 2020 2020  valx.end).      
+000158f0: 2020 2020 2020 2020 2020 2020 2020 6320                c 
+00015900: 3d20 696e 7465 7276 616c 2869 6e74 6572  = interval(inter
+00015910: 7661 6c79 2e73 7461 7274 2c20 6176 6779  valy.start, avgy
+00015920: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00015930: 2020 2020 2020 6420 3d20 696e 7465 7276        d = interv
+00015940: 616c 2861 7667 792c 2069 6e74 6572 7661  al(avgy, interva
+00015950: 6c79 2e65 6e64 290a 2020 2020 2020 2020  ly.end).        
+00015960: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
+00015970: 5f69 6e74 6572 7661 6c5f 6c69 7374 2e61  _interval_list.a
+00015980: 7070 656e 6428 5b61 2c20 635d 290a 2020  ppend([a, c]).  
+00015990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000159a0: 2020 7465 6d70 5f69 6e74 6572 7661 6c5f    temp_interval_
+000159b0: 6c69 7374 2e61 7070 656e 6428 5b61 2c20  list.append([a, 
+000159c0: 645d 290a 2020 2020 2020 2020 2020 2020  d]).            
+000159d0: 2020 2020 2020 2020 7465 6d70 5f69 6e74          temp_int
+000159e0: 6572 7661 6c5f 6c69 7374 2e61 7070 656e  erval_list.appen
+000159f0: 6428 5b62 2c20 635d 290a 2020 2020 2020  d([b, c]).      
+00015a00: 2020 2020 2020 2020 2020 2020 2020 7465                te
+00015a10: 6d70 5f69 6e74 6572 7661 6c5f 6c69 7374  mp_interval_list
+00015a20: 2e61 7070 656e 6428 5b62 2c20 645d 290a  .append([b, d]).
+00015a30: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00015a40: 726e 2074 656d 705f 696e 7465 7276 616c  rn temp_interval
+00015a50: 5f6c 6973 742c 2070 6c6f 745f 6c69 7374  _list, plot_list
+00015a60: 0a0a 2020 2020 2020 2020 7768 696c 6520  ..        while 
+00015a70: 6b20 3e3d 2030 2061 6e64 206c 656e 2869  k >= 0 and len(i
+00015a80: 6e74 6572 7661 6c5f 6c69 7374 293a 0a20  nterval_list):. 
+00015a90: 2020 2020 2020 2020 2020 2069 6e74 6572             inter
+00015aa0: 7661 6c5f 6c69 7374 2c20 706c 6f74 5f6c  val_list, plot_l
+00015ab0: 6973 745f 7465 6d70 203d 2072 6566 696e  ist_temp = refin
+00015ac0: 655f 7069 7865 6c73 2869 6e74 6572 7661  e_pixels(interva
+00015ad0: 6c5f 6c69 7374 290a 2020 2020 2020 2020  l_list).        
+00015ae0: 2020 2020 706c 6f74 5f6c 6973 742e 6578      plot_list.ex
+00015af0: 7465 6e64 2870 6c6f 745f 6c69 7374 5f74  tend(plot_list_t
+00015b00: 656d 7029 0a20 2020 2020 2020 2020 2020  emp).           
+00015b10: 206b 203d 206b 202d 2031 0a20 2020 2020   k = k - 1.     
+00015b20: 2020 2023 2043 6865 636b 2077 6865 7468     # Check wheth
+00015b30: 6572 2074 6865 2065 7870 7265 7373 696f  er the expressio
+00015b40: 6e20 7265 7072 6573 656e 7473 2061 6e20  n represents an 
+00015b50: 6571 7561 6c69 7479 0a20 2020 2020 2020  equality.       
+00015b60: 2023 2049 6620 6974 2072 6570 7265 7365   # If it represe
+00015b70: 6e74 7320 616e 2065 7175 616c 6974 792c  nts an equality,
+00015b80: 2074 6865 6e20 6e6f 6e65 206f 6620 7468   then none of th
+00015b90: 6520 696e 7465 7276 616c 730a 2020 2020  e intervals.    
+00015ba0: 2020 2020 2320 776f 756c 6420 6861 7665      # would have
+00015bb0: 2073 6174 6973 6669 6564 2074 6865 2065   satisfied the e
+00015bc0: 7870 7265 7373 696f 6e20 6475 6520 746f  xpression due to
+00015bd0: 2066 6c6f 6174 696e 6720 706f 696e 740a   floating point.
+00015be0: 2020 2020 2020 2020 2320 6469 6666 6572          # differ
+00015bf0: 656e 6365 732e 2041 6464 2061 6c6c 2074  ences. Add all t
+00015c00: 6865 2075 6e64 6563 6964 6564 2076 616c  he undecided val
+00015c10: 7565 7320 746f 2074 6865 2070 6c6f 742e  ues to the plot.
+00015c20: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00015c30: 2e68 6173 5f65 7175 616c 6974 793a 0a20  .has_equality:. 
+00015c40: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
+00015c50: 6e74 6572 7661 6c73 2069 6e20 696e 7465  ntervals in inte
+00015c60: 7276 616c 5f6c 6973 743a 0a20 2020 2020  rval_list:.     
+00015c70: 2020 2020 2020 2020 2020 2069 6e74 6572             inter
+00015c80: 7661 6c78 203d 2069 6e74 6572 7661 6c73  valx = intervals
+00015c90: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
+00015ca0: 2020 2020 696e 7465 7276 616c 7920 3d20      intervaly = 
+00015cb0: 696e 7465 7276 616c 735b 315d 0a20 2020  intervals[1].   
+00015cc0: 2020 2020 2020 2020 2020 2020 2066 756e               fun
+00015cd0: 635f 6576 616c 203d 2066 756e 6328 696e  c_eval = func(in
+00015ce0: 7465 7276 616c 782c 2069 6e74 6572 7661  tervalx, interva
+00015cf0: 6c79 290a 2020 2020 2020 2020 2020 2020  ly).            
+00015d00: 2020 2020 6966 2066 756e 635f 6576 616c      if func_eval
+00015d10: 5b31 5d20 616e 6420 6675 6e63 5f65 7661  [1] and func_eva
+00015d20: 6c5b 305d 2069 7320 6e6f 7420 4661 6c73  l[0] is not Fals
+00015d30: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00015d40: 2020 2020 2020 2070 6c6f 745f 6c69 7374         plot_list
+00015d50: 2e61 7070 656e 6428 5b69 6e74 6572 7661  .append([interva
+00015d60: 6c78 2c20 696e 7465 7276 616c 795d 290a  lx, intervaly]).
+00015d70: 2020 2020 2020 2020 7265 7475 726e 2070          return p
+00015d80: 6c6f 745f 6c69 7374 2c20 2266 696c 6c22  lot_list, "fill"
+00015d90: 0a0a 2020 2020 6465 6620 5f67 6574 5f6d  ..    def _get_m
+00015da0: 6573 6865 735f 6772 6964 2873 656c 6629  eshes_grid(self)
+00015db0: 3a0a 2020 2020 2020 2020 2222 2247 656e  :.        """Gen
+00015dc0: 6572 6174 6573 2074 6865 206d 6573 6820  erates the mesh 
+00015dd0: 666f 7220 6765 6e65 7261 7469 6e67 2061  for generating a
+00015de0: 2063 6f6e 746f 7572 2e0a 0a20 2020 2020   contour...     
+00015df0: 2020 2049 6e20 7468 6520 6361 7365 206f     In the case o
+00015e00: 6620 6571 7561 6c69 7479 2c20 6060 636f  f equality, ``co
+00015e10: 6e74 6f75 7260 6020 6675 6e63 7469 6f6e  ntour`` function
+00015e20: 206f 6620 6d61 7470 6c6f 746c 6962 2063   of matplotlib c
+00015e30: 616e 0a20 2020 2020 2020 2062 6520 7573  an.        be us
+00015e40: 6564 2e20 496e 206f 7468 6572 2063 6173  ed. In other cas
+00015e50: 6573 2c20 6d61 7470 6c6f 746c 6962 2773  es, matplotlib's
+00015e60: 2060 6063 6f6e 746f 7572 6660 6020 6973   ``contourf`` is
+00015e70: 2075 7365 642e 0a20 2020 2020 2020 2022   used..        "
+00015e80: 2222 0a20 2020 2020 2020 206e 7020 3d20  "".        np = 
+00015e90: 696d 706f 7274 5f6d 6f64 756c 6528 276e  import_module('n
+00015ea0: 756d 7079 2729 0a0a 2020 2020 2020 2020  umpy')..        
+00015eb0: 7861 7272 6179 2c20 7961 7272 6179 2c20  xarray, yarray, 
+00015ec0: 7a5f 6772 6964 203d 2073 656c 662e 5f65  z_grid = self._e
+00015ed0: 7661 6c75 6174 6528 290a 2020 2020 2020  valuate().      
+00015ee0: 2020 5f72 652c 205f 696d 203d 206e 702e    _re, _im = np.
+00015ef0: 7265 616c 287a 5f67 7269 6429 2c20 6e70  real(z_grid), np
+00015f00: 2e69 6d61 6728 7a5f 6772 6964 290a 2020  .imag(z_grid).  
+00015f10: 2020 2020 2020 5f72 655b 6e70 2e69 6e76        _re[np.inv
+00015f20: 6572 7428 6e70 2e69 7363 6c6f 7365 285f  ert(np.isclose(_
+00015f30: 696d 2c20 6e70 2e7a 6572 6f73 5f6c 696b  im, np.zeros_lik
+00015f40: 6528 5f69 6d29 2929 5d20 3d20 6e70 2e6e  e(_im)))] = np.n
+00015f50: 616e 0a20 2020 2020 2020 2069 6620 7365  an.        if se
+00015f60: 6c66 2e5f 6973 5f65 7175 616c 6974 793a  lf._is_equality:
+00015f70: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00015f80: 7572 6e20 7861 7272 6179 2c20 7961 7272  urn xarray, yarr
+00015f90: 6179 2c20 5f72 652c 2027 636f 6e74 6f75  ay, _re, 'contou
+00015fa0: 7227 0a20 2020 2020 2020 2072 6574 7572  r'.        retur
+00015fb0: 6e20 7861 7272 6179 2c20 7961 7272 6179  n xarray, yarray
+00015fc0: 2c20 5f72 652c 2027 636f 6e74 6f75 7266  , _re, 'contourf
+00015fd0: 270a 0a20 2020 2040 7374 6174 6963 6d65  '..    @staticme
+00015fe0: 7468 6f64 0a20 2020 2064 6566 205f 7072  thod.    def _pr
+00015ff0: 6570 726f 6365 7373 5f6d 6573 6867 7269  eprocess_meshgri
+00016000: 645f 6578 7072 6573 7369 6f6e 2865 7870  d_expression(exp
+00016010: 722c 2061 6461 7074 6976 6529 3a0a 2020  r, adaptive):.  
+00016020: 2020 2020 2020 2222 2249 6620 7468 6520        """If the 
+00016030: 6578 7072 6573 7369 6f6e 2069 7320 6120  expression is a 
+00016040: 5265 6c61 7469 6f6e 616c 2c20 7265 7772  Relational, rewr
+00016050: 6974 6520 6974 2061 7320 6120 7369 6e67  ite it as a sing
+00016060: 6c65 0a20 2020 2020 2020 2065 7870 7265  le.        expre
+00016070: 7373 696f 6e2e 0a0a 2020 2020 2020 2020  ssion...        
+00016080: 5265 7475 726e 730a 2020 2020 2020 2020  Returns.        
+00016090: 3d3d 3d3d 3d3d 3d0a 0a20 2020 2020 2020  =======..       
+000160a0: 2065 7870 7220 3a20 4578 7072 0a20 2020   expr : Expr.   
+000160b0: 2020 2020 2020 2020 2054 6865 2072 6577           The rew
+000160c0: 7269 7474 656e 2065 7870 7265 7373 696f  ritten expressio
+000160d0: 6e0a 0a20 2020 2020 2020 2065 7175 616c  n..        equal
+000160e0: 6974 7920 3a20 426f 6f6c 6561 6e0a 2020  ity : Boolean.  
+000160f0: 2020 2020 2020 2020 2020 5768 6574 6572            Wheter
+00016100: 2074 6865 206f 7269 6769 6e61 6c20 6578   the original ex
+00016110: 7072 6573 7369 6f6e 2077 6173 2061 6e20  pression was an 
+00016120: 4571 7561 6c69 7479 206f 7220 6e6f 742e  Equality or not.
+00016130: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00016140: 2020 2020 2065 7175 616c 6974 7920 3d20       equality = 
+00016150: 4661 6c73 650a 2020 2020 2020 2020 6966  False.        if
+00016160: 2069 7369 6e73 7461 6e63 6528 6578 7072   isinstance(expr
+00016170: 2c20 4571 7561 6c69 7479 293a 0a20 2020  , Equality):.   
+00016180: 2020 2020 2020 2020 2065 7870 7220 3d20           expr = 
+00016190: 6578 7072 2e6c 6873 202d 2065 7870 722e  expr.lhs - expr.
+000161a0: 7268 730a 2020 2020 2020 2020 2020 2020  rhs.            
+000161b0: 6571 7561 6c69 7479 203d 2054 7275 650a  equality = True.
+000161c0: 2020 2020 2020 2020 656c 6966 2069 7369          elif isi
+000161d0: 6e73 7461 6e63 6528 6578 7072 2c20 2847  nstance(expr, (G
+000161e0: 7265 6174 6572 5468 616e 2c20 5374 7269  reaterThan, Stri
+000161f0: 6374 4772 6561 7465 7254 6861 6e29 293a  ctGreaterThan)):
+00016200: 0a20 2020 2020 2020 2020 2020 2065 7870  .            exp
+00016210: 7220 3d20 6578 7072 2e6c 6873 202d 2065  r = expr.lhs - e
+00016220: 7870 722e 7268 730a 2020 2020 2020 2020  xpr.rhs.        
+00016230: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
+00016240: 6578 7072 2c20 284c 6573 7354 6861 6e2c  expr, (LessThan,
+00016250: 2053 7472 6963 744c 6573 7354 6861 6e29   StrictLessThan)
+00016260: 293a 0a20 2020 2020 2020 2020 2020 2065  ):.            e
+00016270: 7870 7220 3d20 6578 7072 2e72 6873 202d  xpr = expr.rhs -
+00016280: 2065 7870 722e 6c68 730a 2020 2020 2020   expr.lhs.      
+00016290: 2020 656c 6966 206e 6f74 2061 6461 7074    elif not adapt
+000162a0: 6976 653a 0a20 2020 2020 2020 2020 2020  ive:.           
+000162b0: 2072 6169 7365 204e 6f74 496d 706c 656d   raise NotImplem
+000162c0: 656e 7465 6445 7272 6f72 280a 2020 2020  entedError(.    
+000162d0: 2020 2020 2020 2020 2020 2020 2254 6865              "The
+000162e0: 2065 7870 7265 7373 696f 6e20 6973 206e   expression is n
+000162f0: 6f74 2073 7570 706f 7274 6564 2066 6f72  ot supported for
+00016300: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
+00016310: 2020 2022 706c 6f74 7469 6e67 2069 6e20     "plotting in 
+00016320: 756e 6966 6f72 6d20 6d65 7368 6564 2070  uniform meshed p
+00016330: 6c6f 742e 220a 2020 2020 2020 2020 2020  lot.".          
+00016340: 2020 290a 2020 2020 2020 2020 7265 7475    ).        retu
+00016350: 726e 2065 7870 722c 2065 7175 616c 6974  rn expr, equalit
+00016360: 790a 0a20 2020 2064 6566 2067 6574 5f6c  y..    def get_l
+00016370: 6162 656c 2873 656c 662c 2075 7365 5f6c  abel(self, use_l
+00016380: 6174 6578 3d46 616c 7365 2c20 7772 6170  atex=False, wrap
+00016390: 7065 723d 2224 2573 2422 293a 0a20 2020  per="$%s$"):.   
+000163a0: 2020 2020 2022 2222 5265 7475 726e 2074       """Return t
+000163b0: 6865 206c 6162 656c 2074 6f20 6265 2075  he label to be u
+000163c0: 7365 6420 746f 2064 6973 706c 6179 2074  sed to display t
+000163d0: 6865 2065 7870 7265 7373 696f 6e2e 0a0a  he expression...
+000163e0: 2020 2020 2020 2020 5061 7261 6d65 7465          Paramete
+000163f0: 7273 0a20 2020 2020 2020 203d 3d3d 3d3d  rs.        =====
+00016400: 3d3d 3d3d 3d0a 2020 2020 2020 2020 7573  =====.        us
+00016410: 655f 6c61 7465 7820 3a20 626f 6f6c 0a20  e_latex : bool. 
+00016420: 2020 2020 2020 2020 2020 2049 6620 4661             If Fa
+00016430: 6c73 652c 2074 6865 2073 7472 696e 6720  lse, the string 
+00016440: 7265 7072 6573 656e 7461 7469 6f6e 206f  representation o
+00016450: 6620 7468 6520 6578 7072 6573 7369 6f6e  f the expression
+00016460: 2069 7320 7265 7475 726e 6564 2e0a 2020   is returned..  
+00016470: 2020 2020 2020 2020 2020 4966 2054 7275            If Tru
+00016480: 652c 2074 6865 206c 6174 6578 2072 6570  e, the latex rep
+00016490: 7265 7365 6e74 6174 696f 6e20 6973 2072  resentation is r
+000164a0: 6574 7572 6e65 642e 0a20 2020 2020 2020  eturned..       
+000164b0: 2077 7261 7070 6572 203a 2073 7472 0a20   wrapper : str. 
+000164c0: 2020 2020 2020 2020 2020 2054 6865 2062             The b
+000164d0: 6163 6b65 6e64 206d 6967 6874 206e 6565  ackend might nee
+000164e0: 6420 7468 6520 6c61 7465 7820 7265 7072  d the latex repr
+000164f0: 6573 656e 7461 7469 6f6e 2074 6f20 6265  esentation to be
+00016500: 2077 7261 7070 6564 2062 790a 2020 2020   wrapped by.    
+00016510: 2020 2020 2020 2020 736f 6d65 2063 6861          some cha
+00016520: 7261 6374 6572 732e 2044 6566 6175 6c74  racters. Default
+00016530: 2074 6f20 6060 2224 2573 2422 6060 2e0a   to ``"$%s$"``..
+00016540: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
+00016550: 0a20 2020 2020 2020 203d 3d3d 3d3d 3d3d  .        =======
+00016560: 0a20 2020 2020 2020 206c 6162 656c 203a  .        label :
+00016570: 2073 7472 0a20 2020 2020 2020 2022 2222   str.        """
+00016580: 0a20 2020 2020 2020 2069 6620 7573 655f  .        if use_
+00016590: 6c61 7465 7820 6973 2046 616c 7365 3a0a  latex is False:.
+000165a0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000165b0: 726e 2073 656c 662e 5f6c 6162 656c 0a20  rn self._label. 
+000165c0: 2020 2020 2020 2069 6620 280a 2020 2020         if (.    
+000165d0: 2020 2020 2020 2020 2873 656c 662e 5f6c          (self._l
+000165e0: 6162 656c 203d 3d20 7374 7228 7365 6c66  abel == str(self
+000165f0: 2e5f 6164 6170 7469 7665 5f65 7870 7229  ._adaptive_expr)
+00016600: 2920 6f72 0a20 2020 2020 2020 2020 2020  ) or.           
+00016610: 2028 2245 7128 2573 2c20 3029 2220 2520   ("Eq(%s, 0)" % 
+00016620: 7365 6c66 2e5f 6c61 6265 6c20 3d3d 2073  self._label == s
+00016630: 7472 2873 656c 662e 5f61 6461 7074 6976  tr(self._adaptiv
+00016640: 655f 6578 7072 2929 0a20 2020 2020 2020  e_expr)).       
+00016650: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
+00016660: 7265 7475 726e 2073 656c 662e 5f67 6574  return self._get
+00016670: 5f77 7261 7070 6564 5f6c 6162 656c 2873  _wrapped_label(s
+00016680: 656c 662e 5f6c 6174 6578 5f6c 6162 656c  elf._latex_label
+00016690: 2c20 7772 6170 7065 7229 0a20 2020 2020  , wrapper).     
+000166a0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+000166b0: 6c61 7465 785f 6c61 6265 6c0a 0a0a 636c  latex_label...cl
+000166c0: 6173 7320 496d 706c 6963 6974 3344 5365  ass Implicit3DSe
+000166d0: 7269 6573 280a 2020 2020 436f 6d6d 6f6e  ries(.    Common
+000166e0: 556e 6966 6f72 6d45 7661 6c75 6174 696f  UniformEvaluatio
+000166f0: 6e2c 2053 7572 6661 6365 4261 7365 5365  n, SurfaceBaseSe
+00016700: 7269 6573 0a29 3a0a 2020 2020 6973 5f69  ries.):.    is_i
+00016710: 6d70 6c69 6369 7420 3d20 5472 7565 0a20  mplicit = True. 
+00016720: 2020 205f 4e20 3d20 3630 0a0a 2020 2020     _N = 60..    
+00016730: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
+00016740: 662c 2065 7870 722c 2072 616e 6765 5f78  f, expr, range_x
+00016750: 2c20 7261 6e67 655f 792c 2072 616e 6765  , range_y, range
+00016760: 5f7a 2c20 6c61 6265 6c3d 2222 2c20 2a2a  _z, label="", **
+00016770: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+00016780: 2073 7570 6572 2829 2e5f 5f69 6e69 745f   super().__init_
+00016790: 5f28 2a2a 6b77 6172 6773 290a 2020 2020  _(**kwargs).    
+000167a0: 2020 2020 7365 6c66 2e65 7870 7220 3d20      self.expr = 
+000167b0: 6578 7072 2069 6620 6361 6c6c 6162 6c65  expr if callable
+000167c0: 2865 7870 7229 2065 6c73 6520 7379 6d70  (expr) else symp
+000167d0: 6966 7928 6578 7072 290a 2020 2020 2020  ify(expr).      
+000167e0: 2020 7365 6c66 2e72 616e 6765 7320 3d20    self.ranges = 
+000167f0: 5b72 616e 6765 5f78 2c20 7261 6e67 655f  [range_x, range_
+00016800: 792c 2072 616e 6765 5f7a 5d0a 2020 2020  y, range_z].    
+00016810: 2020 2020 7365 6c66 2e76 6172 5f78 2c20      self.var_x, 
+00016820: 7365 6c66 2e73 7461 7274 5f78 2c20 7365  self.start_x, se
+00016830: 6c66 2e65 6e64 5f78 203d 2073 656c 662e  lf.end_x = self.
+00016840: 7261 6e67 6573 5b30 5d0a 2020 2020 2020  ranges[0].      
+00016850: 2020 7365 6c66 2e76 6172 5f79 2c20 7365    self.var_y, se
+00016860: 6c66 2e73 7461 7274 5f79 2c20 7365 6c66  lf.start_y, self
+00016870: 2e65 6e64 5f79 203d 2073 656c 662e 7261  .end_y = self.ra
+00016880: 6e67 6573 5b31 5d0a 2020 2020 2020 2020  nges[1].        
+00016890: 7365 6c66 2e76 6172 5f7a 2c20 7365 6c66  self.var_z, self
+000168a0: 2e73 7461 7274 5f7a 2c20 7365 6c66 2e65  .start_z, self.e
+000168b0: 6e64 5f7a 203d 2073 656c 662e 7261 6e67  nd_z = self.rang
+000168c0: 6573 5b32 5d0a 2020 2020 2020 2020 6966  es[2].        if
+000168d0: 2069 7369 6e73 7461 6e63 6528 7365 6c66   isinstance(self
+000168e0: 2e65 7870 722c 2050 6c61 6e65 293a 0a20  .expr, Plane):. 
+000168f0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00016900: 6578 7072 203d 2073 656c 662e 6578 7072  expr = self.expr
+00016910: 2e65 7175 6174 696f 6e28 7365 6c66 2e76  .equation(self.v
+00016920: 6172 5f78 2c20 7365 6c66 2e76 6172 5f79  ar_x, self.var_y
+00016930: 2c20 7365 6c66 2e76 6172 5f7a 290a 2020  , self.var_z).  
+00016940: 2020 2020 2020 7365 6c66 2e5f 7365 745f        self._set_
+00016950: 7375 7266 6163 655f 6c61 6265 6c28 6c61  surface_label(la
+00016960: 6265 6c29 0a0a 2020 2020 6465 6620 5f5f  bel)..    def __
+00016970: 7374 725f 5f28 7365 6c66 293a 0a20 2020  str__(self):.   
+00016980: 2020 2020 2076 6172 5f78 2c20 7374 6172       var_x, star
+00016990: 745f 782c 2065 6e64 5f78 203d 2073 656c  t_x, end_x = sel
+000169a0: 662e 7261 6e67 6573 5b30 5d0a 2020 2020  f.ranges[0].    
+000169b0: 2020 2020 7661 725f 792c 2073 7461 7274      var_y, start
+000169c0: 5f79 2c20 656e 645f 7920 3d20 7365 6c66  _y, end_y = self
+000169d0: 2e72 616e 6765 735b 315d 0a20 2020 2020  .ranges[1].     
+000169e0: 2020 2076 6172 5f7a 2c20 7374 6172 745f     var_z, start_
+000169f0: 7a2c 2065 6e64 5f7a 203d 2073 656c 662e  z, end_z = self.
+00016a00: 7261 6e67 6573 5b32 5d0a 2020 2020 2020  ranges[2].      
+00016a10: 2020 7265 7475 726e 2028 0a20 2020 2020    return (.     
+00016a20: 2020 2020 2020 2022 696d 706c 6963 6974         "implicit
+00016a30: 2073 7572 6661 6365 2073 6572 6965 733a   surface series:
+00016a40: 2025 7320 666f 7220 2573 206f 7665 7220   %s for %s over 
+00016a50: 2573 2061 6e64 2025 7320 6f76 6572 2025  %s and %s over %
+00016a60: 7322 0a20 2020 2020 2020 2020 2020 2022  s".            "
+00016a70: 2061 6e64 2025 7320 6f76 6572 2025 7322   and %s over %s"
+00016a80: 2920 2520 280a 2020 2020 2020 2020 2020  ) % (.          
+00016a90: 2020 2020 2020 7374 7228 7365 6c66 2e65        str(self.e
+00016aa0: 7870 7229 2c0a 2020 2020 2020 2020 2020  xpr),.          
+00016ab0: 2020 2020 2020 7374 7228 7661 725f 7829        str(var_x)
+00016ac0: 2c20 7374 7228 2866 6c6f 6174 2873 7461  , str((float(sta
+00016ad0: 7274 5f78 292c 2066 6c6f 6174 2865 6e64  rt_x), float(end
+00016ae0: 5f78 2929 292c 0a20 2020 2020 2020 2020  _x))),.         
+00016af0: 2020 2020 2020 2073 7472 2876 6172 5f79         str(var_y
+00016b00: 292c 2073 7472 2828 666c 6f61 7428 7374  ), str((float(st
+00016b10: 6172 745f 7929 2c20 666c 6f61 7428 656e  art_y), float(en
+00016b20: 645f 7929 2929 2c0a 2020 2020 2020 2020  d_y))),.        
+00016b30: 2020 2020 2020 2020 7374 7228 7661 725f          str(var_
+00016b40: 7a29 2c20 7374 7228 2866 6c6f 6174 2873  z), str((float(s
+00016b50: 7461 7274 5f7a 292c 2066 6c6f 6174 2865  tart_z), float(e
+00016b60: 6e64 5f7a 2929 290a 2020 2020 2020 2020  nd_z))).        
+00016b70: 2020 2020 290a 0a20 2020 2064 6566 2067      )..    def g
+00016b80: 6574 5f64 6174 6128 7365 6c66 293a 0a20  et_data(self):. 
+00016b90: 2020 2020 2020 2022 2222 4576 616c 7561         """Evalua
+00016ba0: 7465 2074 6865 2065 7870 7265 7373 696f  te the expressio
+00016bb0: 6e20 6f76 6572 2074 6865 2070 726f 7669  n over the provi
+00016bc0: 6465 6420 646f 6d61 696e 2e20 5468 6520  ded domain. The 
+00016bd0: 6261 636b 656e 6420 7769 6c6c 0a20 2020  backend will.   
+00016be0: 2020 2020 2074 6865 6e20 7472 7920 746f       then try to
+00016bf0: 2063 6f6d 7075 7465 2061 6e64 2076 6973   compute and vis
+00016c00: 7561 6c69 7a65 2074 6865 2066 696e 616c  ualize the final
+00016c10: 2072 6573 756c 742c 2069 6620 6974 2073   result, if it s
+00016c20: 7570 706f 7274 2074 6869 730a 2020 2020  upport this.    
+00016c30: 2020 2020 6461 7461 2073 6572 6965 732e      data series.
+00016c40: 0a0a 2020 2020 2020 2020 5265 7475 726e  ..        Return
+00016c50: 730a 2020 2020 2020 2020 3d3d 3d3d 3d3d  s.        ======
+00016c60: 3d0a 2020 2020 2020 2020 6d65 7368 5f78  =.        mesh_x
+00016c70: 203a 206e 702e 6e64 6172 7261 7920 5b6e   : np.ndarray [n
+00016c80: 3120 7820 6e32 2078 206e 335d 0a20 2020  1 x n2 x n3].   
+00016c90: 2020 2020 206d 6573 685f 7920 3a20 6e70       mesh_y : np
+00016ca0: 2e6e 6461 7272 6179 205b 6e31 2078 206e  .ndarray [n1 x n
+00016cb0: 3220 7820 6e33 5d0a 2020 2020 2020 2020  2 x n3].        
+00016cc0: 6d65 7368 5f7a 203a 206e 702e 6e64 6172  mesh_z : np.ndar
+00016cd0: 7261 7920 5b6e 3120 7820 6e32 2078 206e  ray [n1 x n2 x n
+00016ce0: 335d 0a20 2020 2020 2020 2066 203a 206e  3].        f : n
+00016cf0: 702e 6e64 6172 7261 7920 5b6e 3120 7820  p.ndarray [n1 x 
+00016d00: 6e32 2078 206e 335d 0a20 2020 2020 2020  n2 x n3].       
+00016d10: 2022 2222 0a20 2020 2020 2020 206e 7020   """.        np 
+00016d20: 3d20 696d 706f 7274 5f6d 6f64 756c 6528  = import_module(
+00016d30: 276e 756d 7079 2729 0a0a 2020 2020 2020  'numpy')..      
+00016d40: 2020 7265 7375 6c74 7320 3d20 7365 6c66    results = self
+00016d50: 2e5f 6576 616c 7561 7465 2829 0a20 2020  ._evaluate().   
+00016d60: 2020 2020 2066 6f72 2069 2c20 7220 696e       for i, r in
+00016d70: 2065 6e75 6d65 7261 7465 2872 6573 756c   enumerate(resul
+00016d80: 7473 293a 0a20 2020 2020 2020 2020 2020  ts):.           
+00016d90: 2072 655f 762c 2069 6d5f 7620 3d20 6e70   re_v, im_v = np
+00016da0: 2e72 6561 6c28 7229 2c20 6e70 2e69 6d61  .real(r), np.ima
+00016db0: 6728 7229 0a20 2020 2020 2020 2020 2020  g(r).           
+00016dc0: 2072 655f 765b 6e70 2e69 6e76 6572 7428   re_v[np.invert(
+00016dd0: 6e70 2e69 7363 6c6f 7365 2869 6d5f 762c  np.isclose(im_v,
+00016de0: 206e 702e 7a65 726f 735f 6c69 6b65 2869   np.zeros_like(i
+00016df0: 6d5f 7629 2929 5d20 3d20 6e70 2e6e 616e  m_v)))] = np.nan
+00016e00: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+00016e10: 756c 7473 5b69 5d20 3d20 7265 5f76 0a0a  ults[i] = re_v..
+00016e20: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00016e30: 656c 662e 5f61 7070 6c79 5f74 7261 6e73  elf._apply_trans
+00016e40: 666f 726d 282a 7265 7375 6c74 7329 0a0a  form(*results)..
+00016e50: 0a63 6c61 7373 2043 6f6d 706c 6578 506f  .class ComplexPo
+00016e60: 696e 7453 6572 6965 7328 4c69 6e65 3244  intSeries(Line2D
+00016e70: 4261 7365 5365 7269 6573 293a 0a20 2020  BaseSeries):.   
+00016e80: 2022 2222 5265 7072 6573 656e 7461 7469   """Representati
+00016e90: 6f6e 2066 6f72 2061 206c 696e 6520 696e  on for a line in
+00016ea0: 2074 6865 2063 6f6d 706c 6578 2070 6c61   the complex pla
+00016eb0: 6e65 2063 6f6e 7369 7374 696e 6720 6f66  ne consisting of
+00016ec0: 0a20 2020 206c 6973 7420 6f66 2070 6f69  .    list of poi
+00016ed0: 6e74 732e 2222 220a 0a20 2020 2064 6566  nts."""..    def
+00016ee0: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+00016ef0: 6578 7072 2c20 6c61 6265 6c3d 2222 2c20  expr, label="", 
+00016f00: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
+00016f10: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
+00016f20: 745f 5f28 6c61 6265 6c3d 6c61 6265 6c2c  t__(label=label,
+00016f30: 202a 2a6b 7761 7267 7329 0a20 2020 2020   **kwargs).     
+00016f40: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+00016f50: 2865 7870 722c 2028 6c69 7374 2c20 7475  (expr, (list, tu
+00016f60: 706c 6529 293a 0a20 2020 2020 2020 2020  ple)):.         
+00016f70: 2020 2073 656c 662e 6578 7072 203d 2054     self.expr = T
+00016f80: 7570 6c65 282a 6578 7072 290a 2020 2020  uple(*expr).    
+00016f90: 2020 2020 656c 6966 2069 7369 6e73 7461      elif isinsta
+00016fa0: 6e63 6528 6578 7072 2c20 4578 7072 293a  nce(expr, Expr):
+00016fb0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00016fc0: 662e 6578 7072 203d 2054 7570 6c65 2865  f.expr = Tuple(e
+00016fd0: 7870 7229 0a20 2020 2020 2020 2065 6c73  xpr).        els
+00016fe0: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
+00016ff0: 656c 662e 6578 7072 203d 2065 7870 720a  elf.expr = expr.
+00017000: 0a20 2020 2020 2020 2073 656c 662e 5f62  .        self._b
+00017010: 6c6f 636b 5f6c 616d 6264 615f 6675 6e63  lock_lambda_func
+00017020: 7469 6f6e 7328 2a73 656c 662e 6578 7072  tions(*self.expr
+00017030: 290a 0a20 2020 2020 2020 2073 656c 662e  )..        self.
+00017040: 6973 5f70 6f69 6e74 203d 206b 7761 7267  is_point = kwarg
+00017050: 732e 6765 7428 2273 6361 7474 6572 222c  s.get("scatter",
+00017060: 206b 7761 7267 732e 6765 7428 2269 735f   kwargs.get("is_
+00017070: 706f 696e 7422 2c20 5472 7565 2929 0a20  point", True)). 
+00017080: 2020 2020 2020 2069 6620 7365 6c66 2e75         if self.u
+00017090: 7365 5f63 6d20 616e 6420 7365 6c66 2e63  se_cm and self.c
+000170a0: 6f6c 6f72 5f66 756e 633a 0a20 2020 2020  olor_func:.     
+000170b0: 2020 2020 2020 2073 656c 662e 6973 5f70         self.is_p
+000170c0: 6172 616d 6574 7269 6320 3d20 5472 7565  arametric = True
+000170d0: 0a0a 2020 2020 6465 6620 5f67 6574 5f64  ..    def _get_d
+000170e0: 6174 615f 6865 6c70 6572 2873 656c 6629  ata_helper(self)
+000170f0: 3a0a 2020 2020 2020 2020 2222 2252 6574  :.        """Ret
+00017100: 7572 6e73 2063 6f6f 7264 696e 6174 6573  urns coordinates
+00017110: 2074 6861 7420 6e65 6564 7320 746f 2062   that needs to b
+00017120: 6520 706f 7374 7072 6f63 6573 7365 642e  e postprocessed.
+00017130: 2222 220a 2020 2020 2020 2020 6e70 203d  """.        np =
+00017140: 2069 6d70 6f72 745f 6d6f 6475 6c65 2827   import_module('
+00017150: 6e75 6d70 7927 290a 2020 2020 2020 2020  numpy').        
+00017160: 706f 696e 7473 203d 205b 636f 6d70 6c65  points = [comple
+00017170: 7828 702e 6576 616c 6628 7375 6273 3d73  x(p.evalf(subs=s
+00017180: 656c 662e 7061 7261 6d73 2929 2066 6f72  elf.params)) for
+00017190: 2070 2069 6e20 7365 6c66 2e65 7870 725d   p in self.expr]
+000171a0: 0a20 2020 2020 2020 2070 6f69 6e74 7320  .        points 
+000171b0: 3d20 6e70 2e61 7272 6179 2870 6f69 6e74  = np.array(point
+000171c0: 7329 0a20 2020 2020 2020 2072 2c20 6920  s).        r, i 
+000171d0: 3d20 6e70 2e72 6561 6c28 706f 696e 7473  = np.real(points
+000171e0: 292c 206e 702e 696d 6167 2870 6f69 6e74  ), np.imag(point
+000171f0: 7329 0a20 2020 2020 2020 2069 6620 7365  s).        if se
+00017200: 6c66 2e75 7365 5f63 6d20 616e 6420 6361  lf.use_cm and ca
+00017210: 6c6c 6162 6c65 2873 656c 662e 636f 6c6f  llable(self.colo
+00017220: 725f 6675 6e63 293a 0a20 2020 2020 2020  r_func):.       
+00017230: 2020 2020 2072 6574 7572 6e20 722c 2069       return r, i
+00017240: 2c20 7365 6c66 2e65 7661 6c5f 636f 6c6f  , self.eval_colo
+00017250: 725f 6675 6e63 2872 2c20 6929 0a20 2020  r_func(r, i).   
+00017260: 2020 2020 2072 6574 7572 6e20 722c 2069       return r, i
+00017270: 0a0a 2020 2020 6465 6620 5f5f 7374 725f  ..    def __str_
+00017280: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
+00017290: 2072 6574 7572 6e20 7365 6c66 2e5f 7374   return self._st
+000172a0: 725f 6865 6c70 6572 2822 636f 6d70 6c65  r_helper("comple
+000172b0: 7820 706f 696e 7473 3a20 2573 2220 2520  x points: %s" % 
+000172c0: 7365 6c66 2e65 7870 7229 0a0a 0a63 6c61  self.expr)...cla
+000172d0: 7373 2043 6f6d 706c 6578 5375 7266 6163  ss ComplexSurfac
+000172e0: 6542 6173 6553 6572 6965 7328 5375 7266  eBaseSeries(Surf
+000172f0: 6163 6542 6173 6553 6572 6965 7329 3a0a  aceBaseSeries):.
+00017300: 2020 2020 2222 2252 6570 7265 7365 6e74      """Represent
+00017310: 2061 2063 6f6d 706c 6578 2066 756e 6374   a complex funct
+00017320: 696f 6e2e 2222 220a 2020 2020 6973 5f63  ion.""".    is_c
+00017330: 6f6d 706c 6578 203d 2054 7275 650a 2020  omplex = True.  
+00017340: 2020 5f4e 203d 2033 3030 0a0a 2020 2020    _N = 300..    
+00017350: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
+00017360: 662c 2065 7870 722c 2072 2c20 6c61 6265  f, expr, r, labe
+00017370: 6c3d 2222 2c20 2a2a 6b77 6172 6773 293a  l="", **kwargs):
+00017380: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
+00017390: 2e5f 5f69 6e69 745f 5f28 2a2a 6b77 6172  .__init__(**kwar
+000173a0: 6773 290a 2020 2020 2020 2020 7365 6c66  gs).        self
+000173b0: 2e72 616e 6765 7320 3d20 5b72 5d0a 2020  .ranges = [r].  
+000173c0: 2020 2020 2020 7365 6c66 2e5f 6c61 6265        self._labe
+000173d0: 6c20 3d20 7374 7228 6578 7072 2920 6966  l = str(expr) if
+000173e0: 206c 6162 656c 2069 7320 4e6f 6e65 2065   label is None e
+000173f0: 6c73 6520 6c61 6265 6c0a 2020 2020 2020  lse label.      
+00017400: 2020 7365 6c66 2e5f 6c61 7465 785f 6c61    self._latex_la
+00017410: 6265 6c20 3d20 6c61 7465 7828 6578 7072  bel = latex(expr
+00017420: 2920 6966 206c 6162 656c 2069 7320 4e6f  ) if label is No
+00017430: 6e65 2065 6c73 6520 6c61 6265 6c0a 2020  ne else label.  
+00017440: 2020 2020 2020 2320 6465 7465 726d 696e        # determin
+00017450: 6573 2077 6861 7420 6461 7461 2074 6f20  es what data to 
+00017460: 7265 7475 726e 206f 6e20 7468 6520 7a2d  return on the z-
+00017470: 6178 6973 0a20 2020 2020 2020 2073 656c  axis.        sel
+00017480: 662e 5f72 6574 7572 6e20 3d20 6b77 6172  f._return = kwar
+00017490: 6773 2e67 6574 2822 7265 7475 726e 222c  gs.get("return",
+000174a0: 204e 6f6e 6529 0a0a 2020 2020 4070 726f   None)..    @pro
+000174b0: 7065 7274 790a 2020 2020 6465 6620 7661  perty.    def va
+000174c0: 7228 7365 6c66 293a 0a20 2020 2020 2020  r(self):.       
+000174d0: 2072 6574 7572 6e20 7365 6c66 2e72 616e   return self.ran
+000174e0: 6765 735b 305d 5b30 5d0a 0a20 2020 2040  ges[0][0]..    @
+000174f0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00017500: 2073 7461 7274 2873 656c 6629 3a0a 2020   start(self):.  
+00017510: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00017520: 662e 7261 6e67 6573 5b30 5d5b 315d 0a0a  f.ranges[0][1]..
+00017530: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
+00017540: 2020 6465 6620 656e 6428 7365 6c66 293a    def end(self):
+00017550: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00017560: 7365 6c66 2e72 616e 6765 735b 305d 5b32  self.ranges[0][2
+00017570: 5d0a 0a20 2020 2064 6566 205f 5f73 7472  ]..    def __str
+00017580: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
+00017590: 2020 6966 2073 656c 662e 6973 5f64 6f6d    if self.is_dom
+000175a0: 6169 6e5f 636f 6c6f 7269 6e67 3a0a 2020  ain_coloring:.  
+000175b0: 2020 2020 2020 2020 2020 7072 6566 6978            prefix
+000175c0: 203d 2022 636f 6d70 6c65 7820 646f 6d61   = "complex doma
+000175d0: 696e 2063 6f6c 6f72 696e 6722 0a20 2020  in coloring".   
+000175e0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+000175f0: 2e69 735f 3344 7375 7266 6163 653a 0a20  .is_3Dsurface:. 
+00017600: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00017610: 7265 6669 7820 3d20 2263 6f6d 706c 6578  refix = "complex
+00017620: 2033 4420 646f 6d61 696e 2063 6f6c 6f72   3D domain color
+00017630: 696e 6722 0a20 2020 2020 2020 2065 6c73  ing".        els
+00017640: 653a 0a20 2020 2020 2020 2020 2020 2070  e:.            p
+00017650: 7265 6669 7820 3d20 2263 6f6d 706c 6578  refix = "complex
+00017660: 2063 6172 7465 7369 616e 2073 7572 6661   cartesian surfa
+00017670: 6365 220a 2020 2020 2020 2020 2020 2020  ce".            
+00017680: 6966 2073 656c 662e 6973 5f63 6f6e 746f  if self.is_conto
+00017690: 7572 3a0a 2020 2020 2020 2020 2020 2020  ur:.            
+000176a0: 2020 2020 7072 6566 6978 203d 2022 636f      prefix = "co
+000176b0: 6d70 6c65 7820 636f 6e74 6f75 7222 0a0a  mplex contour"..
+000176c0: 2020 2020 2020 2020 7772 6170 7065 7220          wrapper 
+000176d0: 3d20 5f67 6574 5f77 7261 7070 6572 5f66  = _get_wrapper_f
+000176e0: 6f72 5f65 7870 7228 7365 6c66 2e5f 7265  or_expr(self._re
+000176f0: 7475 726e 290a 2020 2020 2020 2020 7265  turn).        re
+00017700: 732c 2072 6565 203d 2072 6528 7365 6c66  s, ree = re(self
+00017710: 2e73 7461 7274 292c 2072 6528 7365 6c66  .start), re(self
+00017720: 2e65 6e64 290a 2020 2020 2020 2020 696d  .end).        im
+00017730: 732c 2069 6d65 203d 2069 6d28 7365 6c66  s, ime = im(self
+00017740: 2e73 7461 7274 292c 2069 6d28 7365 6c66  .start), im(self
+00017750: 2e65 6e64 290a 2020 2020 2020 2020 6620  .end).        f 
+00017760: 3d20 6c61 6d62 6461 2074 3a20 666c 6f61  = lambda t: floa
+00017770: 7428 7429 2069 6620 6c65 6e28 742e 6672  t(t) if len(t.fr
+00017780: 6565 5f73 796d 626f 6c73 2920 3d3d 2030  ee_symbols) == 0
+00017790: 2065 6c73 6520 740a 0a20 2020 2020 2020   else t..       
+000177a0: 2072 6574 7572 6e20 7365 6c66 2e5f 7374   return self._st
+000177b0: 725f 6865 6c70 6572 280a 2020 2020 2020  r_helper(.      
+000177c0: 2020 2020 2020 7072 6566 6978 202b 2022        prefix + "
+000177d0: 3a20 2573 2066 6f72 2220 2220 7265 2825  : %s for" " re(%
+000177e0: 7329 206f 7665 7220 2573 2061 6e64 2069  s) over %s and i
+000177f0: 6d28 2573 2920 6f76 6572 2025 7322 2025  m(%s) over %s" %
+00017800: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
+00017810: 2020 2077 7261 7070 6572 2025 2073 656c     wrapper % sel
+00017820: 662e 6578 7072 2c0a 2020 2020 2020 2020  f.expr,.        
+00017830: 2020 2020 2020 2020 7374 7228 7365 6c66          str(self
+00017840: 2e76 6172 292c 0a20 2020 2020 2020 2020  .var),.         
+00017850: 2020 2020 2020 2073 7472 2828 6628 7265         str((f(re
+00017860: 7329 2c20 6628 7265 6529 2929 2c0a 2020  s), f(ree))),.  
+00017870: 2020 2020 2020 2020 2020 2020 2020 7374                st
+00017880: 7228 7365 6c66 2e76 6172 292c 0a20 2020  r(self.var),.   
+00017890: 2020 2020 2020 2020 2020 2020 2073 7472               str
+000178a0: 2828 6628 696d 7329 2c20 6628 696d 6529  ((f(ims), f(ime)
+000178b0: 2929 2c0a 2020 2020 2020 2020 2020 2020  )),.            
+000178c0: 290a 2020 2020 2020 2020 290a 0a20 2020  ).        )..   
+000178d0: 2064 6566 205f 6372 6561 7465 5f64 6973   def _create_dis
+000178e0: 6372 6574 697a 6564 5f64 6f6d 6169 6e28  cretized_domain(
+000178f0: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+00017900: 2222 4469 7363 7265 7469 7a65 2074 6865  ""Discretize the
+00017910: 2072 616e 6765 7320 696e 2063 6173 6520   ranges in case 
+00017920: 6f66 2075 6e69 666f 726d 206d 6573 6869  of uniform meshi
+00017930: 6e67 2073 7472 6174 6567 792e 0a20 2020  ng strategy..   
+00017940: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00017950: 206e 7020 3d20 696d 706f 7274 5f6d 6f64   np = import_mod
+00017960: 756c 6528 276e 756d 7079 2729 0a20 2020  ule('numpy').   
+00017970: 2020 2020 2073 7461 7274 5f78 203d 2073       start_x = s
+00017980: 656c 662e 5f75 7064 6174 655f 7261 6e67  elf._update_rang
+00017990: 655f 7661 6c75 6528 7365 6c66 2e73 7461  e_value(self.sta
+000179a0: 7274 292e 7265 616c 0a20 2020 2020 2020  rt).real.       
+000179b0: 2065 6e64 5f78 203d 2073 656c 662e 5f75   end_x = self._u
+000179c0: 7064 6174 655f 7261 6e67 655f 7661 6c75  pdate_range_valu
+000179d0: 6528 7365 6c66 2e65 6e64 292e 7265 616c  e(self.end).real
+000179e0: 0a20 2020 2020 2020 2073 7461 7274 5f79  .        start_y
+000179f0: 203d 2073 656c 662e 5f75 7064 6174 655f   = self._update_
+00017a00: 7261 6e67 655f 7661 6c75 6528 7365 6c66  range_value(self
+00017a10: 2e73 7461 7274 292e 696d 6167 0a20 2020  .start).imag.   
+00017a20: 2020 2020 2065 6e64 5f79 203d 2073 656c       end_y = sel
+00017a30: 662e 5f75 7064 6174 655f 7261 6e67 655f  f._update_range_
+00017a40: 7661 6c75 6528 7365 6c66 2e65 6e64 292e  value(self.end).
+00017a50: 696d 6167 0a20 2020 2020 2020 2078 203d  imag.        x =
+00017a60: 2073 656c 662e 5f64 6973 6372 6574 697a   self._discretiz
+00017a70: 6528 0a20 2020 2020 2020 2020 2020 2073  e(.            s
+00017a80: 7461 7274 5f78 2c20 656e 645f 782c 2073  tart_x, end_x, s
+00017a90: 656c 662e 6e5b 305d 2c20 7365 6c66 2e73  elf.n[0], self.s
+00017aa0: 6361 6c65 735b 305d 2c20 7365 6c66 2e6f  cales[0], self.o
+00017ab0: 6e6c 795f 696e 7465 6765 7273 290a 2020  nly_integers).  
+00017ac0: 2020 2020 2020 7920 3d20 7365 6c66 2e5f        y = self._
+00017ad0: 6469 7363 7265 7469 7a65 280a 2020 2020  discretize(.    
+00017ae0: 2020 2020 2020 2020 7374 6172 745f 792c          start_y,
+00017af0: 2065 6e64 5f79 2c20 7365 6c66 2e6e 5b31   end_y, self.n[1
+00017b00: 5d2c 2073 656c 662e 7363 616c 6573 5b31  ], self.scales[1
+00017b10: 5d2c 2073 656c 662e 6f6e 6c79 5f69 6e74  ], self.only_int
+00017b20: 6567 6572 7329 0a20 2020 2020 2020 2078  egers).        x
+00017b30: 782c 2079 7920 3d20 6e70 2e6d 6573 6867  x, yy = np.meshg
+00017b40: 7269 6428 782c 2079 290a 2020 2020 2020  rid(x, y).      
+00017b50: 2020 646f 6d61 696e 203d 2078 7820 2b20    domain = xx + 
+00017b60: 316a 202a 2079 790a 2020 2020 2020 2020  1j * yy.        
+00017b70: 7365 6c66 2e5f 6469 7363 7265 7469 7a65  self._discretize
+00017b80: 645f 646f 6d61 696e 203d 207b 7365 6c66  d_domain = {self
+00017b90: 2e76 6172 3a20 646f 6d61 696e 7d0a 0a0a  .var: domain}...
+00017ba0: 636c 6173 7320 436f 6d70 6c65 7853 7572  class ComplexSur
+00017bb0: 6661 6365 5365 7269 6573 280a 2020 2020  faceSeries(.    
+00017bc0: 436f 6d6d 6f6e 556e 6966 6f72 6d45 7661  CommonUniformEva
+00017bd0: 6c75 6174 696f 6e2c 2043 6f6d 706c 6578  luation, Complex
+00017be0: 5375 7266 6163 6542 6173 6553 6572 6965  SurfaceBaseSerie
+00017bf0: 730a 293a 0a20 2020 2022 2222 5265 7072  s.):.    """Repr
+00017c00: 6573 656e 7473 2061 2033 4420 7375 7266  esents a 3D surf
+00017c10: 6163 6520 6f72 2063 6f6e 746f 7572 2070  ace or contour p
+00017c20: 6c6f 7420 6f66 2061 2063 6f6d 706c 6578  lot of a complex
+00017c30: 2066 756e 6374 696f 6e20 6f76 6572 0a20   function over. 
+00017c40: 2020 2074 6865 2063 6f6d 706c 6578 2070     the complex p
+00017c50: 6c61 6e65 2e0a 2020 2020 2222 220a 2020  lane..    """.  
+00017c60: 2020 6973 5f33 4473 7572 6661 6365 203d    is_3Dsurface =
+00017c70: 2054 7275 650a 2020 2020 6973 5f63 6f6e   True.    is_con
+00017c80: 746f 7572 203d 2046 616c 7365 0a20 2020  tour = False.   
+00017c90: 2069 735f 646f 6d61 696e 5f63 6f6c 6f72   is_domain_color
+00017ca0: 696e 6720 3d20 4661 6c73 650a 2020 2020  ing = False.    
+00017cb0: 5f61 6c6c 6f77 6564 5f6b 6579 7320 3d20  _allowed_keys = 
+00017cc0: 5b22 7468 7265 6564 222c 2022 6973 5f66  ["threed", "is_f
+00017cd0: 696c 6c65 6422 2c20 2263 6c61 6265 6c73  illed", "clabels
+00017ce0: 225d 0a0a 2020 2020 6465 6620 5f5f 696e  "]..    def __in
+00017cf0: 6974 5f5f 2873 656c 662c 2065 7870 722c  it__(self, expr,
+00017d00: 2072 2c20 6c61 6265 6c3d 2222 2c20 2a2a   r, label="", **
+00017d10: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+00017d20: 2073 7570 6572 2829 2e5f 5f69 6e69 745f   super().__init_
+00017d30: 5f28 6578 7072 2c20 722c 206c 6162 656c  _(expr, r, label
+00017d40: 2c20 2a2a 6b77 6172 6773 290a 0a20 2020  , **kwargs)..   
+00017d50: 2020 2020 2073 656c 662e 6578 7072 203d       self.expr =
+00017d60: 2065 7870 7220 6966 2063 616c 6c61 626c   expr if callabl
+00017d70: 6528 6578 7072 2920 656c 7365 2073 796d  e(expr) else sym
+00017d80: 7069 6679 2865 7870 7229 0a20 2020 2020  pify(expr).     
+00017d90: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+00017da0: 2873 656c 662c 2043 6f6d 706c 6578 5375  (self, ComplexSu
+00017db0: 7266 6163 6553 6572 6965 7329 3a0a 2020  rfaceSeries):.  
+00017dc0: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+00017dd0: 626c 6f63 6b5f 6c61 6d62 6461 5f66 756e  block_lambda_fun
+00017de0: 6374 696f 6e73 2873 656c 662e 6578 7072  ctions(self.expr
+00017df0: 290a 0a20 2020 2020 2020 2069 6620 6e6f  )..        if no
+00017e00: 7420 6b77 6172 6773 2e67 6574 2822 7468  t kwargs.get("th
+00017e10: 7265 6564 222c 2046 616c 7365 293a 0a20  reed", False):. 
+00017e20: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00017e30: 6973 5f63 6f6e 746f 7572 203d 2054 7275  is_contour = Tru
+00017e40: 650a 2020 2020 2020 2020 2020 2020 7365  e.            se
+00017e50: 6c66 2e69 735f 3344 7375 7266 6163 6520  lf.is_3Dsurface 
+00017e60: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+00017e70: 7365 6c66 2e69 735f 6669 6c6c 6564 203d  self.is_filled =
+00017e80: 206b 7761 7267 732e 6765 7428 2269 735f   kwargs.get("is_
+00017e90: 6669 6c6c 6564 222c 206b 7761 7267 732e  filled", kwargs.
+00017ea0: 6765 7428 2266 696c 6c22 2c20 5472 7565  get("fill", True
+00017eb0: 2929 0a20 2020 2020 2020 2073 656c 662e  )).        self.
+00017ec0: 7368 6f77 5f63 6c61 6265 6c73 203d 206b  show_clabels = k
+00017ed0: 7761 7267 732e 6765 7428 2263 6c61 6265  wargs.get("clabe
+00017ee0: 6c73 222c 2054 7275 6529 0a20 2020 2020  ls", True).     
+00017ef0: 2020 2073 656c 662e 5f70 6f73 745f 696e     self._post_in
+00017f00: 6974 2829 0a0a 2020 2020 6465 6620 5f63  it()..    def _c
+00017f10: 7265 6174 655f 6469 7363 7265 7469 7a65  reate_discretize
+00017f20: 645f 646f 6d61 696e 2873 656c 6629 3a0a  d_domain(self):.
+00017f30: 2020 2020 2020 2020 7265 7475 726e 2043          return C
+00017f40: 6f6d 706c 6578 5375 7266 6163 6542 6173  omplexSurfaceBas
+00017f50: 6553 6572 6965 732e 5f63 7265 6174 655f  eSeries._create_
+00017f60: 6469 7363 7265 7469 7a65 645f 646f 6d61  discretized_doma
+00017f70: 696e 2873 656c 6629 0a0a 2020 2020 6465  in(self)..    de
+00017f80: 6620 6765 745f 6461 7461 2873 656c 6629  f get_data(self)
+00017f90: 3a0a 2020 2020 2020 2020 2222 2252 6574  :.        """Ret
+00017fa0: 7572 6e20 6172 7261 7973 206f 6620 636f  urn arrays of co
+00017fb0: 6f72 6469 6e61 7465 7320 666f 7220 706c  ordinates for pl
+00017fc0: 6f74 7469 6e67 2e0a 0a20 2020 2020 2020  otting...       
+00017fd0: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
+00017fe0: 203d 3d3d 3d3d 3d3d 0a0a 2020 2020 2020   =======..      
+00017ff0: 2020 6d65 7368 5f78 203a 206e 702e 6e64    mesh_x : np.nd
+00018000: 6172 7261 7920 5b6e 3220 7820 6e31 5d0a  array [n2 x n1].
+00018010: 2020 2020 2020 2020 2020 2020 5265 616c              Real
+00018020: 2064 6973 6372 6574 697a 6564 2064 6f6d   discretized dom
+00018030: 6169 6e2e 0a0a 2020 2020 2020 2020 6d65  ain...        me
+00018040: 7368 5f79 203a 206e 702e 6e64 6172 7261  sh_y : np.ndarra
+00018050: 7920 5b6e 3220 7820 6e31 5d0a 2020 2020  y [n2 x n1].    
+00018060: 2020 2020 2020 2020 496d 6167 696e 6172          Imaginar
+00018070: 7920 6469 7363 7265 7469 7a65 6420 646f  y discretized do
+00018080: 6d61 696e 2e0a 0a20 2020 2020 2020 207a  main...        z
+00018090: 203a 206e 702e 6e64 6172 7261 7920 5b6e   : np.ndarray [n
+000180a0: 3220 7820 6e31 5d0a 2020 2020 2020 2020  2 x n1].        
+000180b0: 2020 2020 5265 7375 6c74 7320 6f66 2074      Results of t
+000180c0: 6865 2065 7661 6c75 6174 696f 6e2e 0a20  he evaluation.. 
+000180d0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+000180e0: 2020 206e 7020 3d20 696d 706f 7274 5f6d     np = import_m
+000180f0: 6f64 756c 6528 276e 756d 7079 2729 0a0a  odule('numpy')..
+00018100: 2020 2020 2020 2020 646f 6d61 696e 2c20          domain, 
+00018110: 7a20 3d20 7365 6c66 2e5f 6576 616c 7561  z = self._evalua
+00018120: 7465 2846 616c 7365 290a 2020 2020 2020  te(False).      
+00018130: 2020 6966 2073 656c 662e 5f72 6574 7572    if self._retur
+00018140: 6e20 6973 204e 6f6e 653a 0a20 2020 2020  n is None:.     
+00018150: 2020 2020 2020 2070 6173 730a 2020 2020         pass.    
+00018160: 2020 2020 656c 6966 2073 656c 662e 5f72      elif self._r
+00018170: 6574 7572 6e20 3d3d 2022 7265 616c 223a  eturn == "real":
+00018180: 0a20 2020 2020 2020 2020 2020 207a 203d  .            z =
+00018190: 206e 702e 7265 616c 287a 290a 2020 2020   np.real(z).    
+000181a0: 2020 2020 656c 6966 2073 656c 662e 5f72      elif self._r
+000181b0: 6574 7572 6e20 3d3d 2022 696d 6167 223a  eturn == "imag":
+000181c0: 0a20 2020 2020 2020 2020 2020 207a 203d  .            z =
+000181d0: 206e 702e 696d 6167 287a 290a 2020 2020   np.imag(z).    
+000181e0: 2020 2020 656c 6966 2073 656c 662e 5f72      elif self._r
+000181f0: 6574 7572 6e20 3d3d 2022 6162 7322 3a0a  eturn == "abs":.
+00018200: 2020 2020 2020 2020 2020 2020 7a20 3d20              z = 
+00018210: 6e70 2e61 6273 6f6c 7574 6528 7a29 0a20  np.absolute(z). 
+00018220: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
+00018230: 2e5f 7265 7475 726e 203d 3d20 2261 7267  ._return == "arg
+00018240: 223a 0a20 2020 2020 2020 2020 2020 207a  ":.            z
+00018250: 203d 206e 702e 616e 676c 6528 7a29 0a20   = np.angle(z). 
+00018260: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00018270: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
+00018280: 616c 7565 4572 726f 7228 0a20 2020 2020  alueError(.     
+00018290: 2020 2020 2020 2020 2020 2022 605f 7265             "`_re
+000182a0: 7475 726e 6020 6e6f 7420 7265 636f 676e  turn` not recogn
+000182b0: 697a 6564 2e20 5265 6365 6976 6564 3a20  ized. Received: 
+000182c0: 2573 2220 2520 7365 6c66 2e5f 7265 7475  %s" % self._retu
+000182d0: 726e 290a 0a20 2020 2020 2020 2072 6574  rn)..        ret
+000182e0: 7572 6e20 7365 6c66 2e5f 6170 706c 795f  urn self._apply_
+000182f0: 7472 616e 7366 6f72 6d28 6e70 2e72 6561  transform(np.rea
+00018300: 6c28 646f 6d61 696e 292c 206e 702e 696d  l(domain), np.im
+00018310: 6167 2864 6f6d 6169 6e29 2c20 7a29 0a0a  ag(domain), z)..
+00018320: 0a63 6c61 7373 2043 6f6d 706c 6578 446f  .class ComplexDo
+00018330: 6d61 696e 436f 6c6f 7269 6e67 5365 7269  mainColoringSeri
+00018340: 6573 280a 2020 2020 436f 6d6d 6f6e 556e  es(.    CommonUn
+00018350: 6966 6f72 6d45 7661 6c75 6174 696f 6e2c  iformEvaluation,
+00018360: 2043 6f6d 706c 6578 5375 7266 6163 6542   ComplexSurfaceB
+00018370: 6173 6553 6572 6965 730a 293a 0a20 2020  aseSeries.):.   
+00018380: 2022 2222 5265 7072 6573 656e 7473 2061   """Represents a
+00018390: 2032 442f 3344 2064 6f6d 6169 6e20 636f   2D/3D domain co
+000183a0: 6c6f 7269 6e67 2070 6c6f 7420 6f66 2061  loring plot of a
+000183b0: 2063 6f6d 706c 6578 2066 756e 6374 696f   complex functio
+000183c0: 6e20 6f76 6572 0a20 2020 2074 6865 2063  n over.    the c
+000183d0: 6f6d 706c 6578 2070 6c61 6e65 2e0a 2020  omplex plane..  
+000183e0: 2020 2222 220a 2020 2020 6973 5f33 4473    """.    is_3Ds
+000183f0: 7572 6661 6365 203d 2046 616c 7365 0a20  urface = False. 
+00018400: 2020 2069 735f 646f 6d61 696e 5f63 6f6c     is_domain_col
+00018410: 6f72 696e 6720 3d20 5472 7565 0a20 2020  oring = True.   
+00018420: 205f 616c 6c6f 7765 645f 6b65 7973 203d   _allowed_keys =
+00018430: 205b 0a20 2020 2020 2020 2022 7468 7265   [.        "thre
+00018440: 6564 222c 2022 636f 6c6f 7269 6e67 222c  ed", "coloring",
+00018450: 2022 7068 6173 6572 6573 222c 2022 636d   "phaseres", "cm
+00018460: 6170 222c 2022 626c 6576 656c 222c 2022  ap", "blevel", "
+00018470: 7068 6173 656f 6666 7365 7422 2c0a 2020  phaseoffset",.  
+00018480: 2020 2020 2020 2263 6f6c 6f72 6261 7222        "colorbar"
+00018490: 2c20 2261 745f 696e 6669 6e69 7479 222c  , "at_infinity",
+000184a0: 2022 7269 656d 616e 6e5f 6d61 736b 222c   "riemann_mask",
+000184b0: 2022 616e 6e6f 7461 7465 220a 2020 2020   "annotate".    
+000184c0: 5d0a 0a20 2020 2064 6566 205f 5f69 6e69  ]..    def __ini
+000184d0: 745f 5f28 7365 6c66 2c20 6578 7072 2c20  t__(self, expr, 
+000184e0: 722c 206c 6162 656c 3d22 222c 202a 2a6b  r, label="", **k
+000184f0: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
+00018500: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+00018510: 2865 7870 722c 2072 2c20 6c61 6265 6c2c  (expr, r, label,
+00018520: 202a 2a6b 7761 7267 7329 0a20 2020 2020   **kwargs).     
+00018530: 2020 2069 6620 6b77 6172 6773 2e67 6574     if kwargs.get
+00018540: 2822 7468 7265 6564 222c 2046 616c 7365  ("threed", False
+00018550: 293a 0a20 2020 2020 2020 2020 2020 2073  ):.            s
+00018560: 656c 662e 6973 5f33 4473 7572 6661 6365  elf.is_3Dsurface
+00018570: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
+00018580: 2020 2020 7365 6c66 2e75 7365 5f63 6d20      self.use_cm 
+00018590: 3d20 6b77 6172 6773 2e67 6574 2822 7573  = kwargs.get("us
+000185a0: 655f 636d 222c 2054 7275 6529 0a0a 2020  e_cm", True)..  
+000185b0: 2020 2020 2020 7365 6c66 2e65 7870 7220        self.expr 
+000185c0: 3d20 6578 7072 2069 6620 6361 6c6c 6162  = expr if callab
+000185d0: 6c65 2865 7870 7229 2065 6c73 6520 7379  le(expr) else sy
+000185e0: 6d70 6966 7928 6578 7072 290a 2020 2020  mpify(expr).    
+000185f0: 2020 2020 2320 6170 706c 7920 7468 6520      # apply the 
+00018600: 7472 616e 7366 6f72 6d61 7469 6f6e 207a  transformation z
+00018610: 202d 3e20 312f 7a20 696e 206f 7264 6572   -> 1/z in order
+00018620: 2074 6f20 7374 7564 7920 7468 6520 6265   to study the be
+00018630: 6861 7669 6f72 0a20 2020 2020 2020 2023  havior.        #
+00018640: 206f 6620 7468 6520 6675 6e63 7469 6f6e   of the function
+00018650: 2061 7420 7a3d 696e 6669 6e69 7479 0a20   at z=infinity. 
+00018660: 2020 2020 2020 2073 656c 662e 6174 5f69         self.at_i
+00018670: 6e66 696e 6974 7920 3d20 6b77 6172 6773  nfinity = kwargs
+00018680: 2e67 6574 2822 6174 5f69 6e66 696e 6974  .get("at_infinit
+00018690: 7922 2c20 4661 6c73 6529 0a20 2020 2020  y", False).     
+000186a0: 2020 2069 6620 7365 6c66 2e61 745f 696e     if self.at_in
+000186b0: 6669 6e69 7479 3a0a 2020 2020 2020 2020  finity:.        
+000186c0: 2020 2020 6966 2063 616c 6c61 626c 6528      if callable(
+000186d0: 7365 6c66 2e65 7870 7229 3a0a 2020 2020  self.expr):.    
+000186e0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+000186f0: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
+00018700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018710: 2020 2260 6061 745f 696e 6669 6e69 7479    "``at_infinity
+00018720: 3d54 7275 6560 6020 6973 206f 6e6c 7920  =True`` is only 
+00018730: 7375 7070 6f72 7465 6420 666f 7220 7379  supported for sy
+00018740: 6d62 6f6c 6963 2022 0a20 2020 2020 2020  mbolic ".       
+00018750: 2020 2020 2020 2020 2020 2020 2022 6578               "ex
+00018760: 7072 6573 7369 6f6e 732e 2049 6e73 7465  pressions. Inste
+00018770: 6164 2c20 6120 6361 6c6c 6162 6c65 2077  ad, a callable w
+00018780: 6173 2070 726f 7669 6465 642e 2229 0a20  as provided."). 
+00018790: 2020 2020 2020 2020 2020 207a 203d 2073             z = s
+000187a0: 656c 662e 7261 6e67 6573 5b30 5d5b 305d  elf.ranges[0][0]
+000187b0: 0a20 2020 2020 2020 2020 2020 2074 6d70  .            tmp
+000187c0: 203d 2073 656c 662e 6578 7072 2e73 7562   = self.expr.sub
+000187d0: 7328 7a2c 2031 202f 207a 290a 2020 2020  s(z, 1 / z).    
+000187e0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+000187f0: 5f6c 6162 656c 203d 3d20 7374 7228 7365  _label == str(se
+00018800: 6c66 2e65 7870 7229 3a0a 2020 2020 2020  lf.expr):.      
+00018810: 2020 2020 2020 2020 2020 2320 6164 6a75            # adju
+00018820: 7374 206c 6162 656c 7320 746f 2070 7265  st labels to pre
+00018830: 7665 6e74 2074 6865 2077 726f 6e67 206f  vent the wrong o
+00018840: 6e65 2074 6f20 6265 2073 6565 6e20 6f6e  ne to be seen on
+00018850: 2063 6f6c 6f72 6261 720a 2020 2020 2020   colorbar.      
+00018860: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+00018870: 6c61 6265 6c20 3d20 7374 7228 746d 7029  label = str(tmp)
+00018880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018890: 2073 656c 662e 5f6c 6174 6578 5f6c 6162   self._latex_lab
+000188a0: 656c 203d 206c 6174 6578 2874 6d70 290a  el = latex(tmp).
+000188b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000188c0: 2e65 7870 7220 3d20 746d 700a 0a20 2020  .expr = tmp..   
+000188d0: 2020 2020 2023 2064 6f6d 6169 6e20 636f       # domain co
+000188e0: 6c6f 7269 6e67 206d 6f64 650a 2020 2020  loring mode.    
+000188f0: 2020 2020 7365 6c66 2e5f 696e 6974 5f64      self._init_d
+00018900: 6f6d 6169 6e5f 636f 6c6f 7269 6e67 5f6b  omain_coloring_k
+00018910: 7728 2a2a 6b77 6172 6773 290a 0a20 2020  w(**kwargs)..   
+00018920: 2020 2020 2073 656c 662e 616e 6e6f 7461       self.annota
+00018930: 7465 203d 206b 7761 7267 732e 6765 7428  te = kwargs.get(
+00018940: 2261 6e6e 6f74 6174 6522 2c20 5472 7565  "annotate", True
+00018950: 290a 2020 2020 2020 2020 7365 6c66 2e72  ).        self.r
+00018960: 6965 6d61 6e6e 5f6d 6173 6b20 3d20 6b77  iemann_mask = kw
+00018970: 6172 6773 2e67 6574 2822 7269 656d 616e  args.get("rieman
+00018980: 6e5f 6d61 736b 222c 2046 616c 7365 290a  n_mask", False).
+00018990: 2020 2020 2020 2020 7365 6c66 2e5f 706f          self._po
+000189a0: 7374 5f69 6e69 7428 290a 0a20 2020 2064  st_init()..    d
+000189b0: 6566 205f 696e 6974 5f64 6f6d 6169 6e5f  ef _init_domain_
+000189c0: 636f 6c6f 7269 6e67 5f6b 7728 7365 6c66  coloring_kw(self
+000189d0: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
+000189e0: 2020 2020 2073 656c 662e 636f 6c6f 7269       self.colori
+000189f0: 6e67 203d 206b 7761 7267 732e 6765 7428  ng = kwargs.get(
+00018a00: 2263 6f6c 6f72 696e 6722 2c20 2261 2229  "coloring", "a")
+00018a10: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
+00018a20: 7374 616e 6365 2873 656c 662e 636f 6c6f  stance(self.colo
+00018a30: 7269 6e67 2c20 7374 7229 3a0a 2020 2020  ring, str):.    
+00018a40: 2020 2020 2020 2020 7365 6c66 2e63 6f6c          self.col
+00018a50: 6f72 696e 6720 3d20 7365 6c66 2e63 6f6c  oring = self.col
+00018a60: 6f72 696e 672e 6c6f 7765 7228 290a 2020  oring.lower().  
+00018a70: 2020 2020 2020 656c 6966 206e 6f74 2063        elif not c
+00018a80: 616c 6c61 626c 6528 7365 6c66 2e63 6f6c  allable(self.col
+00018a90: 6f72 696e 6729 3a0a 2020 2020 2020 2020  oring):.        
+00018aa0: 2020 2020 7261 6973 6520 5479 7065 4572      raise TypeEr
+00018ab0: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
+00018ac0: 2020 2020 2022 6063 6f6c 6f72 696e 6760       "`coloring`
+00018ad0: 206d 7573 7420 6265 2061 2063 6861 7261   must be a chara
+00018ae0: 6374 6572 2066 726f 6d20 2761 2720 746f  cter from 'a' to
+00018af0: 2027 6a27 206f 7220 220a 2020 2020 2020   'j' or ".      
+00018b00: 2020 2020 2020 2020 2020 2261 2063 616c            "a cal
+00018b10: 6c61 626c 652e 2229 0a20 2020 2020 2020  lable.").       
+00018b20: 2073 656c 662e 7068 6173 6572 6573 203d   self.phaseres =
+00018b30: 206b 7761 7267 732e 6765 7428 2270 6861   kwargs.get("pha
+00018b40: 7365 7265 7322 2c20 3230 290a 2020 2020  seres", 20).    
+00018b50: 2020 2020 7365 6c66 2e63 6d61 7020 3d20      self.cmap = 
+00018b60: 6b77 6172 6773 2e67 6574 2822 636d 6170  kwargs.get("cmap
+00018b70: 222c 204e 6f6e 6529 0a20 2020 2020 2020  ", None).       
+00018b80: 2073 656c 662e 626c 6576 656c 203d 2066   self.blevel = f
+00018b90: 6c6f 6174 286b 7761 7267 732e 6765 7428  loat(kwargs.get(
+00018ba0: 2262 6c65 7665 6c22 2c20 302e 3735 2929  "blevel", 0.75))
+00018bb0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00018bc0: 2e62 6c65 7665 6c20 3c20 303a 0a20 2020  .blevel < 0:.   
+00018bd0: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
+00018be0: 732e 7761 726e 280a 2020 2020 2020 2020  s.warn(.        
+00018bf0: 2020 2020 2020 2020 2249 7420 6d75 7374          "It must
+00018c00: 2062 6520 3020 3c3d 2062 6c65 7665 6c20   be 0 <= blevel 
+00018c10: 3c3d 2031 2e20 4175 746f 6d61 7469 6361  <= 1. Automatica
+00018c20: 6c6c 7920 220a 2020 2020 2020 2020 2020  lly ".          
+00018c30: 2020 2020 2020 2273 6574 7469 6e67 2062        "setting b
+00018c40: 6c65 7665 6c20 3d20 302e 2229 0a20 2020  level = 0.").   
+00018c50: 2020 2020 2020 2020 2073 656c 662e 626c           self.bl
+00018c60: 6576 656c 203d 2030 0a20 2020 2020 2020  evel = 0.       
+00018c70: 2069 6620 7365 6c66 2e62 6c65 7665 6c20   if self.blevel 
+00018c80: 3e20 313a 0a20 2020 2020 2020 2020 2020  > 1:.           
+00018c90: 2077 6172 6e69 6e67 732e 7761 726e 280a   warnings.warn(.
+00018ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018cb0: 2249 7420 6d75 7374 2062 6520 3020 3c3d  "It must be 0 <=
+00018cc0: 2062 6c65 7665 6c20 3c3d 2031 2e20 4175   blevel <= 1. Au
+00018cd0: 746f 6d61 7469 6361 6c6c 7920 220a 2020  tomatically ".  
+00018ce0: 2020 2020 2020 2020 2020 2020 2020 2273                "s
+00018cf0: 6574 7469 6e67 2062 6c65 7665 6c20 3d20  etting blevel = 
+00018d00: 312e 2229 0a20 2020 2020 2020 2020 2020  1.").           
+00018d10: 2073 656c 662e 626c 6576 656c 203d 2031   self.blevel = 1
+00018d20: 0a20 2020 2020 2020 2073 656c 662e 7068  .        self.ph
+00018d30: 6173 656f 6666 7365 7420 3d20 666c 6f61  aseoffset = floa
+00018d40: 7428 6b77 6172 6773 2e67 6574 2822 7068  t(kwargs.get("ph
+00018d50: 6173 656f 6666 7365 7422 2c20 3029 290a  aseoffset", 0)).
+00018d60: 0a20 2020 2064 6566 205f 6372 6561 7465  .    def _create
+00018d70: 5f64 6973 6372 6574 697a 6564 5f64 6f6d  _discretized_dom
+00018d80: 6169 6e28 7365 6c66 293a 0a20 2020 2020  ain(self):.     
+00018d90: 2020 2072 6574 7572 6e20 436f 6d70 6c65     return Comple
+00018da0: 7853 7572 6661 6365 4261 7365 5365 7269  xSurfaceBaseSeri
+00018db0: 6573 2e5f 6372 6561 7465 5f64 6973 6372  es._create_discr
+00018dc0: 6574 697a 6564 5f64 6f6d 6169 6e28 7365  etized_domain(se
+00018dd0: 6c66 290a 0a20 2020 2064 6566 205f 646f  lf)..    def _do
+00018de0: 6d61 696e 5f63 6f6c 6f72 696e 6728 7365  main_coloring(se
+00018df0: 6c66 2c20 646f 6d61 696e 2c20 7729 3a0a  lf, domain, w):.
+00018e00: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+00018e10: 7461 6e63 6528 7365 6c66 2e63 6f6c 6f72  tance(self.color
+00018e20: 696e 672c 2073 7472 293a 0a20 2020 2020  ing, str):.     
+00018e30: 2020 2020 2020 2073 656c 662e 636f 6c6f         self.colo
+00018e40: 7269 6e67 203d 2073 656c 662e 636f 6c6f  ring = self.colo
+00018e50: 7269 6e67 2e6c 6f77 6572 2829 0a20 2020  ring.lower().   
+00018e60: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00018e70: 7765 6765 7274 280a 2020 2020 2020 2020  wegert(.        
+00018e80: 2020 2020 2020 2020 7365 6c66 2e63 6f6c          self.col
+00018e90: 6f72 696e 672c 2077 2c20 7365 6c66 2e70  oring, w, self.p
+00018ea0: 6861 7365 7265 732c 2073 656c 662e 636d  haseres, self.cm
+00018eb0: 6170 2c0a 2020 2020 2020 2020 2020 2020  ap,.            
+00018ec0: 2020 2020 7365 6c66 2e62 6c65 7665 6c2c      self.blevel,
+00018ed0: 2073 656c 662e 7068 6173 656f 6666 7365   self.phaseoffse
+00018ee0: 742c 0a20 2020 2020 2020 2020 2020 2020  t,.             
+00018ef0: 2020 2073 656c 662e 6174 5f69 6e66 696e     self.at_infin
+00018f00: 6974 792c 2073 656c 662e 7269 656d 616e  ity, self.rieman
+00018f10: 6e5f 6d61 736b 2c0a 2020 2020 2020 2020  n_mask,.        
+00018f20: 2020 2020 2020 2020 646f 6d61 696e 3d5b          domain=[
+00018f30: 646f 6d61 696e 5b30 2c20 305d 2c20 646f  domain[0, 0], do
+00018f40: 6d61 696e 5b2d 312c 202d 315d 5d29 0a20  main[-1, -1]]). 
+00018f50: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00018f60: 6c66 2e63 6f6c 6f72 696e 6728 7729 0a0a  lf.coloring(w)..
+00018f70: 2020 2020 6465 6620 6765 745f 6461 7461      def get_data
+00018f80: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00018f90: 2222 2252 6574 7572 6e20 6172 7261 7973  """Return arrays
+00018fa0: 206f 6620 636f 6f72 6469 6e61 7465 7320   of coordinates 
+00018fb0: 666f 7220 706c 6f74 7469 6e67 2e0a 0a20  for plotting... 
+00018fc0: 2020 2020 2020 2052 6574 7572 6e73 0a20         Returns. 
+00018fd0: 2020 2020 2020 203d 3d3d 3d3d 3d3d 0a0a         =======..
+00018fe0: 2020 2020 2020 2020 6d65 7368 5f78 203a          mesh_x :
+00018ff0: 206e 702e 6e64 6172 7261 7920 5b6e 3220   np.ndarray [n2 
+00019000: 7820 6e31 5d0a 2020 2020 2020 2020 2020  x n1].          
+00019010: 2020 5265 616c 2064 6973 6372 6574 697a    Real discretiz
+00019020: 6564 2064 6f6d 6169 6e2e 0a0a 2020 2020  ed domain...    
+00019030: 2020 2020 6d65 7368 5f79 203a 206e 702e      mesh_y : np.
+00019040: 6e64 6172 7261 7920 5b6e 3220 7820 6e31  ndarray [n2 x n1
+00019050: 5d0a 2020 2020 2020 2020 2020 2020 496d  ].            Im
+00019060: 6167 696e 6172 7920 6469 7363 7265 7469  aginary discreti
+00019070: 7a65 6420 646f 6d61 696e 2e0a 0a20 2020  zed domain...   
+00019080: 2020 2020 2061 6273 203a 206e 702e 6e64       abs : np.nd
+00019090: 6172 7261 7920 5b6e 3220 7820 6e31 5d0a  array [n2 x n1].
+000190a0: 2020 2020 2020 2020 2020 2020 4162 736f              Abso
+000190b0: 6c75 7465 2076 616c 7565 206f 6620 7468  lute value of th
+000190c0: 6520 6675 6e63 7469 6f6e 2e0a 0a20 2020  e function...   
+000190d0: 2020 2020 2061 7267 203a 206e 702e 6e64       arg : np.nd
+000190e0: 6172 7261 7920 5b6e 3220 7820 6e31 5d0a  array [n2 x n1].
+000190f0: 2020 2020 2020 2020 2020 2020 4172 6775              Argu
+00019100: 6d65 6e74 206f 6620 7468 6520 6675 6e63  ment of the func
+00019110: 7469 6f6e 2e0a 0a20 2020 2020 2020 2069  tion...        i
+00019120: 6d67 203a 206e 702e 6e64 6172 7261 7920  mg : np.ndarray 
+00019130: 5b6e 3220 7820 6e31 2078 2033 5d0a 2020  [n2 x n1 x 3].  
+00019140: 2020 2020 2020 2020 2020 5247 4220 696d            RGB im
+00019150: 6167 6520 7661 6c75 6573 2063 6f6d 7075  age values compu
+00019160: 7465 6420 6672 6f6d 2074 6865 2061 7267  ted from the arg
+00019170: 756d 656e 7420 6f66 2074 6865 2066 756e  ument of the fun
+00019180: 6374 696f 6e2e 0a20 2020 2020 2020 2020  ction..         
+00019190: 2020 2030 203c 3d20 522c 2047 2c20 4220     0 <= R, G, B 
+000191a0: 3c3d 2032 3535 0a0a 2020 2020 2020 2020  <= 255..        
+000191b0: 636f 6c6f 7273 203a 206e 702e 6e64 6172  colors : np.ndar
+000191c0: 7261 7920 5b32 3536 2078 2033 5d0a 2020  ray [256 x 3].  
+000191d0: 2020 2020 2020 2020 2020 436f 6c6f 7220            Color 
+000191e0: 7363 616c 6520 6173 736f 6369 6174 6564  scale associated
+000191f0: 2074 6f20 6069 6d67 602e 0a20 2020 2020   to `img`..     
+00019200: 2020 2022 2222 0a20 2020 2020 2020 206e     """.        n
+00019210: 7020 3d20 696d 706f 7274 5f6d 6f64 756c  p = import_modul
+00019220: 6528 276e 756d 7079 2729 0a0a 2020 2020  e('numpy')..    
+00019230: 2020 2020 646f 6d61 696e 2c20 7a20 3d20      domain, z = 
+00019240: 7365 6c66 2e5f 6576 616c 7561 7465 2846  self._evaluate(F
+00019250: 616c 7365 290a 2020 2020 2020 2020 7265  alse).        re
+00019260: 7475 726e 2073 656c 662e 5f61 7070 6c79  turn self._apply
+00019270: 5f74 7261 6e73 666f 726d 280a 2020 2020  _transform(.    
+00019280: 2020 2020 2020 2020 6e70 2e72 6561 6c28          np.real(
+00019290: 646f 6d61 696e 292c 206e 702e 696d 6167  domain), np.imag
+000192a0: 2864 6f6d 6169 6e29 2c0a 2020 2020 2020  (domain),.      
+000192b0: 2020 2020 2020 6e70 2e61 6273 6f6c 7574        np.absolut
+000192c0: 6528 7a29 2c20 6e70 2e61 6e67 6c65 287a  e(z), np.angle(z
+000192d0: 292c 0a20 2020 2020 2020 2020 2020 202a  ),.            *
+000192e0: 7365 6c66 2e5f 646f 6d61 696e 5f63 6f6c  self._domain_col
+000192f0: 6f72 696e 6728 646f 6d61 696e 2c20 7a29  oring(domain, z)
+00019300: 2c0a 2020 2020 2020 2020 290a 0a0a 636c  ,.        )...cl
+00019310: 6173 7320 436f 6d70 6c65 7850 6172 616d  ass ComplexParam
+00019320: 6574 7269 6333 444c 696e 6553 6572 6965  etric3DLineSerie
+00019330: 7328 5061 7261 6d65 7472 6963 3344 4c69  s(Parametric3DLi
+00019340: 6e65 5365 7269 6573 293a 0a20 2020 2022  neSeries):.    "
+00019350: 2222 5265 7072 6573 656e 7420 6120 6d65  ""Represent a me
+00019360: 7368 2f77 6972 6566 7261 6d65 206c 696e  sh/wireframe lin
+00019370: 6520 6f66 2061 2063 6f6d 706c 6578 2073  e of a complex s
+00019380: 7572 6661 6365 2073 6572 6965 732e 0a20  urface series.. 
+00019390: 2020 2022 2222 0a0a 2020 2020 6465 6620     """..    def 
+000193a0: 5f5f 696e 6974 5f5f 2873 656c 662c 202a  __init__(self, *
+000193b0: 6172 6773 2c20 2a2a 6b77 6172 6773 293a  args, **kwargs):
+000193c0: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
+000193d0: 2e5f 5f69 6e69 745f 5f28 2a61 7267 732c  .__init__(*args,
+000193e0: 202a 2a6b 7761 7267 7329 0a20 2020 2020   **kwargs).     
+000193f0: 2020 2023 2064 6574 6572 6d69 6e65 7320     # determines 
+00019400: 7768 6174 2064 6174 6120 746f 2072 6574  what data to ret
+00019410: 7572 6e20 6f6e 2074 6865 207a 2d61 7869  urn on the z-axi
+00019420: 730a 2020 2020 2020 2020 7365 6c66 2e5f  s.        self._
+00019430: 7265 7475 726e 203d 206b 7761 7267 732e  return = kwargs.
+00019440: 6765 7428 2272 6574 7572 6e22 2c20 4e6f  get("return", No
+00019450: 6e65 290a 0a20 2020 2064 6566 205f 6164  ne)..    def _ad
+00019460: 6170 7469 7665 5f73 616d 706c 696e 6728  aptive_sampling(
+00019470: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+00019480: 6169 7365 204e 6f74 496d 706c 656d 656e  aise NotImplemen
+00019490: 7465 6445 7272 6f72 0a0a 2020 2020 6465  tedError..    de
+000194a0: 6620 5f75 6e69 666f 726d 5f73 616d 706c  f _uniform_sampl
+000194b0: 696e 6728 7365 6c66 293a 0a20 2020 2020  ing(self):.     
+000194c0: 2020 2022 2222 5265 7475 726e 7320 636f     """Returns co
+000194d0: 6f72 6469 6e61 7465 7320 7468 6174 206e  ordinates that n
+000194e0: 6565 6473 2074 6f20 6265 2070 6f73 7470  eeds to be postp
+000194f0: 726f 6365 7373 6564 2e22 2222 0a20 2020  rocessed.""".   
+00019500: 2020 2020 206e 7020 3d20 696d 706f 7274       np = import
+00019510: 5f6d 6f64 756c 6528 276e 756d 7079 2729  _module('numpy')
+00019520: 0a0a 2020 2020 2020 2020 7265 7375 6c74  ..        result
+00019530: 7320 3d20 7365 6c66 2e5f 6576 616c 7561  s = self._evalua
+00019540: 7465 2829 0a20 2020 2020 2020 2066 6f72  te().        for
+00019550: 2069 2069 6e20 7261 6e67 6528 6c65 6e28   i in range(len(
+00019560: 7265 7375 6c74 7329 202d 2031 293a 0a20  results) - 1):. 
+00019570: 2020 2020 2020 2020 2020 205f 7265 2c20             _re, 
+00019580: 5f69 6d20 3d20 6e70 2e72 6561 6c28 7265  _im = np.real(re
+00019590: 7375 6c74 735b 695d 292c 206e 702e 696d  sults[i]), np.im
+000195a0: 6167 2872 6573 756c 7473 5b69 5d29 0a20  ag(results[i]). 
+000195b0: 2020 2020 2020 2020 2020 205f 7265 5b6e             _re[n
+000195c0: 702e 696e 7665 7274 286e 702e 6973 636c  p.invert(np.iscl
+000195d0: 6f73 6528 5f69 6d2c 206e 702e 7a65 726f  ose(_im, np.zero
+000195e0: 735f 6c69 6b65 285f 696d 2929 295d 203d  s_like(_im)))] =
+000195f0: 206e 702e 6e61 6e0a 2020 2020 2020 2020   np.nan.        
+00019600: 2020 2020 7265 7375 6c74 735b 695d 203d      results[i] =
+00019610: 205f 7265 0a0a 2020 2020 2020 2020 6966   _re..        if
+00019620: 2073 656c 662e 5f72 6574 7572 6e20 6973   self._return is
+00019630: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00019640: 2020 2070 6173 730a 2020 2020 2020 2020     pass.        
+00019650: 656c 6966 2073 656c 662e 5f72 6574 7572  elif self._retur
+00019660: 6e20 3d3d 2022 7265 616c 223a 0a20 2020  n == "real":.   
+00019670: 2020 2020 2020 2020 2072 6573 756c 7473           results
+00019680: 5b2d 315d 203d 206e 702e 7265 616c 2872  [-1] = np.real(r
+00019690: 6573 756c 7473 5b2d 315d 290a 2020 2020  esults[-1]).    
+000196a0: 2020 2020 656c 6966 2073 656c 662e 5f72      elif self._r
+000196b0: 6574 7572 6e20 3d3d 2022 696d 6167 223a  eturn == "imag":
+000196c0: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+000196d0: 756c 7473 5b2d 315d 203d 206e 702e 696d  ults[-1] = np.im
+000196e0: 6167 2872 6573 756c 7473 5b2d 315d 290a  ag(results[-1]).
+000196f0: 2020 2020 2020 2020 656c 6966 2073 656c          elif sel
+00019700: 662e 5f72 6574 7572 6e20 3d3d 2022 6162  f._return == "ab
+00019710: 7322 206f 7220 7365 6c66 2e5f 7265 7475  s" or self._retu
+00019720: 726e 203d 3d20 2261 6273 6172 6722 3a0a  rn == "absarg":.
+00019730: 2020 2020 2020 2020 2020 2020 7265 7375              resu
+00019740: 6c74 735b 2d31 5d20 3d20 6e70 2e61 6273  lts[-1] = np.abs
+00019750: 6f6c 7574 6528 7265 7375 6c74 735b 2d31  olute(results[-1
+00019760: 5d29 0a20 2020 2020 2020 2065 6c69 6620  ]).        elif 
+00019770: 7365 6c66 2e5f 7265 7475 726e 203d 3d20  self._return == 
+00019780: 2261 7267 223a 0a20 2020 2020 2020 2020  "arg":.         
+00019790: 2020 2072 6573 756c 7473 5b2d 315d 203d     results[-1] =
+000197a0: 206e 702e 616e 676c 6528 7265 7375 6c74   np.angle(result
+000197b0: 735b 2d31 5d29 0a20 2020 2020 2020 2065  s[-1]).        e
+000197c0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000197d0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+000197e0: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
+000197f0: 2020 2022 605f 7265 7475 726e 6020 6e6f     "`_return` no
+00019800: 7420 7265 636f 676e 697a 6564 2e20 5265  t recognized. Re
+00019810: 6365 6976 6564 3a20 2573 2220 2520 7365  ceived: %s" % se
+00019820: 6c66 2e5f 7265 7475 726e 290a 0a20 2020  lf._return)..   
+00019830: 2020 2020 2072 6574 7572 6e20 5b2a 7265       return [*re
+00019840: 7375 6c74 735b 313a 5d2c 2072 6573 756c  sults[1:], resul
+00019850: 7473 5b30 5d5d 0a0a 0a64 6566 205f 7365  ts[0]]...def _se
+00019860: 745f 6469 7363 7265 7469 7a61 7469 6f6e  t_discretization
+00019870: 5f70 6f69 6e74 7328 6b77 6172 6773 2c20  _points(kwargs, 
+00019880: 7074 293a 0a20 2020 2022 2222 416c 6c6f  pt):.    """Allo
+00019890: 7720 7468 6520 7573 6520 6f66 2074 6865  w the use of the
+000198a0: 206b 6579 776f 7264 2061 7267 756d 656e   keyword argumen
+000198b0: 7473 206e 2c20 6e31 2061 6e64 206e 3220  ts n, n1 and n2 
+000198c0: 2861 6e64 206e 3329 2074 6f0a 2020 2020  (and n3) to.    
+000198d0: 7370 6563 6966 7920 7468 6520 6e75 6d62  specify the numb
+000198e0: 6572 206f 6620 6469 7363 7265 7469 7a61  er of discretiza
+000198f0: 7469 6f6e 2070 6f69 6e74 7320 696e 2074  tion points in t
+00019900: 776f 2028 6f72 2074 6872 6565 2920 6469  wo (or three) di
+00019910: 7265 6374 696f 6e73 2e0a 0a20 2020 2050  rections...    P
+00019920: 6172 616d 6574 6572 730a 2020 2020 3d3d  arameters.    ==
+00019930: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 6b77  ========..    kw
+00019940: 6172 6773 203a 2064 6963 740a 0a20 2020  args : dict..   
+00019950: 2070 7420 3a20 7479 7065 0a20 2020 2020   pt : type.     
+00019960: 2020 2054 6865 2074 7970 6520 6f66 2074     The type of t
+00019970: 6865 2073 6572 6965 732c 2077 6869 6368  he series, which
+00019980: 2069 6e64 6963 6174 6573 2074 6865 206b   indicates the k
+00019990: 696e 6420 6f66 2070 6c6f 7420 7765 2061  ind of plot we a
+000199a0: 7265 0a20 2020 2020 2020 2074 7279 696e  re.        tryin
+000199b0: 6720 746f 2063 7265 6174 652e 0a0a 2020  g to create...  
+000199c0: 2020 5265 7475 726e 730a 2020 2020 3d3d    Returns.    ==
+000199d0: 3d3d 3d3d 3d0a 0a20 2020 206b 7761 7267  =====..    kwarg
+000199e0: 7320 3a20 6469 6374 0a20 2020 2022 2222  s : dict.    """
+000199f0: 0a20 2020 2064 6570 7265 6361 7465 645f  .    deprecated_
+00019a00: 6b65 7977 6f72 6473 203d 207b 0a20 2020  keywords = {.   
+00019a10: 2020 2020 2022 6e62 5f6f 665f 706f 696e       "nb_of_poin
+00019a20: 7473 223a 2022 6e22 2c0a 2020 2020 2020  ts": "n",.      
+00019a30: 2020 226e 625f 6f66 5f70 6f69 6e74 735f    "nb_of_points_
+00019a40: 7822 3a20 226e 3122 2c0a 2020 2020 2020  x": "n1",.      
+00019a50: 2020 226e 625f 6f66 5f70 6f69 6e74 735f    "nb_of_points_
+00019a60: 7922 3a20 226e 3222 2c0a 2020 2020 2020  y": "n2",.      
+00019a70: 2020 226e 625f 6f66 5f70 6f69 6e74 735f    "nb_of_points_
+00019a80: 7522 3a20 226e 3122 2c0a 2020 2020 2020  u": "n1",.      
+00019a90: 2020 226e 625f 6f66 5f70 6f69 6e74 735f    "nb_of_points_
+00019aa0: 7622 3a20 226e 3222 2c0a 2020 2020 2020  v": "n2",.      
+00019ab0: 2020 2270 6f69 6e74 7322 3a20 226e 220a    "points": "n".
+00019ac0: 2020 2020 7d0a 2020 2020 666f 7220 6b2c      }.    for k,
+00019ad0: 2076 2069 6e20 6465 7072 6563 6174 6564   v in deprecated
+00019ae0: 5f6b 6579 776f 7264 732e 6974 656d 7328  _keywords.items(
+00019af0: 293a 0a20 2020 2020 2020 2069 6620 6b20  ):.        if k 
+00019b00: 696e 206b 7761 7267 732e 6b65 7973 2829  in kwargs.keys()
+00019b10: 3a0a 2020 2020 2020 2020 2020 2020 6b77  :.            kw
+00019b20: 6172 6773 5b76 5d20 3d20 6b77 6172 6773  args[v] = kwargs
+00019b30: 2e70 6f70 286b 290a 0a20 2020 2069 6620  .pop(k)..    if 
+00019b40: 7074 2069 6e20 5b0a 2020 2020 2020 2020  pt in [.        
+00019b50: 4c69 6e65 4f76 6572 3144 5261 6e67 6553  LineOver1DRangeS
+00019b60: 6572 6965 732c 2050 6172 616d 6574 7269  eries, Parametri
+00019b70: 6332 444c 696e 6553 6572 6965 732c 0a20  c2DLineSeries,. 
+00019b80: 2020 2020 2020 2050 6172 616d 6574 7269         Parametri
+00019b90: 6333 444c 696e 6553 6572 6965 732c 2041  c3DLineSeries, A
+00019ba0: 6273 4172 674c 696e 6553 6572 6965 732c  bsArgLineSeries,
+00019bb0: 2043 6f6c 6f72 6564 4c69 6e65 4f76 6572   ColoredLineOver
+00019bc0: 3144 5261 6e67 6553 6572 6965 732c 0a20  1DRangeSeries,. 
+00019bd0: 2020 2020 2020 2043 6f6d 706c 6578 5061         ComplexPa
+00019be0: 7261 6d65 7472 6963 3344 4c69 6e65 5365  rametric3DLineSe
+00019bf0: 7269 6573 2c20 4e79 7175 6973 744c 696e  ries, NyquistLin
+00019c00: 6553 6572 6965 732c 204e 6963 686f 6c73  eSeries, Nichols
+00019c10: 4c69 6e65 5365 7269 6573 2c0a 2020 2020  LineSeries,.    
+00019c20: 2020 2020 5379 7374 656d 5265 7370 6f6e      SystemRespon
+00019c30: 7365 5365 7269 6573 2c20 436f 6c6f 7265  seSeries, Colore
+00019c40: 6453 7973 7465 6d52 6573 706f 6e73 6553  dSystemResponseS
+00019c50: 6572 6965 730a 2020 2020 5d3a 0a20 2020  eries.    ]:.   
+00019c60: 2020 2020 2069 6620 226e 2220 696e 206b       if "n" in k
+00019c70: 7761 7267 732e 6b65 7973 2829 3a0a 2020  wargs.keys():.  
+00019c80: 2020 2020 2020 2020 2020 6b77 6172 6773            kwargs
+00019c90: 5b22 6e31 225d 203d 206b 7761 7267 735b  ["n1"] = kwargs[
+00019ca0: 226e 225d 0a20 2020 2020 2020 2020 2020  "n"].           
+00019cb0: 2069 6620 6861 7361 7474 7228 6b77 6172   if hasattr(kwar
+00019cc0: 6773 5b22 6e22 5d2c 2022 5f5f 6974 6572  gs["n"], "__iter
+00019cd0: 5f5f 2229 2061 6e64 2028 6c65 6e28 6b77  __") and (len(kw
+00019ce0: 6172 6773 5b22 6e22 5d29 203e 2030 293a  args["n"]) > 0):
+00019cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019d00: 206b 7761 7267 735b 226e 3122 5d20 3d20   kwargs["n1"] = 
+00019d10: 6b77 6172 6773 5b22 6e22 5d5b 305d 0a20  kwargs["n"][0]. 
+00019d20: 2020 2065 6c69 6620 7074 2069 6e20 5b0a     elif pt in [.
+00019d30: 2020 2020 2020 2020 5375 7266 6163 654f          SurfaceO
+00019d40: 7665 7232 4452 616e 6765 5365 7269 6573  ver2DRangeSeries
+00019d50: 2c20 436f 6e74 6f75 7253 6572 6965 732c  , ContourSeries,
+00019d60: 2050 6172 616d 6574 7269 6353 7572 6661   ParametricSurfa
+00019d70: 6365 5365 7269 6573 2c0a 2020 2020 2020  ceSeries,.      
+00019d80: 2020 436f 6d70 6c65 7853 7572 6661 6365    ComplexSurface
+00019d90: 5365 7269 6573 2c20 436f 6d70 6c65 7844  Series, ComplexD
+00019da0: 6f6d 6169 6e43 6f6c 6f72 696e 6753 6572  omainColoringSer
+00019db0: 6965 732c 0a20 2020 2020 2020 2056 6563  ies,.        Vec
+00019dc0: 746f 7232 4453 6572 6965 732c 2049 6d70  tor2DSeries, Imp
+00019dd0: 6c69 6369 7453 6572 6965 732c 2052 6965  licitSeries, Rie
+00019de0: 6d61 6e6e 5370 6865 7265 5365 7269 6573  mannSphereSeries
+00019df0: 0a20 2020 205d 3a0a 2020 2020 2020 2020  .    ]:.        
+00019e00: 6966 2022 6e22 2069 6e20 6b77 6172 6773  if "n" in kwargs
+00019e10: 2e6b 6579 7328 293a 0a20 2020 2020 2020  .keys():.       
+00019e20: 2020 2020 2069 6620 6861 7361 7474 7228       if hasattr(
+00019e30: 6b77 6172 6773 5b22 6e22 5d2c 2022 5f5f  kwargs["n"], "__
+00019e40: 6974 6572 5f5f 2229 2061 6e64 2028 6c65  iter__") and (le
+00019e50: 6e28 6b77 6172 6773 5b22 6e22 5d29 203e  n(kwargs["n"]) >
+00019e60: 2031 293a 0a20 2020 2020 2020 2020 2020   1):.           
+00019e70: 2020 2020 206b 7761 7267 735b 226e 3122       kwargs["n1"
+00019e80: 5d20 3d20 6b77 6172 6773 5b22 6e22 5d5b  ] = kwargs["n"][
+00019e90: 305d 0a20 2020 2020 2020 2020 2020 2020  0].             
+00019ea0: 2020 206b 7761 7267 735b 226e 3222 5d20     kwargs["n2"] 
+00019eb0: 3d20 6b77 6172 6773 5b22 6e22 5d5b 315d  = kwargs["n"][1]
+00019ec0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+00019ed0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00019ee0: 2020 206b 7761 7267 735b 226e 3122 5d20     kwargs["n1"] 
+00019ef0: 3d20 6b77 6172 6773 5b22 6e32 225d 203d  = kwargs["n2"] =
+00019f00: 206b 7761 7267 735b 226e 225d 0a20 2020   kwargs["n"].   
+00019f10: 2065 6c69 6620 7074 2069 6e20 5b0a 2020   elif pt in [.  
+00019f20: 2020 2020 2020 5665 6374 6f72 3344 5365        Vector3DSe
+00019f30: 7269 6573 2c20 536c 6963 6556 6563 746f  ries, SliceVecto
+00019f40: 7233 4453 6572 6965 732c 2049 6d70 6c69  r3DSeries, Impli
+00019f50: 6369 7433 4453 6572 6965 732c 2050 6c61  cit3DSeries, Pla
+00019f60: 6e65 5365 7269 6573 0a20 2020 205d 3a0a  neSeries.    ]:.
+00019f70: 2020 2020 2020 2020 6966 2022 6e22 2069          if "n" i
+00019f80: 6e20 6b77 6172 6773 2e6b 6579 7328 293a  n kwargs.keys():
+00019f90: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00019fa0: 6861 7361 7474 7228 6b77 6172 6773 5b22  hasattr(kwargs["
+00019fb0: 6e22 5d2c 2022 5f5f 6974 6572 5f5f 2229  n"], "__iter__")
+00019fc0: 2061 6e64 2028 6c65 6e28 6b77 6172 6773   and (len(kwargs
+00019fd0: 5b22 6e22 5d29 203e 2032 293a 0a20 2020  ["n"]) > 2):.   
+00019fe0: 2020 2020 2020 2020 2020 2020 206b 7761               kwa
+00019ff0: 7267 735b 226e 3122 5d20 3d20 6b77 6172  rgs["n1"] = kwar
+0001a000: 6773 5b22 6e22 5d5b 305d 0a20 2020 2020  gs["n"][0].     
+0001a010: 2020 2020 2020 2020 2020 206b 7761 7267             kwarg
+0001a020: 735b 226e 3222 5d20 3d20 6b77 6172 6773  s["n2"] = kwargs
+0001a030: 5b22 6e22 5d5b 315d 0a20 2020 2020 2020  ["n"][1].       
+0001a040: 2020 2020 2020 2020 206b 7761 7267 735b           kwargs[
+0001a050: 226e 3322 5d20 3d20 6b77 6172 6773 5b22  "n3"] = kwargs["
+0001a060: 6e22 5d5b 325d 0a20 2020 2020 2020 2020  n"][2].         
+0001a070: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001a080: 2020 2020 2020 2020 206b 7761 7267 735b           kwargs[
+0001a090: 226e 3122 5d20 3d20 6b77 6172 6773 5b22  "n1"] = kwargs["
+0001a0a0: 6e32 225d 203d 206b 7761 7267 735b 226e  n2"] = kwargs["n
+0001a0b0: 3322 5d20 3d20 6b77 6172 6773 5b22 6e22  3"] = kwargs["n"
+0001a0c0: 5d0a 2020 2020 7265 7475 726e 206b 7761  ].    return kwa
+0001a0d0: 7267 730a 0a0a 636c 6173 7320 5665 6374  rgs...class Vect
+0001a0e0: 6f72 4261 7365 2843 6f6d 6d6f 6e55 6e69  orBase(CommonUni
+0001a0f0: 666f 726d 4576 616c 7561 7469 6f6e 2c20  formEvaluation, 
+0001a100: 4261 7365 5365 7269 6573 293a 0a20 2020  BaseSeries):.   
+0001a110: 2022 2222 5265 7072 6573 656e 7420 6120   """Represent a 
+0001a120: 7665 6374 6f72 2066 6965 6c64 2e22 2222  vector field."""
+0001a130: 0a0a 2020 2020 6973 5f76 6563 746f 7220  ..    is_vector 
+0001a140: 3d20 5472 7565 0a20 2020 2069 735f 736c  = True.    is_sl
+0001a150: 6963 6520 3d20 4661 6c73 650a 2020 2020  ice = False.    
+0001a160: 6973 5f73 7472 6561 6d6c 696e 6573 203d  is_streamlines =
+0001a170: 2046 616c 7365 0a20 2020 205f 616c 6c6f   False.    _allo
+0001a180: 7765 645f 6b65 7973 203d 205b 0a20 2020  wed_keys = [.   
+0001a190: 2020 2020 2022 7374 7265 616d 6c69 6e65       "streamline
+0001a1a0: 7322 2c20 2271 7569 7665 725f 6b77 222c  s", "quiver_kw",
+0001a1b0: 2022 7374 7265 616d 5f6b 7722 2c20 226e   "stream_kw", "n
+0001a1c0: 6f72 6d61 6c69 7a65 225d 0a0a 2020 2020  ormalize"]..    
+0001a1d0: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
+0001a1e0: 662c 2065 7870 7273 2c20 7261 6e67 6573  f, exprs, ranges
+0001a1f0: 2c20 6c61 6265 6c2c 202a 2a6b 7761 7267  , label, **kwarg
+0001a200: 7329 3a0a 2020 2020 2020 2020 7375 7065  s):.        supe
+0001a210: 7228 292e 5f5f 696e 6974 5f5f 282a 2a6b  r().__init__(**k
+0001a220: 7761 7267 7329 0a20 2020 2020 2020 2073  wargs).        s
+0001a230: 656c 662e 6578 7072 203d 2074 7570 6c65  elf.expr = tuple
+0001a240: 285b 6520 6966 2063 616c 6c61 626c 6528  ([e if callable(
+0001a250: 6529 2065 6c73 6520 7379 6d70 6966 7928  e) else sympify(
+0001a260: 6529 2066 6f72 2065 2069 6e20 6578 7072  e) for e in expr
+0001a270: 735d 290a 2020 2020 2020 2020 7365 6c66  s]).        self
+0001a280: 2e72 616e 6765 7320 3d20 7261 6e67 6573  .ranges = ranges
+0001a290: 0a20 2020 2020 2020 2073 656c 662e 5f6c  .        self._l
+0001a2a0: 6162 656c 203d 2073 7472 2865 7870 7273  abel = str(exprs
+0001a2b0: 2920 6966 206c 6162 656c 2069 7320 4e6f  ) if label is No
+0001a2c0: 6e65 2065 6c73 6520 6c61 6265 6c0a 2020  ne else label.  
+0001a2d0: 2020 2020 2020 7365 6c66 2e5f 6c61 7465        self._late
+0001a2e0: 785f 6c61 6265 6c20 3d20 6c61 7465 7828  x_label = latex(
+0001a2f0: 6578 7072 7329 2069 6620 6c61 6265 6c20  exprs) if label 
+0001a300: 6973 204e 6f6e 6520 656c 7365 206c 6162  is None else lab
+0001a310: 656c 0a20 2020 2020 2020 2073 656c 662e  el.        self.
+0001a320: 6973 5f73 7472 6561 6d6c 696e 6573 203d  is_streamlines =
+0001a330: 206b 7761 7267 732e 6765 7428 2273 7472   kwargs.get("str
+0001a340: 6561 6d6c 696e 6573 222c 2046 616c 7365  eamlines", False
+0001a350: 290a 2020 2020 2020 2020 7365 6c66 2e75  ).        self.u
+0001a360: 7365 5f63 6d20 3d20 6b77 6172 6773 2e67  se_cm = kwargs.g
+0001a370: 6574 2822 7573 655f 636d 222c 2054 7275  et("use_cm", Tru
+0001a380: 6529 0a20 2020 2020 2020 2023 204e 4f54  e).        # NOT
+0001a390: 453a 206e 6f72 6d61 6c69 7a61 7469 6f6e  E: normalization
+0001a3a0: 2069 7320 6163 6869 6576 6564 2061 7420   is achieved at 
+0001a3b0: 7468 6520 6261 636b 656e 6420 7369 6465  the backend side
+0001a3c0: 3a20 7468 6973 2061 6c6c 6f77 7320 746f  : this allows to
+0001a3d0: 0a20 2020 2020 2020 2023 206f 6274 6169  .        # obtai
+0001a3e0: 6e20 7361 6d65 206c 656e 6774 6820 6172  n same length ar
+0001a3f0: 726f 7773 2c20 6275 7420 636f 6c6f 7265  rows, but colore
+0001a400: 6420 7769 7468 2074 6865 2061 6374 7561  d with the actua
+0001a410: 6c20 6d61 676e 6974 7564 652e 0a20 2020  l magnitude..   
+0001a420: 2020 2020 2023 2049 6620 6e6f 726d 616c       # If normal
+0001a430: 697a 6174 696f 6e20 6973 2061 7070 6c69  ization is appli
+0001a440: 6564 206f 6e20 7468 6520 7365 7269 6573  ed on the series
+0001a450: 2067 6574 5f64 6174 6128 292c 2074 6865   get_data(), the
+0001a460: 2063 6f6c 6f72 696e 670a 2020 2020 2020   coloring.      
+0001a470: 2020 2320 6279 206d 6167 6e69 7475 6465    # by magnitude
+0001a480: 2077 6f75 6c64 206e 6f74 2062 6520 6170   would not be ap
+0001a490: 706c 6963 6162 6c65 2061 7420 7468 6520  plicable at the 
+0001a4a0: 6261 636b 656e 642e 0a20 2020 2020 2020  backend..       
+0001a4b0: 2073 656c 662e 6e6f 726d 616c 697a 6520   self.normalize 
+0001a4c0: 3d20 6b77 6172 6773 2e67 6574 2822 6e6f  = kwargs.get("no
+0001a4d0: 726d 616c 697a 6522 2c20 4661 6c73 6529  rmalize", False)
+0001a4e0: 0a0a 2020 2020 2020 2020 2320 6966 2074  ..        # if t
+0001a4f0: 6865 2065 7870 7265 7373 696f 6e73 2061  he expressions a
+0001a500: 7265 206c 616d 6264 6120 6675 6e63 7469  re lambda functi
+0001a510: 6f6e 7320 616e 6420 6e6f 206c 6162 656c  ons and no label
+0001a520: 2068 6173 2062 6565 6e0a 2020 2020 2020   has been.      
+0001a530: 2020 2320 7072 6f76 6964 6564 2c20 7468    # provided, th
+0001a540: 656e 2069 7473 2062 6574 7465 7220 746f  en its better to
+0001a550: 2064 6f20 7468 6520 666f 6c6c 6f77 696e   do the followin
+0001a560: 6720 696e 206f 7264 6572 2074 6f20 6176  g in order to av
+0001a570: 6f69 640a 2020 2020 2020 2020 2320 7375  oid.        # su
+0001a580: 7072 6973 6573 206f 6e20 7468 6520 6261  prises on the ba
+0001a590: 636b 656e 640a 2020 2020 2020 2020 6966  ckend.        if
+0001a5a0: 2061 6e79 2863 616c 6c61 626c 6528 6529   any(callable(e)
+0001a5b0: 2066 6f72 2065 2069 6e20 7365 6c66 2e65   for e in self.e
+0001a5c0: 7870 7229 3a0a 2020 2020 2020 2020 2020  xpr):.          
+0001a5d0: 2020 6966 2073 656c 662e 5f6c 6162 656c    if self._label
+0001a5e0: 203d 3d20 7374 7228 7365 6c66 2e65 7870   == str(self.exp
+0001a5f0: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+0001a600: 2020 2020 7365 6c66 2e5f 6c61 6265 6c20      self._label 
+0001a610: 3d20 224d 6167 6e69 7475 6465 220a 0a20  = "Magnitude".. 
+0001a620: 2020 2020 2020 2023 204e 4f54 453a 2077         # NOTE: w
+0001a630: 6865 6e20 706c 6f74 7469 6e67 2076 6563  hen plotting vec
+0001a640: 746f 7220 6669 656c 6473 2069 7420 6d69  tor fields it mi
+0001a650: 6768 7420 6265 2075 7365 6675 6c20 746f  ght be useful to
+0001a660: 2072 6570 6561 7420 7468 650a 2020 2020   repeat the.    
+0001a670: 2020 2020 2320 706c 6f74 2063 6f6d 6d61      # plot comma
+0001a680: 6e64 2073 7769 7463 6869 6e67 2062 6574  nd switching bet
+0001a690: 7765 656e 2071 7569 7665 7273 2061 6e64  ween quivers and
+0001a6a0: 2073 7472 6561 6d6c 696e 6573 2e0a 2020   streamlines..  
+0001a6b0: 2020 2020 2020 2320 5573 7561 6c6c 792c        # Usually,
+0001a6c0: 2070 6c6f 7474 696e 6720 6c69 6272 6172   plotting librar
+0001a6d0: 6965 7320 6578 706f 7365 2064 6966 6665  ies expose diffe
+0001a6e0: 7265 6e74 2066 756e 6374 696f 6e73 2066  rent functions f
+0001a6f0: 6f72 2071 7569 7665 7273 0a20 2020 2020  or quivers.     
+0001a700: 2020 2023 2061 6e64 2073 7472 6561 6d6c     # and streaml
+0001a710: 696e 6573 2c20 6163 6365 7074 696e 6720  ines, accepting 
+0001a720: 6469 6666 6572 656e 7420 6b65 7977 6f72  different keywor
+0001a730: 6420 6172 6775 6d65 6e74 732e 0a20 2020  d arguments..   
+0001a740: 2020 2020 2023 2054 6865 2063 686f 6963       # The choic
+0001a750: 6520 746f 2069 6d70 6c65 6d65 6e74 2073  e to implement s
+0001a760: 6570 6172 6174 6573 2073 7472 6561 6d5f  eparates stream_
+0001a770: 6b77 2061 6e64 2071 7569 7665 725f 6b77  kw and quiver_kw
+0001a780: 2061 6c6c 6f77 730a 2020 2020 2020 2020   allows.        
+0001a790: 2320 7468 6973 2071 7569 636b 2073 7769  # this quick swi
+0001a7a0: 7463 682e 0a20 2020 2020 2020 2069 6620  tch..        if 
+0001a7b0: 7365 6c66 2e69 735f 7374 7265 616d 6c69  self.is_streamli
+0001a7c0: 6e65 733a 0a20 2020 2020 2020 2020 2020  nes:.           
+0001a7d0: 2073 656c 662e 7265 6e64 6572 696e 675f   self.rendering_
+0001a7e0: 6b77 203d 206b 7761 7267 732e 6765 7428  kw = kwargs.get(
+0001a7f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a800: 2022 7374 7265 616d 5f6b 7722 2c20 6b77   "stream_kw", kw
+0001a810: 6172 6773 2e67 6574 2822 7265 6e64 6572  args.get("render
+0001a820: 696e 675f 6b77 222c 2064 6963 7428 2929  ing_kw", dict())
+0001a830: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+0001a840: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001a850: 2e72 656e 6465 7269 6e67 5f6b 7720 3d20  .rendering_kw = 
+0001a860: 6b77 6172 6773 2e67 6574 280a 2020 2020  kwargs.get(.    
+0001a870: 2020 2020 2020 2020 2020 2020 2271 7569              "qui
+0001a880: 7665 725f 6b77 222c 206b 7761 7267 732e  ver_kw", kwargs.
+0001a890: 6765 7428 2272 656e 6465 7269 6e67 5f6b  get("rendering_k
+0001a8a0: 7722 2c20 6469 6374 2829 2929 0a20 2020  w", dict())).   
+0001a8b0: 2020 2020 2073 656c 662e 5f70 6f73 745f       self._post_
+0001a8c0: 696e 6974 2829 0a0a 2020 2020 6465 6620  init()..    def 
+0001a8d0: 6765 745f 6c61 6265 6c28 7365 6c66 2c20  get_label(self, 
+0001a8e0: 7573 655f 6c61 7465 783d 4661 6c73 652c  use_latex=False,
+0001a8f0: 2077 7261 7070 6572 3d22 2425 7324 2229   wrapper="$%s$")
+0001a900: 3a0a 2020 2020 2020 2020 6966 2075 7365  :.        if use
+0001a910: 5f6c 6174 6578 3a0a 2020 2020 2020 2020  _latex:.        
+0001a920: 2020 2020 6578 7072 203d 2073 656c 662e      expr = self.
+0001a930: 6578 7072 0a20 2020 2020 2020 2020 2020  expr.           
+0001a940: 2069 6620 7365 6c66 2e5f 6c61 6265 6c20   if self._label 
+0001a950: 213d 2073 7472 2865 7870 7229 3a0a 2020  != str(expr):.  
+0001a960: 2020 2020 2020 2020 2020 2020 2020 7265                re
+0001a970: 7475 726e 2073 656c 662e 5f6c 6174 6578  turn self._latex
+0001a980: 5f6c 6162 656c 0a20 2020 2020 2020 2020  _label.         
+0001a990: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+0001a9a0: 6765 745f 7772 6170 7065 645f 6c61 6265  get_wrapped_labe
+0001a9b0: 6c28 7365 6c66 2e5f 6c61 7465 785f 6c61  l(self._latex_la
+0001a9c0: 6265 6c2c 2077 7261 7070 6572 290a 2020  bel, wrapper).  
+0001a9d0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0001a9e0: 662e 5f6c 6162 656c 0a0a 2020 2020 6465  f._label..    de
+0001a9f0: 6620 6765 745f 6461 7461 2873 656c 6629  f get_data(self)
+0001aa00: 3a0a 2020 2020 2020 2020 2222 2252 6574  :.        """Ret
+0001aa10: 7572 6e20 6172 7261 7973 206f 6620 636f  urn arrays of co
+0001aa20: 6f72 6469 6e61 7465 7320 666f 7220 706c  ordinates for pl
+0001aa30: 6f74 7469 6e67 2e20 4465 7065 6e64 696e  otting. Dependin
+0001aa40: 6720 6f6e 2074 6865 0a20 2020 2020 2020  g on the.       
+0001aa50: 2060 6164 6170 7469 7665 6020 6f70 7469   `adaptive` opti
+0001aa60: 6f6e 2c20 7468 6973 2066 756e 6374 696f  on, this functio
+0001aa70: 6e20 7769 6c6c 2065 6974 6865 7220 7573  n will either us
+0001aa80: 6520 616e 2061 6461 7074 6976 6520 616c  e an adaptive al
+0001aa90: 676f 7269 7468 6d0a 2020 2020 2020 2020  gorithm.        
+0001aaa0: 6f72 2069 7420 7769 6c6c 2075 6e69 666f  or it will unifo
+0001aab0: 726d 6c79 2073 616d 706c 6520 7468 6520  rmly sample the 
+0001aac0: 6578 7072 6573 7369 6f6e 206f 7665 7220  expression over 
+0001aad0: 7468 6520 7072 6f76 6964 6564 2072 616e  the provided ran
+0001aae0: 6765 2e0a 0a20 2020 2020 2020 2052 6574  ge...        Ret
+0001aaf0: 7572 6e73 0a20 2020 2020 2020 203d 3d3d  urns.        ===
+0001ab00: 3d3d 3d3d 0a0a 2020 2020 2020 2020 6d65  ====..        me
+0001ab10: 7368 5f78 203a 206e 702e 6e64 6172 7261  sh_x : np.ndarra
+0001ab20: 7920 5b6e 3220 7820 6e31 5d0a 2020 2020  y [n2 x n1].    
+0001ab30: 2020 2020 2020 2020 4469 7363 7265 7469          Discreti
+0001ab40: 7a65 6420 782d 646f 6d61 696e 2e0a 0a20  zed x-domain... 
+0001ab50: 2020 2020 2020 206d 6573 685f 7920 3a20         mesh_y : 
+0001ab60: 6e70 2e6e 6461 7272 6179 205b 6e32 2078  np.ndarray [n2 x
+0001ab70: 206e 315d 0a20 2020 2020 2020 2020 2020   n1].           
+0001ab80: 2044 6973 6372 6574 697a 6564 2079 2d64   Discretized y-d
+0001ab90: 6f6d 6169 6e2e 0a0a 2020 2020 2020 2020  omain...        
+0001aba0: 6d65 7368 5f7a 203a 206e 702e 6e64 6172  mesh_z : np.ndar
+0001abb0: 7261 7920 5b6e 3220 7820 6e31 5d20 286f  ray [n2 x n1] (o
+0001abc0: 7074 696f 6e61 6c29 0a20 2020 2020 2020  ptional).       
+0001abd0: 2020 2020 2044 6973 6372 6574 697a 6564       Discretized
+0001abe0: 207a 2d64 6f6d 6169 6e20 696e 2074 6865   z-domain in the
+0001abf0: 2063 6173 6520 6f66 2056 6563 746f 7233   case of Vector3
+0001ac00: 4453 6572 6965 732e 0a0a 2020 2020 2020  DSeries...      
+0001ac10: 2020 7520 3a20 6e70 2e6e 6461 7272 6179    u : np.ndarray
+0001ac20: 205b 6e32 2078 206e 315d 0a20 2020 2020   [n2 x n1].     
+0001ac30: 2020 2020 2020 2046 6972 7374 2063 6f6d         First com
+0001ac40: 706f 6e65 6e74 206f 6620 7468 6520 7665  ponent of the ve
+0001ac50: 6374 6f72 2066 6965 6c64 2e0a 0a20 2020  ctor field...   
+0001ac60: 2020 2020 2076 203a 206e 702e 6e64 6172       v : np.ndar
+0001ac70: 7261 7920 5b6e 3220 7820 6e31 5d0a 2020  ray [n2 x n1].  
+0001ac80: 2020 2020 2020 2020 2020 5365 636f 6e64            Second
+0001ac90: 2063 6f6d 706f 6e65 6e74 206f 6620 7468   component of th
+0001aca0: 6520 7665 6374 6f72 2066 6965 6c64 2e0a  e vector field..
+0001acb0: 0a20 2020 2020 2020 2077 203a 206e 702e  .        w : np.
+0001acc0: 6e64 6172 7261 7920 5b6e 3220 7820 6e31  ndarray [n2 x n1
+0001acd0: 5d20 286f 7074 696f 6e61 6c29 0a20 2020  ] (optional).   
+0001ace0: 2020 2020 2020 2020 2054 6869 7264 2063           Third c
+0001acf0: 6f6d 706f 6e65 6e74 206f 6620 7468 6520  omponent of the 
+0001ad00: 7665 6374 6f72 2066 6965 6c64 2069 6e20  vector field in 
+0001ad10: 7468 6520 6361 7365 206f 6620 5665 6374  the case of Vect
+0001ad20: 6f72 3344 5365 7269 6573 2e0a 2020 2020  or3DSeries..    
+0001ad30: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0001ad40: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
+0001ad50: 6c65 2827 6e75 6d70 7927 290a 0a20 2020  le('numpy')..   
+0001ad60: 2020 2020 2072 6573 756c 7473 203d 2073       results = s
+0001ad70: 656c 662e 5f65 7661 6c75 6174 6528 290a  elf._evaluate().
+0001ad80: 2020 2020 2020 2020 666f 7220 692c 2072          for i, r
+0001ad90: 2069 6e20 656e 756d 6572 6174 6528 7265   in enumerate(re
+0001ada0: 7375 6c74 7329 3a0a 2020 2020 2020 2020  sults):.        
+0001adb0: 2020 2020 7265 5f76 2c20 696d 5f76 203d      re_v, im_v =
+0001adc0: 206e 702e 7265 616c 2872 292c 206e 702e   np.real(r), np.
+0001add0: 696d 6167 2872 290a 2020 2020 2020 2020  imag(r).        
+0001ade0: 2020 2020 7265 5f76 5b6e 702e 696e 7665      re_v[np.inve
+0001adf0: 7274 286e 702e 6973 636c 6f73 6528 696d  rt(np.isclose(im
+0001ae00: 5f76 2c20 6e70 2e7a 6572 6f73 5f6c 696b  _v, np.zeros_lik
+0001ae10: 6528 696d 5f76 2929 295d 203d 206e 702e  e(im_v)))] = np.
+0001ae20: 6e61 6e0a 2020 2020 2020 2020 2020 2020  nan.            
+0001ae30: 7265 7375 6c74 735b 695d 203d 2072 655f  results[i] = re_
+0001ae40: 760a 0a20 2020 2020 2020 2072 6574 7572  v..        retur
+0001ae50: 6e20 7365 6c66 2e5f 6170 706c 795f 7472  n self._apply_tr
+0001ae60: 616e 7366 6f72 6d28 2a72 6573 756c 7473  ansform(*results
+0001ae70: 290a 0a0a 636c 6173 7320 5665 6374 6f72  )...class Vector
+0001ae80: 3244 5365 7269 6573 2856 6563 746f 7242  2DSeries(VectorB
+0001ae90: 6173 6529 3a0a 2020 2020 2222 2252 6570  ase):.    """Rep
+0001aea0: 7265 7365 6e74 7320 6120 3244 2076 6563  resents a 2D vec
+0001aeb0: 746f 7220 6669 656c 642e 2222 220a 0a20  tor field.""".. 
+0001aec0: 2020 2069 735f 3244 7665 6374 6f72 203d     is_2Dvector =
+0001aed0: 2054 7275 650a 2020 2020 2320 6465 6661   True.    # defa
+0001aee0: 756c 7420 6e75 6d62 6572 206f 6620 6469  ult number of di
+0001aef0: 7363 7265 7469 7a61 7469 6f6e 2070 6f69  scretization poi
+0001af00: 6e74 730a 2020 2020 5f4e 203d 2032 350a  nts.    _N = 25.
+0001af10: 2020 2020 5f61 6c6c 6f77 6564 5f6b 6579      _allowed_key
+0001af20: 7320 3d20 5b22 7363 616c 6172 225d 0a0a  s = ["scalar"]..
+0001af30: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+0001af40: 2873 656c 662c 2075 2c20 762c 2072 616e  (self, u, v, ran
+0001af50: 6765 312c 2072 616e 6765 322c 206c 6162  ge1, range2, lab
+0001af60: 656c 3d22 222c 202a 2a6b 7761 7267 7329  el="", **kwargs)
+0001af70: 3a0a 2020 2020 2020 2020 7375 7065 7228  :.        super(
+0001af80: 292e 5f5f 696e 6974 5f5f 2828 752c 2076  ).__init__((u, v
+0001af90: 292c 2028 7261 6e67 6531 2c20 7261 6e67  ), (range1, rang
+0001afa0: 6532 292c 206c 6162 656c 2c20 2a2a 6b77  e2), label, **kw
+0001afb0: 6172 6773 290a 2020 2020 2020 2020 6966  args).        if
+0001afc0: 2022 7363 616c 6172 2220 6e6f 7420 696e   "scalar" not in
+0001afd0: 206b 7761 7267 732e 6b65 7973 2829 3a0a   kwargs.keys():.
+0001afe0: 2020 2020 2020 2020 2020 2020 7573 655f              use_
+0001aff0: 636d 203d 2046 616c 7365 0a20 2020 2020  cm = False.     
+0001b000: 2020 2065 6c69 6620 286e 6f74 206b 7761     elif (not kwa
+0001b010: 7267 735b 2273 6361 6c61 7222 5d29 206f  rgs["scalar"]) o
+0001b020: 7220 286b 7761 7267 735b 2273 6361 6c61  r (kwargs["scala
+0001b030: 7222 5d20 6973 204e 6f6e 6529 3a0a 2020  r"] is None):.  
+0001b040: 2020 2020 2020 2020 2020 7573 655f 636d            use_cm
+0001b050: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
+0001b060: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001b070: 2020 7573 655f 636d 203d 2046 616c 7365    use_cm = False
+0001b080: 0a20 2020 2020 2020 2073 656c 662e 7573  .        self.us
+0001b090: 655f 636d 203d 206b 7761 7267 732e 6765  e_cm = kwargs.ge
+0001b0a0: 7428 2275 7365 5f63 6d22 2c20 7573 655f  t("use_cm", use_
+0001b0b0: 636d 290a 0a20 2020 2064 6566 205f 5f73  cm)..    def __s
+0001b0c0: 7472 5f5f 2873 656c 6629 3a0a 2020 2020  tr__(self):.    
+0001b0d0: 2020 2020 7261 6e67 6573 203d 205b 5d0a      ranges = [].
+0001b0e0: 2020 2020 2020 2020 6620 3d20 6c61 6d62          f = lamb
+0001b0f0: 6461 2074 3a20 7420 6966 206c 656e 2874  da t: t if len(t
+0001b100: 2e66 7265 655f 7379 6d62 6f6c 7329 203e  .free_symbols) >
+0001b110: 2030 2065 6c73 6520 666c 6f61 7428 7429   0 else float(t)
+0001b120: 0a20 2020 2020 2020 2066 6f72 2072 2069  .        for r i
+0001b130: 6e20 7365 6c66 2e72 616e 6765 733a 0a20  n self.ranges:. 
+0001b140: 2020 2020 2020 2020 2020 2072 616e 6765             range
+0001b150: 732e 6170 7065 6e64 2828 725b 305d 2c20  s.append((r[0], 
+0001b160: 6628 725b 315d 292c 2066 2872 5b32 5d29  f(r[1]), f(r[2])
+0001b170: 2929 0a20 2020 2020 2020 2072 6574 7572  )).        retur
+0001b180: 6e20 7365 6c66 2e5f 7374 725f 6865 6c70  n self._str_help
+0001b190: 6572 280a 2020 2020 2020 2020 2020 2020  er(.            
+0001b1a0: 2232 4420 7665 6374 6f72 2073 6572 6965  "2D vector serie
+0001b1b0: 733a 205b 2573 2c20 2573 5d20 6f76 6572  s: [%s, %s] over
+0001b1c0: 2025 732c 2025 7322 2025 2028 0a20 2020   %s, %s" % (.   
+0001b1d0: 2020 2020 2020 2020 2020 2020 202a 7365               *se
+0001b1e0: 6c66 2e65 7870 722c 202a 7261 6e67 6573  lf.expr, *ranges
+0001b1f0: 2929 0a0a 0a63 6c61 7373 2056 6563 746f  ))...class Vecto
+0001b200: 7233 4453 6572 6965 7328 5665 6374 6f72  r3DSeries(Vector
+0001b210: 4261 7365 293a 0a20 2020 2022 2222 5265  Base):.    """Re
+0001b220: 7072 6573 656e 7473 2061 2033 4420 7665  presents a 3D ve
+0001b230: 6374 6f72 2066 6965 6c64 2e22 2222 0a0a  ctor field."""..
+0001b240: 2020 2020 6973 5f33 4420 3d20 5472 7565      is_3D = True
+0001b250: 0a20 2020 2069 735f 3344 7665 6374 6f72  .    is_3Dvector
+0001b260: 203d 2054 7275 650a 2020 2020 2320 6465   = True.    # de
+0001b270: 6661 756c 7420 6e75 6d62 6572 206f 6620  fault number of 
+0001b280: 6469 7363 7265 7469 7a61 7469 6f6e 2070  discretization p
+0001b290: 6f69 6e74 730a 2020 2020 5f4e 203d 2031  oints.    _N = 1
+0001b2a0: 300a 0a20 2020 2064 6566 205f 5f69 6e69  0..    def __ini
+0001b2b0: 745f 5f28 7365 6c66 2c20 752c 2076 2c20  t__(self, u, v, 
+0001b2c0: 7a2c 2072 616e 6765 312c 2072 616e 6765  z, range1, range
+0001b2d0: 322c 2072 616e 6765 332c 206c 6162 656c  2, range3, label
+0001b2e0: 3d22 222c 202a 2a6b 7761 7267 7329 3a0a  ="", **kwargs):.
+0001b2f0: 2020 2020 2020 2020 7375 7065 7228 292e          super().
+0001b300: 5f5f 696e 6974 5f5f 2828 752c 2076 2c20  __init__((u, v, 
+0001b310: 7a29 2c20 2872 616e 6765 312c 2072 616e  z), (range1, ran
+0001b320: 6765 322c 2072 616e 6765 3329 2c20 6c61  ge2, range3), la
+0001b330: 6265 6c2c 202a 2a6b 7761 7267 7329 0a20  bel, **kwargs). 
+0001b340: 2020 2020 2020 2069 6620 7365 6c66 2e69         if self.i
+0001b350: 735f 7374 7265 616d 6c69 6e65 7320 616e  s_streamlines an
+0001b360: 6420 6973 696e 7374 616e 6365 2873 656c  d isinstance(sel
+0001b370: 662e 636f 6c6f 725f 6675 6e63 2c20 4578  f.color_func, Ex
+0001b380: 7072 293a 0a20 2020 2020 2020 2020 2020  pr):.           
+0001b390: 2072 6169 7365 2054 7970 6545 7272 6f72   raise TypeError
+0001b3a0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0001b3b0: 2020 2256 6563 746f 7233 4453 6572 6965    "Vector3DSerie
+0001b3c0: 7320 7769 7468 2073 7472 6561 6d6c 696e  s with streamlin
+0001b3d0: 6573 2063 616e 2774 2075 7365 2022 0a20  es can't use ". 
+0001b3e0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0001b3f0: 7379 6d62 6f6c 6963 2060 636f 6c6f 725f  symbolic `color_
+0001b400: 6675 6e63 602e 2229 0a0a 2020 2020 6465  func`.")..    de
+0001b410: 6620 5f5f 7374 725f 5f28 7365 6c66 293a  f __str__(self):
+0001b420: 0a20 2020 2020 2020 2072 616e 6765 7320  .        ranges 
+0001b430: 3d20 5b5d 0a20 2020 2020 2020 2066 6f72  = [].        for
+0001b440: 2072 2069 6e20 7365 6c66 2e72 616e 6765   r in self.range
+0001b450: 733a 0a20 2020 2020 2020 2020 2020 2072  s:.            r
+0001b460: 616e 6765 732e 6170 7065 6e64 2828 725b  anges.append((r[
+0001b470: 305d 2c20 666c 6f61 7428 725b 315d 292c  0], float(r[1]),
+0001b480: 2066 6c6f 6174 2872 5b32 5d29 2929 0a20   float(r[2]))). 
+0001b490: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0001b4a0: 6c66 2e5f 7374 725f 6865 6c70 6572 280a  lf._str_helper(.
+0001b4b0: 2020 2020 2020 2020 2020 2020 2233 4420              "3D 
+0001b4c0: 7665 6374 6f72 2073 6572 6965 733a 205b  vector series: [
+0001b4d0: 2573 2c20 2573 2c20 2573 5d20 6f76 6572  %s, %s, %s] over
+0001b4e0: 2025 732c 2025 732c 2025 7322 2025 2028   %s, %s, %s" % (
+0001b4f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001b500: 202a 7365 6c66 2e65 7870 722c 202a 7261   *self.expr, *ra
+0001b510: 6e67 6573 2929 0a0a 0a64 6566 205f 6275  nges))...def _bu
+0001b520: 696c 645f 736c 6963 655f 7365 7269 6573  ild_slice_series
+0001b530: 2873 6c69 6365 5f73 7572 662c 2072 616e  (slice_surf, ran
+0001b540: 6765 732c 202a 2a6b 7761 7267 7329 3a0a  ges, **kwargs):.
+0001b550: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+0001b560: 6528 736c 6963 655f 7375 7266 2c20 506c  e(slice_surf, Pl
+0001b570: 616e 6529 3a0a 2020 2020 2020 2020 7265  ane):.        re
+0001b580: 7475 726e 2050 6c61 6e65 5365 7269 6573  turn PlaneSeries
+0001b590: 2873 796d 7069 6679 2873 6c69 6365 5f73  (sympify(slice_s
+0001b5a0: 7572 6629 2c20 2a72 616e 6765 732c 202a  urf), *ranges, *
+0001b5b0: 2a6b 7761 7267 7329 0a20 2020 2065 6c69  *kwargs).    eli
+0001b5c0: 6620 6973 696e 7374 616e 6365 2873 6c69  f isinstance(sli
+0001b5d0: 6365 5f73 7572 662c 2042 6173 6553 6572  ce_surf, BaseSer
+0001b5e0: 6965 7329 3a0a 2020 2020 2020 2020 6966  ies):.        if
+0001b5f0: 2073 6c69 6365 5f73 7572 662e 6973 5f33   slice_surf.is_3
+0001b600: 4473 7572 6661 6365 3a0a 2020 2020 2020  Dsurface:.      
+0001b610: 2020 2020 2020 7265 7475 726e 2073 6c69        return sli
+0001b620: 6365 5f73 7572 660a 2020 2020 2020 2020  ce_surf.        
+0001b630: 7261 6973 6520 5479 7065 4572 726f 7228  raise TypeError(
+0001b640: 224f 6e6c 7920 3344 2073 7572 6661 6365  "Only 3D surface
+0001b650: 2d72 656c 6174 6564 2073 6572 6965 7320  -related series 
+0001b660: 6172 6520 7375 7070 6f72 7465 642e 2229  are supported.")
+0001b670: 0a0a 2020 2020 2320 4966 2074 6865 2076  ..    # If the v
+0001b680: 6563 746f 7220 6669 656c 6420 6973 2056  ector field is V
+0001b690: 2878 2c20 792c 207a 292c 2074 6865 2073  (x, y, z), the s
+0001b6a0: 6c69 6365 2065 7870 7265 7373 696f 6e20  lice expression 
+0001b6b0: 6361 6e20 6265 2066 2878 2c20 7929 0a20  can be f(x, y). 
+0001b6c0: 2020 2023 206f 7220 6628 792c 207a 2920     # or f(y, z) 
+0001b6d0: 6f72 2066 2878 2c20 7a29 2e20 4578 7472  or f(x, z). Extr
+0001b6e0: 6163 7420 7468 6520 636f 7272 6563 7420  act the correct 
+0001b6f0: 7261 6e67 6573 2e0a 2020 2020 6673 203d  ranges..    fs =
+0001b700: 2073 6c69 6365 5f73 7572 662e 6672 6565   slice_surf.free
+0001b710: 5f73 796d 626f 6c73 0a20 2020 206e 6577  _symbols.    new
+0001b720: 5f72 616e 6765 7320 3d20 5b72 2066 6f72  _ranges = [r for
+0001b730: 2072 2069 6e20 7261 6e67 6573 2069 6620   r in ranges if 
+0001b740: 725b 305d 2069 6e20 6673 5d0a 2020 2020  r[0] in fs].    
+0001b750: 2320 6170 706c 7920 7468 6520 636f 7272  # apply the corr
+0001b760: 6563 7420 6469 7363 7265 7469 7a61 7469  ect discretizati
+0001b770: 6f6e 206e 756d 6265 720a 2020 2020 6e20  on number.    n 
+0001b780: 3d20 5b0a 2020 2020 2020 2020 696e 7428  = [.        int(
+0001b790: 6b77 6172 6773 2e67 6574 2822 6e31 222c  kwargs.get("n1",
+0001b7a0: 2056 6563 746f 7233 4453 6572 6965 732e   Vector3DSeries.
+0001b7b0: 5f4e 2929 2c0a 2020 2020 2020 2020 696e  _N)),.        in
+0001b7c0: 7428 6b77 6172 6773 2e67 6574 2822 6e32  t(kwargs.get("n2
+0001b7d0: 222c 2056 6563 746f 7233 4453 6572 6965  ", Vector3DSerie
+0001b7e0: 732e 5f4e 2929 2c0a 2020 2020 2020 2020  s._N)),.        
+0001b7f0: 696e 7428 6b77 6172 6773 2e67 6574 2822  int(kwargs.get("
+0001b800: 6e33 222c 2056 6563 746f 7233 4453 6572  n3", Vector3DSer
+0001b810: 6965 732e 5f4e 2929 5d0a 2020 2020 6469  ies._N))].    di
+0001b820: 7363 725f 7379 6d62 6f6c 7320 3d20 5b72  scr_symbols = [r
+0001b830: 5b30 5d20 666f 7220 7220 696e 2072 616e  [0] for r in ran
+0001b840: 6765 735d 0a20 2020 2069 6478 203d 205b  ges].    idx = [
+0001b850: 6469 7363 725f 7379 6d62 6f6c 732e 696e  discr_symbols.in
+0001b860: 6465 7828 7329 2066 6f72 2073 2069 6e20  dex(s) for s in 
+0001b870: 5b72 5b30 5d20 666f 7220 7220 696e 206e  [r[0] for r in n
+0001b880: 6577 5f72 616e 6765 735d 5d0a 2020 2020  ew_ranges]].    
+0001b890: 6b77 6172 6773 3220 3d20 6b77 6172 6773  kwargs2 = kwargs
+0001b8a0: 2e63 6f70 7928 290a 2020 2020 6b77 6172  .copy().    kwar
+0001b8b0: 6773 325b 226e 3122 5d20 3d20 6e5b 6964  gs2["n1"] = n[id
+0001b8c0: 785b 305d 5d0a 2020 2020 6b77 6172 6773  x[0]].    kwargs
+0001b8d0: 325b 226e 3222 5d20 3d20 6e5b 6964 785b  2["n2"] = n[idx[
+0001b8e0: 315d 5d0a 0a20 2020 2072 6574 7572 6e20  1]]..    return 
+0001b8f0: 5375 7266 6163 654f 7665 7232 4452 616e  SurfaceOver2DRan
+0001b900: 6765 5365 7269 6573 2873 6c69 6365 5f73  geSeries(slice_s
+0001b910: 7572 662c 202a 6e65 775f 7261 6e67 6573  urf, *new_ranges
+0001b920: 2c20 2a2a 6b77 6172 6773 3229 0a0a 0a63  , **kwargs2)...c
+0001b930: 6c61 7373 2053 6c69 6365 5665 6374 6f72  lass SliceVector
+0001b940: 3344 5365 7269 6573 2856 6563 746f 7233  3DSeries(Vector3
+0001b950: 4453 6572 6965 7329 3a0a 2020 2020 2222  DSeries):.    ""
+0001b960: 2252 6570 7265 7365 6e74 7320 6120 3344  "Represents a 3D
+0001b970: 2076 6563 746f 7220 6669 656c 6420 706c   vector field pl
+0001b980: 6f74 7465 6420 6f76 6572 2061 2073 6c69  otted over a sli
+0001b990: 6365 2e20 5468 6520 736c 6963 6520 6361  ce. The slice ca
+0001b9a0: 6e20 6265 0a20 2020 2061 2050 6c61 6e65  n be.    a Plane
+0001b9b0: 206f 7220 6120 7375 7266 6163 652e 0a20   or a surface.. 
+0001b9c0: 2020 2022 2222 0a20 2020 2069 735f 736c     """.    is_sl
+0001b9d0: 6963 6520 3d20 5472 7565 0a0a 2020 2020  ice = True..    
+0001b9e0: 6465 6620 5f5f 696e 6974 5f5f 280a 2020  def __init__(.  
+0001b9f0: 2020 2020 2020 7365 6c66 2c20 736c 6963        self, slic
+0001ba00: 655f 7375 7266 2c20 752c 2076 2c20 772c  e_surf, u, v, w,
+0001ba10: 2072 616e 6765 5f78 2c20 7261 6e67 655f   range_x, range_
+0001ba20: 792c 2072 616e 6765 5f7a 2c0a 2020 2020  y, range_z,.    
+0001ba30: 2020 2020 6c61 6265 6c3d 2222 2c20 2a2a      label="", **
+0001ba40: 6b77 6172 6773 0a20 2020 2029 3a0a 2020  kwargs.    ):.  
+0001ba50: 2020 2020 2020 7365 6c66 2e73 6c69 6365        self.slice
+0001ba60: 5f73 7572 665f 7365 7269 6573 203d 205f  _surf_series = _
+0001ba70: 6275 696c 645f 736c 6963 655f 7365 7269  build_slice_seri
+0001ba80: 6573 280a 2020 2020 2020 2020 2020 2020  es(.            
+0001ba90: 736c 6963 655f 7375 7266 2c20 5b72 616e  slice_surf, [ran
+0001baa0: 6765 5f78 2c20 7261 6e67 655f 792c 2072  ge_x, range_y, r
+0001bab0: 616e 6765 5f7a 5d2c 202a 2a6b 7761 7267  ange_z], **kwarg
+0001bac0: 7329 0a20 2020 2020 2020 2073 7570 6572  s).        super
+0001bad0: 2829 2e5f 5f69 6e69 745f 5f28 752c 2076  ().__init__(u, v
+0001bae0: 2c20 772c 2072 616e 6765 5f78 2c20 7261  , w, range_x, ra
+0001baf0: 6e67 655f 792c 2072 616e 6765 5f7a 2c20  nge_y, range_z, 
+0001bb00: 6c61 6265 6c2c 202a 2a6b 7761 7267 7329  label, **kwargs)
+0001bb10: 0a0a 2020 2020 6465 6620 5f64 6973 6372  ..    def _discr
+0001bb20: 6574 697a 6528 7365 6c66 293a 0a20 2020  etize(self):.   
+0001bb30: 2020 2020 2064 6174 6120 3d20 7365 6c66       data = self
+0001bb40: 2e73 6c69 6365 5f73 7572 665f 7365 7269  .slice_surf_seri
+0001bb50: 6573 2e67 6574 5f64 6174 6128 290a 2020  es.get_data().  
+0001bb60: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+0001bb70: 6e63 6528 7365 6c66 2e73 6c69 6365 5f73  nce(self.slice_s
+0001bb80: 7572 665f 7365 7269 6573 2c20 506c 616e  urf_series, Plan
+0001bb90: 6553 6572 6965 7329 3a0a 2020 2020 2020  eSeries):.      
+0001bba0: 2020 2020 2020 7265 7475 726e 2064 6174        return dat
+0001bbb0: 610a 2020 2020 2020 2020 6966 2073 656c  a.        if sel
+0001bbc0: 662e 736c 6963 655f 7375 7266 5f73 6572  f.slice_surf_ser
+0001bbd0: 6965 732e 6973 5f70 6172 616d 6574 7269  ies.is_parametri
+0001bbe0: 633a 0a20 2020 2020 2020 2020 2020 2072  c:.            r
+0001bbf0: 6574 7572 6e20 6461 7461 5b3a 335d 0a0a  eturn data[:3]..
+0001bc00: 2020 2020 2020 2020 2320 7379 6d62 6f6c          # symbol
+0001bc10: 7320 7573 6564 2062 7920 7468 6973 2076  s used by this v
+0001bc20: 6563 746f 7227 7320 6469 7363 7265 7469  ector's discreti
+0001bc30: 7a61 7469 6f6e 0a20 2020 2020 2020 2064  zation.        d
+0001bc40: 6973 6372 5f73 796d 626f 6c73 203d 205b  iscr_symbols = [
+0001bc50: 725b 305d 2066 6f72 2072 2069 6e20 7365  r[0] for r in se
+0001bc60: 6c66 2e72 616e 6765 735d 0a20 2020 2020  lf.ranges].     
+0001bc70: 2020 2023 206f 7264 6572 6564 2073 796d     # ordered sym
+0001bc80: 626f 6c73 2066 726f 6d20 736c 6963 655f  bols from slice_
+0001bc90: 7375 7266 5f73 6572 6965 730a 2020 2020  surf_series.    
+0001bca0: 2020 2020 6f72 6465 7220 3d20 7365 6c66      order = self
+0001bcb0: 2e5f 6469 7363 7265 7469 7a65 5f68 656c  ._discretize_hel
+0001bcc0: 7065 7228 6469 7363 725f 7379 6d62 6f6c  per(discr_symbol
+0001bcd0: 7329 0a20 2020 2020 2020 2072 6574 7572  s).        retur
+0001bce0: 6e20 5b64 6174 615b 6b5d 2066 6f72 206b  n [data[k] for k
+0001bcf0: 2069 6e20 6f72 6465 725d 0a0a 2020 2020   in order]..    
+0001bd00: 6465 6620 5f64 6973 6372 6574 697a 655f  def _discretize_
+0001bd10: 6865 6c70 6572 2873 656c 662c 2076 6563  helper(self, vec
+0001bd20: 5f64 6973 6372 5f73 796d 626f 6c73 293a  _discr_symbols):
+0001bd30: 0a20 2020 2020 2020 2023 204e 4f54 453a  .        # NOTE:
+0001bd40: 206c 6574 2773 2073 6179 2074 6865 2076   let's say the v
+0001bd50: 6563 746f 7220 6669 656c 6420 6973 2064  ector field is d
+0001bd60: 6973 6372 6574 697a 6564 2061 6c6f 6e67  iscretized along
+0001bd70: 2078 2c20 792c 207a 2028 696e 0a20 2020   x, y, z (in.   
+0001bd80: 2020 2020 2023 2074 6869 7320 6f72 6465       # this orde
+0001bd90: 7229 2c20 616e 6420 7468 6520 736c 6963  r), and the slic
+0001bda0: 6520 7375 7266 6163 6520 6973 2066 2879  e surface is f(y
+0001bdb0: 2c20 7a29 2e20 5468 656e 2c20 6461 7461  , z). Then, data
+0001bdc0: 2077 696c 6c20 6265 0a20 2020 2020 2020   will be.       
+0001bdd0: 2023 205b 7979 2c20 7a7a 2c20 6628 7979   # [yy, zz, f(yy
+0001bde0: 2c20 7a7a 295d 2c20 7768 6963 6820 6861  , zz)], which ha
+0001bdf0: 7320 6e6f 7420 7468 6520 636f 7272 6563  s not the correc
+0001be00: 7420 6f72 6465 7220 6578 7065 6374 6564  t order expected
+0001be10: 2062 790a 2020 2020 2020 2020 2320 7468   by.        # th
+0001be20: 6520 7665 6374 6f72 2066 6965 6c64 2773  e vector field's
+0001be30: 2064 6973 6372 6574 697a 6174 696f 6e2e   discretization.
+0001be40: 2048 6572 6520 7765 2061 7265 2067 6f69   Here we are goi
+0001be50: 6e67 2074 6f20 6669 7820 7468 6174 2e0a  ng to fix that..
+0001be60: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
+0001be70: 6973 696e 7374 616e 6365 2873 656c 662e  isinstance(self.
+0001be80: 736c 6963 655f 7375 7266 5f73 6572 6965  slice_surf_serie
+0001be90: 732c 2053 7572 6661 6365 4f76 6572 3244  s, SurfaceOver2D
+0001bea0: 5261 6e67 6553 6572 6965 7329 3a0a 2020  RangeSeries):.  
+0001beb0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+0001bec0: 5479 7065 4572 726f 7228 2254 6869 7320  TypeError("This 
+0001bed0: 6865 6c70 6572 2066 756e 6374 696f 6e20  helper function 
+0001bee0: 6973 206d 6561 6e74 2074 6f20 6265 2075  is meant to be u
+0001bef0: 7365 6420 6f6e 6c79 2022 0a20 2020 2020  sed only ".     
+0001bf00: 2020 2020 2020 2020 2020 2022 7769 7468             "with
+0001bf10: 206e 6f6e 2d70 6172 616d 6574 7269 6320   non-parametric 
+0001bf20: 736c 6963 696e 6720 7375 7266 6163 6573  slicing surfaces
+0001bf30: 206f 6620 3220 7661 7269 6162 6c65 732e   of 2 variables.
+0001bf40: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
+0001bf50: 2020 2022 7479 7065 2873 656c 662e 736c     "type(self.sl
+0001bf60: 6963 655f 7375 7266 5f73 6572 6965 7329  ice_surf_series)
+0001bf70: 203d 207b 7d22 2e66 6f72 6d61 7428 0a20   = {}".format(. 
+0001bf80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bf90: 2020 2074 7970 6528 7365 6c66 2e73 6c69     type(self.sli
+0001bfa0: 6365 5f73 7572 665f 7365 7269 6573 2929  ce_surf_series))
+0001bfb0: 290a 0a20 2020 2020 2020 2023 2073 6c69  )..        # sli
+0001bfc0: 6365 2073 7572 6661 6365 2066 7265 6520  ce surface free 
+0001bfd0: 7379 6d62 6f6c 730a 2020 2020 2020 2020  symbols.        
+0001bfe0: 2320 646f 6e27 7420 7573 6520 7365 6c66  # don't use self
+0001bff0: 2e73 6c69 6365 5f73 7572 665f 7365 7269  .slice_surf_seri
+0001c000: 6573 2e66 7265 655f 7379 6d62 6f6c 7320  es.free_symbols 
+0001c010: 6173 2074 6869 7320 6578 7072 6573 7369  as this expressi
+0001c020: 6f6e 0a20 2020 2020 2020 2023 206d 6967  on.        # mig
+0001c030: 6874 206e 6f74 2075 7365 2062 6f74 6820  ht not use both 
+0001c040: 6974 7320 6469 7363 7265 7469 7a61 7469  its discretizati
+0001c050: 6f6e 2073 796d 626f 6c73 0a20 2020 2020  on symbols.     
+0001c060: 2020 2073 7366 7320 3d20 5b72 5b30 5d20     ssfs = [r[0] 
+0001c070: 666f 7220 7220 696e 2073 656c 662e 736c  for r in self.sl
+0001c080: 6963 655f 7375 7266 5f73 6572 6965 732e  ice_surf_series.
+0001c090: 7261 6e67 6573 5d0a 2020 2020 2020 2020  ranges].        
+0001c0a0: 2320 6769 7665 6e20 6628 792c 207a 292c  # given f(y, z),
+0001c0b0: 2077 6520 616c 7265 6164 7920 6861 7665   we already have
+0001c0c0: 2079 2c20 7a20 2873 7366 7329 2c20 6e6f   y, z (ssfs), no
+0001c0d0: 7720 6669 6e64 2078 0a20 2020 2020 2020  w find x.       
+0001c0e0: 206d 6973 7369 6e67 5f73 796d 626f 6c20   missing_symbol 
+0001c0f0: 3d20 6c69 7374 2873 6574 2876 6563 5f64  = list(set(vec_d
+0001c100: 6973 6372 5f73 796d 626f 6c73 292e 6469  iscr_symbols).di
+0001c110: 6666 6572 656e 6365 2873 7366 7329 290a  fference(ssfs)).
+0001c120: 2020 2020 2020 2020 2320 6f72 6465 7265          # ordere
+0001c130: 6420 7379 6d62 6f6c 7320 696e 2074 6865  d symbols in the
+0001c140: 2072 6574 7572 6e65 6420 6461 7461 0a20   returned data. 
+0001c150: 2020 2020 2020 2072 6574 7572 6e65 645f         returned_
+0001c160: 7379 6d62 6f6c 7320 3d20 7373 6673 202b  symbols = ssfs +
+0001c170: 206d 6973 7369 6e67 5f73 796d 626f 6c0a   missing_symbol.
+0001c180: 2020 2020 2020 2020 2320 6f75 7470 7574          # output
+0001c190: 206f 7264 6572 0a20 2020 2020 2020 206f   order.        o
+0001c1a0: 7264 6572 203d 205b 7265 7475 726e 6564  rder = [returned
+0001c1b0: 5f73 796d 626f 6c73 2e69 6e64 6578 2873  _symbols.index(s
+0001c1c0: 2920 666f 7220 7320 696e 2076 6563 5f64  ) for s in vec_d
+0001c1d0: 6973 6372 5f73 796d 626f 6c73 5d0a 2020  iscr_symbols].  
+0001c1e0: 2020 2020 2020 7265 7475 726e 206f 7264        return ord
+0001c1f0: 6572 0a0a 2020 2020 6465 6620 5f63 7265  er..    def _cre
+0001c200: 6174 655f 6469 7363 7265 7469 7a65 645f  ate_discretized_
+0001c210: 646f 6d61 696e 2873 656c 6629 3a0a 2020  domain(self):.  
+0001c220: 2020 2020 2020 2222 2244 6973 6372 6574        """Discret
+0001c230: 697a 6520 7468 6520 7261 6e67 6573 2069  ize the ranges i
+0001c240: 6e20 6361 7365 206f 6620 756e 6966 6f72  n case of unifor
+0001c250: 6d20 6d65 7368 696e 6720 7374 7261 7465  m meshing strate
+0001c260: 6779 2e0a 2020 2020 2020 2020 2222 220a  gy..        """.
+0001c270: 2020 2020 2020 2020 2320 544f 444f 3a20          # TODO: 
+0001c280: 6f6e 6365 2049 6e74 6572 6163 7469 7665  once Interactive
+0001c290: 5365 7269 6573 2068 6173 2062 6565 6e20  Series has been 
+0001c2a0: 7265 6d6f 7665 2c20 7468 6520 666f 6c6c  remove, the foll
+0001c2b0: 6f77 696e 6720 6361 6e0a 2020 2020 2020  owing can.      
+0001c2c0: 2020 2320 6265 2072 656f 7267 616e 697a    # be reorganiz
+0001c2d0: 6564 2069 6e20 6f72 6465 7220 746f 2072  ed in order to r
+0001c2e0: 656d 6f76 6520 636f 6465 2072 6570 6574  emove code repet
+0001c2f0: 6974 696f 6e2c 2073 7065 6369 6669 6361  ition, specifica
+0001c300: 6c6c 7920 7468 650a 2020 2020 2020 2020  lly the.        
+0001c310: 2320 666f 6c6c 6f77 696e 6720 6c69 6e65  # following line
+0001c320: 206f 6620 636f 6465 2e0a 2020 2020 2020   of code..      
+0001c330: 2020 2320 7379 6d62 6f6c 7320 7573 6564    # symbols used
+0001c340: 2062 7920 7468 6973 2076 6563 746f 7227   by this vector'
+0001c350: 7320 6469 7363 7265 7469 7a61 7469 6f6e  s discretization
+0001c360: 0a20 2020 2020 2020 2064 6973 6372 5f73  .        discr_s
+0001c370: 796d 626f 6c73 203d 205b 725b 305d 2066  ymbols = [r[0] f
+0001c380: 6f72 2072 2069 6e20 7365 6c66 2e72 616e  or r in self.ran
+0001c390: 6765 735d 0a20 2020 2020 2020 2064 6973  ges].        dis
+0001c3a0: 6372 6574 697a 6174 696f 6e73 203d 2073  cretizations = s
+0001c3b0: 656c 662e 5f64 6973 6372 6574 697a 6528  elf._discretize(
+0001c3c0: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+0001c3d0: 6469 7363 7265 7469 7a65 645f 646f 6d61  discretized_doma
+0001c3e0: 696e 203d 207b 0a20 2020 2020 2020 2020  in = {.         
+0001c3f0: 2020 206b 3a20 7620 666f 7220 6b2c 2076     k: v for k, v
+0001c400: 2069 6e20 7a69 7028 6469 7363 725f 7379   in zip(discr_sy
+0001c410: 6d62 6f6c 732c 2064 6973 6372 6574 697a  mbols, discretiz
+0001c420: 6174 696f 6e73 297d 0a0a 2020 2020 4070  ations)}..    @p
+0001c430: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+0001c440: 7061 7261 6d73 2873 656c 6629 3a0a 2020  params(self):.  
+0001c450: 2020 2020 2020 2222 2247 6574 206f 7220        """Get or 
+0001c460: 7365 7420 7468 6520 6375 7272 656e 7420  set the current 
+0001c470: 7061 7261 6d65 7465 7273 2064 6963 7469  parameters dicti
+0001c480: 6f6e 6172 792e 0a0a 2020 2020 2020 2020  onary...        
+0001c490: 5061 7261 6d65 7465 7273 0a20 2020 2020  Parameters.     
+0001c4a0: 2020 203d 3d3d 3d3d 3d3d 3d3d 3d0a 0a20     ==========.. 
+0001c4b0: 2020 2020 2020 2070 203a 2064 6963 740a         p : dict.
+0001c4c0: 2020 2020 2020 2020 2020 2020 6b65 793a              key:
+0001c4d0: 2073 796d 626f 6c20 6173 736f 6369 6174   symbol associat
+0001c4e0: 6564 2074 6f20 7468 6520 7061 7261 6d65  ed to the parame
+0001c4f0: 7465 720a 2020 2020 2020 2020 2020 2020  ter.            
+0001c500: 7661 6c3a 2074 6865 2076 616c 7565 0a20  val: the value. 
+0001c510: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0001c520: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+0001c530: 7061 7261 6d73 0a0a 2020 2020 4070 6172  params..    @par
+0001c540: 616d 732e 7365 7474 6572 0a20 2020 2064  ams.setter.    d
+0001c550: 6566 2070 6172 616d 7328 7365 6c66 2c20  ef params(self, 
+0001c560: 7029 3a0a 2020 2020 2020 2020 7365 6c66  p):.        self
+0001c570: 2e5f 7061 7261 6d73 203d 2070 0a20 2020  ._params = p.   
+0001c580: 2020 2020 2069 6620 7365 6c66 2e73 6c69       if self.sli
+0001c590: 6365 5f73 7572 665f 7365 7269 6573 2e69  ce_surf_series.i
+0001c5a0: 735f 696e 7465 7261 6374 6976 653a 0a20  s_interactive:. 
+0001c5b0: 2020 2020 2020 2020 2020 2023 2075 7064             # upd
+0001c5c0: 6174 6520 626f 7468 2070 6172 616d 6574  ate both paramet
+0001c5d0: 6572 7320 616e 6420 6469 7363 7265 7469  ers and discreti
+0001c5e0: 7a61 7469 6f6e 2072 616e 6765 730a 2020  zation ranges.  
+0001c5f0: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
+0001c600: 6c69 6365 5f73 7572 665f 7365 7269 6573  lice_surf_series
+0001c610: 2e70 6172 616d 7320 3d20 700a 2020 2020  .params = p.    
+0001c620: 2020 2020 2320 7379 6d62 6f6c 7320 7573      # symbols us
+0001c630: 6564 2062 7920 7468 6973 2076 6563 746f  ed by this vecto
+0001c640: 7227 7320 6469 7363 7265 7469 7a61 7469  r's discretizati
+0001c650: 6f6e 0a20 2020 2020 2020 2064 6973 6372  on.        discr
+0001c660: 5f73 796d 626f 6c73 203d 205b 725b 305d  _symbols = [r[0]
+0001c670: 2066 6f72 2072 2069 6e20 7365 6c66 2e72   for r in self.r
+0001c680: 616e 6765 735d 0a0a 2020 2020 2020 2020  anges]..        
+0001c690: 6966 2028 0a20 2020 2020 2020 2020 2020  if (.           
+0001c6a0: 2069 7369 6e73 7461 6e63 6528 7365 6c66   isinstance(self
+0001c6b0: 2e73 6c69 6365 5f73 7572 665f 7365 7269  .slice_surf_seri
+0001c6c0: 6573 2c20 5375 7266 6163 654f 7665 7232  es, SurfaceOver2
+0001c6d0: 4452 616e 6765 5365 7269 6573 2920 616e  DRangeSeries) an
+0001c6e0: 640a 2020 2020 2020 2020 2020 2020 286e  d.            (n
+0001c6f0: 6f74 2073 656c 662e 736c 6963 655f 7375  ot self.slice_su
+0001c700: 7266 5f73 6572 6965 732e 6973 5f70 6172  rf_series.is_par
+0001c710: 616d 6574 7269 6329 0a20 2020 2020 2020  ametric).       
+0001c720: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
+0001c730: 2320 6f72 6465 7265 6420 7379 6d62 6f6c  # ordered symbol
+0001c740: 7320 6672 6f6d 2073 6c69 6365 5f73 7572  s from slice_sur
+0001c750: 665f 7365 7269 6573 0a20 2020 2020 2020  f_series.       
+0001c760: 2020 2020 206f 7264 6572 6564 5f73 796d       ordered_sym
+0001c770: 626f 6c73 203d 2073 656c 662e 5f64 6973  bols = self._dis
+0001c780: 6372 6574 697a 655f 6865 6c70 6572 2864  cretize_helper(d
+0001c790: 6973 6372 5f73 796d 626f 6c73 290a 2020  iscr_symbols).  
+0001c7a0: 2020 2020 2020 2020 2020 6461 7461 203d            data =
+0001c7b0: 2073 656c 662e 736c 6963 655f 7375 7266   self.slice_surf
+0001c7c0: 5f73 6572 6965 732e 6765 745f 6461 7461  _series.get_data
+0001c7d0: 2829 0a20 2020 2020 2020 2020 2020 2073  ().            s
+0001c7e0: 656c 662e 5f64 6973 6372 6574 697a 6564  elf._discretized
+0001c7f0: 5f64 6f6d 6169 6e20 3d20 7b0a 2020 2020  _domain = {.    
+0001c800: 2020 2020 2020 2020 2020 2020 6b3a 2064              k: d
+0001c810: 6174 615b 765d 2066 6f72 206b 2c20 7620  ata[v] for k, v 
+0001c820: 696e 207a 6970 2864 6973 6372 5f73 796d  in zip(discr_sym
+0001c830: 626f 6c73 2c20 6f72 6465 7265 645f 7379  bols, ordered_sy
+0001c840: 6d62 6f6c 7329 0a20 2020 2020 2020 2020  mbols).         
+0001c850: 2020 207d 0a20 2020 2020 2020 2065 6c73     }.        els
+0001c860: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
+0001c870: 656c 662e 5f64 6973 6372 6574 697a 6564  elf._discretized
+0001c880: 5f64 6f6d 6169 6e20 3d20 7b0a 2020 2020  _domain = {.    
+0001c890: 2020 2020 2020 2020 2020 2020 6b3a 2076              k: v
+0001c8a0: 2066 6f72 206b 2c20 7620 696e 207a 6970   for k, v in zip
+0001c8b0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0001c8c0: 2020 2020 2020 6469 7363 725f 7379 6d62        discr_symb
+0001c8d0: 6f6c 732c 0a20 2020 2020 2020 2020 2020  ols,.           
+0001c8e0: 2020 2020 2020 2020 2073 656c 662e 736c           self.sl
+0001c8f0: 6963 655f 7375 7266 5f73 6572 6965 732e  ice_surf_series.
+0001c900: 6765 745f 6461 7461 2829 0a20 2020 2020  get_data().     
+0001c910: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+0001c920: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
+0001c930: 6465 6620 5f5f 7374 725f 5f28 7365 6c66  def __str__(self
+0001c940: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0001c950: 6e20 2273 6c69 6365 6420 2220 2b20 7375  n "sliced " + su
+0001c960: 7065 7228 292e 5f5f 7374 725f 5f28 2920  per().__str__() 
+0001c970: 2b20 2220 6174 207b 7d22 2e66 6f72 6d61  + " at {}".forma
+0001c980: 7428 0a20 2020 2020 2020 2020 2020 2073  t(.            s
+0001c990: 656c 662e 736c 6963 655f 7375 7266 5f73  elf.slice_surf_s
+0001c9a0: 6572 6965 7329 0a0a 0a63 6c61 7373 2050  eries)...class P
+0001c9b0: 6c61 6e65 5365 7269 6573 2853 7572 6661  laneSeries(Surfa
+0001c9c0: 6365 4261 7365 5365 7269 6573 293a 0a20  ceBaseSeries):. 
+0001c9d0: 2020 2022 2222 5265 7072 6573 656e 7473     """Represents
+0001c9e0: 2061 2070 6c61 6e65 2069 6e20 6120 3344   a plane in a 3D
+0001c9f0: 2064 6f6d 6169 6e2e 2222 220a 0a20 2020   domain."""..   
+0001ca00: 2069 735f 3344 7375 7266 6163 6520 3d20   is_3Dsurface = 
+0001ca10: 5472 7565 0a20 2020 205f 4e20 3d20 3230  True.    _N = 20
+0001ca20: 0a0a 2020 2020 2320 6120 6765 6e65 7269  ..    # a generi
+0001ca30: 6320 706c 616e 6520 2866 6f72 2065 7861  c plane (for exa
+0001ca40: 6d70 6c65 2077 6974 6820 6e6f 726d 616c  mple with normal
+0001ca50: 2028 312c 312c 3129 2920 6361 6e20 6765   (1,1,1)) can ge
+0001ca60: 6e65 7261 7465 2061 2068 7567 650a 2020  nerate a huge.  
+0001ca70: 2020 2320 7261 6e67 6520 616c 6f6e 6720    # range along 
+0001ca80: 7468 6520 7a2d 6469 7265 6374 696f 6e2e  the z-direction.
+0001ca90: 2057 6974 6820 5f75 7365 5f6e 616e 3d54   With _use_nan=T
+0001caa0: 7275 652c 2065 7665 7279 207a 2d76 616c  rue, every z-val
+0001cab0: 7565 206f 7574 7369 6465 0a20 2020 2023  ue outside.    #
+0001cac0: 206f 6620 7468 6520 7072 6f76 6964 6564   of the provided
+0001cad0: 207a 5f72 616e 6765 2077 696c 6c20 6265   z_range will be
+0001cae0: 2073 6574 2074 6f20 4e61 6e2e 0a20 2020   set to Nan..   
+0001caf0: 205f 7573 655f 6e61 6e20 3d20 5472 7565   _use_nan = True
+0001cb00: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
+0001cb10: 5f5f 280a 2020 2020 2020 2020 7365 6c66  __(.        self
+0001cb20: 2c20 706c 616e 652c 2078 5f72 616e 6765  , plane, x_range
+0001cb30: 2c20 795f 7261 6e67 652c 207a 5f72 616e  , y_range, z_ran
+0001cb40: 6765 3d4e 6f6e 652c 206c 6162 656c 3d22  ge=None, label="
+0001cb50: 222c 202a 2a6b 7761 7267 730a 2020 2020  ", **kwargs.    
+0001cb60: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
+0001cb70: 2829 2e5f 5f69 6e69 745f 5f28 2a2a 6b77  ().__init__(**kw
+0001cb80: 6172 6773 290a 2020 2020 2020 2020 7365  args).        se
+0001cb90: 6c66 2e5f 626c 6f63 6b5f 6c61 6d62 6461  lf._block_lambda
+0001cba0: 5f66 756e 6374 696f 6e73 2870 6c61 6e65  _functions(plane
+0001cbb0: 290a 2020 2020 2020 2020 7365 6c66 2e70  ).        self.p
+0001cbc0: 6c61 6e65 203d 2073 796d 7069 6679 2870  lane = sympify(p
+0001cbd0: 6c61 6e65 290a 2020 2020 2020 2020 7365  lane).        se
+0001cbe0: 6c66 2e65 7870 7220 3d20 7365 6c66 2e70  lf.expr = self.p
+0001cbf0: 6c61 6e65 0a20 2020 2020 2020 2069 6620  lane.        if 
+0001cc00: 6e6f 7420 6973 696e 7374 616e 6365 2873  not isinstance(s
+0001cc10: 656c 662e 706c 616e 652c 2050 6c61 6e65  elf.plane, Plane
+0001cc20: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+0001cc30: 6169 7365 2054 7970 6545 7272 6f72 280a  aise TypeError(.
+0001cc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cc50: 2260 706c 616e 6560 206d 7573 7420 6265  "`plane` must be
+0001cc60: 2061 6e20 696e 7374 616e 6365 206f 6620   an instance of 
+0001cc70: 7379 6d70 792e 6765 6f6d 6574 7279 2e50  sympy.geometry.P
+0001cc80: 6c61 6e65 2229 0a20 2020 2020 2020 2073  lane").        s
+0001cc90: 656c 662e 785f 7261 6e67 6520 3d20 7379  elf.x_range = sy
+0001cca0: 6d70 6966 7928 785f 7261 6e67 6529 0a20  mpify(x_range). 
+0001ccb0: 2020 2020 2020 2073 656c 662e 795f 7261         self.y_ra
+0001ccc0: 6e67 6520 3d20 7379 6d70 6966 7928 795f  nge = sympify(y_
+0001ccd0: 7261 6e67 6529 0a20 2020 2020 2020 2073  range).        s
+0001cce0: 656c 662e 7a5f 7261 6e67 6520 3d20 7379  elf.z_range = sy
+0001ccf0: 6d70 6966 7928 7a5f 7261 6e67 6529 0a20  mpify(z_range). 
+0001cd00: 2020 2020 2020 2073 656c 662e 7261 6e67         self.rang
+0001cd10: 6573 203d 205b 7365 6c66 2e78 5f72 616e  es = [self.x_ran
+0001cd20: 6765 2c20 7365 6c66 2e79 5f72 616e 6765  ge, self.y_range
+0001cd30: 2c20 7365 6c66 2e7a 5f72 616e 6765 5d0a  , self.z_range].
+0001cd40: 2020 2020 2020 2020 7365 6c66 2e5f 7365          self._se
+0001cd50: 745f 7375 7266 6163 655f 6c61 6265 6c28  t_surface_label(
+0001cd60: 6c61 6265 6c29 0a20 2020 2020 2020 2069  label).        i
+0001cd70: 6620 7365 6c66 2e70 6172 616d 7320 616e  f self.params an
+0001cd80: 6420 6e6f 7420 7365 6c66 2e70 6c61 6e65  d not self.plane
+0001cd90: 2e66 7265 655f 7379 6d62 6f6c 733a 0a20  .free_symbols:. 
+0001cda0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0001cdb0: 7061 7261 6d73 203d 2064 6963 7428 290a  params = dict().
+0001cdc0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001cdd0: 2e69 735f 696e 7465 7261 6374 6976 6520  .is_interactive 
+0001cde0: 3d20 4661 6c73 650a 0a20 2020 2064 6566  = False..    def
+0001cdf0: 205f 5f73 7472 5f5f 2873 656c 6629 3a0a   __str__(self):.
+0001ce00: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0001ce10: 656c 662e 5f73 7472 5f68 656c 7065 7228  elf._str_helper(
+0001ce20: 0a20 2020 2020 2020 2020 2020 2022 706c  .            "pl
+0001ce30: 616e 6520 7365 7269 6573 3a20 2573 206f  ane series: %s o
+0001ce40: 7665 7220 2573 2c20 2573 2c20 2573 2220  ver %s, %s, %s" 
+0001ce50: 2520 280a 2020 2020 2020 2020 2020 2020  % (.            
+0001ce60: 2020 2020 7365 6c66 2e70 6c61 6e65 2c20      self.plane, 
+0001ce70: 7365 6c66 2e78 5f72 616e 6765 2c20 7365  self.x_range, se
+0001ce80: 6c66 2e79 5f72 616e 6765 2c20 7365 6c66  lf.y_range, self
+0001ce90: 2e7a 5f72 616e 6765 2929 0a0a 2020 2020  .z_range))..    
+0001cea0: 6465 6620 6765 745f 6461 7461 2873 656c  def get_data(sel
+0001ceb0: 6629 3a0a 2020 2020 2020 2020 6e70 203d  f):.        np =
+0001cec0: 2069 6d70 6f72 745f 6d6f 6475 6c65 2827   import_module('
+0001ced0: 6e75 6d70 7927 290a 0a20 2020 2020 2020  numpy')..       
+0001cee0: 2078 2c20 792c 207a 203d 2073 796d 626f   x, y, z = symbo
+0001cef0: 6c73 2822 782c 2079 2c20 7a22 290a 2020  ls("x, y, z").  
+0001cf00: 2020 2020 2020 706c 616e 6520 3d20 7365        plane = se
+0001cf10: 6c66 2e70 6c61 6e65 2e73 7562 7328 7365  lf.plane.subs(se
+0001cf20: 6c66 2e5f 7061 7261 6d73 290a 2020 2020  lf._params).    
+0001cf30: 2020 2020 6673 203d 2070 6c61 6e65 2e65      fs = plane.e
+0001cf40: 7175 6174 696f 6e28 782c 2079 2c20 7a29  quation(x, y, z)
+0001cf50: 2e66 7265 655f 7379 6d62 6f6c 730a 2020  .free_symbols.  
+0001cf60: 2020 2020 2020 7878 2c20 7979 2c20 7a7a        xx, yy, zz
+0001cf70: 203d 204e 6f6e 652c 204e 6f6e 652c 204e   = None, None, N
+0001cf80: 6f6e 650a 2020 2020 2020 2020 6966 2066  one.        if f
+0001cf90: 7320 3d3d 2073 6574 285b 785d 293a 0a20  s == set([x]):. 
+0001cfa0: 2020 2020 2020 2020 2020 2023 2070 6172             # par
+0001cfb0: 616c 6c65 6c20 746f 2079 7a20 706c 616e  allel to yz plan
+0001cfc0: 6520 286e 6f72 6d61 6c20 7665 6374 6f72  e (normal vector
+0001cfd0: 2028 312c 2030 2c20 3029 290a 2020 2020   (1, 0, 0)).    
+0001cfe0: 2020 2020 2020 2020 7320 3d20 5375 7266          s = Surf
+0001cff0: 6163 654f 7665 7232 4452 616e 6765 5365  aceOver2DRangeSe
+0001d000: 7269 6573 280a 2020 2020 2020 2020 2020  ries(.          
+0001d010: 2020 2020 2020 706c 616e 652e 7031 5b30        plane.p1[0
+0001d020: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0001d030: 2020 2028 782c 202a 7365 6c66 2e7a 5f72     (x, *self.z_r
+0001d040: 616e 6765 5b31 3a5d 292c 0a20 2020 2020  ange[1:]),.     
+0001d050: 2020 2020 2020 2020 2020 2028 792c 202a             (y, *
+0001d060: 7365 6c66 2e79 5f72 616e 6765 5b31 3a5d  self.y_range[1:]
+0001d070: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+0001d080: 2020 2022 222c 0a20 2020 2020 2020 2020     "",.         
+0001d090: 2020 2020 2020 206e 313d 7365 6c66 2e6e         n1=self.n
+0001d0a0: 5b32 5d2c 0a20 2020 2020 2020 2020 2020  [2],.           
+0001d0b0: 2020 2020 206e 323d 7365 6c66 2e6e 5b31       n2=self.n[1
+0001d0c0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0001d0d0: 2020 2078 7363 616c 653d 7365 6c66 2e5f     xscale=self._
+0001d0e0: 7363 616c 6573 5b30 5d2c 0a20 2020 2020  scales[0],.     
+0001d0f0: 2020 2020 2020 2020 2020 2079 7363 616c             yscal
+0001d100: 653d 7365 6c66 2e5f 7363 616c 6573 5b31  e=self._scales[1
+0001d110: 5d0a 2020 2020 2020 2020 2020 2020 290a  ].            ).
+0001d120: 2020 2020 2020 2020 2020 2020 7878 2c20              xx, 
+0001d130: 7979 2c20 7a7a 203d 2073 2e67 6574 5f64  yy, zz = s.get_d
+0001d140: 6174 6128 290a 2020 2020 2020 2020 2020  ata().          
+0001d150: 2020 7878 2c20 7979 2c20 7a7a 203d 207a    xx, yy, zz = z
+0001d160: 7a2c 2079 792c 2078 780a 2020 2020 2020  z, yy, xx.      
+0001d170: 2020 656c 6966 2066 7320 3d3d 2073 6574    elif fs == set
+0001d180: 285b 795d 293a 0a20 2020 2020 2020 2020  ([y]):.         
+0001d190: 2020 2023 2070 6172 616c 6c65 6c20 746f     # parallel to
+0001d1a0: 2078 7a20 706c 616e 6520 286e 6f72 6d61   xz plane (norma
+0001d1b0: 6c20 7665 6374 6f72 2028 302c 2031 2c20  l vector (0, 1, 
+0001d1c0: 3029 290a 2020 2020 2020 2020 2020 2020  0)).            
+0001d1d0: 7320 3d20 5375 7266 6163 654f 7665 7232  s = SurfaceOver2
+0001d1e0: 4452 616e 6765 5365 7269 6573 280a 2020  DRangeSeries(.  
+0001d1f0: 2020 2020 2020 2020 2020 2020 2020 706c                pl
+0001d200: 616e 652e 7031 5b31 5d2c 0a20 2020 2020  ane.p1[1],.     
+0001d210: 2020 2020 2020 2020 2020 2028 782c 202a             (x, *
+0001d220: 7365 6c66 2e78 5f72 616e 6765 5b31 3a5d  self.x_range[1:]
+0001d230: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+0001d240: 2020 2028 792c 202a 7365 6c66 2e7a 5f72     (y, *self.z_r
+0001d250: 616e 6765 5b31 3a5d 292c 0a20 2020 2020  ange[1:]),.     
+0001d260: 2020 2020 2020 2020 2020 2022 222c 0a20             "",. 
+0001d270: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+0001d280: 313d 7365 6c66 2e6e 5b30 5d2c 0a20 2020  1=self.n[0],.   
+0001d290: 2020 2020 2020 2020 2020 2020 206e 323d               n2=
+0001d2a0: 7365 6c66 2e6e 5b32 5d2c 0a20 2020 2020  self.n[2],.     
+0001d2b0: 2020 2020 2020 2020 2020 2078 7363 616c             xscal
+0001d2c0: 653d 7365 6c66 2e5f 7363 616c 6573 5b30  e=self._scales[0
+0001d2d0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0001d2e0: 2020 2079 7363 616c 653d 7365 6c66 2e5f     yscale=self._
+0001d2f0: 7363 616c 6573 5b31 5d0a 2020 2020 2020  scales[1].      
+0001d300: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0001d310: 2020 2020 7878 2c20 7979 2c20 7a7a 203d      xx, yy, zz =
+0001d320: 2073 2e67 6574 5f64 6174 6128 290a 2020   s.get_data().  
+0001d330: 2020 2020 2020 2020 2020 7878 2c20 7979            xx, yy
+0001d340: 2c20 7a7a 203d 2078 782c 207a 7a2c 2079  , zz = xx, zz, y
+0001d350: 790a 2020 2020 2020 2020 656c 6966 2066  y.        elif f
+0001d360: 7320 3d3d 2073 6574 285b 782c 2079 5d29  s == set([x, y])
+0001d370: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+0001d380: 7665 7274 6963 616c 2070 6c61 6e65 206f  vertical plane o
+0001d390: 7269 656e 7465 6420 7769 7468 2073 6f6d  riented with som
+0001d3a0: 6520 616e 676c 650a 0a20 2020 2020 2020  e angle..       
+0001d3b0: 2020 2020 2023 2047 6574 206e 756d 7079       # Get numpy
+0001d3c0: 2076 6563 746f 7273 0a20 2020 2020 2020   vectors.       
+0001d3d0: 2020 2020 2070 3120 3d20 6e70 2e61 7272       p1 = np.arr
+0001d3e0: 6179 2870 6c61 6e65 2e70 312c 2064 7479  ay(plane.p1, dty
+0001d3f0: 7065 3d66 6c6f 6174 290a 2020 2020 2020  pe=float).      
+0001d400: 2020 2020 2020 6e76 203d 206e 702e 6172        nv = np.ar
+0001d410: 7261 7928 706c 616e 652e 6e6f 726d 616c  ray(plane.normal
+0001d420: 5f76 6563 746f 722c 2064 7479 7065 3d66  _vector, dtype=f
+0001d430: 6c6f 6174 290a 2020 2020 2020 2020 2020  loat).          
+0001d440: 2020 2320 636f 6e76 6572 7420 7468 6520    # convert the 
+0001d450: 6e6f 726d 616c 2076 6563 746f 7220 746f  normal vector to
+0001d460: 2075 6e69 7420 6e6f 726d 616c 2076 6563   unit normal vec
+0001d470: 746f 720a 2020 2020 2020 2020 2020 2020  tor.            
+0001d480: 6e76 203d 206e 7620 2f20 6e70 2e73 7172  nv = nv / np.sqr
+0001d490: 7428 6e76 2e54 2040 206e 7629 0a0a 2020  t(nv.T @ nv)..  
+0001d4a0: 2020 2020 2020 2020 2020 2320 706c 616e            # plan
+0001d4b0: 6520 6861 7320 6469 7374 616e 6365 2074  e has distance t
+0001d4c0: 6f20 6f72 6967 696e 2061 7320 6c65 6e67  o origin as leng
+0001d4d0: 7468 206f 6620 7072 6f6a 6563 7469 6f6e  th of projection
+0001d4e0: 206f 660a 2020 2020 2020 2020 2020 2020   of.            
+0001d4f0: 2320 7031 206f 6e74 6f20 6e6f 726d 616c  # p1 onto normal
+0001d500: 2076 6563 746f 720a 2020 2020 2020 2020   vector.        
+0001d510: 2020 2020 7072 6f6a 5f70 326e 7620 3d20      proj_p2nv = 
+0001d520: 6e76 2e64 6f74 2870 3129 0a0a 2020 2020  nv.dot(p1)..    
+0001d530: 2020 2020 2020 2020 7320 3d20 5375 7266          s = Surf
+0001d540: 6163 654f 7665 7232 4452 616e 6765 5365  aceOver2DRangeSe
+0001d550: 7269 6573 280a 2020 2020 2020 2020 2020  ries(.          
+0001d560: 2020 2020 2020 7072 6f6a 5f70 326e 762c        proj_p2nv,
+0001d570: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d580: 2028 782c 202a 7365 6c66 2e78 5f72 616e   (x, *self.x_ran
+0001d590: 6765 5b31 3a5d 292c 0a20 2020 2020 2020  ge[1:]),.       
+0001d5a0: 2020 2020 2020 2020 2028 792c 202a 7365           (y, *se
+0001d5b0: 6c66 2e7a 5f72 616e 6765 5b31 3a5d 292c  lf.z_range[1:]),
+0001d5c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d5d0: 2022 222c 0a20 2020 2020 2020 2020 2020   "",.           
+0001d5e0: 2020 2020 206e 313d 7365 6c66 2e6e 5b30       n1=self.n[0
+0001d5f0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0001d600: 2020 206e 323d 7365 6c66 2e6e 5b32 5d2c     n2=self.n[2],
+0001d610: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d620: 2078 7363 616c 653d 7365 6c66 2e5f 7363   xscale=self._sc
+0001d630: 616c 6573 5b30 5d2c 0a20 2020 2020 2020  ales[0],.       
+0001d640: 2020 2020 2020 2020 2079 7363 616c 653d           yscale=
+0001d650: 7365 6c66 2e5f 7363 616c 6573 5b31 5d0a  self._scales[1].
+0001d660: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0001d670: 2020 2020 2020 2020 2020 7878 2c20 7979            xx, yy
+0001d680: 2c20 7a7a 203d 2073 2e67 6574 5f64 6174  , zz = s.get_dat
+0001d690: 6128 290a 2020 2020 2020 2020 2020 2020  a().            
+0001d6a0: 7878 2c20 7979 2c20 7a7a 203d 2078 782c  xx, yy, zz = xx,
+0001d6b0: 207a 7a2c 2079 790a 0a20 2020 2020 2020   zz, yy..       
+0001d6c0: 2020 2020 2023 2072 6f74 6174 6520 706c       # rotate pl
+0001d6d0: 616e 6520 636f 7272 6573 706f 6e64 696e  ane correspondin
+0001d6e0: 6720 746f 2074 6865 206e 6f72 6d61 6c20  g to the normal 
+0001d6f0: 7665 6374 6f72 0a20 2020 2020 2020 2020  vector.         
+0001d700: 2020 2064 6566 2052 2874 293a 0a20 2020     def R(t):.   
+0001d710: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+0001d720: 7572 6e20 6e70 2e61 7272 6179 285b 0a20  urn np.array([. 
+0001d730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d740: 2020 205b 6e70 2e63 6f73 2874 292c 202d     [np.cos(t), -
+0001d750: 6e70 2e73 696e 2874 292c 2030 5d2c 0a20  np.sin(t), 0],. 
+0001d760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d770: 2020 205b 6e70 2e73 696e 2874 292c 206e     [np.sin(t), n
+0001d780: 702e 636f 7328 7429 2c20 305d 2c0a 2020  p.cos(t), 0],.  
+0001d790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d7a0: 2020 5b30 2c20 302c 2031 5d0a 2020 2020    [0, 0, 1].    
+0001d7b0: 2020 2020 2020 2020 2020 2020 5d29 0a0a              ])..
+0001d7c0: 2020 2020 2020 2020 2020 2020 7468 6574              thet
+0001d7d0: 6120 3d20 6e70 2e61 7263 7461 6e32 286e  a = np.arctan2(n
+0001d7e0: 765b 315d 2c20 6e76 5b30 5d29 0a20 2020  v[1], nv[0]).   
+0001d7f0: 2020 2020 2020 2020 2063 6f6f 7264 7320           coords 
+0001d800: 3d20 6e70 2e73 7461 636b 285b 742e 666c  = np.stack([t.fl
+0001d810: 6174 7465 6e28 2920 666f 7220 7420 696e  atten() for t in
+0001d820: 205b 7878 2c20 7979 2c20 6e70 2e6f 6e65   [xx, yy, np.one
+0001d830: 735f 6c69 6b65 2878 7829 5d5d 292e 540a  s_like(xx)]]).T.
+0001d840: 2020 2020 2020 2020 2020 2020 636f 6f72              coor
+0001d850: 6473 203d 206e 702e 6d61 746d 756c 2863  ds = np.matmul(c
+0001d860: 6f6f 7264 732c 2052 2874 6865 7461 2929  oords, R(theta))
+0001d870: 0a20 2020 2020 2020 2020 2020 2079 792c  .            yy,
+0001d880: 2078 7820 3d20 636f 6f72 6473 5b3a 2c20   xx = coords[:, 
+0001d890: 305d 2e72 6573 6861 7065 2879 792e 7368  0].reshape(yy.sh
+0001d8a0: 6170 6529 2c20 636f 6f72 6473 5b3a 2c20  ape), coords[:, 
+0001d8b0: 315d 2e72 6573 6861 7065 2878 782e 7368  1].reshape(xx.sh
+0001d8c0: 6170 6529 0a20 2020 2020 2020 2065 6c73  ape).        els
+0001d8d0: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
+0001d8e0: 2061 6e79 206f 7468 6572 2070 6c61 6e65   any other plane
+0001d8f0: 0a20 2020 2020 2020 2020 2020 2065 7120  .            eq 
+0001d900: 3d20 706c 616e 652e 6571 7561 7469 6f6e  = plane.equation
+0001d910: 2878 2c20 792c 207a 290a 2020 2020 2020  (x, y, z).      
+0001d920: 2020 2020 2020 6966 207a 2069 6e20 6571        if z in eq
+0001d930: 2e66 7265 655f 7379 6d62 6f6c 733a 0a20  .free_symbols:. 
+0001d940: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0001d950: 7120 3d20 736f 6c76 6528 6571 2c20 7a29  q = solve(eq, z)
+0001d960: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
+0001d970: 7320 3d20 5375 7266 6163 654f 7665 7232  s = SurfaceOver2
+0001d980: 4452 616e 6765 5365 7269 6573 280a 2020  DRangeSeries(.  
+0001d990: 2020 2020 2020 2020 2020 2020 2020 6571                eq
+0001d9a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001d9b0: 2020 2878 2c20 2a73 656c 662e 785f 7261    (x, *self.x_ra
+0001d9c0: 6e67 655b 313a 5d29 2c0a 2020 2020 2020  nge[1:]),.      
+0001d9d0: 2020 2020 2020 2020 2020 2879 2c20 2a73            (y, *s
+0001d9e0: 656c 662e 795f 7261 6e67 655b 313a 5d29  elf.y_range[1:])
+0001d9f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001da00: 2020 2222 2c0a 2020 2020 2020 2020 2020    "",.          
+0001da10: 2020 2020 2020 6e31 3d73 656c 662e 6e5b        n1=self.n[
+0001da20: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+0001da30: 2020 2020 6e32 3d73 656c 662e 6e5b 315d      n2=self.n[1]
+0001da40: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001da50: 2020 7873 6361 6c65 3d73 656c 662e 5f73    xscale=self._s
+0001da60: 6361 6c65 735b 305d 2c0a 2020 2020 2020  cales[0],.      
+0001da70: 2020 2020 2020 2020 2020 7973 6361 6c65            yscale
+0001da80: 3d73 656c 662e 5f73 6361 6c65 735b 315d  =self._scales[1]
+0001da90: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+0001daa0: 2020 2020 2020 2020 2020 2078 782c 2079             xx, y
+0001dab0: 792c 207a 7a20 3d20 732e 6765 745f 6461  y, zz = s.get_da
+0001dac0: 7461 2829 0a20 2020 2020 2020 2020 2020  ta().           
+0001dad0: 2069 6620 286c 656e 2866 7329 203e 2031   if (len(fs) > 1
+0001dae0: 2920 616e 6420 7365 6c66 2e5f 7573 655f  ) and self._use_
+0001daf0: 6e61 6e3a 0a20 2020 2020 2020 2020 2020  nan:.           
+0001db00: 2020 2020 2069 6478 203d 206e 702e 6c6f       idx = np.lo
+0001db10: 6769 6361 6c5f 6f72 287a 7a20 3c20 7365  gical_or(zz < se
+0001db20: 6c66 2e7a 5f72 616e 6765 5b31 5d2c 207a  lf.z_range[1], z
+0001db30: 7a20 3e20 7365 6c66 2e7a 5f72 616e 6765  z > self.z_range
+0001db40: 5b32 5d29 0a20 2020 2020 2020 2020 2020  [2]).           
+0001db50: 2020 2020 207a 7a5b 6964 785d 203d 206e       zz[idx] = n
+0001db60: 702e 6e61 6e0a 2020 2020 2020 2020 7265  p.nan.        re
+0001db70: 7475 726e 2073 656c 662e 5f61 7070 6c79  turn self._apply
+0001db80: 5f74 7261 6e73 666f 726d 2878 782c 2079  _transform(xx, y
+0001db90: 792c 207a 7a29 0a0a 0a63 6c61 7373 2047  y, zz)...class G
+0001dba0: 656f 6d65 7472 7953 6572 6965 7328 4c69  eometrySeries(Li
+0001dbb0: 6e65 3244 4261 7365 5365 7269 6573 293a  ne2DBaseSeries):
+0001dbc0: 0a20 2020 2022 2222 5265 7072 6573 656e  .    """Represen
+0001dbd0: 7473 2061 6e20 656e 7469 7479 2066 726f  ts an entity fro
+0001dbe0: 6d20 7468 6520 7379 6d70 792e 6765 6f6d  m the sympy.geom
+0001dbf0: 6574 7279 206d 6f64 756c 652e 0a20 2020  etry module..   
+0001dc00: 2044 6570 656e 6469 6e67 206f 6e20 7468   Depending on th
+0001dc10: 6520 6765 6f6d 6574 7279 2065 6e74 6974  e geometry entit
+0001dc20: 792c 2074 6869 7320 636c 6173 7320 6361  y, this class ca
+0001dc30: 6e20 6569 7468 6572 2072 6570 7265 7365  n either represe
+0001dc40: 6e74 7320 610a 2020 2020 706f 696e 742c  nts a.    point,
+0001dc50: 2061 206c 696e 652c 206f 7220 6120 7061   a line, or a pa
+0001dc60: 7261 6d65 7472 6963 206c 696e 650a 2020  rametric line.  
+0001dc70: 2020 2222 220a 0a20 2020 2069 735f 6765    """..    is_ge
+0001dc80: 6f6d 6574 7279 203d 2054 7275 650a 0a20  ometry = True.. 
+0001dc90: 2020 2064 6566 205f 5f6e 6577 5f5f 2863     def __new__(c
+0001dca0: 6c73 2c20 2a61 7267 732c 202a 2a6b 7761  ls, *args, **kwa
+0001dcb0: 7267 7329 3a0a 2020 2020 2020 2020 6966  rgs):.        if
+0001dcc0: 2069 7369 6e73 7461 6e63 6528 6172 6773   isinstance(args
+0001dcd0: 5b30 5d2c 2050 6c61 6e65 293a 0a20 2020  [0], Plane):.   
+0001dce0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001dcf0: 506c 616e 6553 6572 6965 7328 2a61 7267  PlaneSeries(*arg
+0001dd00: 732c 202a 2a6b 7761 7267 7329 0a20 2020  s, **kwargs).   
+0001dd10: 2020 2020 2065 6c69 6620 6973 696e 7374       elif isinst
+0001dd20: 616e 6365 2861 7267 735b 305d 2c20 4375  ance(args[0], Cu
+0001dd30: 7276 6529 3a0a 2020 2020 2020 2020 2020  rve):.          
+0001dd40: 2020 6e65 775f 636c 7320 3d20 280a 2020    new_cls = (.  
+0001dd50: 2020 2020 2020 2020 2020 2020 2020 5061                Pa
+0001dd60: 7261 6d65 7472 6963 3244 4c69 6e65 5365  rametric2DLineSe
+0001dd70: 7269 6573 0a20 2020 2020 2020 2020 2020  ries.           
+0001dd80: 2020 2020 2069 6620 6c65 6e28 6172 6773       if len(args
+0001dd90: 5b30 5d2e 6675 6e63 7469 6f6e 7329 203d  [0].functions) =
+0001dda0: 3d20 320a 2020 2020 2020 2020 2020 2020  = 2.            
+0001ddb0: 2020 2020 656c 7365 2050 6172 616d 6574      else Paramet
+0001ddc0: 7269 6333 444c 696e 6553 6572 6965 730a  ric3DLineSeries.
+0001ddd0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0001dde0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0001ddf0: 206e 6577 5f63 6c73 282a 6172 6773 5b30   new_cls(*args[0
+0001de00: 5d2e 6675 6e63 7469 6f6e 732c 2061 7267  ].functions, arg
+0001de10: 735b 305d 2e6c 696d 6974 732c 202a 2a6b  s[0].limits, **k
+0001de20: 7761 7267 7329 0a20 2020 2020 2020 2072  wargs).        r
+0001de30: 6574 7572 6e20 6f62 6a65 6374 2e5f 5f6e  eturn object.__n
+0001de40: 6577 5f5f 2863 6c73 290a 0a20 2020 2064  ew__(cls)..    d
+0001de50: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+0001de60: 2c20 6578 7072 2c20 5f72 616e 6765 3d4e  , expr, _range=N
+0001de70: 6f6e 652c 206c 6162 656c 3d22 222c 202a  one, label="", *
+0001de80: 2a6b 7761 7267 7329 3a0a 2020 2020 2020  *kwargs):.      
+0001de90: 2020 6966 206e 6f74 2069 7369 6e73 7461    if not isinsta
+0001dea0: 6e63 6528 6578 7072 2c20 4765 6f6d 6574  nce(expr, Geomet
+0001deb0: 7279 456e 7469 7479 293a 0a20 2020 2020  ryEntity):.     
+0001dec0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+0001ded0: 7565 4572 726f 7228 0a20 2020 2020 2020  ueError(.       
+0001dee0: 2020 2020 2020 2020 2022 6065 7870 7260           "`expr`
+0001def0: 206d 7573 7420 6265 2061 2067 656f 6d74   must be a geomt
+0001df00: 7269 6320 656e 7469 7479 2e5c 6e22 0a20  ric entity.\n". 
+0001df10: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+0001df20: 2022 5265 6365 6976 6564 3a20 7479 7065   "Received: type
+0001df30: 2865 7870 7229 203d 207b 7d5c 6e22 2e66  (expr) = {}\n".f
+0001df40: 6f72 6d61 7428 7479 7065 2865 7870 7229  ormat(type(expr)
+0001df50: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0001df60: 2020 2b20 2245 7870 723a 207b 7d22 2e66    + "Expr: {}".f
+0001df70: 6f72 6d61 7428 6578 7072 290a 2020 2020  ormat(expr).    
+0001df80: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0001df90: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
+0001dfa0: 5f5f 282a 2a6b 7761 7267 7329 0a20 2020  __(**kwargs).   
+0001dfb0: 2020 2020 2072 203d 2065 7870 722e 6672       r = expr.fr
+0001dfc0: 6565 5f73 796d 626f 6c73 2e64 6966 6665  ee_symbols.diffe
+0001dfd0: 7265 6e63 6528 7365 7428 7365 6c66 2e70  rence(set(self.p
+0001dfe0: 6172 616d 732e 6b65 7973 2829 2929 0a20  arams.keys())). 
+0001dff0: 2020 2020 2020 2069 6620 6c65 6e28 7229         if len(r)
+0001e000: 203e 2030 3a0a 2020 2020 2020 2020 2020   > 0:.          
+0001e010: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+0001e020: 6f72 280a 2020 2020 2020 2020 2020 2020  or(.            
+0001e030: 2020 2020 2254 6f6f 206d 616e 7920 6672      "Too many fr
+0001e040: 6565 2073 796d 626f 6c73 2e20 506c 6561  ee symbols. Plea
+0001e050: 7365 2c20 7370 6563 6966 7920 7468 6520  se, specify the 
+0001e060: 7661 6c75 6573 206f 6620 7468 6520 220a  values of the ".
+0001e070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e080: 6622 666f 6c6c 6f77 696e 6720 7379 6d62  f"following symb
+0001e090: 6f6c 7320 7769 7468 2074 6865 2060 7061  ols with the `pa
+0001e0a0: 7261 6d73 6020 6469 6374 696f 6e61 7279  rams` dictionary
+0001e0b0: 3a20 7b72 7d22 0a20 2020 2020 2020 2020  : {r}".         
+0001e0c0: 2020 2029 0a20 2020 2020 2020 2073 656c     ).        sel
+0001e0d0: 662e 5f65 7870 7220 3d20 6578 7072 0a20  f._expr = expr. 
+0001e0e0: 2020 2020 2020 2073 656c 662e 7261 6e67         self.rang
+0001e0f0: 6573 203d 205b 5f72 616e 6765 5d0a 2020  es = [_range].  
+0001e100: 2020 2020 2020 7365 6c66 2e5f 6c61 6265        self._labe
+0001e110: 6c20 3d20 7374 7228 6578 7072 2920 6966  l = str(expr) if
+0001e120: 206c 6162 656c 2069 7320 4e6f 6e65 2065   label is None e
+0001e130: 6c73 6520 6c61 6265 6c0a 2020 2020 2020  lse label.      
+0001e140: 2020 7365 6c66 2e5f 6c61 7465 785f 6c61    self._latex_la
+0001e150: 6265 6c20 3d20 6c61 7465 7828 6578 7072  bel = latex(expr
+0001e160: 2920 6966 206c 6162 656c 2069 7320 4e6f  ) if label is No
+0001e170: 6e65 2065 6c73 6520 6c61 6265 6c0a 2020  ne else label.  
+0001e180: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+0001e190: 6e63 6528 6578 7072 2c20 284c 696e 6561  nce(expr, (Linea
+0001e1a0: 7245 6e74 6974 7933 442c 2050 6f69 6e74  rEntity3D, Point
+0001e1b0: 3344 2929 3a0a 2020 2020 2020 2020 2020  3D)):.          
+0001e1c0: 2020 7365 6c66 2e69 735f 3244 6c69 6e65    self.is_2Dline
+0001e1d0: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
+0001e1e0: 2020 2020 2073 656c 662e 6973 5f33 446c       self.is_3Dl
+0001e1f0: 696e 6520 3d20 5472 7565 0a20 2020 2020  ine = True.     
+0001e200: 2020 2020 2020 2073 656c 662e 6973 5f70         self.is_p
+0001e210: 6172 616d 6574 7269 6320 3d20 4661 6c73  arametric = Fals
+0001e220: 650a 2020 2020 2020 2020 2020 2020 6966  e.            if
+0001e230: 2069 7369 6e73 7461 6e63 6528 6578 7072   isinstance(expr
+0001e240: 2c20 506f 696e 7433 4429 3a0a 2020 2020  , Point3D):.    
+0001e250: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001e260: 2e69 735f 706f 696e 7420 3d20 5472 7565  .is_point = True
+0001e270: 0a20 2020 2020 2020 2065 6c69 6620 6973  .        elif is
+0001e280: 696e 7374 616e 6365 2865 7870 722c 204c  instance(expr, L
+0001e290: 696e 6561 7245 6e74 6974 7932 4429 3a0a  inearEntity2D):.
+0001e2a0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001e2b0: 2e69 735f 3244 6c69 6e65 203d 2054 7275  .is_2Dline = Tru
+0001e2c0: 650a 2020 2020 2020 2020 656c 6966 2069  e.        elif i
+0001e2d0: 7369 6e73 7461 6e63 6528 6578 7072 2c20  sinstance(expr, 
+0001e2e0: 2850 6f6c 7967 6f6e 2c20 4369 7263 6c65  (Polygon, Circle
+0001e2f0: 2c20 456c 6c69 7073 6529 293a 0a20 2020  , Ellipse)):.   
+0001e300: 2020 2020 2020 2020 2073 656c 662e 6973           self.is
+0001e310: 5f32 446c 696e 6520 3d20 6e6f 7420 7365  _2Dline = not se
+0001e320: 6c66 2e69 735f 6669 6c6c 6564 0a20 2020  lf.is_filled.   
+0001e330: 2020 2020 2065 6c69 6620 6973 696e 7374       elif isinst
+0001e340: 616e 6365 2865 7870 722c 2050 6f69 6e74  ance(expr, Point
+0001e350: 3244 293a 0a20 2020 2020 2020 2020 2020  2D):.           
+0001e360: 2073 656c 662e 6973 5f70 6f69 6e74 203d   self.is_point =
+0001e370: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+0001e380: 2020 7365 6c66 2e69 735f 3244 6c69 6e65    self.is_2Dline
+0001e390: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
+0001e3a0: 2020 2020 7365 6c66 2e70 6f6c 6573 5f6c      self.poles_l
+0001e3b0: 6f63 6174 696f 6e73 203d 205b 5d0a 0a20  ocations = [].. 
+0001e3c0: 2020 2064 6566 2067 6574 5f64 6174 6128     def get_data(
+0001e3d0: 7365 6c66 293a 0a20 2020 2020 2020 206e  self):.        n
+0001e3e0: 7020 3d20 696d 706f 7274 5f6d 6f64 756c  p = import_modul
+0001e3f0: 6528 276e 756d 7079 2729 0a0a 2020 2020  e('numpy')..    
+0001e400: 2020 2020 6578 7072 203d 2073 656c 662e      expr = self.
+0001e410: 6578 7072 2e73 7562 7328 7365 6c66 2e70  expr.subs(self.p
+0001e420: 6172 616d 7329 0a20 2020 2020 2020 2069  arams).        i
+0001e430: 6620 6973 696e 7374 616e 6365 2865 7870  f isinstance(exp
+0001e440: 722c 2050 6f69 6e74 3344 293a 0a20 2020  r, Point3D):.   
+0001e450: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001e460: 7365 6c66 2e5f 6170 706c 795f 7472 616e  self._apply_tran
+0001e470: 7366 6f72 6d28 0a20 2020 2020 2020 2020  sform(.         
+0001e480: 2020 2020 2020 206e 702e 6172 7261 7928         np.array(
+0001e490: 5b65 7870 722e 785d 2c20 6474 7970 653d  [expr.x], dtype=
+0001e4a0: 666c 6f61 7429 2c0a 2020 2020 2020 2020  float),.        
+0001e4b0: 2020 2020 2020 2020 6e70 2e61 7272 6179          np.array
+0001e4c0: 285b 6578 7072 2e79 5d2c 2064 7479 7065  ([expr.y], dtype
+0001e4d0: 3d66 6c6f 6174 292c 0a20 2020 2020 2020  =float),.       
+0001e4e0: 2020 2020 2020 2020 206e 702e 6172 7261           np.arra
+0001e4f0: 7928 5b65 7870 722e 7a5d 2c20 6474 7970  y([expr.z], dtyp
+0001e500: 653d 666c 6f61 7429 0a20 2020 2020 2020  e=float).       
+0001e510: 2020 2020 2029 0a20 2020 2020 2020 2065       ).        e
+0001e520: 6c69 6620 6973 696e 7374 616e 6365 2865  lif isinstance(e
+0001e530: 7870 722c 2050 6f69 6e74 3244 293a 0a20  xpr, Point2D):. 
+0001e540: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001e550: 6e20 7365 6c66 2e5f 6170 706c 795f 7472  n self._apply_tr
+0001e560: 616e 7366 6f72 6d28 0a20 2020 2020 2020  ansform(.       
+0001e570: 2020 2020 2020 2020 206e 702e 6172 7261           np.arra
+0001e580: 7928 5b65 7870 722e 785d 2c20 6474 7970  y([expr.x], dtyp
+0001e590: 653d 666c 6f61 7429 2c0a 2020 2020 2020  e=float),.      
+0001e5a0: 2020 2020 2020 2020 2020 6e70 2e61 7272            np.arr
+0001e5b0: 6179 285b 6578 7072 2e79 5d2c 2064 7479  ay([expr.y], dty
+0001e5c0: 7065 3d66 6c6f 6174 290a 2020 2020 2020  pe=float).      
+0001e5d0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0001e5e0: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
+0001e5f0: 6578 7072 2c20 506f 6c79 676f 6e29 3a0a  expr, Polygon):.
+0001e600: 2020 2020 2020 2020 2020 2020 7820 3d20              x = 
+0001e610: 5b66 6c6f 6174 2876 2e78 2920 666f 7220  [float(v.x) for 
+0001e620: 7620 696e 2065 7870 722e 7665 7274 6963  v in expr.vertic
+0001e630: 6573 5d0a 2020 2020 2020 2020 2020 2020  es].            
+0001e640: 7920 3d20 5b66 6c6f 6174 2876 2e79 2920  y = [float(v.y) 
+0001e650: 666f 7220 7620 696e 2065 7870 722e 7665  for v in expr.ve
+0001e660: 7274 6963 6573 5d0a 2020 2020 2020 2020  rtices].        
+0001e670: 2020 2020 782e 6170 7065 6e64 2878 5b30      x.append(x[0
+0001e680: 5d29 0a20 2020 2020 2020 2020 2020 2079  ]).            y
+0001e690: 2e61 7070 656e 6428 795b 305d 290a 2020  .append(y[0]).  
+0001e6a0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0001e6b0: 2073 656c 662e 5f61 7070 6c79 5f74 7261   self._apply_tra
+0001e6c0: 6e73 666f 726d 286e 702e 6172 7261 7928  nsform(np.array(
+0001e6d0: 7829 2c20 6e70 2e61 7272 6179 2879 2929  x), np.array(y))
+0001e6e0: 0a20 2020 2020 2020 2065 6c69 6620 6973  .        elif is
+0001e6f0: 696e 7374 616e 6365 2865 7870 722c 2043  instance(expr, C
+0001e700: 6972 636c 6529 3a0a 2020 2020 2020 2020  ircle):.        
+0001e710: 2020 2020 6378 2c20 6379 203d 2066 6c6f      cx, cy = flo
+0001e720: 6174 2865 7870 722e 6365 6e74 6572 5b30  at(expr.center[0
+0001e730: 5d29 2c20 666c 6f61 7428 6578 7072 2e63  ]), float(expr.c
+0001e740: 656e 7465 725b 315d 290a 2020 2020 2020  enter[1]).      
+0001e750: 2020 2020 2020 7220 3d20 666c 6f61 7428        r = float(
+0001e760: 6578 7072 2e72 6164 6975 7329 0a20 2020  expr.radius).   
+0001e770: 2020 2020 2020 2020 2074 203d 206e 702e           t = np.
+0001e780: 6c69 6e73 7061 6365 2830 2c20 3220 2a20  linspace(0, 2 * 
+0001e790: 6e70 2e70 692c 2073 656c 662e 6e5b 305d  np.pi, self.n[0]
+0001e7a0: 290a 2020 2020 2020 2020 2020 2020 782c  ).            x,
+0001e7b0: 2079 203d 2063 7820 2b20 7220 2a20 6e70   y = cx + r * np
+0001e7c0: 2e63 6f73 2874 292c 2063 7920 2b20 7220  .cos(t), cy + r 
+0001e7d0: 2a20 6e70 2e73 696e 2874 290a 2020 2020  * np.sin(t).    
+0001e7e0: 2020 2020 2020 2020 7820 3d20 6e70 2e61          x = np.a
+0001e7f0: 7070 656e 6428 782c 2078 5b30 5d29 0a20  ppend(x, x[0]). 
+0001e800: 2020 2020 2020 2020 2020 2079 203d 206e             y = n
+0001e810: 702e 6170 7065 6e64 2879 2c20 795b 305d  p.append(y, y[0]
+0001e820: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0001e830: 7475 726e 2073 656c 662e 5f61 7070 6c79  turn self._apply
+0001e840: 5f74 7261 6e73 666f 726d 2878 2c20 7929  _transform(x, y)
+0001e850: 0a20 2020 2020 2020 2065 6c69 6620 6973  .        elif is
+0001e860: 696e 7374 616e 6365 2865 7870 722c 2045  instance(expr, E
+0001e870: 6c6c 6970 7365 293a 0a20 2020 2020 2020  llipse):.       
+0001e880: 2020 2020 2063 782c 2063 7920 3d20 666c       cx, cy = fl
+0001e890: 6f61 7428 6578 7072 2e63 656e 7465 725b  oat(expr.center[
+0001e8a0: 305d 292c 2066 6c6f 6174 2865 7870 722e  0]), float(expr.
+0001e8b0: 6365 6e74 6572 5b31 5d29 0a20 2020 2020  center[1]).     
+0001e8c0: 2020 2020 2020 2061 203d 2066 6c6f 6174         a = float
+0001e8d0: 2865 7870 722e 6872 6164 6975 7329 0a20  (expr.hradius). 
+0001e8e0: 2020 2020 2020 2020 2020 2065 203d 2066             e = f
+0001e8f0: 6c6f 6174 2865 7870 722e 6563 6365 6e74  loat(expr.eccent
+0001e900: 7269 6369 7479 290a 2020 2020 2020 2020  ricity).        
+0001e910: 2020 2020 7820 3d20 6e70 2e6c 696e 7370      x = np.linsp
+0001e920: 6163 6528 2d61 2c20 612c 2073 656c 662e  ace(-a, a, self.
+0001e930: 6e5b 305d 290a 2020 2020 2020 2020 2020  n[0]).          
+0001e940: 2020 7920 3d20 6e70 2e73 7172 7428 2861    y = np.sqrt((a
+0001e950: 202a 2a20 3220 2d20 7820 2a2a 2032 2920   ** 2 - x ** 2) 
+0001e960: 2a20 2831 202d 2065 202a 2a20 3229 290a  * (1 - e ** 2)).
+0001e970: 2020 2020 2020 2020 2020 2020 7820 2b3d              x +=
+0001e980: 2063 780a 2020 2020 2020 2020 2020 2020   cx.            
+0001e990: 782c 2079 203d 206e 702e 636f 6e63 6174  x, y = np.concat
+0001e9a0: 656e 6174 6528 2878 2c20 785b 3a3a 2d31  enate((x, x[::-1
+0001e9b0: 5d29 292c 206e 702e 636f 6e63 6174 656e  ])), np.concaten
+0001e9c0: 6174 6528 2863 7920 2b20 792c 2063 7920  ate((cy + y, cy 
+0001e9d0: 2d20 795b 3a3a 2d31 5d29 290a 2020 2020  - y[::-1])).    
+0001e9e0: 2020 2020 2020 2020 7820 3d20 6e70 2e61          x = np.a
+0001e9f0: 7070 656e 6428 782c 2078 5b30 5d29 0a20  ppend(x, x[0]). 
+0001ea00: 2020 2020 2020 2020 2020 2079 203d 206e             y = n
+0001ea10: 702e 6170 7065 6e64 2879 2c20 795b 305d  p.append(y, y[0]
+0001ea20: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0001ea30: 7475 726e 2073 656c 662e 5f61 7070 6c79  turn self._apply
+0001ea40: 5f74 7261 6e73 666f 726d 2878 2c20 7929  _transform(x, y)
+0001ea50: 0a20 2020 2020 2020 2065 6c69 6620 6973  .        elif is
+0001ea60: 696e 7374 616e 6365 2865 7870 722c 204c  instance(expr, L
+0001ea70: 696e 6561 7245 6e74 6974 7933 4429 3a0a  inearEntity3D):.
+0001ea80: 2020 2020 2020 2020 2020 2020 7031 2c20              p1, 
+0001ea90: 7032 203d 2065 7870 722e 706f 696e 7473  p2 = expr.points
+0001eaa0: 0a20 2020 2020 2020 2020 2020 2078 203d  .            x =
+0001eab0: 206e 702e 6172 7261 7928 5b70 312e 782c   np.array([p1.x,
+0001eac0: 2070 322e 785d 2c20 6474 7970 653d 666c   p2.x], dtype=fl
+0001ead0: 6f61 7429 0a20 2020 2020 2020 2020 2020  oat).           
+0001eae0: 2079 203d 206e 702e 6172 7261 7928 5b70   y = np.array([p
+0001eaf0: 312e 792c 2070 322e 795d 2c20 6474 7970  1.y, p2.y], dtyp
+0001eb00: 653d 666c 6f61 7429 0a20 2020 2020 2020  e=float).       
+0001eb10: 2020 2020 207a 203d 206e 702e 6172 7261       z = np.arra
+0001eb20: 7928 5b70 312e 7a2c 2070 322e 7a5d 2c20  y([p1.z, p2.z], 
+0001eb30: 6474 7970 653d 666c 6f61 7429 0a20 2020  dtype=float).   
+0001eb40: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001eb50: 7365 6c66 2e5f 6170 706c 795f 7472 616e  self._apply_tran
+0001eb60: 7366 6f72 6d28 782c 2079 2c20 7a29 0a20  sform(x, y, z). 
+0001eb70: 2020 2020 2020 2065 6c69 6620 6973 696e         elif isin
+0001eb80: 7374 616e 6365 2865 7870 722c 2028 5365  stance(expr, (Se
+0001eb90: 676d 656e 742c 2052 6179 2929 3a0a 2020  gment, Ray)):.  
+0001eba0: 2020 2020 2020 2020 2020 7031 2c20 7032            p1, p2
+0001ebb0: 203d 2065 7870 722e 706f 696e 7473 0a20   = expr.points. 
+0001ebc0: 2020 2020 2020 2020 2020 2078 203d 206e             x = n
+0001ebd0: 702e 6172 7261 7928 5b70 312e 782c 2070  p.array([p1.x, p
+0001ebe0: 322e 785d 290a 2020 2020 2020 2020 2020  2.x]).          
+0001ebf0: 2020 7920 3d20 6e70 2e61 7272 6179 285b    y = np.array([
+0001ec00: 7031 2e79 2c20 7032 2e79 5d29 0a20 2020  p1.y, p2.y]).   
+0001ec10: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001ec20: 7365 6c66 2e5f 6170 706c 795f 7472 616e  self._apply_tran
+0001ec30: 7366 6f72 6d28 782e 6173 7479 7065 2866  sform(x.astype(f
+0001ec40: 6c6f 6174 292c 2079 2e61 7374 7970 6528  loat), y.astype(
+0001ec50: 666c 6f61 7429 290a 2020 2020 2020 2020  float)).        
+0001ec60: 656c 7365 3a20 2023 204c 696e 650a 2020  else:  # Line.  
+0001ec70: 2020 2020 2020 2020 2020 7031 2c20 7032            p1, p2
+0001ec80: 203d 2065 7870 722e 706f 696e 7473 0a20   = expr.points. 
+0001ec90: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+0001eca0: 7420 7365 6c66 2e72 616e 6765 733a 0a20  t self.ranges:. 
+0001ecb0: 2020 2020 2020 2020 2020 2020 2020 2078                 x
+0001ecc0: 203d 206e 702e 6172 7261 7928 5b70 312e   = np.array([p1.
+0001ecd0: 782c 2070 322e 785d 290a 2020 2020 2020  x, p2.x]).      
+0001ece0: 2020 2020 2020 2020 2020 7920 3d20 6e70            y = np
+0001ecf0: 2e61 7272 6179 285b 7031 2e79 2c20 7032  .array([p1.y, p2
+0001ed00: 2e79 5d29 0a20 2020 2020 2020 2020 2020  .y]).           
+0001ed10: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0001ed20: 2020 2020 2020 205f 7261 6e67 6520 3d20         _range = 
+0001ed30: 7365 6c66 2e72 616e 6765 735b 305d 0a20  self.ranges[0]. 
+0001ed40: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+0001ed50: 203d 2065 7870 722e 736c 6f70 650a 2020   = expr.slope.  
+0001ed60: 2020 2020 2020 2020 2020 2020 2020 7120                q 
+0001ed70: 3d20 7031 5b31 5d20 2d20 6d20 2a20 7031  = p1[1] - m * p1
+0001ed80: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
+0001ed90: 2020 2020 7820 3d20 6e70 2e61 7272 6179      x = np.array
+0001eda0: 285b 5f72 616e 6765 5b31 5d2c 205f 7261  ([_range[1], _ra
+0001edb0: 6e67 655b 325d 5d29 0a20 2020 2020 2020  nge[2]]).       
+0001edc0: 2020 2020 2020 2020 2079 203d 206d 202a           y = m *
+0001edd0: 2078 202b 2071 0a20 2020 2020 2020 2020   x + q.         
+0001ede0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+0001edf0: 6170 706c 795f 7472 616e 7366 6f72 6d28  apply_transform(
+0001ee00: 782e 6173 7479 7065 2866 6c6f 6174 292c  x.astype(float),
+0001ee10: 2079 2e61 7374 7970 6528 666c 6f61 7429   y.astype(float)
+0001ee20: 290a 0a20 2020 2064 6566 205f 5f73 7472  )..    def __str
+0001ee30: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
+0001ee40: 2020 7265 7475 726e 2073 656c 662e 5f73    return self._s
+0001ee50: 7472 5f68 656c 7065 7228 2267 656f 6d65  tr_helper("geome
+0001ee60: 7472 7920 656e 7469 7479 3a20 2573 2220  try entity: %s" 
+0001ee70: 2520 7374 7228 7365 6c66 2e65 7870 7229  % str(self.expr)
+0001ee80: 290a 0a0a 636c 6173 7320 4765 6e65 7269  )...class Generi
+0001ee90: 6344 6174 6153 6572 6965 7328 4261 7365  cDataSeries(Base
+0001eea0: 5365 7269 6573 293a 0a20 2020 2022 2222  Series):.    """
+0001eeb0: 5265 7072 6573 656e 7473 2067 656e 6572  Represents gener
+0001eec0: 6963 206e 756d 6572 6963 616c 2064 6174  ic numerical dat
+0001eed0: 612e 0a0a 2020 2020 4e4f 5445 3a0a 2020  a...    NOTE:.  
+0001eee0: 2020 5468 6973 2063 6c61 7373 2069 6d70    This class imp
+0001eef0: 6c65 6d65 6e74 7320 6261 636b 2d63 6f6d  lements back-com
+0001ef00: 7061 7469 6269 6c69 7479 2077 6974 6820  patibility with 
+0001ef10: 5379 6d70 7920 3c3d 312e 3131 3a20 6974  Sympy <=1.11: it
+0001ef20: 7320 706c 6f74 7469 6e67 0a20 2020 206d  s plotting.    m
+0001ef30: 6f64 756c 6520 6163 6365 7074 7320 7468  odule accepts th
+0001ef40: 6520 666f 6c6c 6f77 696e 6720 6b65 7977  e following keyw
+0001ef50: 6f72 6420 6172 6775 6d65 6e74 733a 0a0a  ord arguments:..
+0001ef60: 2020 2020 616e 6e6f 7461 7469 6f6e 732c      annotations,
+0001ef70: 206d 6172 6b65 7273 2c20 7265 6374 616e   markers, rectan
+0001ef80: 676c 6573 2c20 6669 6c6c 0a0a 2020 2020  gles, fill..    
+0001ef90: 5361 646c 792c 2074 6865 2064 6576 656c  Sadly, the devel
+0001efa0: 6f70 6572 7320 666f 7267 6f74 2074 6f20  opers forgot to 
+0001efb0: 7072 6f70 6572 6c79 2064 6f63 756d 656e  properly documen
+0001efc0: 7420 7468 656d 3a20 7468 6572 6520 6172  t them: there ar
+0001efd0: 6520 6e6f 0a20 2020 2065 7861 6d70 6c65  e no.    example
+0001efe0: 2077 6861 7473 6f65 7665 7220 6162 6f75   whatsoever abou
+0001eff0: 7420 7468 6569 7220 7573 6167 652e 2054  t their usage. T
+0001f000: 6869 7320 6973 2061 6374 7561 6c6c 7920  his is actually 
+0001f010: 6120 7665 7279 2067 6f6f 6420 7468 696e  a very good thin
+0001f020: 670a 2020 2020 666f 7220 7468 6973 206e  g.    for this n
+0001f030: 6577 2070 6c6f 7474 696e 6720 6d6f 6475  ew plotting modu
+0001f040: 6c65 2c20 7768 6963 6820 7375 7070 6f72  le, which suppor
+0001f050: 7473 206d 756c 7469 706c 6520 6261 636b  ts multiple back
+0001f060: 656e 6473 2e0a 2020 2020 4576 6572 7920  ends..    Every 
+0001f070: 6261 636b 656e 6420 6578 706f 7365 7320  backend exposes 
+0001f080: 6469 6666 6572 656e 7420 6675 6e63 7469  different functi
+0001f090: 6f6e 733a 0a0a 2020 2020 312e 2046 6f72  ons:..    1. For
+0001f0a0: 2065 7861 6d70 6c65 2c20 746f 2063 7265   example, to cre
+0001f0b0: 6174 6520 6c69 6e65 2070 6c6f 7473 204d  ate line plots M
+0001f0c0: 6174 706c 6f74 6c69 6220 6578 706f 7365  atplotlib expose
+0001f0d0: 7320 6060 6178 2e70 6c6f 7460 602c 0a20  s ``ax.plot``,. 
+0001f0e0: 2020 2020 2020 7768 6572 6561 7320 506c        whereas Pl
+0001f0f0: 6f74 6c79 2065 7870 6f73 6573 2060 6067  otly exposes ``g
+0001f100: 6f2e 5363 6174 7465 7260 602c 2077 6865  o.Scatter``, whe
+0001f110: 7265 6173 2042 6f6b 6568 2065 7870 6f73  reas Bokeh expos
+0001f120: 6573 0a20 2020 2020 2020 6060 6669 672e  es.       ``fig.
+0001f130: 6c69 6e65 6060 2c20 6574 632e 2042 7574  line``, etc. But
+0001f140: 2074 686f 7365 2064 6966 6665 7265 6e74   those different
+0001f150: 2077 6179 7320 646f 206e 6f74 206f 7665   ways do not ove
+0001f160: 726c 6170 2063 6f6d 706c 6574 656c 793a  rlap completely:
+0001f170: 0a20 2020 2020 2020 7769 7468 2060 6067  .       with ``g
+0001f180: 6f2e 5363 6174 7465 7260 6020 6974 2773  o.Scatter`` it's
+0001f190: 2061 6c73 6f20 706f 7373 6962 6c65 2074   also possible t
+0001f1a0: 6f20 6372 6561 7465 2066 696c 6c65 6420  o create filled 
+0001f1b0: 7265 6769 6f6e 732c 0a20 2020 2020 2020  regions,.       
+0001f1c0: 7768 6572 6561 7320 7769 7468 2060 6061  whereas with ``a
+0001f1d0: 782e 706c 6f74 6060 2074 6861 7427 7320  x.plot`` that's 
+0001f1e0: 6e6f 7420 706f 7373 6962 6c65 2e0a 2020  not possible..  
+0001f1f0: 2020 322e 204d 6f72 656f 7665 722c 2073    2. Moreover, s
+0001f200: 6f6d 6520 706c 6f74 7469 6e67 206c 6962  ome plotting lib
+0001f210: 7261 7279 2065 7870 6f73 6573 2066 756e  rary exposes fun
+0001f220: 6374 696f 6e61 6c69 7469 6573 2074 6861  ctionalities tha
+0001f230: 7420 6172 650a 2020 2020 2020 2075 6e6d  t are.       unm
+0001f240: 6174 6368 6564 2062 7920 6f74 6865 7273  atched by others
+0001f250: 2e20 466f 7220 6578 616d 706c 652c 204d  . For example, M
+0001f260: 6174 706c 6f74 6c69 6227 7320 6060 6178  atplotlib's ``ax
+0001f270: 2e66 696c 6c5f 6265 7477 6565 6e60 6020  .fill_between`` 
+0001f280: 6973 0a20 2020 2020 2020 7375 6273 7461  is.       substa
+0001f290: 6e74 6961 6c6c 7920 6469 6666 6572 656e  ntially differen
+0001f2a0: 7420 6672 6f6d 2050 6c6f 746c 7927 7320  t from Plotly's 
+0001f2b0: 6669 6c6c 6564 2061 7265 6120 6f72 2077  filled area or w
+0001f2c0: 6861 7465 7665 7220 426f 6b65 680a 2020  hatever Bokeh.  
+0001f2d0: 2020 2020 2065 7870 6f73 6573 2e20 5369       exposes. Si
+0001f2e0: 6d69 6c61 726c 792c 204d 6174 706c 6f74  milarly, Matplot
+0001f2f0: 6c69 6227 7320 5265 6374 616e 676c 6520  lib's Rectangle 
+0001f300: 6973 2076 6572 7920 7370 6563 6966 6963  is very specific
+0001f310: 2c20 7768 6572 6561 730a 2020 2020 2020  , whereas.      
+0001f320: 2077 6974 6820 506c 6f74 6c79 2077 6520   with Plotly we 
+0001f330: 6361 6e20 6164 6420 616e 7920 7368 6170  can add any shap
+0001f340: 6520 2872 6563 7461 6e67 6c65 2c20 6c69  e (rectangle, li
+0001f350: 6e65 2c20 2e2e 2e29 2077 6974 6820 7468  ne, ...) with th
+0001f360: 6520 7361 6d65 0a20 2020 2020 2020 6675  e same.       fu
+0001f370: 6e63 7469 6f6e 2063 616c 6c2e 0a0a 2020  nction call...  
+0001f380: 2020 536f 2c20 7468 6520 7072 6f62 6c65    So, the proble
+0001f390: 6d20 6973 2063 6c65 6172 3a20 6966 2064  m is clear: if d
+0001f3a0: 6576 656c 6f70 6572 7320 646f 6375 6d65  evelopers docume
+0001f3b0: 6e74 2061 2066 6561 7475 7265 2074 6f20  nt a feature to 
+0001f3c0: 646f 206f 6e65 0a20 2020 2073 7065 6369  do one.    speci
+0001f3d0: 6669 6320 7468 696e 672c 2075 7365 7273  fic thing, users
+0001f3e0: 2065 7870 6563 7420 6974 2074 6f20 7072   expect it to pr
+0001f3f0: 6f64 7563 6520 636f 6e73 6973 7465 6e74  oduce consistent
+0001f400: 2072 6573 756c 7473 2061 6372 6f73 730a   results across.
+0001f410: 2020 2020 6261 636b 656e 6473 2e20 5468      backends. Th
+0001f420: 6973 2069 7320 636c 6561 726c 7920 696d  is is clearly im
+0001f430: 706f 7373 6962 6c65 2074 6f20 6163 6869  possible to achi
+0001f440: 6576 652e 0a0a 2020 2020 5468 6572 6520  eve...    There 
+0001f450: 6973 2061 6c73 6f20 7468 6520 7072 6f62  is also the prob
+0001f460: 6c65 6d20 6f66 2077 6865 6e20 2265 6e6f  lem of when "eno
+0001f470: 7567 6820 6973 2065 6e6f 7567 6822 3f20  ugh is enough"? 
+0001f480: 4d65 616e 696e 672c 2077 686f 2069 7320  Meaning, who is 
+0001f490: 746f 0a20 2020 2073 746f 7020 616e 796f  to.    stop anyo
+0001f4a0: 6e65 2066 726f 6d20 6164 6469 6e67 206e  ne from adding n
+0001f4b0: 6577 206b 6579 776f 7264 2061 7267 756d  ew keyword argum
+0001f4c0: 656e 7473 2074 6861 7420 6172 6520 6a75  ents that are ju
+0001f4d0: 7374 2077 7261 7070 6572 7320 746f 0a20  st wrappers to. 
+0001f4e0: 2020 2077 6861 7420 6120 706c 6f74 7469     what a plotti
+0001f4f0: 6e67 206c 6962 7261 7279 2061 6c72 6561  ng library alrea
+0001f500: 6479 2063 616e 2064 6f3f 2046 6f72 2065  dy can do? For e
+0001f510: 7861 6d70 6c65 2c20 4920 636f 756c 6420  xample, I could 
+0001f520: 6164 6420 7468 650a 2020 2020 6060 6865  add the.    ``he
+0001f530: 785f 7469 6c65 6060 206b 6579 776f 7264  x_tile`` keyword
+0001f540: 3a20 6974 2773 2062 6561 7574 6966 756c  : it's beautiful
+0001f550: 2066 6f72 2042 6f6b 6568 2c20 6275 7420   for Bokeh, but 
+0001f560: 7665 7279 2064 6966 6669 6375 6c74 0a20  very difficult. 
+0001f570: 2020 2074 6f20 696d 706c 656d 656e 7420     to implement 
+0001f580: 6f6e 206f 7468 6572 2062 6163 6b65 6e64  on other backend
+0001f590: 732e 204f 7220 6d61 7962 6520 4920 636f  s. Or maybe I co
+0001f5a0: 756c 6420 6164 6420 6060 686c 696e 6573  uld add ``hlines
+0001f5b0: 6060 206f 720a 2020 2020 6060 766c 696e  `` or.    ``vlin
+0001f5c0: 6573 6060 206b 6579 776f 7264 2061 7267  es`` keyword arg
+0001f5d0: 756d 656e 7473 2074 6f20 6164 6420 686f  uments to add ho
+0001f5e0: 7269 7a6f 6e74 616c 206f 7220 7665 7274  rizontal or vert
+0001f5f0: 6963 616c 206c 696e 6573 2e20 4966 2074  ical lines. If t
+0001f600: 6869 730a 2020 2020 6170 7072 6f61 6368  his.    approach
+0001f610: 2077 6173 2074 6f20 6265 2066 6f6c 6c6f   was to be follo
+0001f620: 7765 642c 2077 6520 7769 6c6c 2065 6e64  wed, we will end
+0001f630: 2075 7020 7265 7772 6974 696e 6720 6d75   up rewriting mu
+0001f640: 6c74 6970 6c65 2070 6c6f 7474 696e 670a  ltiple plotting.
+0001f650: 2020 2020 6c69 6272 6172 6965 733a 2066      libraries: f
+0001f660: 6f72 2077 6861 743f 0a0a 2020 2020 496e  or what?..    In
+0001f670: 7374 6561 642c 2074 6865 2067 6f61 6c20  stead, the goal 
+0001f680: 6f66 2074 6869 7320 6d6f 6475 6c65 2069  of this module i
+0001f690: 7320 746f 2066 6163 696c 6974 6174 6520  s to facilitate 
+0001f6a0: 7468 6520 706c 6f74 7469 6e67 206f 6620  the plotting of 
+0001f6b0: 7379 6d62 6f6c 6963 0a20 2020 2065 7870  symbolic.    exp
+0001f6c0: 7265 7373 696f 6e73 2e20 4966 2075 7365  ressions. If use
+0001f6d0: 7220 6e65 6564 7320 746f 2061 6464 206e  r needs to add n
+0001f6e0: 756d 6572 6963 616c 2064 6174 6120 746f  umerical data to
+0001f6f0: 2061 2070 6c6f 742c 2068 652f 7368 6520   a plot, he/she 
+0001f700: 6361 6e0a 2020 2020 6561 7369 6c79 2072  can.    easily r
+0001f710: 6574 7269 6576 6520 7468 6520 6669 6775  etrieve the figu
+0001f720: 7265 206f 626a 6563 7420 616e 6420 7072  re object and pr
+0001f730: 6f63 6565 6420 7769 7468 2074 6865 2075  oceed with the u
+0001f740: 7375 616c 2063 6f6d 6d61 6e64 730a 2020  sual commands.  
+0001f750: 2020 6173 736f 6369 6174 6564 2074 6f20    associated to 
+0001f760: 6120 7370 6563 6966 6963 2070 6c6f 7474  a specific plott
+0001f770: 696e 6720 6c69 6272 6172 792e 0a20 2020  ing library..   
+0001f780: 2046 6f72 2065 7861 6d70 6c65 2c20 666f   For example, fo
+0001f790: 7220 6060 4d61 7470 6c6f 746c 6962 4261  r ``MatplotlibBa
+0001f7a0: 636b 656e 6460 603a 0a0a 2020 2020 2e2e  ckend``:..    ..
+0001f7b0: 2063 6f64 652d 626c 6f63 6b3a 3a20 7079   code-block:: py
+0001f7c0: 7468 6f6e 0a0a 2020 2020 2020 2066 726f  thon..       fro
+0001f7d0: 6d20 7379 6d70 7920 696d 706f 7274 202a  m sympy import *
+0001f7e0: 0a20 2020 2020 2020 6672 6f6d 2073 7062  .       from spb
+0001f7f0: 2069 6d70 6f72 7420 2a0a 2020 2020 2020   import *.      
+0001f800: 2069 6d70 6f72 7420 6e75 6d70 7920 6173   import numpy as
+0001f810: 206e 700a 2020 2020 2020 2076 6172 2822   np.       var("
+0001f820: 7822 290a 0a20 2020 2020 2020 2320 706c  x")..       # pl
+0001f830: 6f74 2073 796d 626f 6c69 6320 6578 7072  ot symbolic expr
+0001f840: 6573 7369 6f6e 730a 2020 2020 2020 2070  essions.       p
+0001f850: 203d 2070 6c6f 7428 7369 6e28 7829 2c20   = plot(sin(x), 
+0001f860: 636f 7328 7829 2c20 6261 636b 656e 643d  cos(x), backend=
+0001f870: 4d42 290a 2020 2020 2020 2023 2065 7874  MB).       # ext
+0001f880: 7261 6374 2074 6865 2061 7865 7320 6f62  ract the axes ob
+0001f890: 6a65 6374 0a20 2020 2020 2020 6178 203d  ject.       ax =
+0001f8a0: 2070 2e66 6967 2e61 7865 735b 305d 0a20   p.fig.axes[0]. 
+0001f8b0: 2020 2020 2020 2320 6164 6420 6e75 6d65        # add nume
+0001f8c0: 7269 6361 6c20 6461 7461 0a20 2020 2020  rical data.     
+0001f8d0: 2020 7878 203d 206e 702e 6c69 6e73 7061    xx = np.linspa
+0001f8e0: 6365 282d 3130 2c20 3130 290a 2020 2020  ce(-10, 10).    
+0001f8f0: 2020 2066 203d 2031 202f 2028 3120 2b20     f = 1 / (1 + 
+0001f900: 6e70 2e65 7870 282d 7878 2929 0a20 2020  np.exp(-xx)).   
+0001f910: 2020 2020 6178 2e70 6c6f 7428 7878 2c20      ax.plot(xx, 
+0001f920: 6631 2c20 226b 3a22 2c20 6c61 6265 6c3d  f1, "k:", label=
+0001f930: 226e 756d 6572 6963 616c 2064 6174 6122  "numerical data"
+0001f940: 290a 2020 2020 2020 2061 782e 6c65 6765  ).       ax.lege
+0001f950: 6e64 2829 0a20 2020 2020 2020 702e 6669  nd().       p.fi
+0001f960: 670a 0a20 2020 2048 656e 6365 2c20 7468  g..    Hence, th
+0001f970: 6520 6465 6369 7369 6f6e 2074 6f20 6d61  e decision to ma
+0001f980: 696e 7461 696e 2074 6869 7320 6261 636b  intain this back
+0001f990: 2d63 6f6d 7061 7469 6269 6c69 7479 2028  -compatibility (
+0001f9a0: 666f 7220 7468 6520 6d6f 6d65 6e74 290a  for the moment).
+0001f9b0: 2020 2020 6275 7420 6e6f 7420 746f 2064      but not to d
+0001f9c0: 6f63 756d 656e 7420 7468 6f73 6520 6b65  ocument those ke
+0001f9d0: 7977 6f72 6420 6172 6775 6d65 6e74 7320  yword arguments 
+0001f9e0: 6f6e 2074 6865 2070 6c6f 7474 696e 6720  on the plotting 
+0001f9f0: 6675 6e63 7469 6f6e 732e 0a20 2020 2022  functions..    "
+0001fa00: 2222 0a20 2020 2069 735f 6765 6e65 7269  "".    is_generi
+0001fa10: 6320 3d20 5472 7565 0a0a 2020 2020 6465  c = True..    de
+0001fa20: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
+0001fa30: 2074 702c 202a 6172 6773 2c20 2a2a 6b77   tp, *args, **kw
+0001fa40: 6172 6773 293a 0a20 2020 2020 2020 2073  args):.        s
+0001fa50: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
+0001fa60: 2a2a 6b77 6172 6773 290a 2020 2020 2020  **kwargs).      
+0001fa70: 2020 7365 6c66 2e74 7970 6520 3d20 7470    self.type = tp
+0001fa80: 0a20 2020 2020 2020 2073 656c 662e 6172  .        self.ar
+0001fa90: 6773 203d 2061 7267 730a 2020 2020 2020  gs = args.      
+0001faa0: 2020 7365 6c66 2e72 656e 6465 7269 6e67    self.rendering
+0001fab0: 5f6b 7720 3d20 6b77 6172 6773 0a0a 2020  _kw = kwargs..  
+0001fac0: 2020 6465 6620 6765 745f 6461 7461 2873    def get_data(s
+0001fad0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0001fae0: 7475 726e 2073 656c 662e 6172 6773 0a0a  turn self.args..
+0001faf0: 0a63 6c61 7373 2052 6965 6d61 6e6e 5370  .class RiemannSp
+0001fb00: 6865 7265 5365 7269 6573 2842 6173 6553  hereSeries(BaseS
+0001fb10: 6572 6965 7329 3a0a 2020 2020 6973 5f63  eries):.    is_c
+0001fb20: 6f6d 706c 6578 203d 2054 7275 650a 2020  omplex = True.  
+0001fb30: 2020 6973 5f64 6f6d 6169 6e5f 636f 6c6f    is_domain_colo
+0001fb40: 7269 6e67 203d 2054 7275 650a 2020 2020  ring = True.    
+0001fb50: 6973 5f33 4473 7572 6661 6365 203d 2054  is_3Dsurface = T
+0001fb60: 7275 650a 2020 2020 5f4e 203d 2031 3530  rue.    _N = 150
+0001fb70: 0a20 2020 205f 616c 6c6f 7765 645f 6b65  .    _allowed_ke
+0001fb80: 7973 203d 205b 0a20 2020 2020 2020 2022  ys = [.        "
+0001fb90: 636d 6170 222c 2022 636f 6c6f 7269 6e67  cmap", "coloring
+0001fba0: 222c 2022 626c 6576 656c 222c 2022 7068  ", "blevel", "ph
+0001fbb0: 6173 6572 6573 222c 2022 7068 6173 656f  aseres", "phaseo
+0001fbc0: 6666 7365 7422 5d0a 0a20 2020 2064 6566  ffset"]..    def
+0001fbd0: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+0001fbe0: 662c 2072 616e 6765 5f74 2c20 7261 6e67  f, range_t, rang
+0001fbf0: 655f 702c 202a 2a6b 7761 7267 7329 3a0a  e_p, **kwargs):.
+0001fc00: 2020 2020 2020 2020 7365 6c66 2e5f 626c          self._bl
+0001fc10: 6f63 6b5f 6c61 6d62 6461 5f66 756e 6374  ock_lambda_funct
+0001fc20: 696f 6e73 2866 290a 2020 2020 2020 2020  ions(f).        
+0001fc30: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+0001fc40: 282a 2a6b 7761 7267 7329 0a20 2020 2020  (**kwargs).     
+0001fc50: 2020 2069 6620 6c65 6e28 662e 6672 6565     if len(f.free
+0001fc60: 5f73 796d 626f 6c73 2920 3e20 313a 0a20  _symbols) > 1:. 
+0001fc70: 2020 2020 2020 2020 2020 2023 204e 4f54             # NOT
+0001fc80: 453a 2063 6f6e 7369 6465 7269 6e67 2068  E: considering h
+0001fc90: 6f77 2063 6f6d 7075 7461 7469 6f6e 616c  ow computational
+0001fca0: 6c79 2068 6561 7679 2074 6869 7320 7365  ly heavy this se
+0001fcb0: 7269 6573 2069 732c 0a20 2020 2020 2020  ries is,.       
+0001fcc0: 2020 2020 2023 2069 7420 6973 2072 6174       # it is rat
+0001fcd0: 6865 7220 756e 7573 6566 756c 2074 6f20  her unuseful to 
+0001fce0: 616c 6c6f 7720 696e 7465 7261 6374 6976  allow interactiv
+0001fcf0: 652d 7769 6467 6574 7320 706c 6f74 2e0a  e-widgets plot..
+0001fd00: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0001fd10: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
+0001fd20: 2020 2020 2020 2020 2020 2020 2020 2243                "C
+0001fd30: 6f6d 706c 6578 2066 756e 6374 696f 6e20  omplex function 
+0001fd40: 6361 6e20 6f6e 6c79 2068 6176 6520 6f6e  can only have on
+0001fd50: 6520 6672 6565 2073 796d 626f 6c2e 2022  e free symbol. "
+0001fd60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001fd70: 2022 5265 6365 6976 6564 2066 7265 6520   "Received free 
+0001fd80: 7379 6d62 6f6c 733a 2025 7322 2025 2066  symbols: %s" % f
+0001fd90: 2e66 7265 655f 7379 6d62 6f6c 7329 0a20  .free_symbols). 
+0001fda0: 2020 2020 2020 2073 656c 662e 6578 7072         self.expr
+0001fdb0: 203d 2066 0a20 2020 2020 2020 2023 204e   = f.        # N
+0001fdc0: 4f54 453a 2077 6520 6361 6e20 6561 7369  OTE: we can easi
+0001fdd0: 6c79 2063 7265 6174 6520 6120 7370 6865  ly create a sphe
+0001fde0: 7265 2077 6974 6820 6120 7369 6e67 6c65  re with a single
+0001fdf0: 2064 6174 6120 7365 7269 6573 2e0a 2020   data series..  
+0001fe00: 2020 2020 2020 2320 486f 7765 7665 722c        # However,
+0001fe10: 204b 3344 4261 636b 656e 6420 6973 2075   K3DBackend is u
+0001fe20: 6e61 626c 6520 746f 2070 726f 7065 726c  nable to properl
+0001fe30: 7920 7669 7375 616c 697a 6520 6974 2c20  y visualize it, 
+0001fe40: 616e 6420 6974 0a20 2020 2020 2020 2023  and it.        #
+0001fe50: 2077 6f75 6c64 2072 6571 7569 7265 2061   would require a
+0001fe60: 2066 6577 2068 6f75 7273 206f 6620 776f   few hours of wo
+0001fe70: 726b 2074 6f20 6170 706c 7920 7468 6520  rk to apply the 
+0001fe80: 6e65 6365 7373 6172 7920 6564 6974 732e  necessary edits.
+0001fe90: 0a20 2020 2020 2020 2023 2049 6e73 7465  .        # Inste
+0001fea0: 6164 2c20 4927 6d20 676f 696e 6720 746f  ad, I'm going to
+0001feb0: 2063 7265 6174 6520 7477 6f20 7370 6865   create two sphe
+0001fec0: 7265 2063 6170 7320 284e 6f72 7468 656e  re caps (Northen
+0001fed0: 2061 6e64 2053 6f75 7468 6572 6e0a 2020   and Southern.  
+0001fee0: 2020 2020 2020 2320 6865 6d69 7370 6865        # hemisphe
+0001fef0: 7265 732c 2072 6573 7065 6374 6976 656c  res, respectivel
+0001ff00: 7929 2c20 6865 6e63 6520 7468 6520 6e65  y), hence the ne
+0001ff10: 6564 2066 6f72 2072 616e 6765 7320 3a44  ed for ranges :D
+0001ff20: 0a20 2020 2020 2020 2073 656c 662e 7261  .        self.ra
+0001ff30: 6e67 6573 203d 205b 7261 6e67 655f 742c  nges = [range_t,
+0001ff40: 2072 616e 6765 5f70 5d0a 2020 2020 2020   range_p].      
+0001ff50: 2020 436f 6d70 6c65 7844 6f6d 6169 6e43    ComplexDomainC
+0001ff60: 6f6c 6f72 696e 6753 6572 6965 732e 5f69  oloringSeries._i
+0001ff70: 6e69 745f 646f 6d61 696e 5f63 6f6c 6f72  nit_domain_color
+0001ff80: 696e 675f 6b77 2873 656c 662c 202a 2a6b  ing_kw(self, **k
+0001ff90: 7761 7267 7329 0a20 2020 2020 2020 2069  wargs).        i
+0001ffa0: 6620 7365 6c66 2e6e 5b30 5d20 3d3d 2073  f self.n[0] == s
+0001ffb0: 656c 662e 6e5b 315d 3a0a 2020 2020 2020  elf.n[1]:.      
+0001ffc0: 2020 2020 2020 7365 6c66 2e6e 203d 205b        self.n = [
+0001ffd0: 7365 6c66 2e6e 5b30 5d2c 2034 202a 2073  self.n[0], 4 * s
+0001ffe0: 656c 662e 6e5b 305d 5d0a 2020 2020 2020  elf.n[0]].      
+0001fff0: 2020 7365 6c66 2e75 7365 5f63 6d20 3d20    self.use_cm = 
+00020000: 5472 7565 0a0a 2020 2020 6465 6620 6765  True..    def ge
+00020010: 745f 6461 7461 2873 656c 6629 3a0a 2020  t_data(self):.  
+00020020: 2020 2020 2020 2222 2252 6574 7572 6e20        """Return 
+00020030: 6172 7261 7973 206f 6620 636f 6f72 6469  arrays of coordi
+00020040: 6e61 7465 7320 666f 7220 706c 6f74 7469  nates for plotti
+00020050: 6e67 2e0a 0a20 2020 2020 2020 2052 6574  ng...        Ret
+00020060: 7572 6e73 0a20 2020 2020 2020 203d 3d3d  urns.        ===
+00020070: 3d3d 3d3d 0a0a 2020 2020 2020 2020 782c  ====..        x,
+00020080: 2079 2c20 7a20 3a20 6e70 2e6e 6461 7272   y, z : np.ndarr
+00020090: 6179 205b 6e32 2078 206e 315d 0a20 2020  ay [n2 x n1].   
+000200a0: 2020 2020 2020 2020 2043 6f6f 7264 696e           Coordin
+000200b0: 6174 6573 206f 6e20 7468 6520 756e 6974  ates on the unit
+000200c0: 2073 7068 6572 652e 0a0a 2020 2020 2020   sphere...      
+000200d0: 2020 6172 6720 3a20 6e70 2e6e 6461 7272    arg : np.ndarr
+000200e0: 6179 205b 6e32 2078 206e 315d 0a20 2020  ay [n2 x n1].   
+000200f0: 2020 2020 2020 2020 2041 7267 756d 656e           Argumen
+00020100: 7420 6f66 2074 6865 2066 756e 6374 696f  t of the functio
+00020110: 6e2e 0a0a 2020 2020 2020 2020 696d 6720  n...        img 
+00020120: 3a20 6e70 2e6e 6461 7272 6179 205b 6e32  : np.ndarray [n2
+00020130: 2078 206e 3120 7820 335d 0a20 2020 2020   x n1 x 3].     
+00020140: 2020 2020 2020 2052 4742 2069 6d61 6765         RGB image
+00020150: 2076 616c 7565 7320 636f 6d70 7574 6564   values computed
+00020160: 2066 726f 6d20 7468 6520 6172 6775 6d65   from the argume
+00020170: 6e74 206f 6620 7468 6520 6675 6e63 7469  nt of the functi
+00020180: 6f6e 2e0a 2020 2020 2020 2020 2020 2020  on..            
+00020190: 3020 3c3d 2052 2c20 472c 2042 203c 3d20  0 <= R, G, B <= 
+000201a0: 3235 350a 0a20 2020 2020 2020 2063 6f6c  255..        col
+000201b0: 6f72 7320 3a20 6e70 2e6e 6461 7272 6179  ors : np.ndarray
+000201c0: 205b 3235 3620 7820 335d 0a20 2020 2020   [256 x 3].     
+000201d0: 2020 2020 2020 2043 6f6c 6f72 2073 6361         Color sca
+000201e0: 6c65 2061 7373 6f63 6961 7465 6420 746f  le associated to
+000201f0: 2060 696d 6760 2e0a 2020 2020 2020 2020   `img`..        
+00020200: 2222 220a 2020 2020 2020 2020 6e70 203d  """.        np =
+00020210: 2069 6d70 6f72 745f 6d6f 6475 6c65 2827   import_module('
+00020220: 6e75 6d70 7927 290a 0a20 2020 2020 2020  numpy')..       
+00020230: 2023 2064 6973 6372 6574 697a 6520 7468   # discretize th
+00020240: 6520 756e 6974 2073 7068 6572 650a 2020  e unit sphere.  
+00020250: 2020 2020 2020 7220 3d20 310a 2020 2020        r = 1.    
+00020260: 2020 2020 2320 544f 444f 3a20 7468 6973      # TODO: this
+00020270: 2070 6172 616d 6574 6572 697a 6174 696f   parameterizatio
+00020280: 6e20 706c 6163 6573 2061 206c 6f74 206f  n places a lot o
+00020290: 6620 706f 696e 7473 206e 6561 7220 7468  f points near th
+000202a0: 6520 706f 6c65 730a 2020 2020 2020 2020  e poles.        
+000202b0: 2320 6275 7420 6e6f 7420 656e 6f75 6768  # but not enough
+000202c0: 206e 6561 7220 7468 6520 6571 7561 746f   near the equato
+000202d0: 722e 2043 616e 2061 2064 6966 6665 7265  r. Can a differe
+000202e0: 6e74 2070 6172 616d 6574 6572 697a 6174  nt parameterizat
+000202f0: 696f 6e0a 2020 2020 2020 2020 2320 696d  ion.        # im
+00020300: 7072 6f76 6573 2074 6865 2066 696e 616c  proves the final
+00020310: 2072 6573 756c 742c 206d 6179 6265 2065   result, maybe e
+00020320: 7665 6e20 7265 6475 6369 6e67 2074 6865  ven reducing the
+00020330: 2063 6f6d 7075 7461 7469 6f6e 616c 0a20   computational. 
+00020340: 2020 2020 2020 2023 2063 6f73 743f 0a20         # cost?. 
+00020350: 2020 2020 2020 2074 732c 2074 6520 3d20         ts, te = 
+00020360: 5b66 6c6f 6174 2874 2920 666f 7220 7420  [float(t) for t 
+00020370: 696e 2073 656c 662e 7261 6e67 6573 5b30  in self.ranges[0
+00020380: 5d5b 313a 5d5d 0a20 2020 2020 2020 2070  ][1:]].        p
+00020390: 732c 2070 6520 3d20 5b66 6c6f 6174 2874  s, pe = [float(t
+000203a0: 2920 666f 7220 7420 696e 2073 656c 662e  ) for t in self.
+000203b0: 7261 6e67 6573 5b31 5d5b 313a 5d5d 0a20  ranges[1][1:]]. 
+000203c0: 2020 2020 2020 2074 2c20 7020 3d20 6e70         t, p = np
+000203d0: 2e6d 6772 6964 5b74 733a 7465 3a73 656c  .mgrid[ts:te:sel
+000203e0: 662e 6e5b 305d 2a31 6a2c 2070 733a 7065  f.n[0]*1j, ps:pe
+000203f0: 3a73 656c 662e 6e5b 315d 2a31 6a5d 0a20  :self.n[1]*1j]. 
+00020400: 2020 2020 2020 2058 203d 2072 202a 206e         X = r * n
+00020410: 702e 7369 6e28 7429 202a 206e 702e 636f  p.sin(t) * np.co
+00020420: 7328 7029 0a20 2020 2020 2020 2059 203d  s(p).        Y =
+00020430: 2072 202a 206e 702e 7369 6e28 7429 202a   r * np.sin(t) *
+00020440: 206e 702e 7369 6e28 7029 0a20 2020 2020   np.sin(p).     
+00020450: 2020 205a 203d 2072 202a 206e 702e 636f     Z = r * np.co
+00020460: 7328 7429 0a20 2020 2020 2020 2023 2073  s(t).        # s
+00020470: 7465 7265 6f67 7261 7068 6963 2070 726f  tereographic pro
+00020480: 6a65 6374 696f 6e0a 2020 2020 2020 2020  jection.        
+00020490: 2320 544f 444f 3a20 7375 7070 7265 7373  # TODO: suppress
+000204a0: 2077 6172 6e69 6e67 730a 2020 2020 2020   warnings.      
+000204b0: 2020 7820 3d20 5820 2f20 2831 202d 205a    x = X / (1 - Z
+000204c0: 290a 2020 2020 2020 2020 7920 3d20 5920  ).        y = Y 
+000204d0: 2f20 2831 202d 205a 290a 2020 2020 2020  / (1 - Z).      
+000204e0: 2020 2320 6576 616c 7561 7469 6f6e 206f    # evaluation o
+000204f0: 7665 7220 7468 6520 636f 6d70 6c65 7820  ver the complex 
+00020500: 706c 616e 650a 2020 2020 2020 2020 2320  plane.        # 
+00020510: 4e4f 5445 3a20 5f75 6e69 666f 726d 5f65  NOTE: _uniform_e
+00020520: 7661 6c20 7368 6f75 6c64 2062 6520 7573  val should be us
+00020530: 6564 2c20 6173 2069 7420 6973 2061 626c  ed, as it is abl
+00020540: 6520 746f 2064 6561 6c20 7769 7468 0a20  e to deal with. 
+00020550: 2020 2020 2020 2023 2064 6966 6665 7265         # differe
+00020560: 6e74 2065 7661 6c75 6174 696f 6e20 6d6f  nt evaluation mo
+00020570: 6475 6c65 732e 2048 6f77 6576 6572 2c20  dules. However, 
+00020580: 7468 6174 206d 6574 686f 6420 6973 206d  that method is m
+00020590: 7563 6820 736c 6f77 6572 0a20 2020 2020  uch slower.     
+000205a0: 2020 2023 2074 6861 6e20 7661 6e69 6c6c     # than vanill
+000205b0: 612d 4e75 6d70 7920 7769 7468 2076 6563  a-Numpy with vec
+000205c0: 746f 7269 7a61 7469 6f6e 2c20 6576 656e  torization, even
+000205d0: 2077 6865 6e20 7573 696e 6720 4e75 6d70   when using Nump
+000205e0: 792e 0a20 2020 2020 2020 2023 2054 6f20  y..        # To 
+000205f0: 6765 7420 6465 6365 6e74 2072 6573 756c  get decent resul
+00020600: 7473 2c20 7468 6520 6675 6e63 7469 6f6e  ts, the function
+00020610: 206d 7573 7420 6265 2065 7661 6c75 6174   must be evaluat
+00020620: 6564 206f 6e20 6120 6269 670a 2020 2020  ed on a big.    
+00020630: 2020 2020 2320 6e75 6d62 6572 206f 6620      # number of 
+00020640: 6469 7363 7265 7469 7a61 7469 6f6e 2070  discretization p
+00020650: 6f69 6e74 732c 2077 6869 6368 2061 7574  oints, which aut
+00020660: 6f6d 6174 6963 616c 6c79 2070 7265 636c  omatically precl
+00020670: 7564 6573 0a20 2020 2020 2020 2023 206d  udes.        # m
+00020680: 706d 6174 6820 6f72 2073 796d 7079 2e20  pmath or sympy. 
+00020690: 4865 6e63 652c 206a 7573 7420 7573 6520  Hence, just use 
+000206a0: 6261 7265 2062 6f6e 6573 204e 756d 7079  bare bones Numpy
+000206b0: 2c20 6576 656e 2074 686f 7567 6820 7468  , even though th
+000206c0: 6973 0a20 2020 2020 2020 2023 206d 6f64  is.        # mod
+000206d0: 756c 6520 6d69 6768 7420 6e6f 7420 696d  ule might not im
+000206e0: 706c 656d 656e 7420 616c 6c20 7468 6520  plement all the 
+000206f0: 696e 7465 7265 7374 696e 6720 6675 6e63  interesting func
+00020700: 7469 6f6e 732e 0a20 2020 2020 2020 207a  tions..        z
+00020710: 203d 2078 202b 2031 6a20 2a20 790a 2020   = x + 1j * y.  
+00020720: 2020 2020 2020 6620 3d20 6c61 6d62 6469        f = lambdi
+00020730: 6679 286c 6973 7428 7365 6c66 2e65 7870  fy(list(self.exp
+00020740: 722e 6672 6565 5f73 796d 626f 6c73 295b  r.free_symbols)[
+00020750: 305d 2c20 7365 6c66 2e65 7870 7229 0a20  0], self.expr). 
+00020760: 2020 2020 2020 2077 203d 2066 287a 290a         w = f(z).
+00020770: 2020 2020 2020 2020 696d 672c 2063 7320          img, cs 
+00020780: 3d20 7765 6765 7274 2873 656c 662e 636f  = wegert(self.co
+00020790: 6c6f 7269 6e67 2c20 772c 2073 656c 662e  loring, w, self.
+000207a0: 7068 6173 6572 6573 2c20 7365 6c66 2e63  phaseres, self.c
+000207b0: 6d61 7029 0a20 2020 2020 2020 2072 6574  map).        ret
+000207c0: 7572 6e20 7365 6c66 2e5f 6170 706c 795f  urn self._apply_
+000207d0: 7472 616e 7366 6f72 6d28 582c 2059 2c20  transform(X, Y, 
+000207e0: 5a2c 206e 702e 616e 676c 6528 7729 2c20  Z, np.angle(w), 
+000207f0: 696d 672c 2063 7329 0a0a 0a63 6c61 7373  img, cs)...class
+00020800: 2048 564c 696e 6553 6572 6965 7328 4261   HVLineSeries(Ba
+00020810: 7365 5365 7269 6573 293a 0a20 2020 2022  seSeries):.    "
+00020820: 2222 5265 7072 6573 656e 7420 616e 2068  ""Represent an h
+00020830: 6f72 697a 6f6e 7461 6c20 6f72 2076 6572  orizontal or ver
+00020840: 7469 6361 6c20 6c69 6e65 2073 6572 6965  tical line serie
+00020850: 732e 0a20 2020 2049 6e20 4d61 7470 6c6f  s..    In Matplo
+00020860: 746c 6962 2c20 7468 6973 2077 696c 6c20  tlib, this will 
+00020870: 6265 2072 656e 6465 7265 6420 6279 2061  be rendered by a
+00020880: 7868 6c69 6e65 206f 7220 6178 766c 696e  xhline or axvlin
+00020890: 652e 0a20 2020 2022 2222 0a20 2020 2064  e..    """.    d
+000208a0: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+000208b0: 2c20 762c 2068 6f72 697a 6f6e 7461 6c2c  , v, horizontal,
+000208c0: 206c 6162 656c 3d22 222c 202a 2a6b 7761   label="", **kwa
+000208d0: 7267 7329 3a0a 2020 2020 2020 2020 7375  rgs):.        su
+000208e0: 7065 7228 292e 5f5f 696e 6974 5f5f 282a  per().__init__(*
+000208f0: 2a6b 7761 7267 7329 0a20 2020 2020 2020  *kwargs).       
+00020900: 2073 656c 662e 5f65 7870 7220 3d20 7379   self._expr = sy
+00020910: 6d70 6966 7928 7629 0a20 2020 2020 2020  mpify(v).       
+00020920: 2073 656c 662e 6973 5f68 6f72 697a 6f6e   self.is_horizon
+00020930: 7461 6c20 3d20 686f 7269 7a6f 6e74 616c  tal = horizontal
+00020940: 0a20 2020 2020 2020 2073 656c 662e 5f6c  .        self._l
+00020950: 6162 656c 203d 2073 7472 2873 656c 662e  abel = str(self.
+00020960: 6578 7072 2920 6966 206c 6162 656c 2069  expr) if label i
+00020970: 7320 4e6f 6e65 2065 6c73 6520 6c61 6265  s None else labe
+00020980: 6c0a 2020 2020 2020 2020 7365 6c66 2e5f  l.        self._
+00020990: 6c61 7465 785f 6c61 6265 6c20 3d20 6c61  latex_label = la
+000209a0: 7465 7828 7365 6c66 2e65 7870 7229 2069  tex(self.expr) i
+000209b0: 6620 6c61 6265 6c20 6973 204e 6f6e 6520  f label is None 
+000209c0: 656c 7365 206c 6162 656c 0a0a 2020 2020  else label..    
+000209d0: 6465 6620 6765 745f 6461 7461 2873 656c  def get_data(sel
+000209e0: 6629 3a0a 2020 2020 2020 2020 6c6f 6361  f):.        loca
+000209f0: 7469 6f6e 203d 2073 656c 662e 6578 7072  tion = self.expr
+00020a00: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00020a10: 2e69 735f 696e 7465 7261 6374 6976 653a  .is_interactive:
+00020a20: 0a20 2020 2020 2020 2020 2020 206c 6f63  .            loc
+00020a30: 6174 696f 6e20 3d20 7365 6c66 2e65 7870  ation = self.exp
+00020a40: 722e 7375 6273 2873 656c 662e 7061 7261  r.subs(self.para
+00020a50: 6d73 290a 2020 2020 2020 2020 7265 7475  ms).        retu
+00020a60: 726e 2066 6c6f 6174 286c 6f63 6174 696f  rn float(locatio
+00020a70: 6e29 0a0a 2020 2020 6465 6620 5f5f 7374  n)..    def __st
+00020a80: 725f 5f28 7365 6c66 293a 0a20 2020 2020  r__(self):.     
+00020a90: 2020 2070 7265 203d 2022 686f 7269 7a6f     pre = "horizo
+00020aa0: 6e74 616c 2220 6966 2073 656c 662e 6973  ntal" if self.is
+00020ab0: 5f68 6f72 697a 6f6e 7461 6c20 656c 7365  _horizontal else
+00020ac0: 2022 7665 7274 6963 616c 220a 2020 2020   "vertical".    
+00020ad0: 2020 2020 706f 7374 203d 2022 7920 3d20      post = "y = 
+00020ae0: 2220 6966 2073 656c 662e 6973 5f68 6f72  " if self.is_hor
+00020af0: 697a 6f6e 7461 6c20 656c 7365 2022 7820  izontal else "x 
+00020b00: 3d20 220a 2020 2020 2020 2020 7265 7475  = ".        retu
+00020b10: 726e 2073 656c 662e 5f73 7472 5f68 656c  rn self._str_hel
+00020b20: 7065 7228 7072 6520 2b20 2220 6c69 6e65  per(pre + " line
+00020b30: 2061 7420 2220 2b20 706f 7374 202b 2073   at " + post + s
+00020b40: 7472 2873 656c 662e 6578 7072 2929 0a0a  tr(self.expr))..
+00020b50: 0a63 6c61 7373 2041 7272 6f77 3244 5365  .class Arrow2DSe
+00020b60: 7269 6573 2842 6173 6553 6572 6965 7329  ries(BaseSeries)
+00020b70: 3a0a 2020 2020 2222 2252 6570 7265 7365  :.    """Represe
+00020b80: 6e74 2061 6e20 6172 726f 7720 696e 2061  nt an arrow in a
+00020b90: 2032 4420 7370 6163 652e 0a20 2020 2022   2D space..    "
+00020ba0: 2222 0a0a 2020 2020 6973 5f32 4476 6563  ""..    is_2Dvec
+00020bb0: 746f 7220 3d20 5472 7565 0a20 2020 205f  tor = True.    _
+00020bc0: 616c 6c6f 7765 645f 6b65 7973 203d 205b  allowed_keys = [
+00020bd0: 226e 6f72 6d61 6c69 7a65 225d 0a0a 2020  "normalize"]..  
+00020be0: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+00020bf0: 656c 662c 2073 7461 7274 2c20 6469 7265  elf, start, dire
+00020c00: 6374 696f 6e2c 206c 6162 656c 3d22 222c  ction, label="",
+00020c10: 202a 2a6b 7761 7267 7329 3a0a 2020 2020   **kwargs):.    
+00020c20: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
+00020c30: 6974 5f5f 282a 2a6b 7761 7267 7329 0a20  it__(**kwargs). 
+00020c40: 2020 2020 2020 206e 7020 3d20 696d 706f         np = impo
+00020c50: 7274 5f6d 6f64 756c 6528 276e 756d 7079  rt_module('numpy
+00020c60: 2729 0a20 2020 2020 2020 2069 6620 6c65  ').        if le
+00020c70: 6e28 7374 6172 7429 2021 3d20 6c65 6e28  n(start) != len(
+00020c80: 6469 7265 6374 696f 6e29 3a0a 2020 2020  direction):.    
+00020c90: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00020ca0: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
+00020cb0: 2020 2020 2020 2020 2020 2260 7374 6172            "`star
+00020cc0: 7460 2061 6e64 2060 6469 7265 6374 696f  t` and `directio
+00020cd0: 6e60 206d 7573 7420 6861 7665 2074 6865  n` must have the
+00020ce0: 2073 616d 6520 6e75 6d62 6572 206f 6620   same number of 
+00020cf0: 656c 656d 656e 7473 2e5c 6e22 0a20 2020  elements.\n".   
+00020d00: 2020 2020 2020 2020 2020 2020 2066 2252               f"R
+00020d10: 6563 6569 7665 643a 206c 656e 2873 7461  eceived: len(sta
+00020d20: 7274 2920 3d20 7b6c 656e 2873 7461 7274  rt) = {len(start
+00020d30: 297d 2022 0a20 2020 2020 2020 2020 2020  )} ".           
+00020d40: 2020 2020 2066 2261 6e64 206c 656e 2864       f"and len(d
+00020d50: 6972 6563 7469 6f6e 2920 3d20 7b6c 656e  irection) = {len
+00020d60: 2864 6972 6563 7469 6f6e 297d 220a 2020  (direction)}".  
+00020d70: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00020d80: 2020 2020 7365 6c66 2e5f 626c 6f63 6b5f      self._block_
+00020d90: 6c61 6d62 6461 5f66 756e 6374 696f 6e73  lambda_functions
+00020da0: 2873 7461 7274 2c20 6469 7265 6374 696f  (start, directio
+00020db0: 6e29 0a20 2020 2020 2020 2063 6865 636b  n).        check
+00020dc0: 203d 206c 616d 6264 6120 6c3a 205b 0a20   = lambda l: [. 
+00020dd0: 2020 2020 2020 2020 2020 2069 7369 6e73             isins
+00020de0: 7461 6e63 6528 742c 2045 7870 7229 2061  tance(t, Expr) a
+00020df0: 6e64 2028 6e6f 7420 742e 6973 5f6e 756d  nd (not t.is_num
+00020e00: 6265 7229 2066 6f72 2074 2069 6e20 6c0a  ber) for t in l.
+00020e10: 2020 2020 2020 2020 5d0a 2020 2020 2020          ].      
+00020e20: 2020 6966 2061 6e79 2863 6865 636b 2873    if any(check(s
+00020e30: 7461 7274 2920 2b20 6368 6563 6b28 6469  tart) + check(di
+00020e40: 7265 6374 696f 6e29 2920 6f72 2073 656c  rection)) or sel
+00020e50: 662e 7061 7261 6d73 3a0a 2020 2020 2020  f.params:.      
+00020e60: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
+00020e70: 662e 7061 7261 6d73 3a0a 2020 2020 2020  f.params:.      
+00020e80: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00020e90: 5661 6c75 6545 7272 6f72 280a 2020 2020  ValueError(.    
+00020ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020eb0: 2253 6f6d 6520 6f72 2061 6c6c 2065 6c65  "Some or all ele
+00020ec0: 6d65 6e74 7320 6f66 2074 6865 2070 726f  ments of the pro
+00020ed0: 7669 6465 6420 636f 6f72 6469 6e61 7465  vided coordinate
+00020ee0: 7320 220a 2020 2020 2020 2020 2020 2020  s ".            
+00020ef0: 2020 2020 2020 2020 2261 7265 2073 796d          "are sym
+00020f00: 626f 6c69 6320 6578 7072 6573 7369 6f6e  bolic expression
+00020f10: 732c 2062 7574 2074 6865 2060 6070 6172  s, but the ``par
+00020f20: 616d 7360 6020 6469 6374 696f 6e61 7279  ams`` dictionary
+00020f30: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
+00020f40: 2020 2020 2020 2022 7761 7320 6e6f 7420         "was not 
+00020f50: 7072 6f76 6964 6564 3a20 7468 6f73 6520  provided: those 
+00020f60: 656c 656d 656e 7473 2063 616e 2774 2062  elements can't b
+00020f70: 6520 6576 616c 7561 7465 642e 220a 2020  e evaluated.".  
+00020f80: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00020f90: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00020fa0: 2e73 7461 7274 203d 2054 7570 6c65 282a  .start = Tuple(*
+00020fb0: 7374 6172 7429 0a20 2020 2020 2020 2020  start).         
+00020fc0: 2020 2073 656c 662e 6469 7265 6374 696f     self.directio
+00020fd0: 6e20 3d20 5475 706c 6528 2a64 6972 6563  n = Tuple(*direc
+00020fe0: 7469 6f6e 290a 2020 2020 2020 2020 656c  tion).        el
+00020ff0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00021000: 7365 6c66 2e73 7461 7274 203d 206e 702e  self.start = np.
+00021010: 6172 7261 7928 7374 6172 742c 2064 7479  array(start, dty
+00021020: 7065 3d6e 702e 666c 6f61 7436 3429 0a20  pe=np.float64). 
+00021030: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00021040: 6469 7265 6374 696f 6e20 3d20 6e70 2e61  direction = np.a
+00021050: 7272 6179 2864 6972 6563 7469 6f6e 2c20  rray(direction, 
+00021060: 6474 7970 653d 6e70 2e66 6c6f 6174 3634  dtype=np.float64
+00021070: 290a 0a20 2020 2020 2020 2073 656c 662e  )..        self.
+00021080: 5f65 7870 7220 3d20 2873 656c 662e 7374  _expr = (self.st
+00021090: 6172 742c 2073 656c 662e 6469 7265 6374  art, self.direct
+000210a0: 696f 6e29 0a20 2020 2020 2020 2069 6620  ion).        if 
+000210b0: 6e6f 7420 616e 7928 6973 696e 7374 616e  not any(isinstan
+000210c0: 6365 2874 2c20 6e70 2e6e 6461 7272 6179  ce(t, np.ndarray
+000210d0: 2920 666f 7220 7420 696e 205b 7365 6c66  ) for t in [self
+000210e0: 2e73 7461 7274 2c20 7365 6c66 2e64 6972  .start, self.dir
+000210f0: 6563 7469 6f6e 5d29 3a0a 2020 2020 2020  ection]):.      
+00021100: 2020 2020 2020 7365 6c66 2e5f 6368 6563        self._chec
+00021110: 6b5f 6673 2829 0a20 2020 2020 2020 2069  k_fs().        i
+00021120: 6620 6c61 6265 6c3a 0a20 2020 2020 2020  f label:.       
+00021130: 2020 2020 2073 656c 662e 6c61 6265 6c20       self.label 
+00021140: 3d20 6c61 6265 6c0a 2020 2020 2020 2020  = label.        
+00021150: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00021160: 2020 2320 6c61 6265 6c3a 2028 6672 6f6d    # label: (from
+00021170: 2920 2d3e 2028 746f 290a 2020 2020 2020  ) -> (to).      
+00021180: 2020 2020 2020 7365 6c66 2e5f 6c61 6265        self._labe
+00021190: 6c20 3d20 280a 2020 2020 2020 2020 2020  l = (.          
+000211a0: 2020 2020 2020 2228 7b7d 2920 2d3e 2028        "({}) -> (
+000211b0: 7b7d 2922 2e66 6f72 6d61 7428 0a20 2020  {})".format(.   
+000211c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000211d0: 2022 2c20 222e 6a6f 696e 285b 7374 7228   ", ".join([str(
+000211e0: 7429 2066 6f72 2074 2069 6e20 7365 6c66  t) for t in self
+000211f0: 2e73 7461 7274 5d29 2c0a 2020 2020 2020  .start]),.      
+00021200: 2020 2020 2020 2020 2020 2020 2020 222c                ",
+00021210: 2022 2e6a 6f69 6e28 5b73 7472 2875 202b   ".join([str(u +
+00021220: 2076 2920 666f 7220 752c 2076 2069 6e20   v) for u, v in 
+00021230: 7a69 7028 0a20 2020 2020 2020 2020 2020  zip(.           
+00021240: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00021250: 662e 7374 6172 742c 2073 656c 662e 6469  f.start, self.di
+00021260: 7265 6374 696f 6e29 5d29 0a20 2020 2020  rection)]).     
+00021270: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00021280: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00021290: 2020 2020 2020 2073 656c 662e 5f6c 6174         self._lat
+000212a0: 6578 5f6c 6162 656c 203d 2028 0a20 2020  ex_label = (.   
+000212b0: 2020 2020 2020 2020 2020 2020 2072 225c               r"\
+000212c0: 6c65 6674 287b 7d5c 7269 6768 7429 205c  left({}\right) \
+000212d0: 7269 6768 7461 7272 6f77 205c 6c65 6674  rightarrow \left
+000212e0: 287b 7d5c 7269 6768 7429 222e 666f 726d  ({}\right)".form
+000212f0: 6174 280a 2020 2020 2020 2020 2020 2020  at(.            
+00021300: 2020 2020 2020 2020 222c 2022 2e6a 6f69          ", ".joi
+00021310: 6e28 5b6c 6174 6578 2874 2920 666f 7220  n([latex(t) for 
+00021320: 7420 696e 2073 656c 662e 7374 6172 745d  t in self.start]
+00021330: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00021340: 2020 2020 2020 2022 2c20 222e 6a6f 696e         ", ".join
+00021350: 285b 6c61 7465 7828 7520 2b20 7629 2066  ([latex(u + v) f
+00021360: 6f72 2075 2c20 7620 696e 207a 6970 280a  or u, v in zip(.
+00021370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021380: 2020 2020 2020 2020 7365 6c66 2e73 7461          self.sta
+00021390: 7274 2c20 7365 6c66 2e64 6972 6563 7469  rt, self.directi
+000213a0: 6f6e 295d 290a 2020 2020 2020 2020 2020  on)]).          
+000213b0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+000213c0: 2020 2020 290a 2020 2020 2020 2020 7365      ).        se
+000213d0: 6c66 2e75 7365 5f71 7569 7665 725f 736f  lf.use_quiver_so
+000213e0: 6c69 645f 636f 6c6f 7220 3d20 6e6f 7420  lid_color = not 
+000213f0: 7365 6c66 2e75 7365 5f63 6d0a 2020 2020  self.use_cm.    
+00021400: 2020 2020 7365 6c66 2e6e 6f72 6d61 6c69      self.normali
+00021410: 7a65 203d 206b 7761 7267 732e 6765 7428  ze = kwargs.get(
+00021420: 226e 6f72 6d61 6c69 7a65 222c 2046 616c  "normalize", Fal
+00021430: 7365 290a 2020 2020 2020 2020 2320 544f  se).        # TO
+00021440: 444f 3a20 446f 2049 204e 6565 6420 7468  DO: Do I Need th
+00021450: 6973 3f0a 2020 2020 2020 2020 7365 6c66  is?.        self
+00021460: 2e69 735f 7374 7265 616d 6c69 6e65 7320  .is_streamlines 
+00021470: 3d20 6b77 6172 6773 2e67 6574 2822 7374  = kwargs.get("st
+00021480: 7265 616d 6c69 6e65 7322 2c20 4661 6c73  reamlines", Fals
+00021490: 6529 0a0a 2020 2020 6465 6620 5f5f 7374  e)..    def __st
+000214a0: 725f 5f28 7365 6c66 293a 0a20 2020 2020  r__(self):.     
+000214b0: 2020 2070 7265 203d 2022 3344 2022 2069     pre = "3D " i
+000214c0: 6620 7365 6c66 2e69 735f 3344 2065 6c73  f self.is_3D els
+000214d0: 6520 2232 4420 220a 2020 2020 2020 2020  e "2D ".        
+000214e0: 7374 6172 7420 3d20 7475 706c 6528 7365  start = tuple(se
+000214f0: 6c66 2e73 7461 7274 290a 2020 2020 2020  lf.start).      
+00021500: 2020 656e 6420 3d20 7475 706c 6528 7320    end = tuple(s 
+00021510: 2b20 6420 666f 7220 732c 2064 2069 6e20  + d for s, d in 
+00021520: 7a69 7028 7374 6172 742c 2073 656c 662e  zip(start, self.
+00021530: 6469 7265 6374 696f 6e29 290a 2020 2020  direction)).    
+00021540: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00021550: 5f73 7472 5f68 656c 7065 7228 0a20 2020  _str_helper(.   
+00021560: 2020 2020 2020 2020 2070 7265 202b 2066           pre + f
+00021570: 2261 7272 6f77 2066 726f 6d20 7b73 7461  "arrow from {sta
+00021580: 7274 7d20 746f 207b 656e 647d 220a 2020  rt} to {end}".  
+00021590: 2020 2020 2020 290a 0a20 2020 2064 6566        )..    def
+000215a0: 2067 6574 5f6c 6162 656c 2873 656c 662c   get_label(self,
+000215b0: 2075 7365 5f6c 6174 6578 3d46 616c 7365   use_latex=False
+000215c0: 2c20 7772 6170 7065 723d 2224 2573 2422  , wrapper="$%s$"
+000215d0: 293a 0a20 2020 2020 2020 2022 2222 5265  ):.        """Re
+000215e0: 7475 726e 2074 6865 206c 6162 656c 2074  turn the label t
+000215f0: 6f20 6265 2075 7365 6420 746f 2064 6973  o be used to dis
+00021600: 706c 6179 2074 6865 2065 7870 7265 7373  play the express
+00021610: 696f 6e2e 0a0a 2020 2020 2020 2020 5061  ion...        Pa
+00021620: 7261 6d65 7465 7273 0a20 2020 2020 2020  rameters.       
+00021630: 203d 3d3d 3d3d 3d3d 3d3d 3d0a 2020 2020   ==========.    
+00021640: 2020 2020 7573 655f 6c61 7465 7820 3a20      use_latex : 
+00021650: 626f 6f6c 0a20 2020 2020 2020 2020 2020  bool.           
+00021660: 2049 6620 4661 6c73 652c 2074 6865 2073   If False, the s
+00021670: 7472 696e 6720 7265 7072 6573 656e 7461  tring representa
+00021680: 7469 6f6e 206f 6620 7468 6520 6578 7072  tion of the expr
+00021690: 6573 7369 6f6e 2069 7320 7265 7475 726e  ession is return
+000216a0: 6564 2e0a 2020 2020 2020 2020 2020 2020  ed..            
+000216b0: 4966 2054 7275 652c 2074 6865 206c 6174  If True, the lat
+000216c0: 6578 2072 6570 7265 7365 6e74 6174 696f  ex representatio
+000216d0: 6e20 6973 2072 6574 7572 6e65 642e 0a20  n is returned.. 
+000216e0: 2020 2020 2020 2077 7261 7070 6572 203a         wrapper :
+000216f0: 2073 7472 0a20 2020 2020 2020 2020 2020   str.           
+00021700: 2054 6865 2062 6163 6b65 6e64 206d 6967   The backend mig
+00021710: 6874 206e 6565 6420 7468 6520 6c61 7465  ht need the late
+00021720: 7820 7265 7072 6573 656e 7461 7469 6f6e  x representation
+00021730: 2074 6f20 6265 2077 7261 7070 6564 2062   to be wrapped b
+00021740: 790a 2020 2020 2020 2020 2020 2020 736f  y.            so
+00021750: 6d65 2063 6861 7261 6374 6572 732e 2044  me characters. D
+00021760: 6566 6175 6c74 2074 6f20 6060 2224 2573  efault to ``"$%s
+00021770: 2422 6060 2e0a 0a20 2020 2020 2020 2052  $"``...        R
+00021780: 6574 7572 6e73 0a20 2020 2020 2020 203d  eturns.        =
+00021790: 3d3d 3d3d 3d3d 0a20 2020 2020 2020 206c  ======.        l
+000217a0: 6162 656c 203a 2073 7472 0a20 2020 2020  abel : str.     
+000217b0: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+000217c0: 6620 7573 655f 6c61 7465 7820 6973 2046  f use_latex is F
+000217d0: 616c 7365 3a0a 2020 2020 2020 2020 2020  alse:.          
+000217e0: 2020 7265 7475 726e 2073 656c 662e 5f6c    return self._l
+000217f0: 6162 656c 0a20 2020 2020 2020 2072 6574  abel.        ret
+00021800: 7572 6e20 7365 6c66 2e5f 6765 745f 7772  urn self._get_wr
+00021810: 6170 7065 645f 6c61 6265 6c28 7365 6c66  apped_label(self
+00021820: 2e5f 6c61 7465 785f 6c61 6265 6c2c 2077  ._latex_label, w
+00021830: 7261 7070 6572 290a 0a20 2020 2064 6566  rapper)..    def
+00021840: 2067 6574 5f64 6174 6128 7365 6c66 293a   get_data(self):
+00021850: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
+00021860: 726e 2061 7272 6179 7320 6f66 2063 6f6f  rn arrays of coo
+00021870: 7264 696e 6174 6573 2066 6f72 2070 6c6f  rdinates for plo
+00021880: 7474 696e 672e 0a0a 2020 2020 2020 2020  tting...        
+00021890: 5265 7475 726e 730a 2020 2020 2020 2020  Returns.        
+000218a0: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
+000218b0: 7831 2c20 7931 2c20 7a31 205b 6f70 7469  x1, y1, z1 [opti
+000218c0: 6f6e 616c 5d20 3a20 666c 6f61 740a 2020  onal] : float.  
+000218d0: 2020 2020 2020 2020 2020 436f 6f72 6469            Coordi
+000218e0: 6e61 7465 7320 6f66 2074 6865 2073 7461  nates of the sta
+000218f0: 7274 2070 6f73 6974 696f 6e2e 0a20 2020  rt position..   
+00021900: 2020 2020 2078 322c 2079 322c 207a 3220       x2, y2, z2 
+00021910: 5b6f 7074 696f 6e61 6c5d 203a 2066 6c6f  [optional] : flo
+00021920: 6174 0a20 2020 2020 2020 2020 2020 2043  at.            C
+00021930: 6f6f 7264 696e 6174 6573 206f 6620 7468  oordinates of th
+00021940: 6520 656e 6420 706f 7369 7469 6f6e 2e0a  e end position..
+00021950: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00021960: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
+00021970: 6d6f 6475 6c65 2827 6e75 6d70 7927 290a  module('numpy').
+00021980: 2020 2020 2020 2020 7374 6172 742c 2064          start, d
+00021990: 6972 6563 7469 6f6e 203d 2073 656c 662e  irection = self.
+000219a0: 7374 6172 742c 2073 656c 662e 6469 7265  start, self.dire
+000219b0: 6374 696f 6e0a 0a20 2020 2020 2020 2069  ction..        i
+000219c0: 6620 6e6f 7420 7365 6c66 2e69 735f 696e  f not self.is_in
+000219d0: 7465 7261 6374 6976 653a 0a20 2020 2020  teractive:.     
+000219e0: 2020 2020 2020 2073 7461 7274 2c20 6469         start, di
+000219f0: 7265 6374 696f 6e20 3d20 5b0a 2020 2020  rection = [.    
+00021a00: 2020 2020 2020 2020 2020 2020 6e70 2e61              np.a
+00021a10: 7272 6179 2874 2c20 6474 7970 653d 666c  rray(t, dtype=fl
+00021a20: 6f61 7429 2066 6f72 2074 2069 6e20 5b73  oat) for t in [s
+00021a30: 7461 7274 2c20 6469 7265 6374 696f 6e5d  tart, direction]
+00021a40: 0a20 2020 2020 2020 2020 2020 205d 0a20  .            ]. 
+00021a50: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00021a60: 2020 2020 2020 2020 2073 7461 7274 203d           start =
+00021a70: 206e 702e 6172 7261 7928 0a20 2020 2020   np.array(.     
+00021a80: 2020 2020 2020 2020 2020 205b 742e 6576             [t.ev
+00021a90: 616c 6628 7375 6273 3d73 656c 662e 7061  alf(subs=self.pa
+00021aa0: 7261 6d73 2920 666f 7220 7420 696e 2073  rams) for t in s
+00021ab0: 7461 7274 5d2c 2064 7479 7065 3d66 6c6f  tart], dtype=flo
+00021ac0: 6174 290a 2020 2020 2020 2020 2020 2020  at).            
+00021ad0: 6469 7265 6374 696f 6e20 3d20 6e70 2e61  direction = np.a
+00021ae0: 7272 6179 280a 2020 2020 2020 2020 2020  rray(.          
+00021af0: 2020 2020 2020 5b74 2e65 7661 6c66 2873        [t.evalf(s
+00021b00: 7562 733d 7365 6c66 2e70 6172 616d 7329  ubs=self.params)
+00021b10: 2066 6f72 2074 2069 6e20 6469 7265 6374   for t in direct
+00021b20: 696f 6e5d 2c20 6474 7970 653d 666c 6f61  ion], dtype=floa
+00021b30: 7429 0a0a 2020 2020 2020 2020 656e 6420  t)..        end 
+00021b40: 3d20 7374 6172 7420 2b20 6469 7265 6374  = start + direct
+00021b50: 696f 6e0a 2020 2020 2020 2020 7265 7475  ion.        retu
+00021b60: 726e 2073 656c 662e 5f61 7070 6c79 5f74  rn self._apply_t
+00021b70: 7261 6e73 666f 726d 282a 7374 6172 742c  ransform(*start,
+00021b80: 202a 656e 6429 0a0a 0a63 6c61 7373 2041   *end)...class A
+00021b90: 7272 6f77 3344 5365 7269 6573 2841 7272  rrow3DSeries(Arr
+00021ba0: 6f77 3244 5365 7269 6573 293a 0a20 2020  ow2DSeries):.   
+00021bb0: 2022 2222 5265 7072 6573 656e 7420 616e   """Represent an
+00021bc0: 2061 7272 6f77 2069 6e20 6120 3344 2073   arrow in a 3D s
+00021bd0: 7061 6365 2e0a 2020 2020 2222 220a 2020  pace..    """.  
+00021be0: 2020 6973 5f33 4420 3d20 5472 7565 0a20    is_3D = True. 
+00021bf0: 2020 2069 735f 3244 7665 6374 6f72 203d     is_2Dvector =
+00021c00: 2046 616c 7365 0a20 2020 2069 735f 3344   False.    is_3D
+00021c10: 7665 6374 6f72 203d 2054 7275 650a 0a20  vector = True.. 
+00021c20: 2020 2064 6566 2067 6574 5f64 6174 6128     def get_data(
+00021c30: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+00021c40: 2222 5265 7475 726e 2061 7272 6179 7320  ""Return arrays 
+00021c50: 6f66 2063 6f6f 7264 696e 6174 6573 2066  of coordinates f
+00021c60: 6f72 2070 6c6f 7474 696e 672e 0a0a 2020  or plotting...  
+00021c70: 2020 2020 2020 5265 7475 726e 730a 2020        Returns.  
+00021c80: 2020 2020 2020 3d3d 3d3d 3d3d 3d0a 2020        =======.  
+00021c90: 2020 2020 2020 782c 2079 2c20 7a20 3a20        x, y, z : 
+00021ca0: 666c 6f61 740a 2020 2020 2020 2020 2020  float.          
+00021cb0: 2020 436f 6f72 6469 6e61 7465 7320 6f66    Coordinates of
+00021cc0: 2074 6865 2073 7461 7274 2070 6f73 6974   the start posit
+00021cd0: 696f 6e2e 0a20 2020 2020 2020 2075 2c20  ion..        u, 
+00021ce0: 762c 2077 203a 2066 6c6f 6174 0a20 2020  v, w : float.   
+00021cf0: 2020 2020 2020 2020 2043 6f6f 7264 696e           Coordin
+00021d00: 6174 6573 206f 6620 7468 6520 656e 6420  ates of the end 
+00021d10: 706f 7369 7469 6f6e 2e0a 2020 2020 2020  position..      
+00021d20: 2020 2222 220a 2020 2020 2020 2020 7265    """.        re
+00021d30: 7475 726e 2073 7570 6572 2829 2e67 6574  turn super().get
+00021d40: 5f64 6174 6128 290a 0a0a 636c 6173 7320  _data()...class 
+00021d50: 4772 6964 4261 7365 3a0a 2020 2020 2222  GridBase:.    ""
+00021d60: 220a 2020 2020 2a47 7269 644c 696e 6553  ".    *GridLineS
+00021d70: 6572 6965 7320 6d61 7920 636f 7665 7220  eries may cover 
+00021d80: 7468 6520 656e 7469 7265 2076 6973 6962  the entire visib
+00021d90: 6c65 2061 7265 612e 2048 656e 6365 2c20  le area. Hence, 
+00021da0: 7468 6579 206e 6565 6420 746f 0a20 2020  they need to.   
+00021db0: 206b 6e6f 7720 7468 6520 6178 6973 206c   know the axis l
+00021dc0: 696d 6974 732e 0a0a 2020 2020 4178 6973  imits...    Axis
+00021dd0: 206c 696d 6974 7320 6361 6e20 6265 3a0a   limits can be:.
+00021de0: 2020 2020 312e 2070 726f 7669 6465 6420      1. provided 
+00021df0: 6279 2074 6865 2075 7365 7220 696e 2074  by the user in t
+00021e00: 6865 2070 6c6f 7420 6675 6e63 7469 6f6e  he plot function
+00021e10: 2063 616c 6c2e 2046 6f72 2065 7861 6d70   call. For examp
+00021e20: 6c65 3a0a 2020 2020 2020 2060 6070 6c6f  le:.       ``plo
+00021e30: 7428 2e2e 2e2c 2078 6c69 6d3d 2861 2c20  t(..., xlim=(a, 
+00021e40: 6229 2c20 796c 696d 3d28 632c 2064 2929  b), ylim=(c, d))
+00021e50: 6060 0a20 2020 2032 2e20 636f 6d70 7574  ``.    2. comput
+00021e60: 6564 2066 726f 6d20 7468 6520 6461 7461  ed from the data
+00021e70: 2074 6861 7420 6861 7320 616c 7265 6164   that has alread
+00021e80: 7920 6265 2070 6c6f 7474 6564 2e0a 2020  y be plotted..  
+00021e90: 2020 332e 2070 726f 7669 6465 6420 696e    3. provided in
+00021ea0: 2073 6f6d 6520 6675 6e63 7469 6f6e 2063   some function c
+00021eb0: 616c 6c20 7468 6174 2067 656e 6572 6174  all that generat
+00021ec0: 6573 2064 6174 6120 7365 7269 6573 2e20  es data series. 
+00021ed0: 466f 7220 6578 616d 706c 653a 0a20 2020  For example:.   
+00021ee0: 2020 2020 6060 6772 6170 6869 6373 2873      ``graphics(s
+00021ef0: 6772 6964 2878 6c69 6d3d 2861 2c20 6229  grid(xlim=(a, b)
+00021f00: 2c20 796c 696d 3d28 632c 2064 2929 2960  , ylim=(c, d)))`
+00021f10: 600a 0a20 2020 2045 6974 6865 7220 7761  `..    Either wa
+00021f20: 792c 2074 6865 2061 7070 726f 7072 6961  y, the appropria
+00021f30: 7465 2072 656e 6465 7265 7220 7769 6c6c  te renderer will
+00021f40: 3a0a 0a20 2020 2031 2e20 6669 6775 7265  :..    1. figure
+00021f50: 2069 7420 6f75 7420 7468 6520 6178 6973   it out the axis
+00021f60: 206c 696d 6974 732e 0a20 2020 2032 2e20   limits..    2. 
+00021f70: 4c65 7420 7468 6520 6772 6964 2073 6572  Let the grid ser
+00021f80: 6965 7320 6b6e 6f77 7320 6162 6f75 7420  ies knows about 
+00021f90: 7468 6973 206c 696d 6974 7320 6279 2063  this limits by c
+00021fa0: 616c 6c69 6e67 0a20 2020 2020 2020 6060  alling.       ``
+00021fb0: 7365 7269 6573 2e73 6574 5f61 7869 735f  series.set_axis_
+00021fc0: 6c69 6d69 7473 2878 6c69 6d2c 2079 6c69  limits(xlim, yli
+00021fd0: 6d29 6060 2e0a 2020 2020 332e 2043 6f6d  m)``..    3. Com
+00021fe0: 7075 7465 2074 6865 206e 756d 6572 6963  pute the numeric
+00021ff0: 616c 2064 6174 6120 666f 7220 7468 6520  al data for the 
+00022000: 7370 6563 6966 6965 6420 6772 6964 2074  specified grid t
+00022010: 6861 7420 636f 7665 7220 7468 650a 2020  hat cover the.  
+00022020: 2020 2020 2073 7065 6369 6669 6564 2061       specified a
+00022030: 7265 612c 2077 6974 6820 6060 7365 7269  rea, with ``seri
+00022040: 6573 2e67 6574 5f64 6174 6128 2960 602e  es.get_data()``.
+00022050: 0a0a 2020 2020 2222 220a 2020 2020 6973  ..    """.    is
+00022060: 5f67 7269 6420 3d20 5472 7565 0a0a 2020  _grid = True..  
+00022070: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+00022080: 656c 662c 202a 6172 6773 2c20 2a2a 6b77  elf, *args, **kw
+00022090: 6172 6773 293a 0a20 2020 2020 2020 2073  args):.        s
+000220a0: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
+000220b0: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
+000220c0: 0a20 2020 2020 2020 2073 656c 662e 7368  .        self.sh
+000220d0: 6f77 5f69 6e5f 6c65 6765 6e64 203d 206b  ow_in_legend = k
+000220e0: 7761 7267 732e 6765 7428 2273 686f 775f  wargs.get("show_
+000220f0: 696e 5f6c 6567 656e 6422 2c20 4661 6c73  in_legend", Fals
+00022100: 6529 0a20 2020 2020 2020 2078 6c69 6d20  e).        xlim 
+00022110: 3d20 6b77 6172 6773 2e67 6574 2822 786c  = kwargs.get("xl
+00022120: 696d 222c 204e 6f6e 6529 0a20 2020 2020  im", None).     
+00022130: 2020 2079 6c69 6d20 3d20 6b77 6172 6773     ylim = kwargs
+00022140: 2e67 6574 2822 796c 696d 222c 204e 6f6e  .get("ylim", Non
+00022150: 6529 0a20 2020 2020 2020 2023 204a 7570  e).        # Jup
+00022160: 7974 6572 206c 6162 202b 2022 6672 6f6d  yter lab + "from
+00022170: 2073 796d 7079 2069 6d70 6f72 7420 2a22   sympy import *"
+00022180: 2063 6f6e 7665 7274 2061 6c6c 206e 756d   convert all num
+00022190: 6265 7273 2074 6f0a 2020 2020 2020 2020  bers to.        
+000221a0: 2320 7379 6d70 7927 7320 7479 7065 732e  # sympy's types.
+000221b0: 2054 6865 2061 6c67 6f72 6974 686d 2065   The algorithm e
+000221c0: 7870 6563 7465 7320 7468 656d 2074 6f20  xpectes them to 
+000221d0: 6265 2060 666c 6f61 7460 2e0a 2020 2020  be `float`..    
+000221e0: 2020 2020 7365 6c66 2e5f 786c 696d 203d      self._xlim =
+000221f0: 205b 666c 6f61 7428 7429 2066 6f72 2074   [float(t) for t
+00022200: 2069 6e20 786c 696d 5d20 6966 2078 6c69   in xlim] if xli
+00022210: 6d20 656c 7365 204e 6f6e 650a 2020 2020  m else None.    
+00022220: 2020 2020 7365 6c66 2e5f 796c 696d 203d      self._ylim =
+00022230: 205b 666c 6f61 7428 7429 2066 6f72 2074   [float(t) for t
+00022240: 2069 6e20 796c 696d 5d20 6966 2079 6c69   in ylim] if yli
+00022250: 6d20 656c 7365 204e 6f6e 650a 0a20 2020  m else None..   
+00022260: 2064 6566 2073 6574 5f61 7869 735f 6c69   def set_axis_li
+00022270: 6d69 7473 2873 656c 662c 2078 6c69 6d2c  mits(self, xlim,
+00022280: 2079 6c69 6d29 3a0a 2020 2020 2020 2020   ylim):.        
+00022290: 7365 6c66 2e5f 786c 696d 203d 2078 6c69  self._xlim = xli
+000222a0: 6d0a 2020 2020 2020 2020 7365 6c66 2e5f  m.        self._
+000222b0: 796c 696d 203d 2079 6c69 6d0a 0a20 2020  ylim = ylim..   
+000222c0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+000222d0: 6566 2078 6c69 6d28 7365 6c66 293a 0a20  ef xlim(self):. 
+000222e0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+000222f0: 6c66 2e5f 786c 696d 0a0a 2020 2020 4070  lf._xlim..    @p
+00022300: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+00022310: 796c 696d 2873 656c 6629 3a0a 2020 2020  ylim(self):.    
+00022320: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00022330: 5f79 6c69 6d0a 0a0a 636c 6173 7320 5347  _ylim...class SG
+00022340: 7269 644c 696e 6553 6572 6965 7328 4772  ridLineSeries(Gr
+00022350: 6964 4261 7365 2c20 4261 7365 5365 7269  idBase, BaseSeri
+00022360: 6573 293a 0a20 2020 2022 2222 5265 7072  es):.    """Repr
+00022370: 6573 656e 7420 6120 6772 6964 206f 6620  esent a grid of 
+00022380: 6461 6d70 696e 6720 7261 7469 6f20 6c69  damping ratio li
+00022390: 6e65 7320 616e 6420 6e61 7475 7261 6c20  nes and natural 
+000223a0: 6672 6571 7565 6e63 7920 6c69 6e65 730a  frequency lines.
+000223b0: 2020 2020 6f6e 2074 6865 2073 2d70 6c61      on the s-pla
+000223c0: 6e65 2e20 5468 6973 2064 6174 6120 7365  ne. This data se
+000223d0: 7269 6573 2069 6d70 6c65 6d65 6e74 7320  ries implements 
+000223e0: 7477 6f20 6d6f 6465 7320 6f66 206f 7065  two modes of ope
+000223f0: 7261 7469 6f6e 3a0a 0a20 2020 2031 2e20  ration:..    1. 
+00022400: 5573 6572 2063 616e 2070 726f 7669 6465  User can provide
+00022410: 2078 692c 2077 6e2e 0a20 2020 2032 2e20   xi, wn..    2. 
+00022420: 5573 6572 2063 616e 2070 726f 7669 6465  User can provide
+00022430: 2064 756d 6d79 2078 692c 2077 6e2c 2061   dummy xi, wn, a
+00022440: 6e64 2061 206c 6973 7420 6f66 2061 7373  nd a list of ass
+00022450: 6f63 6961 7465 6420 526f 6f74 4c6f 6375  ociated RootLocu
+00022460: 7353 6572 6965 732e 0a20 2020 2020 2020  sSeries..       
+00022470: 5768 656e 2060 6067 6574 5f64 6174 6128  When ``get_data(
+00022480: 2960 6020 7769 6c6c 2062 6520 6361 6c6c  )`` will be call
+00022490: 6564 2c20 6974 2066 6972 7374 206c 6f6f  ed, it first loo
+000224a0: 7073 206f 7665 7220 7468 6520 6173 736f  ps over the asso
+000224b0: 6369 6174 6564 0a20 2020 2020 2020 726f  ciated.       ro
+000224c0: 6f74 206c 6f63 7573 2073 6572 6965 7320  ot locus series 
+000224d0: 696e 206f 7264 6572 2074 6f20 6465 7465  in order to dete
+000224e0: 726d 696e 6520 7468 6520 6178 6973 206c  rmine the axis l
+000224f0: 696d 6974 7320 6f66 2074 6865 2076 6973  imits of the vis
+00022500: 6962 6c65 0a20 2020 2020 2020 6172 6561  ible.       area
+00022510: 2e20 5468 656e 2c20 6974 2063 6f6d 7075  . Then, it compu
+00022520: 7465 7320 6e65 7720 7661 6c75 6573 206f  tes new values o
+00022530: 6620 7869 2c20 776e 2069 6e20 6f72 6465  f xi, wn in orde
+00022540: 7220 746f 2067 6574 2067 7269 6420 6c69  r to get grid li
+00022550: 6e65 730a 2020 2020 2020 2022 6576 656e  nes.       "even
+00022560: 6c79 2220 6469 7374 7269 6275 7465 6420  ly" distributed 
+00022570: 6f6e 2074 6865 2061 7661 696c 6162 6c65  on the available
+00022580: 2073 7061 6365 2e0a 2020 2020 2222 220a   space..    """.
+00022590: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+000225a0: 5f28 7365 6c66 2c20 7869 2c20 776e 2c20  _(self, xi, wn, 
+000225b0: 7470 2c20 7473 2c20 7365 7269 6573 3d5b  tp, ts, series=[
+000225c0: 5d2c 202a 2a6b 7761 7267 7329 3a0a 2020  ], **kwargs):.  
+000225d0: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
+000225e0: 696e 6974 5f5f 282a 2a6b 7761 7267 7329  init__(**kwargs)
+000225f0: 0a20 2020 2020 2020 2073 656c 662e 7869  .        self.xi
+00022600: 203d 2078 690a 2020 2020 2020 2020 7365   = xi.        se
+00022610: 6c66 2e77 6e20 3d20 776e 0a20 2020 2020  lf.wn = wn.     
+00022620: 2020 2073 656c 662e 7470 203d 2074 700a     self.tp = tp.
+00022630: 2020 2020 2020 2020 7365 6c66 2e74 7320          self.ts 
+00022640: 3d20 7473 0a20 2020 2020 2020 2023 2077  = ts.        # w
+00022650: 6865 7468 6572 2063 6f6d 7075 7465 7320  hether computes 
+00022660: 7869 2f77 6e20 696e 206f 7264 6572 2074  xi/wn in order t
+00022670: 6f20 6576 656e 6c79 2064 6973 7472 6962  o evenly distrib
+00022680: 7574 6520 6c69 6e65 7320 6f76 6572 0a20  ute lines over. 
+00022690: 2020 2020 2020 2023 2074 6865 2061 7661         # the ava
+000226a0: 696c 6162 6c65 2070 6c6f 742d 6172 6561  ilable plot-area
+000226b0: 0a20 2020 2020 2020 2073 656c 662e 6175  .        self.au
+000226c0: 746f 203d 206b 7761 7267 732e 6765 7428  to = kwargs.get(
+000226d0: 2261 7574 6f22 2c20 4661 6c73 6529 0a20  "auto", False). 
+000226e0: 2020 2020 2020 2073 656c 662e 7368 6f77         self.show
+000226f0: 5f63 6f6e 7472 6f6c 5f61 7869 7320 3d20  _control_axis = 
+00022700: 6b77 6172 6773 2e67 6574 2822 7368 6f77  kwargs.get("show
+00022710: 5f63 6f6e 7472 6f6c 5f61 7869 7322 2c20  _control_axis", 
+00022720: 4661 6c73 6529 0a0a 2020 2020 6465 6620  False)..    def 
+00022730: 5f5f 7374 725f 5f28 7365 6c66 293a 0a20  __str__(self):. 
+00022740: 2020 2020 2020 2072 6574 7572 6e20 2273         return "s
+00022750: 2d67 7269 6422 0a0a 2020 2020 6465 6620  -grid"..    def 
+00022760: 5f73 6772 6964 5f64 6566 6175 6c74 5f78  _sgrid_default_x
+00022770: 6928 7365 6c66 2c20 786c 696d 2c20 796c  i(self, xlim, yl
+00022780: 696d 293a 0a20 2020 2020 2020 2022 2222  im):.        """
+00022790: 5265 7475 726e 2064 6566 6175 6c74 206c  Return default l
+000227a0: 6973 7420 6f66 2064 616d 7069 6e67 2063  ist of damping c
+000227b0: 6f65 6666 6963 6965 6e74 730a 0a20 2020  oefficients..   
+000227c0: 2020 2020 2054 6869 7320 6675 6e63 7469       This functi
+000227d0: 6f6e 2063 6f6d 7075 7465 7320 6120 6c69  on computes a li
+000227e0: 7374 206f 6620 6461 6d70 696e 6720 636f  st of damping co
+000227f0: 6566 6669 6369 656e 7473 2062 6173 6564  efficients based
+00022800: 206f 6e20 7468 6520 6c69 6d69 7473 0a20   on the limits. 
+00022810: 2020 2020 2020 206f 6620 7468 6520 6772         of the gr
+00022820: 6170 682e 2020 4120 7365 7420 6f66 2034  aph.  A set of 4
+00022830: 2064 616d 7069 6e67 2063 6f65 6666 6963   damping coeffic
+00022840: 6965 6e74 7320 6172 6520 636f 6d70 7574  ients are comput
+00022850: 6564 2066 6f72 2074 6865 2078 2d61 7869  ed for the x-axi
+00022860: 730a 2020 2020 2020 2020 616e 6420 6120  s.        and a 
+00022870: 7365 7420 6f66 2074 6872 6565 2064 616d  set of three dam
+00022880: 7069 6e67 2063 6f65 6666 6963 6965 6e74  ping coefficient
+00022890: 7320 6172 6520 636f 6d70 7574 6564 2066  s are computed f
+000228a0: 6f72 2074 6865 2079 2d61 7869 730a 2020  or the y-axis.  
+000228b0: 2020 2020 2020 2863 6f72 7265 7370 6f6e        (correspon
+000228c0: 6469 6e67 2074 6f20 7468 6520 6e6f 726d  ding to the norm
+000228d0: 616c 2034 3a33 2070 6c6f 7420 6173 7065  al 4:3 plot aspe
+000228e0: 6374 2072 6174 696f 2069 6e20 606d 6174  ct ratio in `mat
+000228f0: 706c 6f74 6c69 6260 3f29 2e0a 0a20 2020  plotlib`?)...   
+00022900: 2020 2020 2050 6172 616d 6574 6572 730a       Parameters.
+00022910: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
+00022920: 2d2d 0a20 2020 2020 2020 2078 6c69 6d20  --.        xlim 
+00022930: 3a20 6172 7261 795f 6c69 6b65 0a20 2020  : array_like.   
+00022940: 2020 2020 2020 2020 204c 6973 7420 6f66           List of
+00022950: 2078 2d61 7869 7320 6c69 6d69 7473 205b   x-axis limits [
+00022960: 6d69 6e2c 206d 6178 5d0a 2020 2020 2020  min, max].      
+00022970: 2020 796c 696d 203a 2061 7272 6179 5f6c    ylim : array_l
+00022980: 696b 650a 2020 2020 2020 2020 2020 2020  ike.            
+00022990: 4c69 7374 206f 6620 792d 6178 6973 206c  List of y-axis l
+000229a0: 696d 6974 7320 5b6d 696e 2c20 6d61 785d  imits [min, max]
+000229b0: 0a0a 2020 2020 2020 2020 5265 7475 726e  ..        Return
+000229c0: 730a 2020 2020 2020 2020 2d2d 2d2d 2d2d  s.        ------
+000229d0: 2d0a 2020 2020 2020 2020 7a65 7461 203a  -.        zeta :
+000229e0: 206c 6973 740a 2020 2020 2020 2020 2020   list.          
+000229f0: 2020 4c69 7374 206f 6620 6465 6661 756c    List of defaul
+00022a00: 7420 6461 6d70 696e 6720 636f 6566 6669  t damping coeffi
+00022a10: 6369 656e 7473 2066 6f72 2074 6865 2070  cients for the p
+00022a20: 6c6f 740a 0a20 2020 2020 2020 2022 2222  lot..        """
+00022a30: 0a20 2020 2020 2020 206e 7020 3d20 696d  .        np = im
+00022a40: 706f 7274 5f6d 6f64 756c 6528 226e 756d  port_module("num
+00022a50: 7079 2229 0a0a 2020 2020 2020 2020 785f  py")..        x_
+00022a60: 6c6f 7765 725f 6c69 6d20 3d20 786c 696d  lower_lim = xlim
+00022a70: 5b30 5d20 6966 2078 6c69 6d20 656c 7365  [0] if xlim else
+00022a80: 202d 3130 0a20 2020 2020 2020 2079 5f75   -10.        y_u
+00022a90: 7070 6572 5f6c 696d 203d 2079 6c69 6d5b  pper_lim = ylim[
+00022aa0: 315d 2069 6620 796c 696d 2065 6c73 6520  1] if ylim else 
+00022ab0: 3130 0a0a 2020 2020 2020 2020 2320 4461  10..        # Da
+00022ac0: 6d70 696e 6720 636f 6566 6669 6369 656e  mping coefficien
+00022ad0: 7420 6c69 6e65 7320 7468 6174 2069 6e74  t lines that int
+00022ae0: 6572 7365 6374 2074 6865 2078 2d61 7869  ersect the x-axi
+00022af0: 730a 2020 2020 2020 2020 7365 7031 203d  s.        sep1 =
+00022b00: 202d 785f 6c6f 7765 725f 6c69 6d20 2f20   -x_lower_lim / 
+00022b10: 340a 2020 2020 2020 2020 616e 6731 203d  4.        ang1 =
+00022b20: 205b 6e70 2e61 7263 7461 6e28 2873 6570   [np.arctan((sep
+00022b30: 312a 6929 2f79 5f75 7070 6572 5f6c 696d  1*i)/y_upper_lim
+00022b40: 2920 666f 7220 6920 696e 206e 702e 6172  ) for i in np.ar
+00022b50: 616e 6765 2831 2c20 342c 2031 295d 0a0a  ange(1, 4, 1)]..
+00022b60: 2020 2020 2020 2020 2320 4461 6d70 696e          # Dampin
+00022b70: 6720 636f 6566 6669 6369 656e 7420 6c69  g coefficient li
+00022b80: 6e65 7320 7468 6174 2069 6e74 6572 7365  nes that interse
+00022b90: 6374 696f 6e20 7468 6520 792d 6178 6973  ction the y-axis
+00022ba0: 0a20 2020 2020 2020 2073 6570 3220 3d20  .        sep2 = 
+00022bb0: 795f 7570 7065 725f 6c69 6d20 2f20 330a  y_upper_lim / 3.
+00022bc0: 2020 2020 2020 2020 616e 6732 203d 205b          ang2 = [
+00022bd0: 0a20 2020 2020 2020 2020 2020 206e 702e  .            np.
+00022be0: 6172 6374 616e 282d 785f 6c6f 7765 725f  arctan(-x_lower_
+00022bf0: 6c69 6d2f 2879 5f75 7070 6572 5f6c 696d  lim/(y_upper_lim
+00022c00: 2d73 6570 322a 6929 290a 2020 2020 2020  -sep2*i)).      
+00022c10: 2020 2020 2020 666f 7220 6920 696e 206e        for i in n
+00022c20: 702e 6172 616e 6765 2831 2c20 332c 2031  p.arange(1, 3, 1
+00022c30: 290a 2020 2020 2020 2020 5d0a 0a20 2020  ).        ]..   
+00022c40: 2020 2020 2023 2050 7574 2074 6865 206c       # Put the l
+00022c50: 696e 6573 2074 6f67 6574 6865 7220 616e  ines together an
+00022c60: 6420 6164 6420 6f6e 6520 6174 202d 7069  d add one at -pi
+00022c70: 2f32 2028 6e65 6761 7469 7665 2072 6561  /2 (negative rea
+00022c80: 6c20 6178 6973 290a 2020 2020 2020 2020  l axis).        
+00022c90: 616e 676c 6573 203d 206e 702e 636f 6e63  angles = np.conc
+00022ca0: 6174 656e 6174 6528 2861 6e67 312c 2061  atenate((ang1, a
+00022cb0: 6e67 3229 290a 0a20 2020 2020 2020 2023  ng2))..        #
+00022cc0: 2052 6574 7572 6e20 7468 6520 6461 6d70   Return the damp
+00022cd0: 696e 6720 636f 6566 6669 6369 656e 7473  ing coefficients
+00022ce0: 2063 6f72 7265 7370 6f6e 6469 6e67 2074   corresponding t
+00022cf0: 6f20 7468 6573 6520 616e 676c 6573 0a20  o these angles. 
+00022d00: 2020 2020 2020 207a 6574 6120 3d20 6e70         zeta = np
+00022d10: 2e73 696e 2861 6e67 6c65 7329 2e74 6f6c  .sin(angles).tol
+00022d20: 6973 7428 290a 2020 2020 2020 2020 6966  ist().        if
+00022d30: 206e 6f74 2073 656c 662e 7368 6f77 5f63   not self.show_c
+00022d40: 6f6e 7472 6f6c 5f61 7869 733a 0a20 2020  ontrol_axis:.   
+00022d50: 2020 2020 2020 2020 207a 6574 6120 2b3d           zeta +=
+00022d60: 205b 302c 2031 5d0a 2020 2020 2020 2020   [0, 1].        
+00022d70: 7265 7475 726e 207a 6574 610a 0a20 2020  return zeta..   
+00022d80: 2064 6566 205f 7367 7269 645f 6465 6661   def _sgrid_defa
+00022d90: 756c 745f 776e 2873 656c 662c 2078 6c69  ult_wn(self, xli
+00022da0: 6d2c 2079 6c69 6d2c 206d 6178 5f6c 696e  m, ylim, max_lin
+00022db0: 6573 3d37 293a 0a20 2020 2020 2020 2022  es=7):.        "
+00022dc0: 2222 5265 7475 726e 2064 6566 6175 6c74  ""Return default
+00022dd0: 2077 6e20 666f 7220 726f 6f74 206c 6f63   wn for root loc
+00022de0: 7573 2070 6c6f 740a 0a20 2020 2020 2020  us plot..       
+00022df0: 2054 6869 7320 6675 6e63 7469 6f6e 2063   This function c
+00022e00: 6f6d 7075 7465 7320 6120 6c69 7374 206f  omputes a list o
+00022e10: 6620 6e61 7475 7261 6c20 6672 6571 7565  f natural freque
+00022e20: 6e63 6965 7320 6261 7365 6420 6f6e 2074  ncies based on t
+00022e30: 6865 2067 7269 640a 2020 2020 2020 2020  he grid.        
+00022e40: 7061 7261 6d65 7465 7273 206f 6620 7468  parameters of th
+00022e50: 6520 6772 6170 682e 0a0a 2020 2020 2020  e graph...      
+00022e60: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+00022e70: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a       ----------.
+00022e80: 2020 2020 2020 2020 786c 6f63 203a 2061          xloc : a
+00022e90: 7272 6179 5f6c 696b 650a 2020 2020 2020  rray_like.      
+00022ea0: 2020 2020 2020 4c69 7374 206f 6620 782d        List of x-
+00022eb0: 6178 6973 2074 6963 6b20 7661 6c75 6573  axis tick values
+00022ec0: 0a20 2020 2020 2020 2079 6c69 6d20 3a20  .        ylim : 
+00022ed0: 6172 7261 795f 6c69 6b65 0a20 2020 2020  array_like.     
+00022ee0: 2020 2020 2020 204c 6973 7420 6f66 2079         List of y
+00022ef0: 2d61 7869 7320 6c69 6d69 7473 205b 6d69  -axis limits [mi
+00022f00: 6e2c 206d 6178 5d0a 2020 2020 2020 2020  n, max].        
+00022f10: 6d61 785f 6c69 6e65 7320 3a20 696e 742c  max_lines : int,
+00022f20: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
+00022f30: 2020 2020 2020 4d61 7869 6d75 6d20 6e75        Maximum nu
+00022f40: 6d62 6572 206f 6620 6672 6571 7565 6e63  mber of frequenc
+00022f50: 6965 7320 746f 2067 656e 6572 6174 6520  ies to generate 
+00022f60: 2864 6566 6175 6c74 203d 2037 290a 0a20  (default = 7).. 
+00022f70: 2020 2020 2020 2052 6574 7572 6e73 0a20         Returns. 
+00022f80: 2020 2020 2020 202d 2d2d 2d2d 2d2d 0a20         -------. 
+00022f90: 2020 2020 2020 2077 6e20 3a20 6c69 7374         wn : list
+00022fa0: 0a20 2020 2020 2020 2020 2020 204c 6973  .            Lis
+00022fb0: 7420 6f66 2064 6566 6175 6c74 206e 6174  t of default nat
+00022fc0: 7572 616c 2066 7265 7175 656e 6369 6573  ural frequencies
+00022fd0: 2066 6f72 2074 6865 2070 6c6f 740a 0a20   for the plot.. 
+00022fe0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00022ff0: 2020 206c 6f77 6572 5f6c 696d 203d 2078     lower_lim = x
+00023000: 6c69 6d5b 305d 2069 6620 786c 696d 2065  lim[0] if xlim e
+00023010: 6c73 6520 2d31 300a 2020 2020 2020 2020  lse -10.        
+00023020: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
+00023030: 6c65 2822 6e75 6d70 7922 290a 2020 2020  le("numpy").    
+00023040: 2020 2020 6176 6169 6c61 626c 655f 7769      available_wi
+00023050: 6474 6820 3d20 3020 2d20 6c6f 7765 725f  dth = 0 - lower_
+00023060: 6c69 6d0a 2020 2020 2020 2020 776e 203d  lim.        wn =
+00023070: 206e 702e 6c69 6e73 7061 6365 2830 2c20   np.linspace(0, 
+00023080: 6162 7328 6c6f 7765 725f 6c69 6d29 2c20  abs(lower_lim), 
+00023090: 6d61 785f 6c69 6e65 7329 5b31 3a2d 315d  max_lines)[1:-1]
+000230a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000230b0: 776e 0a0a 2020 2020 6465 6620 6765 745f  wn..    def get_
+000230c0: 6461 7461 2873 656c 6629 3a0a 2020 2020  data(self):.    
+000230d0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+000230e0: 5265 7475 726e 730a 2020 2020 2020 2020  Returns.        
+000230f0: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
+00023100: 7869 5f64 6963 7420 3a20 6469 6374 0a20  xi_dict : dict. 
+00023110: 2020 2020 2020 2077 6e5f 6469 6374 203a         wn_dict :
+00023120: 2064 6963 740a 2020 2020 2020 2020 795f   dict.        y_
+00023130: 7470 203a 206e 702e 6e64 6172 7261 790a  tp : np.ndarray.
+00023140: 2020 2020 2020 2020 785f 7473 203a 206e          x_ts : n
+00023150: 702e 6e64 6172 7261 790a 2020 2020 2020  p.ndarray.      
+00023160: 2020 2222 220a 2020 2020 2020 2020 6e70    """.        np
+00023170: 203d 2069 6d70 6f72 745f 6d6f 6475 6c65   = import_module
+00023180: 2822 6e75 6d70 7922 290a 0a20 2020 2020  ("numpy")..     
+00023190: 2020 2069 6620 7365 6c66 2e61 7574 6f3a     if self.auto:
+000231a0: 0a20 2020 2020 2020 2020 2020 2078 6920  .            xi 
+000231b0: 3d20 7365 6c66 2e5f 7367 7269 645f 6465  = self._sgrid_de
+000231c0: 6661 756c 745f 7869 2873 656c 662e 786c  fault_xi(self.xl
+000231d0: 696d 2c20 7365 6c66 2e79 6c69 6d29 0a20  im, self.ylim). 
+000231e0: 2020 2020 2020 2020 2020 2077 6e20 3d20             wn = 
+000231f0: 7365 6c66 2e5f 7367 7269 645f 6465 6661  self._sgrid_defa
+00023200: 756c 745f 776e 2873 656c 662e 786c 696d  ult_wn(self.xlim
+00023210: 2c20 7365 6c66 2e79 6c69 6d29 0a20 2020  , self.ylim).   
+00023220: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00023230: 2020 2020 2020 2078 6920 3d20 6e70 2e61         xi = np.a
+00023240: 7272 6179 285b 0a20 2020 2020 2020 2020  rray([.         
+00023250: 2020 2020 2020 2074 2e65 7661 6c66 2873         t.evalf(s
+00023260: 7562 733d 7365 6c66 2e70 6172 616d 7329  ubs=self.params)
+00023270: 2069 6620 6973 696e 7374 616e 6365 2874   if isinstance(t
+00023280: 2c20 4578 7072 2920 656c 7365 2074 0a20  , Expr) else t. 
+00023290: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+000232a0: 6f72 2074 2069 6e20 7365 6c66 2e78 695d  or t in self.xi]
+000232b0: 2c20 6474 7970 653d 666c 6f61 7429 0a20  , dtype=float). 
+000232c0: 2020 2020 2020 2020 2020 2069 6620 616e             if an
+000232d0: 7928 7869 203e 2031 2920 6f72 2061 6e79  y(xi > 1) or any
+000232e0: 2878 6920 3c20 3029 3a0a 2020 2020 2020  (xi < 0):.      
+000232f0: 2020 2020 2020 2020 2020 2320 456e 666f            # Enfo
+00023300: 7263 6520 7468 6973 2063 6f6e 6469 7469  rce this conditi
+00023310: 6f6e 0a20 2020 2020 2020 2020 2020 2020  on.             
+00023320: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00023330: 726f 7228 2249 7420 6d75 7374 2062 6520  ror("It must be 
+00023340: 6060 3020 3c3d 2078 6920 3c3d 2031 2e20  ``0 <= xi <= 1. 
+00023350: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+00023360: 2020 2020 2020 2243 6f6d 7075 7465 643a        "Computed:
+00023370: 2025 7322 2025 2078 6929 0a20 2020 2020   %s" % xi).     
+00023380: 2020 2020 2020 2077 6e20 3d20 6e70 2e61         wn = np.a
+00023390: 7272 6179 285b 0a20 2020 2020 2020 2020  rray([.         
+000233a0: 2020 2020 2020 2074 2e65 7661 6c66 2873         t.evalf(s
+000233b0: 7562 733d 7365 6c66 2e70 6172 616d 7329  ubs=self.params)
+000233c0: 2069 6620 6973 696e 7374 616e 6365 2874   if isinstance(t
+000233d0: 2c20 4578 7072 2920 656c 7365 2074 0a20  , Expr) else t. 
+000233e0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+000233f0: 6f72 2074 2069 6e20 7365 6c66 2e77 6e5d  or t in self.wn]
+00023400: 2c20 6474 7970 653d 666c 6f61 7429 0a20  , dtype=float). 
+00023410: 2020 2020 2020 2074 7020 3d20 6e70 2e61         tp = np.a
+00023420: 7272 6179 285b 0a20 2020 2020 2020 2020  rray([.         
+00023430: 2020 2074 2e65 7661 6c66 2873 7562 733d     t.evalf(subs=
+00023440: 7365 6c66 2e70 6172 616d 7329 2069 6620  self.params) if 
+00023450: 6973 696e 7374 616e 6365 2874 2c20 4578  isinstance(t, Ex
+00023460: 7072 2920 656c 7365 2074 0a20 2020 2020  pr) else t.     
+00023470: 2020 2020 2020 2066 6f72 2074 2069 6e20         for t in 
+00023480: 7365 6c66 2e74 705d 2c20 6474 7970 653d  self.tp], dtype=
+00023490: 666c 6f61 7429 0a20 2020 2020 2020 2074  float).        t
+000234a0: 7320 3d20 6e70 2e61 7272 6179 285b 0a20  s = np.array([. 
+000234b0: 2020 2020 2020 2020 2020 2074 2e65 7661             t.eva
+000234c0: 6c66 2873 7562 733d 7365 6c66 2e70 6172  lf(subs=self.par
+000234d0: 616d 7329 2069 6620 6973 696e 7374 616e  ams) if isinstan
+000234e0: 6365 2874 2c20 4578 7072 2920 656c 7365  ce(t, Expr) else
+000234f0: 2074 0a20 2020 2020 2020 2020 2020 2066   t.            f
+00023500: 6f72 2074 2069 6e20 7365 6c66 2e74 735d  or t in self.ts]
+00023510: 2c20 6474 7970 653d 666c 6f61 7429 0a0a  , dtype=float)..
+00023520: 2020 2020 2020 2020 616e 676c 6573 203d          angles =
+00023530: 206e 702e 7069 202d 206e 702e 6172 6363   np.pi - np.arcc
+00023540: 6f73 2878 6929 0a20 2020 2020 2020 2079  os(xi).        y
+00023550: 5f6f 7665 725f 7820 3d20 6e70 2e74 616e  _over_x = np.tan
+00023560: 2861 6e67 6c65 7329 0a20 2020 2020 2020  (angles).       
+00023570: 2072 203d 206d 6178 2831 3030 302c 206d   r = max(1000, m
+00023580: 6178 2877 6e29 2920 6966 206c 656e 2877  ax(wn)) if len(w
+00023590: 6e29 203e 2030 2065 6c73 6520 3130 3030  n) > 0 else 1000
+000235a0: 0a0a 2020 2020 2020 2020 7869 5f64 6963  ..        xi_dic
+000235b0: 7420 3d20 7b6b 3a20 7b7d 2066 6f72 206b  t = {k: {} for k
+000235c0: 2069 6e20 7a69 7028 7869 2c20 616e 676c   in zip(xi, angl
+000235d0: 6573 2c20 795f 6f76 6572 5f78 297d 0a20  es, y_over_x)}. 
+000235e0: 2020 2020 2020 2077 6e5f 6469 6374 203d         wn_dict =
+000235f0: 207b 6b3a 207b 7d20 666f 7220 6b20 696e   {k: {} for k in
+00023600: 2077 6e7d 0a20 2020 2020 2020 2074 705f   wn}.        tp_
+00023610: 6469 6374 203d 207b 6b3a 207b 7d20 666f  dict = {k: {} fo
+00023620: 7220 6b20 696e 2074 707d 0a20 2020 2020  r k in tp}.     
+00023630: 2020 2074 735f 6469 6374 203d 207b 6b3a     ts_dict = {k:
+00023640: 207b 7d20 666f 7220 6b20 696e 2074 737d   {} for k in ts}
+00023650: 0a0a 2020 2020 2020 2020 2320 6461 6d70  ..        # damp
+00023660: 696e 6720 7261 7469 6f20 6c69 6e65 730a  ing ratio lines.
+00023670: 2020 2020 2020 2020 666f 7220 6b20 696e          for k in
+00023680: 207a 6970 2878 692c 2061 6e67 6c65 732c   zip(xi, angles,
+00023690: 2079 5f6f 7665 725f 7829 3a0a 2020 2020   y_over_x):.    
+000236a0: 2020 2020 2020 2020 782c 2061 2c20 7970          x, a, yp
+000236b0: 203d 206b 0a20 2020 2020 2020 2020 2020   = k.           
+000236c0: 2078 695f 6469 6374 5b6b 5d5b 2278 225d   xi_dict[k]["x"]
+000236d0: 203d 206e 702e 6172 7261 7928 5b30 2c20   = np.array([0, 
+000236e0: 7220 2a20 6e70 2e63 6f73 2861 295d 290a  r * np.cos(a)]).
+000236f0: 2020 2020 2020 2020 2020 2020 7869 5f64              xi_d
+00023700: 6963 745b 6b5d 5b22 7922 5d20 3d20 6e70  ict[k]["y"] = np
+00023710: 2e61 7272 6179 285b 302c 2072 202a 206e  .array([0, r * n
+00023720: 702e 7369 6e28 6129 5d29 0a20 2020 2020  p.sin(a)]).     
+00023730: 2020 2020 2020 2078 695f 6469 6374 5b6b         xi_dict[k
+00023740: 5d5b 226c 6162 656c 225d 203d 2022 252e  ]["label"] = "%.
+00023750: 3266 2220 2520 780a 0a20 2020 2020 2020  2f" % x..       
+00023760: 2023 206e 6174 7572 616c 2066 7265 7175   # natural frequ
+00023770: 656e 6379 206c 696e 6573 0a20 2020 2020  ency lines.     
+00023780: 2020 2074 203d 206e 702e 6c69 6e73 7061     t = np.linspa
+00023790: 6365 286e 702e 7069 2f32 2c20 332a 6e70  ce(np.pi/2, 3*np
+000237a0: 2e70 692f 322c 2031 3030 290a 2020 2020  .pi/2, 100).    
+000237b0: 2020 2020 6374 203d 206e 702e 636f 7328      ct = np.cos(
+000237c0: 7429 0a20 2020 2020 2020 2073 7420 3d20  t).        st = 
+000237d0: 6e70 2e73 696e 2874 290a 2020 2020 2020  np.sin(t).      
+000237e0: 2020 796c 696d 203d 2073 656c 662e 5f79    ylim = self._y
+000237f0: 6c69 6d0a 2020 2020 2020 2020 795f 6f66  lim.        y_of
+00023800: 6673 6574 203d 2030 2069 6620 796c 696d  fset = 0 if ylim
+00023810: 2069 7320 4e6f 6e65 2065 6c73 6520 302e   is None else 0.
+00023820: 3031 3520 2a20 6162 7328 796c 696d 5b31  015 * abs(ylim[1
+00023830: 5d20 2d20 796c 696d 5b30 5d29 0a20 2020  ] - ylim[0]).   
+00023840: 2020 2020 2066 6f72 2077 2069 6e20 776e       for w in wn
+00023850: 3a0a 2020 2020 2020 2020 2020 2020 776e  :.            wn
+00023860: 5f64 6963 745b 775d 5b22 7822 5d20 3d20  _dict[w]["x"] = 
+00023870: 7720 2a20 6374 0a20 2020 2020 2020 2020  w * ct.         
+00023880: 2020 2077 6e5f 6469 6374 5b77 5d5b 2279     wn_dict[w]["y
+00023890: 225d 203d 2077 202a 2073 740a 2020 2020  "] = w * st.    
+000238a0: 2020 2020 2020 2020 776e 5f64 6963 745b          wn_dict[
+000238b0: 775d 5b22 6c61 6265 6c22 5d20 3d20 2225  w]["label"] = "%
+000238c0: 2e32 6622 2025 2077 0a20 2020 2020 2020  .2f" % w.       
+000238d0: 2020 2020 2077 6e5f 6469 6374 5b77 5d5b       wn_dict[w][
+000238e0: 226c 7822 5d20 3d20 2d77 0a20 2020 2020  "lx"] = -w.     
+000238f0: 2020 2020 2020 2077 6e5f 6469 6374 5b77         wn_dict[w
+00023900: 5d5b 226c 7922 5d20 3d20 795f 6f66 6673  ]["ly"] = y_offs
+00023910: 6574 0a0a 2020 2020 2020 2020 2320 7065  et..        # pe
+00023920: 616b 2074 696d 6520 6c69 6e65 730a 2020  ak time lines.  
+00023930: 2020 2020 2020 795f 7470 203d 206e 702e        y_tp = np.
+00023940: 7069 202f 2074 700a 2020 2020 2020 2020  pi / tp.        
+00023950: 2320 7365 7474 6c69 6e67 2074 696d 6520  # settling time 
+00023960: 6c69 6e65 730a 2020 2020 2020 2020 785f  lines.        x_
+00023970: 7473 203d 202d 3420 2f20 7473 0a0a 2020  ts = -4 / ts..  
+00023980: 2020 2020 2020 7265 7475 726e 2078 695f        return xi_
+00023990: 6469 6374 2c20 776e 5f64 6963 742c 2079  dict, wn_dict, y
+000239a0: 5f74 702c 2078 5f74 730a 0a0a 636c 6173  _tp, x_ts...clas
+000239b0: 7320 5a47 7269 644c 696e 6553 6572 6965  s ZGridLineSerie
+000239c0: 7328 4772 6964 4261 7365 2c20 4261 7365  s(GridBase, Base
+000239d0: 5365 7269 6573 293a 0a20 2020 2022 2222  Series):.    """
+000239e0: 5265 7072 6573 656e 7420 6120 6772 6964  Represent a grid
+000239f0: 206f 6620 6461 6d70 696e 6720 7261 7469   of damping rati
+00023a00: 6f20 6c69 6e65 7320 616e 6420 6e61 7475  o lines and natu
+00023a10: 7261 6c20 6672 6571 7565 6e63 7920 6c69  ral frequency li
+00023a20: 6e65 730a 2020 2020 6f6e 2074 6865 207a  nes.    on the z
+00023a30: 2d70 6c61 6e65 2e0a 2020 2020 2222 220a  -plane..    """.
+00023a40: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+00023a50: 5f28 7365 6c66 2c20 7869 2c20 776e 2c20  _(self, xi, wn, 
+00023a60: 7470 2c20 7473 2c20 2a2a 6b77 6172 6773  tp, ts, **kwargs
+00023a70: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
+00023a80: 2829 2e5f 5f69 6e69 745f 5f28 2a2a 6b77  ().__init__(**kw
+00023a90: 6172 6773 290a 2020 2020 2020 2020 5420  args).        T 
+00023aa0: 3d20 6b77 6172 6773 2e67 6574 2822 5422  = kwargs.get("T"
+00023ab0: 2c20 4e6f 6e65 290a 2020 2020 2020 2020  , None).        
+00023ac0: 7365 6c66 2e73 616d 706c 696e 675f 7065  self.sampling_pe
+00023ad0: 7269 6f64 203d 2054 2069 6620 5420 6973  riod = T if T is
+00023ae0: 204e 6f6e 6520 656c 7365 2066 6c6f 6174   None else float
+00023af0: 2854 290a 2020 2020 2020 2020 7365 6c66  (T).        self
+00023b00: 2e78 6920 3d20 7869 0a20 2020 2020 2020  .xi = xi.       
+00023b10: 2073 656c 662e 776e 203d 2077 6e0a 2020   self.wn = wn.  
+00023b20: 2020 2020 2020 7365 6c66 2e74 7020 3d20        self.tp = 
+00023b30: 7470 0a20 2020 2020 2020 2073 656c 662e  tp.        self.
+00023b40: 7473 203d 2074 730a 2020 2020 2020 2020  ts = ts.        
+00023b50: 7365 6c66 2e73 686f 775f 636f 6e74 726f  self.show_contro
+00023b60: 6c5f 6178 6973 203d 206b 7761 7267 732e  l_axis = kwargs.
+00023b70: 6765 7428 2273 686f 775f 636f 6e74 726f  get("show_contro
+00023b80: 6c5f 6178 6973 222c 2046 616c 7365 290a  l_axis", False).
+00023b90: 0a20 2020 2064 6566 205f 5f73 7472 5f5f  .    def __str__
+00023ba0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00023bb0: 7265 7475 726e 2022 7a2d 6772 6964 220a  return "z-grid".
+00023bc0: 0a20 2020 2064 6566 2067 6574 5f64 6174  .    def get_dat
+00023bd0: 6128 7365 6c66 293a 0a20 2020 2020 2020  a(self):.       
+00023be0: 2022 2222 0a20 2020 2020 2020 2052 6574   """.        Ret
+00023bf0: 7572 6e73 0a20 2020 2020 2020 203d 3d3d  urns.        ===
+00023c00: 3d3d 3d3d 0a20 2020 2020 2020 2078 692c  ====.        xi,
+00023c10: 2077 6e2c 2074 702c 2074 7320 3a20 6469   wn, tp, ts : di
+00023c20: 6374 0a20 2020 2020 2020 2020 2020 2044  ct.            D
+00023c30: 6963 7469 6f6e 6172 6965 7320 636f 6e74  ictionaries cont
+00023c40: 6169 6e69 6e67 2074 6865 2072 6571 7569  aining the requi
+00023c50: 7265 6420 6e75 6d65 7269 6361 6c20 6461  red numerical da
+00023c60: 7461 2074 6f20 6372 6561 7465 0a20 2020  ta to create.   
+00023c70: 2020 2020 2020 2020 206c 696e 6573 2061           lines a
+00023c80: 6e64 2061 6e6e 6f74 6174 696f 6e73 2e0a  nd annotations..
+00023c90: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00023ca0: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
+00023cb0: 6d6f 6475 6c65 2822 6e75 6d70 7922 290a  module("numpy").
+00023cc0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00023cd0: 6973 5f69 6e74 6572 6163 7469 7665 3a0a  is_interactive:.
+00023ce0: 2020 2020 2020 2020 2020 2020 7869 203d              xi =
+00023cf0: 206e 702e 6172 7261 7928 5b0a 2020 2020   np.array([.    
+00023d00: 2020 2020 2020 2020 2020 2020 742e 6576              t.ev
+00023d10: 616c 6628 7375 6273 3d73 656c 662e 7061  alf(subs=self.pa
+00023d20: 7261 6d73 2920 6966 2069 7369 6e73 7461  rams) if isinsta
+00023d30: 6e63 6528 742c 2045 7870 7229 2065 6c73  nce(t, Expr) els
+00023d40: 6520 740a 2020 2020 2020 2020 2020 2020  e t.            
+00023d50: 2020 2020 666f 7220 7420 696e 2073 656c      for t in sel
+00023d60: 662e 7869 5d2c 2064 7479 7065 3d66 6c6f  f.xi], dtype=flo
+00023d70: 6174 290a 2020 2020 2020 2020 2020 2020  at).            
+00023d80: 776e 203d 206e 702e 6172 7261 7928 5b0a  wn = np.array([.
+00023d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023da0: 742e 6576 616c 6628 7375 6273 3d73 656c  t.evalf(subs=sel
+00023db0: 662e 7061 7261 6d73 2920 6966 2069 7369  f.params) if isi
+00023dc0: 6e73 7461 6e63 6528 742c 2045 7870 7229  nstance(t, Expr)
+00023dd0: 2065 6c73 6520 740a 2020 2020 2020 2020   else t.        
+00023de0: 2020 2020 2020 2020 666f 7220 7420 696e          for t in
+00023df0: 2073 656c 662e 776e 5d2c 2064 7479 7065   self.wn], dtype
+00023e00: 3d66 6c6f 6174 290a 2020 2020 2020 2020  =float).        
+00023e10: 2020 2020 7470 203d 206e 702e 6172 7261      tp = np.arra
+00023e20: 7928 5b0a 2020 2020 2020 2020 2020 2020  y([.            
+00023e30: 2020 2020 742e 6576 616c 6628 7375 6273      t.evalf(subs
+00023e40: 3d73 656c 662e 7061 7261 6d73 2920 6966  =self.params) if
+00023e50: 2069 7369 6e73 7461 6e63 6528 742c 2045   isinstance(t, E
+00023e60: 7870 7229 2065 6c73 6520 740a 2020 2020  xpr) else t.    
+00023e70: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00023e80: 7420 696e 2073 656c 662e 7470 5d2c 2064  t in self.tp], d
+00023e90: 7479 7065 3d66 6c6f 6174 290a 2020 2020  type=float).    
+00023ea0: 2020 2020 2020 2020 7473 203d 206e 702e          ts = np.
+00023eb0: 6172 7261 7928 5b0a 2020 2020 2020 2020  array([.        
+00023ec0: 2020 2020 2020 2020 742e 6576 616c 6628          t.evalf(
+00023ed0: 7375 6273 3d73 656c 662e 7061 7261 6d73  subs=self.params
+00023ee0: 2920 6966 2069 7369 6e73 7461 6e63 6528  ) if isinstance(
+00023ef0: 742c 2045 7870 7229 2065 6c73 6520 740a  t, Expr) else t.
+00023f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023f10: 666f 7220 7420 696e 2073 656c 662e 7473  for t in self.ts
+00023f20: 5d2c 2064 7479 7065 3d66 6c6f 6174 290a  ], dtype=float).
+00023f30: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00023f40: 2020 2020 2020 2020 2020 7869 203d 206e            xi = n
+00023f50: 702e 6172 7261 7928 7365 6c66 2e78 692c  p.array(self.xi,
+00023f60: 2064 7479 7065 3d66 6c6f 6174 290a 2020   dtype=float).  
+00023f70: 2020 2020 2020 2020 2020 776e 203d 206e            wn = n
+00023f80: 702e 6172 7261 7928 7365 6c66 2e77 6e2c  p.array(self.wn,
+00023f90: 2064 7479 7065 3d66 6c6f 6174 290a 2020   dtype=float).  
+00023fa0: 2020 2020 2020 2020 2020 7470 203d 206e            tp = n
+00023fb0: 702e 6172 7261 7928 7365 6c66 2e74 702c  p.array(self.tp,
+00023fc0: 2064 7479 7065 3d66 6c6f 6174 290a 2020   dtype=float).  
+00023fd0: 2020 2020 2020 2020 2020 7473 203d 206e            ts = n
+00023fe0: 702e 6172 7261 7928 7365 6c66 2e74 732c  p.array(self.ts,
+00023ff0: 2064 7479 7065 3d66 6c6f 6174 290a 0a20   dtype=float).. 
+00024000: 2020 2020 2020 2054 203d 2073 656c 662e         T = self.
+00024010: 7361 6d70 6c69 6e67 5f70 6572 696f 640a  sampling_period.
+00024020: 2020 2020 2020 2020 7869 5f64 6963 7420          xi_dict 
+00024030: 3d20 7b6b 3a20 7b7d 2066 6f72 206b 2069  = {k: {} for k i
+00024040: 6e20 7869 7d0a 2020 2020 2020 2020 776e  n xi}.        wn
+00024050: 5f64 6963 7420 3d20 7b6b 3a20 7b7d 2066  _dict = {k: {} f
+00024060: 6f72 206b 2069 6e20 776e 7d0a 2020 2020  or k in wn}.    
+00024070: 2020 2020 7470 5f64 6963 7420 3d20 7b6b      tp_dict = {k
+00024080: 3a20 7b7d 2066 6f72 206b 2069 6e20 7470  : {} for k in tp
+00024090: 7d0a 2020 2020 2020 2020 7473 5f64 6963  }.        ts_dic
+000240a0: 7420 3d20 7b6b 3a20 7b7d 2066 6f72 206b  t = {k: {} for k
+000240b0: 2069 6e20 7473 7d0a 0a20 2020 2020 2020   in ts}..       
+000240c0: 2023 2064 616d 7069 6e67 2072 6174 696f   # damping ratio
+000240d0: 206c 696e 6573 0a20 2020 2020 2020 2066   lines.        f
+000240e0: 6f72 207a 6574 6120 696e 2078 693a 0a20  or zeta in xi:. 
+000240f0: 2020 2020 2020 2020 2020 2023 2043 616c             # Cal
+00024100: 6375 6c61 7465 2069 6e20 706f 6c61 7220  culate in polar 
+00024110: 636f 6f72 6469 6e61 7465 730a 2020 2020  coordinates.    
+00024120: 2020 2020 2020 2020 6661 6374 6f72 203d          factor =
+00024130: 207a 6574 612f 6e70 2e73 7172 7428 312d   zeta/np.sqrt(1-
+00024140: 7a65 7461 2a2a 3229 0a20 2020 2020 2020  zeta**2).       
+00024150: 2020 2020 2078 203d 206e 702e 6c69 6e73       x = np.lins
+00024160: 7061 6365 2830 2c20 6e70 2e73 7172 7428  pace(0, np.sqrt(
+00024170: 312d 7a65 7461 2a2a 3229 2c20 3230 3029  1-zeta**2), 200)
+00024180: 0a20 2020 2020 2020 2020 2020 2061 6e67  .            ang
+00024190: 203d 206e 702e 7069 2a78 0a20 2020 2020   = np.pi*x.     
+000241a0: 2020 2020 2020 206d 6167 203d 206e 702e         mag = np.
+000241b0: 6578 7028 2d6e 702e 7069 2a66 6163 746f  exp(-np.pi*facto
+000241c0: 722a 7829 0a20 2020 2020 2020 2020 2020  r*x).           
+000241d0: 2023 2044 7261 7720 7570 7065 7220 7061   # Draw upper pa
+000241e0: 7274 2069 6e20 7265 7461 6e67 756c 6172  rt in retangular
+000241f0: 2063 6f6f 7264 696e 6174 6573 0a20 2020   coordinates.   
+00024200: 2020 2020 2020 2020 2078 7265 7420 3d20           xret = 
+00024210: 6d61 672a 6e70 2e63 6f73 2861 6e67 290a  mag*np.cos(ang).
+00024220: 2020 2020 2020 2020 2020 2020 7972 6574              yret
+00024230: 203d 206d 6167 2a6e 702e 7369 6e28 616e   = mag*np.sin(an
+00024240: 6729 0a20 2020 2020 2020 2020 2020 2078  g).            x
+00024250: 695f 6469 6374 5b7a 6574 615d 5b22 7831  i_dict[zeta]["x1
+00024260: 225d 203d 2078 7265 740a 2020 2020 2020  "] = xret.      
+00024270: 2020 2020 2020 7869 5f64 6963 745b 7a65        xi_dict[ze
+00024280: 7461 5d5b 2279 3122 5d20 3d20 7972 6574  ta]["y1"] = yret
+00024290: 0a20 2020 2020 2020 2020 2020 2023 2044  .            # D
+000242a0: 7261 7720 6c6f 7765 7220 7061 7274 2069  raw lower part i
+000242b0: 6e20 7265 7461 6e67 756c 6172 2063 6f6f  n retangular coo
+000242c0: 7264 696e 6174 6573 0a20 2020 2020 2020  rdinates.       
+000242d0: 2020 2020 2078 7265 7420 3d20 6d61 672a       xret = mag*
+000242e0: 6e70 2e63 6f73 282d 616e 6729 0a20 2020  np.cos(-ang).   
+000242f0: 2020 2020 2020 2020 2079 7265 7420 3d20           yret = 
+00024300: 6d61 672a 6e70 2e73 696e 282d 616e 6729  mag*np.sin(-ang)
+00024310: 0a20 2020 2020 2020 2020 2020 2078 695f  .            xi_
+00024320: 6469 6374 5b7a 6574 615d 5b22 7832 225d  dict[zeta]["x2"]
+00024330: 203d 2078 7265 740a 2020 2020 2020 2020   = xret.        
+00024340: 2020 2020 7869 5f64 6963 745b 7a65 7461      xi_dict[zeta
+00024350: 5d5b 2279 3222 5d20 3d20 7972 6574 0a20  ]["y2"] = yret. 
+00024360: 2020 2020 2020 2020 2020 2023 2041 6e6e             # Ann
+00024370: 6f74 6174 696f 6e0a 2020 2020 2020 2020  otation.        
+00024380: 2020 2020 616e 5f69 203d 2069 6e74 286c      an_i = int(l
+00024390: 656e 2878 7265 7429 2f32 2e35 290a 2020  en(xret)/2.5).  
+000243a0: 2020 2020 2020 2020 2020 616e 5f78 203d            an_x =
+000243b0: 2078 7265 745b 616e 5f69 5d0a 2020 2020   xret[an_i].    
+000243c0: 2020 2020 2020 2020 616e 5f79 203d 2079          an_y = y
+000243d0: 7265 745b 616e 5f69 5d0a 2020 2020 2020  ret[an_i].      
+000243e0: 2020 2020 2020 7869 5f64 6963 745b 7a65        xi_dict[ze
+000243f0: 7461 5d5b 226c 7822 5d20 3d20 7872 6574  ta]["lx"] = xret
+00024400: 5b61 6e5f 695d 0a20 2020 2020 2020 2020  [an_i].         
+00024410: 2020 2078 695f 6469 6374 5b7a 6574 615d     xi_dict[zeta]
+00024420: 5b22 6c79 225d 203d 2079 7265 745b 616e  ["ly"] = yret[an
+00024430: 5f69 5d0a 2020 2020 2020 2020 2020 2020  _i].            
+00024440: 7869 5f64 6963 745b 7a65 7461 5d5b 226c  xi_dict[zeta]["l
+00024450: 6162 656c 225d 203d 2073 7472 2872 6f75  abel"] = str(rou
+00024460: 6e64 287a 6574 612c 2032 2929 0a0a 2020  nd(zeta, 2))..  
+00024470: 2020 2020 2020 2320 6e61 7475 7261 6c20        # natural 
+00024480: 6672 6571 7565 6e63 7920 6c69 6e65 730a  frequency lines.
+00024490: 2020 2020 2020 2020 725f 616e 203d 2031          r_an = 1
+000244a0: 2e30 3735 0a20 2020 2020 2020 2066 6d74  .075.        fmt
+000244b0: 203d 2027 7b3a 312e 3166 7d27 2069 6620   = '{:1.1f}' if 
+000244c0: 6c65 6e28 776e 2920 3e20 3120 656c 7365  len(wn) > 1 else
+000244d0: 2027 7b3a 312e 3266 7d27 0a20 2020 2020   '{:1.2f}'.     
+000244e0: 2020 2064 6566 2067 6574 5f6c 6162 656c     def get_label
+000244f0: 286e 756d 293a 0a20 2020 2020 2020 2020  (num):.         
+00024500: 2020 2064 6566 2066 756e 6328 7573 655f     def func(use_
+00024510: 6c61 7465 783d 5472 7565 293a 0a20 2020  latex=True):.   
+00024520: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00024530: 7573 655f 6c61 7465 783a 0a20 2020 2020  use_latex:.     
+00024540: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00024550: 6574 7572 6e20 7222 245c 6672 6163 7b22  eturn r"$\frac{"
+00024560: 2b6e 756d 2b72 225c 7069 7d7b 547d 2422  +num+r"\pi}{T}$"
+00024570: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00024580: 2072 6574 7572 6e20 7374 7228 6e75 6d29   return str(num)
+00024590: 202b 2022 20cf 802f 5422 0a20 2020 2020   + " ../T".     
+000245a0: 2020 2020 2020 2072 6574 7572 6e20 6675         return fu
+000245b0: 6e63 0a20 2020 2020 2020 2066 6f72 2061  nc.        for a
+000245c0: 2069 6e20 776e 3a0a 2020 2020 2020 2020   in wn:.        
+000245d0: 2020 2020 2320 4361 6c63 756c 6174 6520      # Calculate 
+000245e0: 696e 2070 6f6c 6172 2063 6f6f 7264 696e  in polar coordin
+000245f0: 6174 6573 0a20 2020 2020 2020 2020 2020  ates.           
+00024600: 2078 203d 206e 702e 6c69 6e73 7061 6365   x = np.linspace
+00024610: 282d 6e70 2e70 692f 322c 206e 702e 7069  (-np.pi/2, np.pi
+00024620: 2f32 2c20 3230 3029 0a20 2020 2020 2020  /2, 200).       
+00024630: 2020 2020 2061 6e67 203d 206e 702e 7069       ang = np.pi
+00024640: 2a61 2a6e 702e 7369 6e28 7829 0a20 2020  *a*np.sin(x).   
+00024650: 2020 2020 2020 2020 206d 6167 203d 206e           mag = n
+00024660: 702e 6578 7028 2d6e 702e 7069 2a61 2a6e  p.exp(-np.pi*a*n
+00024670: 702e 636f 7328 7829 290a 2020 2020 2020  p.cos(x)).      
+00024680: 2020 2020 2020 2320 4472 6177 2069 6e20        # Draw in 
+00024690: 7265 7461 6e67 756c 6172 2063 6f6f 7264  retangular coord
+000246a0: 696e 6174 6573 0a20 2020 2020 2020 2020  inates.         
+000246b0: 2020 2078 7265 7420 3d20 6d61 672a 6e70     xret = mag*np
+000246c0: 2e63 6f73 2861 6e67 290a 2020 2020 2020  .cos(ang).      
+000246d0: 2020 2020 2020 7972 6574 203d 206d 6167        yret = mag
+000246e0: 2a6e 702e 7369 6e28 616e 6729 0a20 2020  *np.sin(ang).   
+000246f0: 2020 2020 2020 2020 2077 6e5f 6469 6374           wn_dict
+00024700: 5b61 5d5b 2278 225d 203d 2078 7265 740a  [a]["x"] = xret.
+00024710: 2020 2020 2020 2020 2020 2020 776e 5f64              wn_d
+00024720: 6963 745b 615d 5b22 7922 5d20 3d20 7972  ict[a]["y"] = yr
+00024730: 6574 0a20 2020 2020 2020 2020 2020 2023  et.            #
+00024740: 2041 6e6e 6f74 6174 696f 6e0a 2020 2020   Annotation.    
+00024750: 2020 2020 2020 2020 616e 676c 6520 3d20          angle = 
+00024760: 6e70 2e61 7263 7461 6e32 2879 7265 745b  np.arctan2(yret[
+00024770: 2d31 5d2c 2078 7265 745b 2d31 5d29 0a20  -1], xret[-1]). 
+00024780: 2020 2020 2020 2020 2020 2077 6e5f 6469             wn_di
+00024790: 6374 5b61 5d5b 226c 7822 5d20 3d20 725f  ct[a]["lx"] = r_
+000247a0: 616e 202a 206e 702e 636f 7328 616e 676c  an * np.cos(angl
+000247b0: 6529 0a20 2020 2020 2020 2020 2020 2077  e).            w
+000247c0: 6e5f 6469 6374 5b61 5d5b 226c 7922 5d20  n_dict[a]["ly"] 
+000247d0: 3d20 725f 616e 202a 206e 702e 7369 6e28  = r_an * np.sin(
+000247e0: 616e 676c 6529 0a20 2020 2020 2020 2020  angle).         
+000247f0: 2020 2069 6620 5420 6973 204e 6f6e 653a     if T is None:
+00024800: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00024810: 206e 756d 203d 2066 6d74 2e66 6f72 6d61   num = fmt.forma
+00024820: 7428 6129 0a20 2020 2020 2020 2020 2020  t(a).           
+00024830: 2020 2020 2061 6e20 3d20 7222 245c 6672       an = r"$\fr
+00024840: 6163 7b22 2b6e 756d 2b72 225c 7069 7d7b  ac{"+num+r"\pi}{
+00024850: 547d 2422 0a20 2020 2020 2020 2020 2020  T}$".           
+00024860: 2020 2020 2061 6e20 3d20 6765 745f 6c61       an = get_la
+00024870: 6265 6c28 6e75 6d29 0a20 2020 2020 2020  bel(num).       
+00024880: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00024890: 2020 2020 2020 2020 2020 2066 756e 6320             func 
+000248a0: 3d20 6c61 6d62 6461 2061 2c20 543a 206c  = lambda a, T: l
+000248b0: 616d 6264 6120 7573 655f 6c61 7465 783a  ambda use_latex:
+000248c0: 2022 252e 3266 2220 2520 2861 202a 206e   "%.2f" % (a * n
+000248d0: 702e 7069 202a 2054 290a 2020 2020 2020  p.pi * T).      
+000248e0: 2020 2020 2020 2020 2020 616e 203d 2066            an = f
+000248f0: 756e 6328 612c 2054 290a 2020 2020 2020  unc(a, T).      
+00024900: 2020 2020 2020 776e 5f64 6963 745b 615d        wn_dict[a]
+00024910: 5b22 6c61 6265 6c22 5d20 3d20 616e 0a0a  ["label"] = an..
+00024920: 2020 2020 2020 2020 2320 7065 616b 2074          # peak t
+00024930: 696d 6520 6c69 6e65 730a 2020 2020 2020  ime lines.      
+00024940: 2020 616e 676c 6573 203d 206e 702e 7069    angles = np.pi
+00024950: 202f 2074 700a 2020 2020 2020 2020 666f   / tp.        fo
+00024960: 7220 5f74 702c 2061 2069 6e20 7a69 7028  r _tp, a in zip(
+00024970: 7470 2c20 616e 676c 6573 293a 0a20 2020  tp, angles):.   
+00024980: 2020 2020 2020 2020 2074 705f 6469 6374           tp_dict
+00024990: 5b5f 7470 5d5b 2278 225d 203d 205b 302c  [_tp]["x"] = [0,
+000249a0: 206e 702e 636f 7328 6129 5d0a 2020 2020   np.cos(a)].    
+000249b0: 2020 2020 2020 2020 7470 5f64 6963 745b          tp_dict[
+000249c0: 5f74 705d 5b22 7922 5d20 3d20 5b30 2c20  _tp]["y"] = [0, 
+000249d0: 6e70 2e73 696e 2861 295d 0a20 2020 2020  np.sin(a)].     
+000249e0: 2020 2020 2020 2023 2041 6e6e 6f74 6174         # Annotat
+000249f0: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
+00024a00: 7470 5f64 6963 745b 5f74 705d 5b22 6c78  tp_dict[_tp]["lx
+00024a10: 225d 203d 2072 5f61 6e20 2a20 6e70 2e63  "] = r_an * np.c
+00024a20: 6f73 2861 290a 2020 2020 2020 2020 2020  os(a).          
+00024a30: 2020 7470 5f64 6963 745b 5f74 705d 5b22    tp_dict[_tp]["
+00024a40: 6c79 225d 203d 2072 5f61 6e20 2a20 6e70  ly"] = r_an * np
+00024a50: 2e73 696e 2861 290a 2020 2020 2020 2020  .sin(a).        
+00024a60: 2020 2020 616e 203d 205f 7470 2069 6620      an = _tp if 
+00024a70: 6e6f 7420 5420 656c 7365 205f 7470 202a  not T else _tp *
+00024a80: 2054 0a20 2020 2020 2020 2020 2020 2061   T.            a
+00024a90: 6e20 3d20 2225 2e32 6622 2025 2061 6e20  n = "%.2f" % an 
+00024aa0: 6966 206e 6f74 2054 2065 6c73 6520 2225  if not T else "%
+00024ab0: 2e32 6620 7322 2025 2061 6e0a 2020 2020  .2f s" % an.    
+00024ac0: 2020 2020 2020 2020 7470 5f64 6963 745b          tp_dict[
+00024ad0: 5f74 705d 5b22 6c61 6265 6c22 5d20 3d20  _tp]["label"] = 
+00024ae0: 616e 0a0a 2020 2020 2020 2020 2320 7365  an..        # se
+00024af0: 7474 6c69 6e67 2074 696d 6520 6c69 6e65  ttling time line
+00024b00: 730a 2020 2020 2020 2020 7261 6469 7573  s.        radius
+00024b10: 203d 206e 702e 6578 7028 2d34 202f 2074   = np.exp(-4 / t
+00024b20: 7329 0a20 2020 2020 2020 2074 6865 7461  s).        theta
+00024b30: 203d 206e 702e 6c69 6e73 7061 6365 2830   = np.linspace(0
+00024b40: 2c20 322a 6e70 2e70 692c 2034 3030 290a  , 2*np.pi, 400).
+00024b50: 2020 2020 2020 2020 6374 203d 206e 702e          ct = np.
+00024b60: 636f 7328 7468 6574 6129 0a20 2020 2020  cos(theta).     
+00024b70: 2020 2073 7420 3d20 6e70 2e73 696e 2874     st = np.sin(t
+00024b80: 6865 7461 290a 2020 2020 2020 2020 666f  heta).        fo
+00024b90: 7220 5f74 732c 2072 2069 6e20 7a69 7028  r _ts, r in zip(
+00024ba0: 7473 2c20 7261 6469 7573 293a 0a20 2020  ts, radius):.   
+00024bb0: 2020 2020 2020 2020 2074 735f 6469 6374           ts_dict
+00024bc0: 5b5f 7473 5d5b 2278 225d 203d 2072 202a  [_ts]["x"] = r *
+00024bd0: 2063 740a 2020 2020 2020 2020 2020 2020   ct.            
+00024be0: 7473 5f64 6963 745b 5f74 735d 5b22 7922  ts_dict[_ts]["y"
+00024bf0: 5d20 3d20 7220 2a20 7374 0a20 2020 2020  ] = r * st.     
+00024c00: 2020 2020 2020 2023 2041 6e6e 6f74 6174         # Annotat
+00024c10: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
+00024c20: 616e 5f69 203d 2069 6e74 286c 656e 2874  an_i = int(len(t
+00024c30: 6865 7461 292a 302e 3735 290a 2020 2020  heta)*0.75).    
+00024c40: 2020 2020 2020 2020 7473 5f64 6963 745b          ts_dict[
+00024c50: 5f74 735d 5b22 6c78 225d 203d 2074 735f  _ts]["lx"] = ts_
+00024c60: 6469 6374 5b5f 7473 5d5b 2278 225d 5b61  dict[_ts]["x"][a
+00024c70: 6e5f 695d 0a20 2020 2020 2020 2020 2020  n_i].           
+00024c80: 2074 735f 6469 6374 5b5f 7473 5d5b 226c   ts_dict[_ts]["l
+00024c90: 7922 5d20 3d20 7473 5f64 6963 745b 5f74  y"] = ts_dict[_t
+00024ca0: 735d 5b22 7922 5d5b 616e 5f69 5d0a 2020  s]["y"][an_i].  
+00024cb0: 2020 2020 2020 2020 2020 616e 203d 205f            an = _
+00024cc0: 7473 2069 6620 6e6f 7420 5420 656c 7365  ts if not T else
+00024cd0: 205f 7473 202a 2054 0a20 2020 2020 2020   _ts * T.       
+00024ce0: 2020 2020 2061 6e20 3d20 2225 2e32 6622       an = "%.2f"
+00024cf0: 2025 2061 6e20 6966 206e 6f74 2054 2065   % an if not T e
+00024d00: 6c73 6520 2225 2e32 6620 7322 2025 2061  lse "%.2f s" % a
+00024d10: 6e0a 2020 2020 2020 2020 2020 2020 7473  n.            ts
+00024d20: 5f64 6963 745b 5f74 735d 5b22 6c61 6265  _dict[_ts]["labe
+00024d30: 6c22 5d20 3d20 616e 0a0a 2020 2020 2020  l"] = an..      
+00024d40: 2020 7265 7475 726e 2078 695f 6469 6374    return xi_dict
+00024d50: 2c20 776e 5f64 6963 742c 2074 705f 6469  , wn_dict, tp_di
+00024d60: 6374 2c20 7473 5f64 6963 740a 0a0a 636c  ct, ts_dict...cl
+00024d70: 6173 7320 4172 726f 7773 4d69 7869 6e3a  ass ArrowsMixin:
+00024d80: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+00024d90: 5f28 7365 6c66 2c20 2a61 7267 732c 202a  _(self, *args, *
+00024da0: 2a6b 7761 7267 7329 3a0a 2020 2020 2020  *kwargs):.      
+00024db0: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
+00024dc0: 5f5f 282a 6172 6773 2c20 2a2a 6b77 6172  __(*args, **kwar
+00024dd0: 6773 290a 2020 2020 2020 2020 7365 6c66  gs).        self
+00024de0: 2e61 7272 6f77 7320 3d20 6b77 6172 6773  .arrows = kwargs
+00024df0: 2e67 6574 2822 6172 726f 7773 222c 2033  .get("arrows", 3
+00024e00: 290a 0a20 2020 2020 2020 2023 2050 6172  )..        # Par
+00024e10: 7365 2074 6865 2061 7272 6f77 7320 6b65  se the arrows ke
+00024e20: 7977 6f72 640a 2020 2020 2020 2020 6e70  yword.        np
+00024e30: 203d 2069 6d70 6f72 745f 6d6f 6475 6c65   = import_module
+00024e40: 2822 6e75 6d70 7922 290a 2020 2020 2020  ("numpy").      
+00024e50: 2020 6966 206e 6f74 2073 656c 662e 6172    if not self.ar
+00024e60: 726f 7773 3a0a 2020 2020 2020 2020 2020  rows:.          
+00024e70: 2020 7365 6c66 2e61 7272 6f77 5f6c 6f63    self.arrow_loc
+00024e80: 7320 3d20 5b5d 0a20 2020 2020 2020 2065  s = [].        e
+00024e90: 6c69 6620 6973 696e 7374 616e 6365 2873  lif isinstance(s
+00024ea0: 656c 662e 6172 726f 7773 2c20 696e 7429  elf.arrows, int)
+00024eb0: 3a0a 2020 2020 2020 2020 2020 2020 4e20  :.            N 
+00024ec0: 3d20 3320 6966 2073 656c 662e 6172 726f  = 3 if self.arro
+00024ed0: 7773 2069 7320 5472 7565 2065 6c73 6520  ws is True else 
+00024ee0: 7365 6c66 2e61 7272 6f77 730a 2020 2020  self.arrows.    
+00024ef0: 2020 2020 2020 2020 2320 5370 6163 6520          # Space 
+00024f00: 6172 726f 7773 206f 7574 2c20 7374 6172  arrows out, star
+00024f10: 7469 6e67 206d 6964 7761 7920 616c 6f6e  ting midway alon
+00024f20: 6720 6561 6368 2022 7265 6769 6f6e 220a  g each "region".
+00024f30: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00024f40: 2e61 7272 6f77 5f6c 6f63 7320 3d20 6e70  .arrow_locs = np
+00024f50: 2e6c 696e 7370 6163 6528 302e 352f 4e2c  .linspace(0.5/N,
+00024f60: 2031 202b 2030 2e35 2f4e 2c20 4e2c 2065   1 + 0.5/N, N, e
+00024f70: 6e64 706f 696e 743d 4661 6c73 6529 0a20  ndpoint=False). 
+00024f80: 2020 2020 2020 2065 6c69 6620 6973 696e         elif isin
+00024f90: 7374 616e 6365 2873 656c 662e 6172 726f  stance(self.arro
+00024fa0: 7773 2c20 286c 6973 742c 206e 702e 6e64  ws, (list, np.nd
+00024fb0: 6172 7261 7929 293a 0a20 2020 2020 2020  array)):.       
+00024fc0: 2020 2020 2073 656c 662e 6172 726f 775f       self.arrow_
+00024fd0: 6c6f 6373 203d 206e 702e 736f 7274 286e  locs = np.sort(n
+00024fe0: 702e 6174 6c65 6173 745f 3164 2873 656c  p.atleast_1d(sel
+00024ff0: 662e 6172 726f 7773 2929 0a20 2020 2020  f.arrows)).     
+00025000: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00025010: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00025020: 4572 726f 7228 2275 6e6b 6e6f 776e 206f  Error("unknown o
+00025030: 7220 756e 7375 7070 6f72 7465 6420 6172  r unsupported ar
+00025040: 726f 7720 6c6f 6361 7469 6f6e 2229 0a0a  row location")..
+00025050: 0a63 6c61 7373 204e 6963 686f 6c73 4c69  .class NicholsLi
+00025060: 6e65 5365 7269 6573 2841 7272 6f77 734d  neSeries(ArrowsM
+00025070: 6978 696e 2c20 436f 6d6d 6f6e 556e 6966  ixin, CommonUnif
+00025080: 6f72 6d45 7661 6c75 6174 696f 6e2c 204c  ormEvaluation, L
+00025090: 696e 6532 4442 6173 6553 6572 6965 7329  ine2DBaseSeries)
+000250a0: 3a0a 2020 2020 2222 2252 6570 7265 7365  :.    """Represe
+000250b0: 6e74 2061 204e 6963 686f 6c73 206c 696e  nt a Nichols lin
+000250c0: 6520 696e 2063 6f6e 7472 6f6c 2073 7973  e in control sys
+000250d0: 7465 6d20 706c 6f74 7469 6e67 2e0a 2020  tem plotting..  
+000250e0: 2020 2222 220a 2020 2020 5f61 6c6c 6f77    """.    _allow
+000250f0: 6564 5f6b 6579 7320 3d20 5b22 6172 726f  ed_keys = ["arro
+00025100: 7773 225d 0a0a 2020 2020 6465 6620 5f5f  ws"]..    def __
+00025110: 696e 6974 5f5f 280a 2020 2020 2020 2020  init__(.        
+00025120: 7365 6c66 2c20 7466 2c20 6f6c 5f70 6861  self, tf, ol_pha
+00025130: 7365 2c20 6f6c 5f6d 6167 2c20 636c 5f70  se, ol_mag, cl_p
+00025140: 6861 7365 2c20 636c 5f6d 6167 2c20 6f6d  hase, cl_mag, om
+00025150: 6567 615f 7261 6e67 652c 0a20 2020 2020  ega_range,.     
+00025160: 2020 206c 6162 656c 3d22 222c 202a 2a6b     label="", **k
+00025170: 7761 7267 730a 2020 2020 293a 0a20 2020  wargs.    ):.   
+00025180: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
+00025190: 6e69 745f 5f28 2a2a 6b77 6172 6773 290a  nit__(**kwargs).
+000251a0: 2020 2020 2020 2020 7365 6c66 2e5f 7466          self._tf
+000251b0: 203d 2074 660a 2020 2020 2020 2020 7365   = tf.        se
+000251c0: 6c66 2e65 7870 7220 3d20 5475 706c 6528  lf.expr = Tuple(
+000251d0: 6f6c 5f70 6861 7365 2c20 6f6c 5f6d 6167  ol_phase, ol_mag
+000251e0: 2c20 636c 5f70 6861 7365 2c20 636c 5f6d  , cl_phase, cl_m
+000251f0: 6167 290a 2020 2020 2020 2020 7365 6c66  ag).        self
+00025200: 2e72 616e 6765 7320 3d20 5b6f 6d65 6761  .ranges = [omega
+00025210: 5f72 616e 6765 5d0a 2020 2020 2020 2020  _range].        
+00025220: 7365 6c66 2e6c 6162 656c 203d 206c 6162  self.label = lab
+00025230: 656c 0a20 2020 2020 2020 2073 656c 662e  el.        self.
+00025240: 5f66 6f72 6365 5f72 6561 6c5f 6576 616c  _force_real_eval
+00025250: 203d 2054 7275 650a 0a20 2020 2064 6566   = True..    def
+00025260: 205f 5f73 7472 5f5f 2873 656c 6629 3a0a   __str__(self):.
+00025270: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00025280: 656c 662e 5f73 7472 5f68 656c 7065 7228  elf._str_helper(
+00025290: 226e 6963 686f 6c73 206c 696e 6520 6f66  "nichols line of
+000252a0: 2025 7322 2025 2073 656c 662e 5f74 6629   %s" % self._tf)
+000252b0: 0a0a 2020 2020 6465 6620 6765 745f 6461  ..    def get_da
+000252c0: 7461 2873 656c 6629 3a0a 2020 2020 2020  ta(self):.      
+000252d0: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
+000252e0: 7475 726e 730a 2020 2020 2020 2020 3d3d  turns.        ==
+000252f0: 3d3d 3d3d 3d0a 2020 2020 2020 2020 6f6d  =====.        om
+00025300: 6567 6120 3a20 6e70 2e6e 6461 7272 6179  ega : np.ndarray
+00025310: 0a20 2020 2020 2020 206f 6c5f 7068 6173  .        ol_phas
+00025320: 6520 3a20 6e70 2e6e 6461 7272 6179 0a20  e : np.ndarray. 
+00025330: 2020 2020 2020 206f 6c5f 6d61 6720 3a20         ol_mag : 
+00025340: 6e70 2e6e 6461 7272 6179 0a20 2020 2020  np.ndarray.     
+00025350: 2020 2063 6c5f 7068 6173 6520 3a20 6e70     cl_phase : np
+00025360: 2e6e 6461 7272 6179 0a20 2020 2020 2020  .ndarray.       
+00025370: 2063 6c5f 6d61 6720 3a20 6e70 2e6e 6461   cl_mag : np.nda
+00025380: 7272 6179 0a20 2020 2020 2020 2022 2222  rray.        """
+00025390: 0a20 2020 2020 2020 206e 7020 3d20 696d  .        np = im
+000253a0: 706f 7274 5f6d 6f64 756c 6528 276e 756d  port_module('num
+000253b0: 7079 2729 0a0a 2020 2020 2020 2020 7265  py')..        re
+000253c0: 7375 6c74 7320 3d20 7365 6c66 2e5f 6576  sults = self._ev
+000253d0: 616c 7561 7465 2829 0a20 2020 2020 2020  aluate().       
+000253e0: 2066 6f72 2069 2c20 7220 696e 2065 6e75   for i, r in enu
+000253f0: 6d65 7261 7465 2872 6573 756c 7473 293a  merate(results):
+00025400: 0a20 2020 2020 2020 2020 2020 205f 7265  .            _re
+00025410: 2c20 5f69 6d20 3d20 6e70 2e72 6561 6c28  , _im = np.real(
+00025420: 7229 2c20 6e70 2e69 6d61 6728 7229 0a20  r), np.imag(r). 
+00025430: 2020 2020 2020 2020 2020 205f 7265 5b6e             _re[n
+00025440: 702e 696e 7665 7274 286e 702e 6973 636c  p.invert(np.iscl
+00025450: 6f73 6528 5f69 6d2c 206e 702e 7a65 726f  ose(_im, np.zero
+00025460: 735f 6c69 6b65 285f 696d 2929 295d 203d  s_like(_im)))] =
+00025470: 206e 702e 6e61 6e0a 2020 2020 2020 2020   np.nan.        
+00025480: 2020 2020 7265 7375 6c74 735b 695d 203d      results[i] =
+00025490: 205f 7265 0a0a 2020 2020 2020 2020 6f6d   _re..        om
+000254a0: 6567 612c 206f 6c5f 7068 6173 652c 206f  ega, ol_phase, o
+000254b0: 6c5f 6d61 672c 2063 6c5f 7068 6173 652c  l_mag, cl_phase,
+000254c0: 2063 6c5f 6d61 6720 3d20 7265 7375 6c74   cl_mag = result
+000254d0: 730a 2020 2020 2020 2020 6f6c 5f6d 6167  s.        ol_mag
+000254e0: 203d 2032 3020 2a20 6e70 2e6c 6f67 3130   = 20 * np.log10
+000254f0: 286f 6c5f 6d61 6729 0a20 2020 2020 2020  (ol_mag).       
+00025500: 206f 6c5f 7068 6173 6520 3d20 6e70 2e64   ol_phase = np.d
+00025510: 6567 7265 6573 2875 6e77 7261 7028 6f6c  egrees(unwrap(ol
+00025520: 5f70 6861 7365 2929 0a20 2020 2020 2020  _phase)).       
+00025530: 2063 6c5f 6d61 6720 3d20 3230 202a 206e   cl_mag = 20 * n
+00025540: 702e 6c6f 6731 3028 636c 5f6d 6167 290a  p.log10(cl_mag).
+00025550: 2020 2020 2020 2020 2320 544f 444f 3a20          # TODO: 
+00025560: 6966 2074 6865 206e 6963 686f 6c73 206c  if the nichols l
+00025570: 696e 6520 7061 7373 6573 2074 6872 6f75  ine passes throu
+00025580: 6768 2074 6865 2070 6f69 6e74 2028 2d31  gh the point (-1
+00025590: 3830 2064 6567 2c20 3020 6442 290a 2020  80 deg, 0 dB).  
+000255a0: 2020 2020 2020 2320 2869 6e20 6f70 656e        # (in open
+000255b0: 206c 6f6f 7029 2c20 7468 656e 2074 6865   loop), then the
+000255c0: 2072 6573 756c 7469 6e67 2063 6c6f 7365   resulting close
+000255d0: 642d 6c6f 6f70 2070 6861 7365 2069 7320  d-loop phase is 
+000255e0: 7772 6f6e 672e 2057 6879 3f0a 2020 2020  wrong. Why?.    
+000255f0: 2020 2020 2320 466f 7220 6578 616d 706c      # For exampl
+00025600: 652c 2074 6573 7420 7769 7468 2074 6869  e, test with thi
+00025610: 7320 7379 7374 656d 3a0a 2020 2020 2020  s system:.      
+00025620: 2020 2320 7466 203d 2028 3520 2a20 2873    # tf = (5 * (s
+00025630: 202d 2031 2929 202f 2028 732a 2a32 202a   - 1)) / (s**2 *
+00025640: 2028 732a 2a32 202b 2073 202b 2034 2929   (s**2 + s + 4))
+00025650: 0a20 2020 2020 2020 2063 6c5f 7068 6173  .        cl_phas
+00025660: 6520 3d20 6e70 2e64 6567 7265 6573 2875  e = np.degrees(u
+00025670: 6e77 7261 7028 636c 5f70 6861 7365 2929  nwrap(cl_phase))
+00025680: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00025690: 6f6d 6567 612c 206f 6c5f 7068 6173 652c  omega, ol_phase,
+000256a0: 206f 6c5f 6d61 672c 2063 6c5f 7068 6173   ol_mag, cl_phas
+000256b0: 652c 2063 6c5f 6d61 670a 0a0a 636c 6173  e, cl_mag...clas
+000256c0: 7320 436f 6e74 726f 6c42 6173 6553 6572  s ControlBaseSer
+000256d0: 6965 7328 4c69 6e65 3244 4261 7365 5365  ies(Line2DBaseSe
+000256e0: 7269 6573 293a 0a20 2020 2022 2222 4120  ries):.    """A 
+000256f0: 6261 7365 2073 6572 6965 7320 666f 7220  base series for 
+00025700: 636c 6173 7365 7320 7468 6174 2061 7265  classes that are
+00025710: 2067 6f69 6e67 2074 6f20 7072 6f64 7563   going to produc
+00025720: 6520 6e75 6d65 7269 6361 6c0a 2020 2020  e numerical.    
+00025730: 6461 7461 2075 7369 6e67 2074 6865 2060  data using the `
+00025740: 6063 6f6e 7472 6f6c 6060 206d 6f64 756c  `control`` modul
+00025750: 6520 666f 7220 636f 6e74 726f 6c2d 7379  e for control-sy
+00025760: 7374 656d 2070 6c6f 7474 696e 672e 0a20  stem plotting.. 
+00025770: 2020 2054 686f 7365 2073 6572 6965 7320     Those series 
+00025780: 7265 7072 6573 656e 7420 6120 5349 534f  represent a SISO
+00025790: 2073 7973 7465 6d2e 0a20 2020 2022 2222   system..    """
+000257a0: 0a0a 2020 2020 5f61 6c6c 6f77 6564 5f6b  ..    _allowed_k
+000257b0: 6579 7320 3d20 5b22 636f 6e74 726f 6c5f  eys = ["control_
+000257c0: 6b77 225d 0a0a 2020 2020 6465 6620 5f5f  kw"]..    def __
+000257d0: 696e 6974 5f5f 2873 656c 662c 202a 6172  init__(self, *ar
+000257e0: 6773 2c20 2a2a 6b77 6172 6773 293a 0a20  gs, **kwargs):. 
+000257f0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+00025800: 5f69 6e69 745f 5f28 2a2a 6b77 6172 6773  _init__(**kwargs
+00025810: 290a 2020 2020 2020 2020 5472 616e 7366  ).        Transf
+00025820: 6572 4675 6e63 7469 6f6e 203d 2073 796d  erFunction = sym
+00025830: 7079 2e70 6879 7369 6373 2e63 6f6e 7472  py.physics.contr
+00025840: 6f6c 2e6c 7469 2e54 7261 6e73 6665 7246  ol.lti.TransferF
+00025850: 756e 6374 696f 6e0a 2020 2020 2020 2020  unction.        
+00025860: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
+00025870: 6c65 2827 6e75 6d70 7927 290a 2020 2020  le('numpy').    
+00025880: 2020 2020 7370 203d 2069 6d70 6f72 745f      sp = import_
+00025890: 6d6f 6475 6c65 2827 7363 6970 7927 290a  module('scipy').
+000258a0: 2020 2020 2020 2020 6374 203d 2069 6d70          ct = imp
+000258b0: 6f72 745f 6d6f 6475 6c65 2827 636f 6e74  ort_module('cont
+000258c0: 726f 6c27 290a 2020 2020 2020 2020 6c61  rol').        la
+000258d0: 6265 6c20 3d20 6b77 6172 6773 2e67 6574  bel = kwargs.get
+000258e0: 2822 6c61 6265 6c22 2c20 2222 290a 2020  ("label", "").  
+000258f0: 2020 2020 2020 7466 203d 2061 7267 735b        tf = args[
+00025900: 305d 0a0a 2020 2020 2020 2020 6966 2069  0]..        if i
+00025910: 7369 6e73 7461 6e63 6528 7466 2c20 2845  sinstance(tf, (E
+00025920: 7870 722c 2054 7261 6e73 6665 7246 756e  xpr, TransferFun
+00025930: 6374 696f 6e29 293a 0a20 2020 2020 2020  ction)):.       
+00025940: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
+00025950: 6365 2874 662c 2045 7870 7229 3a0a 2020  ce(tf, Expr):.  
+00025960: 2020 2020 2020 2020 2020 2020 2020 7061                pa
+00025970: 7261 6d73 5f66 7320 3d20 7365 7428 7365  rams_fs = set(se
+00025980: 6c66 2e70 6172 616d 732e 6b65 7973 2829  lf.params.keys()
+00025990: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000259a0: 2020 6673 203d 2074 662e 6672 6565 5f73    fs = tf.free_s
+000259b0: 796d 626f 6c73 2e64 6966 6665 7265 6e63  ymbols.differenc
+000259c0: 6528 7061 7261 6d73 5f66 7329 0a20 2020  e(params_fs).   
+000259d0: 2020 2020 2020 2020 2020 2020 2066 7320               fs 
+000259e0: 3d20 6673 2e70 6f70 2829 2069 6620 6c65  = fs.pop() if le
+000259f0: 6e28 6673 2920 3e20 3020 656c 7365 2073  n(fs) > 0 else s
+00025a00: 796d 626f 6c73 2822 7322 290a 2020 2020  ymbols("s").    
+00025a10: 2020 2020 2020 2020 2020 2020 7466 203d              tf =
+00025a20: 2054 7261 6e73 6665 7246 756e 6374 696f   TransferFunctio
+00025a30: 6e2e 6672 6f6d 5f72 6174 696f 6e61 6c5f  n.from_rational_
+00025a40: 6578 7072 6573 7369 6f6e 2874 662c 2066  expression(tf, f
+00025a50: 7329 0a20 2020 2020 2020 2020 2020 2073  s).            s
+00025a60: 656c 662e 5f65 7870 7220 3d20 7466 0a20  elf._expr = tf. 
+00025a70: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00025a80: 5f63 6f6e 7472 6f6c 5f74 6620 3d20 4e6f  _control_tf = No
+00025a90: 6e65 0a20 2020 2020 2020 2020 2020 2069  ne.            i
+00025aa0: 6620 6e6f 7420 7365 6c66 2e69 735f 696e  f not self.is_in
+00025ab0: 7465 7261 6374 6976 653a 0a20 2020 2020  teractive:.     
+00025ac0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00025ad0: 5f63 6f6e 7472 6f6c 5f74 6620 3d20 7466  _control_tf = tf
+00025ae0: 5f74 6f5f 636f 6e74 726f 6c28 7466 290a  _to_control(tf).
+00025af0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00025b00: 2e5f 6c61 6265 6c20 3d20 7374 7228 7365  ._label = str(se
+00025b10: 6c66 2e65 7870 7229 2069 6620 6c61 6265  lf.expr) if labe
+00025b20: 6c20 6973 204e 6f6e 6520 656c 7365 206c  l is None else l
+00025b30: 6162 656c 0a20 2020 2020 2020 2020 2020  abel.           
+00025b40: 2073 656c 662e 5f6c 6174 6578 5f6c 6162   self._latex_lab
+00025b50: 656c 203d 206c 6174 6578 2873 656c 662e  el = latex(self.
+00025b60: 6578 7072 2920 6966 206c 6162 656c 2069  expr) if label i
+00025b70: 7320 4e6f 6e65 2065 6c73 6520 6c61 6265  s None else labe
+00025b80: 6c0a 2020 2020 2020 2020 656c 6966 2069  l.        elif i
+00025b90: 7369 6e73 7461 6e63 6528 7466 2c20 2873  sinstance(tf, (s
+00025ba0: 702e 7369 676e 616c 2e54 7261 6e73 6665  p.signal.Transfe
+00025bb0: 7246 756e 6374 696f 6e2c 2063 742e 5472  rFunction, ct.Tr
+00025bc0: 616e 7366 6572 4675 6e63 7469 6f6e 2929  ansferFunction))
+00025bd0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+00025be0: 6c66 2e5f 6578 7072 203d 204e 6f6e 650a  lf._expr = None.
+00025bf0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00025c00: 2e5f 6c61 6265 6c20 3d20 6c61 6265 6c0a  ._label = label.
+00025c10: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00025c20: 2e5f 6c61 7465 785f 6c61 6265 6c20 3d20  ._latex_label = 
+00025c30: 6c61 6265 6c0a 2020 2020 2020 2020 2020  label.          
+00025c40: 2020 6966 206c 6162 656c 2069 7320 4e6f    if label is No
+00025c50: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00025c60: 2020 2020 7320 3d20 7379 6d62 6f6c 7328      s = symbols(
+00025c70: 2273 2220 6966 2074 662e 6474 2069 7320  "s" if tf.dt is 
+00025c80: 4e6f 6e65 2065 6c73 6520 227a 2229 0a20  None else "z"). 
+00025c90: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00025ca0: 203d 2074 662e 6e75 6d5b 305d 5b30 5d20   = tf.num[0][0] 
+00025cb0: 6966 2069 7369 6e73 7461 6e63 6528 6374  if isinstance(ct
+00025cc0: 2e54 7261 6e73 6665 7246 756e 6374 696f  .TransferFunctio
+00025cd0: 6e29 2065 6c73 6520 7466 2e6e 756d 0a20  n) else tf.num. 
+00025ce0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00025cf0: 203d 2074 662e 6465 6e5b 305d 5b30 5d20   = tf.den[0][0] 
+00025d00: 6966 2069 7369 6e73 7461 6e63 6528 6374  if isinstance(ct
+00025d10: 2e54 7261 6e73 6665 7246 756e 6374 696f  .TransferFunctio
+00025d20: 6e29 2065 6c73 6520 7466 2e64 656e 0a20  n) else tf.den. 
+00025d30: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00025d40: 7870 7220 3d20 506f 6c79 2e66 726f 6d5f  xpr = Poly.from_
+00025d50: 6c69 7374 286e 2c20 7329 202f 2050 6f6c  list(n, s) / Pol
+00025d60: 792e 6672 6f6d 5f6c 6973 7428 642c 2073  y.from_list(d, s
+00025d70: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00025d80: 2020 7365 6c66 2e5f 6c61 6265 6c20 3d20    self._label = 
+00025d90: 7374 7228 6578 7072 290a 2020 2020 2020  str(expr).      
+00025da0: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+00025db0: 6c61 7465 785f 6c61 6265 6c20 3d20 6c61  latex_label = la
+00025dc0: 7465 7828 6578 7072 290a 2020 2020 2020  tex(expr).      
+00025dd0: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00025de0: 6e63 6528 7466 2c20 7370 2e73 6967 6e61  nce(tf, sp.signa
+00025df0: 6c2e 5472 616e 7366 6572 4675 6e63 7469  l.TransferFuncti
+00025e00: 6f6e 293a 0a20 2020 2020 2020 2020 2020  on):.           
+00025e10: 2020 2020 2073 656c 662e 5f63 6f6e 7472       self._contr
+00025e20: 6f6c 5f74 6620 3d20 7466 5f74 6f5f 636f  ol_tf = tf_to_co
+00025e30: 6e74 726f 6c28 7466 290a 2020 2020 2020  ntrol(tf).      
+00025e40: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00025e50: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00025e60: 2e5f 636f 6e74 726f 6c5f 7466 203d 2074  ._control_tf = t
+00025e70: 660a 2020 2020 2020 2020 656c 7365 3a0a  f.        else:.
+00025e80: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00025e90: 6520 5479 7065 4572 726f 7228 0a20 2020  e TypeError(.   
+00025ea0: 2020 2020 2020 2020 2020 2020 2022 5472               "Tr
+00025eb0: 616e 7366 6572 2066 756e 6374 696f 6e27  ansfer function'
+00025ec0: 7320 7479 7065 206e 6f74 2072 6563 6f67  s type not recog
+00025ed0: 6e69 7a65 642e 2022 0a20 2020 2020 2020  nized. ".       
+00025ee0: 2020 2020 2020 2020 2022 5265 6365 6976           "Receiv
+00025ef0: 6564 3a20 2220 2b20 7374 7228 7479 7065  ed: " + str(type
+00025f00: 2874 6629 290a 2020 2020 2020 2020 2020  (tf)).          
+00025f10: 2020 290a 0a20 2020 2020 2020 2073 656c    )..        sel
+00025f20: 662e 5f63 6f6e 7472 6f6c 5f6b 7720 3d20  f._control_kw = 
+00025f30: 6b77 6172 6773 2e67 6574 2822 636f 6e74  kwargs.get("cont
+00025f40: 726f 6c5f 6b77 222c 207b 7d29 0a0a 2020  rol_kw", {})..  
+00025f50: 2020 6465 6620 5f63 6865 636b 5f66 7328    def _check_fs(
+00025f60: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+00025f70: 2222 2043 6865 636b 7320 6966 2074 6865  "" Checks if the
+00025f80: 7265 2061 7265 2065 6e6f 6768 2070 6172  re are enogh par
+00025f90: 616d 6574 6572 7320 616e 6420 6672 6565  ameters and free
+00025fa0: 2073 796d 626f 6c73 2e0a 2020 2020 2020   symbols..      
+00025fb0: 2020 2222 220a 2020 2020 2020 2020 6673    """.        fs
+00025fc0: 203d 2073 6574 2829 0a20 2020 2020 2020   = set().       
+00025fd0: 2069 6620 7365 6c66 2e5f 6578 7072 3a0a   if self._expr:.
+00025fe0: 2020 2020 2020 2020 2020 2020 6673 203d              fs =
+00025ff0: 207b 7365 6c66 2e5f 6578 7072 2e76 6172   {self._expr.var
+00026000: 7d0a 2020 2020 2020 2020 7261 6e67 6573  }.        ranges
+00026010: 2c20 7061 7261 6d73 203d 2073 656c 662e  , params = self.
+00026020: 7261 6e67 6573 2c20 7365 6c66 2e70 6172  ranges, self.par
+00026030: 616d 730a 0a20 2020 2020 2020 2023 2066  ams..        # f
+00026040: 726f 6d20 7468 6520 6578 7072 6573 7369  rom the expressi
+00026050: 6f6e 2773 2066 7265 6520 7379 6d62 6f6c  on's free symbol
+00026060: 732c 2072 656d 6f76 6520 7468 6520 6f6e  s, remove the on
+00026070: 6573 2075 7365 6420 696e 0a20 2020 2020  es used in.     
+00026080: 2020 2023 2074 6865 2070 6172 616d 6574     # the paramet
+00026090: 6572 7320 616e 6420 7468 6520 7261 6e67  ers and the rang
+000260a0: 6573 0a20 2020 2020 2020 2066 7320 3d20  es.        fs = 
+000260b0: 6673 2e64 6966 6665 7265 6e63 6528 7061  fs.difference(pa
+000260c0: 7261 6d73 2e6b 6579 7328 2929 0a20 2020  rams.keys()).   
+000260d0: 2020 2020 2069 6620 7261 6e67 6573 2069       if ranges i
+000260e0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+000260f0: 2020 2020 2020 2020 6673 203d 2066 732e          fs = fs.
+00026100: 6469 6666 6572 656e 6365 285b 725b 305d  difference([r[0]
+00026110: 2066 6f72 2072 2069 6e20 7261 6e67 6573   for r in ranges
+00026120: 5d29 0a0a 2020 2020 2020 2020 6966 206c  ])..        if l
+00026130: 656e 2866 7329 203e 2031 3a0a 2020 2020  en(fs) > 1:.    
+00026140: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00026150: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
+00026160: 2020 2020 2020 2020 2020 2249 6e63 6f6d            "Incom
+00026170: 7061 7469 626c 6520 6578 7072 6573 7369  patible expressi
+00026180: 6f6e 2061 6e64 2070 6172 616d 6574 6572  on and parameter
+00026190: 732e 5c6e 220a 2020 2020 2020 2020 2020  s.\n".          
+000261a0: 2020 2020 2020 2b20 2253 7065 6369 6679        + "Specify
+000261b0: 2077 6861 7420 7468 6573 6520 7379 6d62   what these symb
+000261c0: 6f6c 7320 7265 7072 6573 656e 743a 207b  ols represent: {
+000261d0: 7d5c 6e22 2e66 6f72 6d61 7428 6673 290a  }\n".format(fs).
+000261e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000261f0: 2b20 2241 7265 2074 6865 7920 7261 6e67  + "Are they rang
+00026200: 6573 206f 7220 7061 7261 6d65 7465 7273  es or parameters
+00026210: 3f22 0a20 2020 2020 2020 2020 2020 2029  ?".            )
+00026220: 0a0a 2020 2020 2020 2020 2320 7665 7269  ..        # veri
+00026230: 6679 2074 6861 7420 616c 6c20 7379 6d62  fy that all symb
+00026240: 6f6c 7320 6172 6520 6b6e 6f77 6e20 2874  ols are known (t
+00026250: 6865 7920 6569 7468 6572 2072 6570 7265  hey either repre
+00026260: 7365 6e74 2070 6c6f 7474 696e 670a 2020  sent plotting.  
+00026270: 2020 2020 2020 2320 7261 6e67 6573 206f        # ranges o
+00026280: 7220 7061 7261 6d65 7465 7273 290a 2020  r parameters).  
+00026290: 2020 2020 2020 7261 6e67 655f 7379 6d62        range_symb
+000262a0: 6f6c 7320 3d20 5b72 5b30 5d20 666f 7220  ols = [r[0] for 
+000262b0: 7220 696e 2072 616e 6765 735d 0a20 2020  r in ranges].   
+000262c0: 2020 2020 2066 6f72 2072 2069 6e20 7261       for r in ra
+000262d0: 6e67 6573 3a0a 2020 2020 2020 2020 2020  nges:.          
+000262e0: 2020 6673 203d 2073 6574 2829 2e75 6e69    fs = set().uni
+000262f0: 6f6e 282a 5b65 2e66 7265 655f 7379 6d62  on(*[e.free_symb
+00026300: 6f6c 7320 666f 7220 6520 696e 2072 5b31  ols for e in r[1
+00026310: 3a5d 5d29 0a20 2020 2020 2020 2020 2020  :]]).           
+00026320: 2069 6620 616e 7928 7420 696e 2066 7320   if any(t in fs 
+00026330: 666f 7220 7420 696e 2072 616e 6765 5f73  for t in range_s
+00026340: 796d 626f 6c73 293a 0a20 2020 2020 2020  ymbols):.       
+00026350: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
+00026360: 616c 7565 4572 726f 7228 2252 616e 6765  alueError("Range
+00026370: 2073 796d 626f 6c73 2063 616e 2774 2062   symbols can't b
+00026380: 6520 696e 636c 7564 6564 2069 6e74 6f20  e included into 
+00026390: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+000263a0: 2020 2020 2020 226d 696e 696d 756d 2061        "minimum a
+000263b0: 6e64 206d 6178 696d 756d 206f 6620 6120  nd maximum of a 
+000263c0: 7261 6e67 652e 2022 0a20 2020 2020 2020  range. ".       
+000263d0: 2020 2020 2020 2020 2020 2020 2022 5265               "Re
+000263e0: 6365 6976 6564 2072 616e 6765 3a20 2573  ceived range: %s
+000263f0: 2220 2520 7374 7228 7229 290a 2020 2020  " % str(r)).    
+00026400: 2020 2020 2020 2020 7265 6d61 696e 696e          remainin
+00026410: 675f 6673 203d 2066 732e 6469 6666 6572  g_fs = fs.differ
+00026420: 656e 6365 2870 6172 616d 732e 6b65 7973  ence(params.keys
+00026430: 2829 290a 2020 2020 2020 2020 2020 2020  ()).            
+00026440: 6966 206c 656e 2872 656d 6169 6e69 6e67  if len(remaining
+00026450: 5f66 7329 203e 2030 3a0a 2020 2020 2020  _fs) > 0:.      
+00026460: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00026470: 5661 6c75 6545 7272 6f72 280a 2020 2020  ValueError(.    
+00026480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026490: 2255 6e6b 6f77 6e20 7379 6d62 6f6c 7320  "Unkown symbols 
+000264a0: 666f 756e 6420 696e 2070 6c6f 7474 696e  found in plottin
+000264b0: 6720 7261 6e67 653a 2025 732e 2022 2025  g range: %s. " %
+000264c0: 2028 722c 2920 2b0a 2020 2020 2020 2020   (r,) +.        
+000264d0: 2020 2020 2020 2020 2020 2020 2241 7265              "Are
+000264e0: 2074 6865 2066 6f6c 6c6f 7769 6e67 2070   the following p
+000264f0: 6172 616d 6574 6572 733f 2025 7322 2025  arameters? %s" %
+00026500: 2072 656d 6169 6e69 6e67 5f66 7329 0a0a   remaining_fs)..
+00026510: 0a63 6c61 7373 204e 7971 7569 7374 4c69  .class NyquistLi
+00026520: 6e65 5365 7269 6573 2841 7272 6f77 734d  neSeries(ArrowsM
+00026530: 6978 696e 2c20 436f 6e74 726f 6c42 6173  ixin, ControlBas
+00026540: 6553 6572 6965 7329 3a0a 2020 2020 2222  eSeries):.    ""
+00026550: 2247 656e 6572 6174 6573 206e 756d 6572  "Generates numer
+00026560: 6963 616c 2064 6174 6120 666f 7220 4e79  ical data for Ny
+00026570: 7175 6973 7420 706c 6f74 2075 7369 6e67  quist plot using
+00026580: 2074 6865 2060 6063 6f6e 7472 6f6c 6060   the ``control``
+00026590: 0a20 2020 206d 6f64 756c 652e 0a20 2020  .    module..   
+000265a0: 2022 2222 0a0a 2020 2020 5f61 6c6c 6f77   """..    _allow
+000265b0: 6564 5f6b 6579 7320 3d20 5b0a 2020 2020  ed_keys = [.    
+000265c0: 2020 2020 2261 7272 6f77 7322 2c20 226d      "arrows", "m
+000265d0: 6178 5f63 7572 7665 5f6d 6167 6e69 7475  ax_curve_magnitu
+000265e0: 6465 222c 2022 6d61 785f 6375 7276 655f  de", "max_curve_
+000265f0: 6f66 6673 6574 222c 0a20 2020 2020 2020  offset",.       
+00026600: 2022 7374 6172 745f 6d61 726b 6572 222c   "start_marker",
+00026610: 2022 7072 696d 6172 795f 7374 796c 6522   "primary_style"
+00026620: 2c20 226d 6972 726f 725f 7374 796c 6522  , "mirror_style"
+00026630: 0a20 2020 205d 0a0a 2020 2020 6465 6620  .    ]..    def 
+00026640: 5f63 6f70 795f 6672 6f6d 5f64 6963 7428  _copy_from_dict(
+00026650: 7365 6c66 2c20 642c 206b 293a 0a20 2020  self, d, k):.   
+00026660: 2020 2020 2069 6620 6b20 696e 2064 2e6b       if k in d.k
+00026670: 6579 7328 293a 0a20 2020 2020 2020 2020  eys():.         
+00026680: 2020 2073 6574 6174 7472 2873 656c 662c     setattr(self,
+00026690: 206b 2c20 645b 6b5d 290a 0a20 2020 2064   k, d[k])..    d
+000266a0: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+000266b0: 2c20 7466 2c20 7661 725f 7374 6172 745f  , tf, var_start_
+000266c0: 656e 642c 206c 6162 656c 3d22 222c 202a  end, label="", *
+000266d0: 2a6b 7761 7267 7329 3a0a 2020 2020 2020  *kwargs):.      
+000266e0: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
+000266f0: 5f5f 2874 662c 206c 6162 656c 3d6c 6162  __(tf, label=lab
+00026700: 656c 2c20 2a2a 6b77 6172 6773 290a 2020  el, **kwargs).  
+00026710: 2020 2020 2020 7365 6c66 2e72 616e 6765        self.range
+00026720: 7320 3d20 5b76 6172 5f73 7461 7274 5f65  s = [var_start_e
+00026730: 6e64 5d0a 2020 2020 2020 2020 7365 6c66  nd].        self
+00026740: 2e5f 6368 6563 6b5f 6673 2829 0a0a 2020  ._check_fs()..  
+00026750: 2020 2020 2020 2320 7468 6573 6520 6174        # these at
+00026760: 7472 6962 7574 6573 2061 7265 2075 7365  tributes are use
+00026770: 6420 6279 2060 6063 6f6e 7472 6f6c 6060  d by ``control``
+00026780: 2069 6e20 7468 6520 7265 6e64 6572 696e   in the renderin
+00026790: 6720 7374 6570 2c0a 2020 2020 2020 2020  g step,.        
+000267a0: 2320 6e6f 7420 696e 2074 6865 2064 6174  # not in the dat
+000267b0: 6120 6765 6e65 7261 7469 6f6e 2073 7465  a generation ste
+000267c0: 702e 2049 206e 6565 6420 7468 656d 2068  p. I need them h
+000267d0: 6572 6520 696e 206f 7264 6572 2074 6f0a  ere in order to.
+000267e0: 2020 2020 2020 2020 2320 636f 6e74 726f          # contro
+000267f0: 6c20 7468 6520 7265 6e64 6572 696e 6720  l the rendering 
+00026800: 696e 2065 6163 6820 6261 636b 656e 642e  in each backend.
+00026810: 0a20 2020 2020 2020 2073 656c 662e 6d61  .        self.ma
+00026820: 785f 6375 7276 655f 6d61 676e 6974 7564  x_curve_magnitud
+00026830: 6520 3d20 6b77 6172 6773 2e67 6574 2822  e = kwargs.get("
+00026840: 6d61 785f 6375 7276 655f 6d61 676e 6974  max_curve_magnit
+00026850: 7564 6522 2c20 3230 290a 2020 2020 2020  ude", 20).      
+00026860: 2020 7365 6c66 2e6d 6178 5f63 7572 7665    self.max_curve
+00026870: 5f6f 6666 7365 7420 3d20 6b77 6172 6773  _offset = kwargs
+00026880: 2e67 6574 2822 6d61 785f 6375 7276 655f  .get("max_curve_
+00026890: 6f66 6673 6574 222c 2030 2e30 3229 0a20  offset", 0.02). 
+000268a0: 2020 2020 2020 2073 656c 662e 7374 6172         self.star
+000268b0: 745f 6d61 726b 6572 203d 206b 7761 7267  t_marker = kwarg
+000268c0: 732e 6765 7428 2273 7461 7274 5f6d 6172  s.get("start_mar
+000268d0: 6b65 7222 2c20 5472 7565 290a 2020 2020  ker", True).    
+000268e0: 2020 2020 7365 6c66 2e70 7269 6d61 7279      self.primary
+000268f0: 5f73 7479 6c65 203d 206b 7761 7267 732e  _style = kwargs.
+00026900: 6765 7428 2270 7269 6d61 7279 5f73 7479  get("primary_sty
+00026910: 6c65 222c 204e 6f6e 6529 0a20 2020 2020  le", None).     
+00026920: 2020 2073 656c 662e 6d69 7272 6f72 5f73     self.mirror_s
+00026930: 7479 6c65 203d 206b 7761 7267 732e 6765  tyle = kwargs.ge
+00026940: 7428 226d 6972 726f 725f 7374 796c 6522  t("mirror_style"
+00026950: 2c20 4e6f 6e65 290a 2020 2020 2020 2020  , None).        
+00026960: 666f 7220 6b20 696e 205b 2261 7272 6f77  for k in ["arrow
+00026970: 7322 2c20 226d 6178 5f63 7572 7665 5f6d  s", "max_curve_m
+00026980: 6167 6e69 7475 6465 222c 2022 6d61 785f  agnitude", "max_
+00026990: 6375 7276 655f 6f66 6673 6574 222c 0a20  curve_offset",. 
+000269a0: 2020 2020 2020 2020 2020 2022 7374 6172             "star
+000269b0: 745f 6d61 726b 6572 222c 2022 7072 696d  t_marker", "prim
+000269c0: 6172 795f 7374 796c 6522 2c20 226d 6972  ary_style", "mir
+000269d0: 726f 725f 7374 796c 6522 5d3a 0a20 2020  ror_style"]:.   
+000269e0: 2020 2020 2020 2020 2073 656c 662e 5f63           self._c
+000269f0: 6f70 795f 6672 6f6d 5f64 6963 7428 7365  opy_from_dict(se
+00026a00: 6c66 2e5f 636f 6e74 726f 6c5f 6b77 2c20  lf._control_kw, 
+00026a10: 6b29 0a0a 2020 2020 6465 6620 5f5f 7374  k)..    def __st
+00026a20: 725f 5f28 7365 6c66 293a 0a20 2020 2020  r__(self):.     
+00026a30: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+00026a40: 7374 725f 6865 6c70 6572 280a 2020 2020  str_helper(.    
+00026a50: 2020 2020 2020 2020 226e 7971 7569 7374          "nyquist
+00026a60: 206c 696e 6520 6f66 2025 7322 2025 2028   line of %s" % (
+00026a70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00026a80: 2073 656c 662e 5f65 7870 7220 6966 2073   self._expr if s
+00026a90: 656c 662e 5f65 7870 7220 656c 7365 2073  elf._expr else s
+00026aa0: 656c 662e 5f63 6f6e 7472 6f6c 5f74 6629  elf._control_tf)
+00026ab0: 290a 0a20 2020 2064 6566 2067 6574 5f64  )..    def get_d
+00026ac0: 6174 6128 7365 6c66 293a 0a20 2020 2020  ata(self):.     
+00026ad0: 2020 2022 2222 0a20 2020 2020 2020 2052     """.        R
+00026ae0: 6574 7572 6e73 0a20 2020 2020 2020 203d  eturns.        =
+00026af0: 3d3d 3d3d 3d3d 0a20 2020 2020 2020 2078  ======.        x
+00026b00: 5f72 6567 2c20 795f 7265 6720 3a20 6e70  _reg, y_reg : np
+00026b10: 2e6e 6461 7272 6179 0a20 2020 2020 2020  .ndarray.       
+00026b20: 2078 5f73 636c 2c20 795f 7363 6c20 3a20   x_scl, y_scl : 
+00026b30: 6e70 2e6e 6461 7272 6179 0a20 2020 2020  np.ndarray.     
+00026b40: 2020 2078 5f69 6e76 312c 2079 5f69 6e76     x_inv1, y_inv
+00026b50: 3120 3a20 6e70 2e6e 6461 7272 6179 0a20  1 : np.ndarray. 
+00026b60: 2020 2020 2020 2078 5f69 6e76 322c 2079         x_inv2, y
+00026b70: 5f69 6e76 3220 3a20 6e70 2e6e 6461 7272  _inv2 : np.ndarr
+00026b80: 6179 0a20 2020 2020 2020 2063 7572 7665  ay.        curve
+00026b90: 5f6f 6666 7365 7420 3a20 6e70 2e6e 6461  _offset : np.nda
+00026ba0: 7272 6179 0a20 2020 2020 2020 2022 2222  rray.        """
+00026bb0: 0a20 2020 2020 2020 206e 7020 3d20 696d  .        np = im
+00026bc0: 706f 7274 5f6d 6f64 756c 6528 226e 756d  port_module("num
+00026bd0: 7079 2229 0a20 2020 2020 2020 2063 7420  py").        ct 
+00026be0: 3d20 696d 706f 7274 5f6d 6f64 756c 6528  = import_module(
+00026bf0: 2263 6f6e 7472 6f6c 2229 0a20 2020 2020  "control").     
+00026c00: 2020 206d 6572 6765 6465 6570 203d 2069     mergedeep = i
+00026c10: 6d70 6f72 745f 6d6f 6475 6c65 2827 6d65  mport_module('me
+00026c20: 7267 6564 6565 7027 290a 0a20 2020 2020  rgedeep')..     
+00026c30: 2020 2069 6620 7365 6c66 2e69 735f 696e     if self.is_in
+00026c40: 7465 7261 6374 6976 653a 0a20 2020 2020  teractive:.     
+00026c50: 2020 2020 2020 2074 6620 3d20 7365 6c66         tf = self
+00026c60: 2e5f 6578 7072 2e73 7562 7328 7365 6c66  ._expr.subs(self
+00026c70: 2e70 6172 616d 7329 0a20 2020 2020 2020  .params).       
+00026c80: 2020 2020 2073 656c 662e 5f63 6f6e 7472       self._contr
+00026c90: 6f6c 5f74 6620 3d20 7466 5f74 6f5f 636f  ol_tf = tf_to_co
+00026ca0: 6e74 726f 6c28 7466 290a 0a20 2020 2020  ntrol(tf)..     
+00026cb0: 2020 2063 6f6e 7472 6f6c 5f6b 7720 3d20     control_kw = 
+00026cc0: 7b7d 0a20 2020 2020 2020 2073 796d 2c20  {}.        sym, 
+00026cd0: 7374 6172 742c 2065 6e64 203d 2073 656c  start, end = sel
+00026ce0: 662e 7261 6e67 6573 5b30 5d0a 2020 2020  f.ranges[0].    
+00026cf0: 2020 2020 6966 2028 7374 6172 7420 213d      if (start !=
+00026d00: 2065 6e64 2920 6f72 2073 656c 662e 5f69   end) or self._i
+00026d10: 6e74 6572 6163 7469 7665 5f72 616e 6765  nteractive_range
+00026d20: 733a 0a20 2020 2020 2020 2020 2020 2073  s:.            s
+00026d30: 7461 7274 203d 2073 656c 662e 5f75 7064  tart = self._upd
+00026d40: 6174 655f 7261 6e67 655f 7661 6c75 6528  ate_range_value(
+00026d50: 7374 6172 7429 2e72 6561 6c0a 2020 2020  start).real.    
+00026d60: 2020 2020 2020 2020 656e 6420 3d20 7365          end = se
+00026d70: 6c66 2e5f 7570 6461 7465 5f72 616e 6765  lf._update_range
+00026d80: 5f76 616c 7565 2865 6e64 292e 7265 616c  _value(end).real
+00026d90: 0a20 2020 2020 2020 2020 2020 2063 6f6e  .            con
+00026da0: 7472 6f6c 5f6b 775b 226f 6d65 6761 5f6c  trol_kw["omega_l
+00026db0: 696d 6974 7322 5d20 3d20 5b31 302a 2a73  imits"] = [10**s
+00026dc0: 7461 7274 2c20 3130 2a2a 656e 645d 0a0a  tart, 10**end]..
+00026dd0: 2020 2020 2020 2020 636b 7720 3d20 6d65          ckw = me
+00026de0: 7267 6564 6565 702e 6d65 7267 6528 7b7d  rgedeep.merge({}
+00026df0: 2c20 636f 6e74 726f 6c5f 6b77 2c20 7365  , control_kw, se
+00026e00: 6c66 2e5f 636f 6e74 726f 6c5f 6b77 290a  lf._control_kw).
+00026e10: 2020 2020 2020 2020 636b 775b 2270 6c6f          ckw["plo
+00026e20: 7422 5d20 3d20 4661 6c73 650a 2020 2020  t"] = False.    
+00026e30: 2020 2020 636b 775b 2272 6574 7572 6e5f      ckw["return_
+00026e40: 636f 6e74 6f75 7222 5d20 3d20 5472 7565  contour"] = True
+00026e50: 0a20 2020 2020 2020 205f 2c20 636f 6e74  .        _, cont
+00026e60: 6f75 7220 3d20 6374 2e6e 7971 7569 7374  our = ct.nyquist
+00026e70: 5f70 6c6f 7428 7365 6c66 2e5f 636f 6e74  _plot(self._cont
+00026e80: 726f 6c5f 7466 2c20 2a2a 636b 7729 0a0a  rol_tf, **ckw)..
+00026e90: 2020 2020 2020 2020 7265 7370 203d 2073          resp = s
+00026ea0: 656c 662e 5f63 6f6e 7472 6f6c 5f74 6628  elf._control_tf(
+00026eb0: 636f 6e74 6f75 7229 0a0a 2020 2020 2020  contour)..      
+00026ec0: 2020 230a 2020 2020 2020 2020 2320 4e4f    #.        # NO
+00026ed0: 5445 3a20 7468 6520 666f 6c6c 6f77 696e  TE: the followin
+00026ee0: 6720 6973 2061 6461 7074 6564 2066 726f  g is adapted fro
+00026ef0: 6d3a 0a20 2020 2020 2020 2023 2060 6063  m:.        # ``c
+00026f00: 6f6e 7472 6f6c 2e66 7265 7170 6c6f 742e  ontrol.freqplot.
+00026f10: 706c 6f74 5f6e 7971 7569 7374 2829 6060  plot_nyquist()``
+00026f20: 0a20 2020 2020 2020 2023 2042 6563 6175  .        # Becau
+00026f30: 7365 2074 6861 7420 6675 6e63 7469 6f6e  se that function
+00026f40: 2064 6f65 736e 2774 2072 6574 7572 6e20   doesn't return 
+00026f50: 6060 7370 6c61 6e65 5f63 6f6e 746f 7572  ``splane_contour
+00026f60: 6060 2061 6e64 2069 7420 6973 0a20 2020  `` and it is.   
+00026f70: 2020 2020 2023 2076 6572 7920 6469 6666       # very diff
+00026f80: 6963 756c 7420 746f 2072 6562 7569 6c64  icult to rebuild
+00026f90: 2069 742c 2049 2072 656d 6f76 6564 2069   it, I removed i
+00026fa0: 7420 6672 6f6d 2074 6865 2066 6f6c 6c6f  t from the follo
+00026fb0: 7769 6e67 2063 6f64 652e 0a20 2020 2020  wing code..     
+00026fc0: 2020 2023 2046 696e 6765 7220 6372 6f73     # Finger cros
+00026fd0: 7365 642e 0a20 2020 2020 2020 2023 0a0a  sed..        #..
+00026fe0: 2020 2020 2020 2020 6d61 785f 6375 7276          max_curv
+00026ff0: 655f 6d61 676e 6974 7564 6520 3d20 7365  e_magnitude = se
+00027000: 6c66 2e6d 6178 5f63 7572 7665 5f6d 6167  lf.max_curve_mag
+00027010: 6e69 7475 6465 0a20 2020 2020 2020 206d  nitude.        m
+00027020: 6178 5f63 7572 7665 5f6f 6666 7365 7420  ax_curve_offset 
+00027030: 3d20 7365 6c66 2e6d 6178 5f63 7572 7665  = self.max_curve
+00027040: 5f6f 6666 7365 740a 0a20 2020 2020 2020  _offset..       
+00027050: 2072 6567 5f6d 6173 6b20 3d20 6e70 2e61   reg_mask = np.a
+00027060: 6273 2872 6573 7029 203e 206d 6178 5f63  bs(resp) > max_c
+00027070: 7572 7665 5f6d 6167 6e69 7475 6465 0a0a  urve_magnitude..
+00027080: 2020 2020 2020 2020 7363 616c 655f 6d61          scale_ma
+00027090: 736b 203d 207e 7265 675f 6d61 736b 205c  sk = ~reg_mask \
+000270a0: 0a20 2020 2020 2020 2020 2020 2026 206e  .            & n
+000270b0: 702e 636f 6e63 6174 656e 6174 6528 287e  p.concatenate((~
+000270c0: 7265 675f 6d61 736b 5b31 3a5d 2c20 7e72  reg_mask[1:], ~r
+000270d0: 6567 5f6d 6173 6b5b 2d31 3a5d 2929 205c  eg_mask[-1:])) \
+000270e0: 0a20 2020 2020 2020 2020 2020 2026 206e  .            & n
+000270f0: 702e 636f 6e63 6174 656e 6174 6528 287e  p.concatenate((~
+00027100: 7265 675f 6d61 736b 5b30 3a31 5d2c 207e  reg_mask[0:1], ~
+00027110: 7265 675f 6d61 736b 5b3a 2d31 5d29 290a  reg_mask[:-1])).
+00027120: 0a20 2020 2020 2020 2023 2052 6573 6361  .        # Resca
+00027130: 6c65 2074 6865 2070 6f69 6e74 7320 7769  le the points wi
+00027140: 7468 206c 6172 6765 206d 6167 6e69 7475  th large magnitu
+00027150: 6465 0a20 2020 2020 2020 2072 6573 6361  de.        resca
+00027160: 6c65 203d 206e 702e 6c6f 6769 6361 6c5f  le = np.logical_
+00027170: 616e 6428 0a20 2020 2020 2020 2020 2020  and(.           
+00027180: 2072 6567 5f6d 6173 6b2c 2061 6273 2872   reg_mask, abs(r
+00027190: 6573 7029 203e 206d 6178 5f63 7572 7665  esp) > max_curve
+000271a0: 5f6d 6167 6e69 7475 6465 290a 2020 2020  _magnitude).    
+000271b0: 2020 2020 7265 7370 5b72 6573 6361 6c65      resp[rescale
+000271c0: 5d20 2a3d 206d 6178 5f63 7572 7665 5f6d  ] *= max_curve_m
+000271d0: 6167 6e69 7475 6465 202f 2061 6273 2872  agnitude / abs(r
+000271e0: 6573 705b 7265 7363 616c 655d 290a 0a20  esp[rescale]).. 
+000271f0: 2020 2020 2020 2023 2050 6c6f 7420 7468         # Plot th
+00027200: 6520 7265 6775 6c61 7220 706f 7274 696f  e regular portio
+00027210: 6e73 206f 6620 7468 6520 6375 7276 6520  ns of the curve 
+00027220: 2861 6e64 2067 7261 6220 7468 6520 636f  (and grab the co
+00027230: 6c6f 7229 0a20 2020 2020 2020 2078 5f72  lor).        x_r
+00027240: 6567 203d 206e 702e 6d61 2e6d 6173 6b65  eg = np.ma.maske
+00027250: 645f 7768 6572 6528 7265 675f 6d61 736b  d_where(reg_mask
+00027260: 2c20 7265 7370 2e72 6561 6c29 0a20 2020  , resp.real).   
+00027270: 2020 2020 2079 5f72 6567 203d 206e 702e       y_reg = np.
+00027280: 6d61 2e6d 6173 6b65 645f 7768 6572 6528  ma.masked_where(
+00027290: 7265 675f 6d61 736b 2c20 7265 7370 2e69  reg_mask, resp.i
+000272a0: 6d61 6729 0a0a 2020 2020 2020 2020 2320  mag)..        # 
+000272b0: 4669 6775 7265 206f 7574 2068 6f77 206d  Figure out how m
+000272c0: 7563 6820 746f 206f 6666 7365 7420 7468  uch to offset th
+000272d0: 6520 6375 7276 653a 2074 6865 206f 6666  e curve: the off
+000272e0: 7365 7420 676f 6573 2066 726f 6d0a 2020  set goes from.  
+000272f0: 2020 2020 2020 2320 7a65 726f 2061 7420        # zero at 
+00027300: 7468 6520 7374 6172 7420 6f66 2074 6865  the start of the
+00027310: 2073 6361 6c65 6420 7365 6374 696f 6e20   scaled section 
+00027320: 746f 206d 6178 5f63 7572 7665 5f6f 6666  to max_curve_off
+00027330: 7365 7420 6173 0a20 2020 2020 2020 2023  set as.        #
+00027340: 2077 6520 6d6f 7665 2061 6c6f 6e67 2074   we move along t
+00027350: 6865 2063 7572 7665 0a20 2020 2020 2020  he curve.       
+00027360: 2063 7572 7665 5f6f 6666 7365 7420 3d20   curve_offset = 
+00027370: 7365 6c66 2e5f 636f 6d70 7574 655f 6375  self._compute_cu
+00027380: 7276 655f 6f66 6673 6574 280a 2020 2020  rve_offset(.    
+00027390: 2020 2020 2020 2020 7265 7370 2c20 7363          resp, sc
+000273a0: 616c 655f 6d61 736b 2c20 6d61 785f 6375  ale_mask, max_cu
+000273b0: 7276 655f 6f66 6673 6574 290a 0a20 2020  rve_offset)..   
+000273c0: 2020 2020 2023 2050 6c6f 7420 7468 6520       # Plot the 
+000273d0: 7363 616c 6564 2073 6563 7469 6f6e 7320  scaled sections 
+000273e0: 6f66 2074 6865 2063 7572 7665 2028 6368  of the curve (ch
+000273f0: 616e 6769 6e67 206c 696e 6573 7479 6c65  anging linestyle
+00027400: 290a 2020 2020 2020 2020 785f 7363 6c20  ).        x_scl 
+00027410: 3d20 6e70 2e6d 612e 6d61 736b 6564 5f77  = np.ma.masked_w
+00027420: 6865 7265 2873 6361 6c65 5f6d 6173 6b2c  here(scale_mask,
+00027430: 2072 6573 702e 7265 616c 290a 2020 2020   resp.real).    
+00027440: 2020 2020 795f 7363 6c20 3d20 6e70 2e6d      y_scl = np.m
+00027450: 612e 6d61 736b 6564 5f77 6865 7265 2873  a.masked_where(s
+00027460: 6361 6c65 5f6d 6173 6b2c 2072 6573 702e  cale_mask, resp.
+00027470: 696d 6167 290a 0a20 2020 2020 2020 2023  imag)..        #
+00027480: 2074 6865 2070 7269 6d61 7279 2063 7572   the primary cur
+00027490: 7665 2028 696e 7669 7369 626c 6529 2066  ve (invisible) f
+000274a0: 6f72 2073 6574 7469 6e67 2061 7272 6f77  or setting arrow
+000274b0: 730a 2020 2020 2020 2020 785f 696e 7631  s.        x_inv1
+000274c0: 2c20 795f 696e 7631 203d 2072 6573 702e  , y_inv1 = resp.
+000274d0: 7265 616c 2e63 6f70 7928 292c 2072 6573  real.copy(), res
+000274e0: 702e 696d 6167 2e63 6f70 7928 290a 2020  p.imag.copy().  
+000274f0: 2020 2020 2020 785f 696e 7631 5b72 6567        x_inv1[reg
+00027500: 5f6d 6173 6b5d 202a 3d20 2831 202b 2063  _mask] *= (1 + c
+00027510: 7572 7665 5f6f 6666 7365 745b 7265 675f  urve_offset[reg_
+00027520: 6d61 736b 5d29 0a20 2020 2020 2020 2079  mask]).        y
+00027530: 5f69 6e76 315b 7265 675f 6d61 736b 5d20  _inv1[reg_mask] 
+00027540: 2a3d 2028 3120 2b20 6375 7276 655f 6f66  *= (1 + curve_of
+00027550: 6673 6574 5b72 6567 5f6d 6173 6b5d 290a  fset[reg_mask]).
+00027560: 0a20 2020 2020 2020 2023 2041 6464 2074  .        # Add t
+00027570: 6865 2061 7272 6f77 7320 746f 2074 6865  he arrows to the
+00027580: 206d 6972 726f 7220 696d 6167 6520 286f   mirror image (o
+00027590: 6e20 746f 7020 6f66 2061 6e20 696e 7669  n top of an invi
+000275a0: 7369 626c 6520 636f 6e74 6f75 7229 0a20  sible contour). 
+000275b0: 2020 2020 2020 2078 5f69 6e76 322c 2079         x_inv2, y
+000275c0: 5f69 6e76 3220 3d20 7265 7370 2e72 6561  _inv2 = resp.rea
+000275d0: 6c2e 636f 7079 2829 2c20 7265 7370 2e69  l.copy(), resp.i
+000275e0: 6d61 672e 636f 7079 2829 0a20 2020 2020  mag.copy().     
+000275f0: 2020 2078 5f69 6e76 325b 7265 675f 6d61     x_inv2[reg_ma
+00027600: 736b 5d20 2a3d 2028 3120 2d20 6375 7276  sk] *= (1 - curv
+00027610: 655f 6f66 6673 6574 5b72 6567 5f6d 6173  e_offset[reg_mas
+00027620: 6b5d 290a 2020 2020 2020 2020 795f 696e  k]).        y_in
+00027630: 7632 5b72 6567 5f6d 6173 6b5d 202a 3d20  v2[reg_mask] *= 
+00027640: 2831 202d 2063 7572 7665 5f6f 6666 7365  (1 - curve_offse
+00027650: 745b 7265 675f 6d61 736b 5d29 0a0a 2020  t[reg_mask])..  
+00027660: 2020 2020 2020 7265 7475 726e 2078 5f72        return x_r
+00027670: 6567 2c20 795f 7265 672c 2078 5f73 636c  eg, y_reg, x_scl
+00027680: 2c20 795f 7363 6c2c 2078 5f69 6e76 312c  , y_scl, x_inv1,
+00027690: 2079 5f69 6e76 312c 2078 5f69 6e76 322c   y_inv1, x_inv2,
+000276a0: 2079 5f69 6e76 322c 2063 7572 7665 5f6f   y_inv2, curve_o
+000276b0: 6666 7365 740a 0a20 2020 2040 7374 6174  ffset..    @stat
+000276c0: 6963 6d65 7468 6f64 0a20 2020 2064 6566  icmethod.    def
+000276d0: 205f 636f 6d70 7574 655f 6375 7276 655f   _compute_curve_
+000276e0: 6f66 6673 6574 2872 6573 702c 206d 6173  offset(resp, mas
+000276f0: 6b2c 206d 6178 5f6f 6666 7365 7429 3a0a  k, max_offset):.
+00027700: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00027710: 2020 2020 2020 2020 4675 6e63 7469 6f6e          Function
+00027720: 2074 6f20 636f 6d70 7574 6520 4e79 7175   to compute Nyqu
+00027730: 6973 7420 6375 7276 6520 6f66 6673 6574  ist curve offset
+00027740: 730a 0a20 2020 2020 2020 2054 6869 7320  s..        This 
+00027750: 6675 6e63 7469 6f6e 2063 6f6d 7075 7465  function compute
+00027760: 7320 6120 736d 6f6f 7468 6c79 2076 6172  s a smoothly var
+00027770: 7969 6e67 206f 6666 7365 7420 7468 6174  ying offset that
+00027780: 2073 7461 7274 7320 616e 6420 656e 6473   starts and ends
+00027790: 2061 740a 2020 2020 2020 2020 7a65 726f   at.        zero
+000277a0: 2061 7420 7468 6520 656e 6473 206f 6620   at the ends of 
+000277b0: 6120 7363 616c 6564 2073 6567 6d65 6e74  a scaled segment
+000277c0: 2e0a 0a20 2020 2020 2020 2054 6869 7320  ...        This 
+000277d0: 6675 6e63 7469 6f6e 2063 6f6d 6573 2066  function comes f
+000277e0: 726f 6d20 6060 636f 6e74 726f 6c2f 6672  rom ``control/fr
+000277f0: 6571 706c 6f74 2e70 7960 602e 0a20 2020  eqplot.py``..   
+00027800: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00027810: 206e 7020 3d20 696d 706f 7274 5f6d 6f64   np = import_mod
+00027820: 756c 6528 226e 756d 7079 2229 0a0a 2020  ule("numpy")..  
+00027830: 2020 2020 2020 2320 436f 6d70 7574 6520        # Compute 
+00027840: 7468 6520 6172 6320 6c65 6e67 7468 2061  the arc length a
+00027850: 6c6f 6e67 2074 6865 2063 7572 7665 0a20  long the curve. 
+00027860: 2020 2020 2020 2073 5f63 7572 7665 203d         s_curve =
+00027870: 206e 702e 6375 6d73 756d 280a 2020 2020   np.cumsum(.    
+00027880: 2020 2020 2020 2020 6e70 2e73 7172 7428          np.sqrt(
+00027890: 6e70 2e64 6966 6628 7265 7370 2e72 6561  np.diff(resp.rea
+000278a0: 6c29 202a 2a20 3220 2b20 6e70 2e64 6966  l) ** 2 + np.dif
+000278b0: 6628 7265 7370 2e69 6d61 6729 202a 2a20  f(resp.imag) ** 
+000278c0: 3229 290a 0a20 2020 2020 2020 2023 2049  2))..        # I
+000278d0: 6e69 7469 616c 697a 6520 7468 6520 6f66  nitialize the of
+000278e0: 6673 6574 0a20 2020 2020 2020 206f 6666  fset.        off
+000278f0: 7365 7420 3d20 6e70 2e7a 6572 6f73 2872  set = np.zeros(r
+00027900: 6573 702e 7369 7a65 290a 2020 2020 2020  esp.size).      
+00027910: 2020 6172 636c 656e 203d 206e 702e 7a65    arclen = np.ze
+00027920: 726f 7328 7265 7370 2e73 697a 6529 0a0a  ros(resp.size)..
+00027930: 2020 2020 2020 2020 2320 5761 6c6b 2074          # Walk t
+00027940: 6872 6f75 6768 2074 6865 2072 6573 706f  hrough the respo
+00027950: 6e73 6520 616e 6420 6b65 6570 2074 7261  nse and keep tra
+00027960: 636b 206f 6620 6561 6368 2063 6f6e 7469  ck of each conti
+00027970: 6e6f 7573 2063 6f6d 706f 6e65 6e74 0a20  nous component. 
+00027980: 2020 2020 2020 2069 2c20 6e73 6567 7320         i, nsegs 
+00027990: 3d20 302c 2030 0a20 2020 2020 2020 2077  = 0, 0.        w
+000279a0: 6869 6c65 2069 203c 2072 6573 702e 7369  hile i < resp.si
+000279b0: 7a65 3a0a 2020 2020 2020 2020 2020 2020  ze:.            
+000279c0: 2320 536b 6970 2074 6865 2072 6567 756c  # Skip the regul
+000279d0: 6172 2073 6567 6d65 6e74 0a20 2020 2020  ar segment.     
+000279e0: 2020 2020 2020 2077 6869 6c65 2069 203c         while i <
+000279f0: 2072 6573 702e 7369 7a65 2061 6e64 206d   resp.size and m
+00027a00: 6173 6b5b 695d 3a0a 2020 2020 2020 2020  ask[i]:.        
+00027a10: 2020 2020 2020 2020 6920 2b3d 2031 2020          i += 1  
+00027a20: 2020 2020 2020 2020 2020 2020 2320 496e              # In
+00027a30: 6372 656d 656e 7420 7468 6520 636f 756e  crement the coun
+00027a40: 7465 720a 2020 2020 2020 2020 2020 2020  ter.            
+00027a50: 2020 2020 6966 2069 203d 3d20 7265 7370      if i == resp
+00027a60: 2e73 697a 653a 0a20 2020 2020 2020 2020  .size:.         
+00027a70: 2020 2020 2020 2020 2020 2062 7265 616b             break
+00027a80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00027a90: 2023 204b 6565 7020 7472 6163 6b20 6f66   # Keep track of
+00027aa0: 2074 6865 2061 7263 6c65 6e67 7468 0a20   the arclength. 
+00027ab0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+00027ac0: 7263 6c65 6e5b 695d 203d 2061 7263 6c65  rclen[i] = arcle
+00027ad0: 6e5b 692d 315d 202b 206e 702e 6162 7328  n[i-1] + np.abs(
+00027ae0: 7265 7370 5b69 5d20 2d20 7265 7370 5b69  resp[i] - resp[i
+00027af0: 2d31 5d29 0a0a 2020 2020 2020 2020 2020  -1])..          
+00027b00: 2020 6e73 6567 7320 2b3d 2030 2e35 0a20    nsegs += 0.5. 
+00027b10: 2020 2020 2020 2020 2020 2069 6620 6920             if i 
+00027b20: 3d3d 2072 6573 702e 7369 7a65 3a0a 2020  == resp.size:.  
+00027b30: 2020 2020 2020 2020 2020 2020 2020 6272                br
+00027b40: 6561 6b0a 0a20 2020 2020 2020 2020 2020  eak..           
+00027b50: 2023 2053 6176 6520 7468 6520 7374 6172   # Save the star
+00027b60: 7469 6e67 206f 6666 7365 7420 6f66 2074  ting offset of t
+00027b70: 6869 7320 7365 676d 656e 740a 2020 2020  his segment.    
+00027b80: 2020 2020 2020 2020 7365 675f 7374 6172          seg_star
+00027b90: 7420 3d20 690a 0a20 2020 2020 2020 2020  t = i..         
+00027ba0: 2020 2023 2057 616c 6b20 7468 726f 7567     # Walk throug
+00027bb0: 6820 7468 6520 7363 616c 6564 2073 6567  h the scaled seg
+00027bc0: 6d65 6e74 0a20 2020 2020 2020 2020 2020  ment.           
+00027bd0: 2077 6869 6c65 2069 203c 2072 6573 702e   while i < resp.
+00027be0: 7369 7a65 2061 6e64 206e 6f74 206d 6173  size and not mas
+00027bf0: 6b5b 695d 3a0a 2020 2020 2020 2020 2020  k[i]:.          
+00027c00: 2020 2020 2020 6920 2b3d 2031 0a20 2020        i += 1.   
+00027c10: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00027c20: 6920 3d3d 2072 6573 702e 7369 7a65 3a20  i == resp.size: 
+00027c30: 2023 2053 6565 2069 6620 7765 2061 7265   # See if we are
+00027c40: 2064 6f6e 6520 7769 7468 2074 6869 7320   done with this 
+00027c50: 7365 676d 656e 740a 2020 2020 2020 2020  segment.        
+00027c60: 2020 2020 2020 2020 2020 2020 6272 6561              brea
+00027c70: 6b0a 2020 2020 2020 2020 2020 2020 2020  k.              
+00027c80: 2020 2320 4b65 6570 2074 7261 636b 206f    # Keep track o
+00027c90: 6620 7468 6520 6172 636c 656e 6774 680a  f the arclength.
+00027ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00027cb0: 6172 636c 656e 5b69 5d20 3d20 6172 636c  arclen[i] = arcl
+00027cc0: 656e 5b69 2d31 5d20 2b20 6e70 2e61 6273  en[i-1] + np.abs
+00027cd0: 2872 6573 705b 695d 202d 2072 6573 705b  (resp[i] - resp[
+00027ce0: 692d 315d 290a 0a20 2020 2020 2020 2020  i-1])..         
+00027cf0: 2020 206e 7365 6773 202b 3d20 302e 350a     nsegs += 0.5.
+00027d00: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+00027d10: 203d 3d20 7265 7370 2e73 697a 653a 0a20   == resp.size:. 
+00027d20: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+00027d30: 7265 616b 0a0a 2020 2020 2020 2020 2020  reak..          
+00027d40: 2020 2320 5361 7665 2074 6865 2065 6e64    # Save the end
+00027d50: 696e 6720 6f66 6673 6574 206f 6620 7468  ing offset of th
+00027d60: 6973 2073 6567 6d65 6e74 0a20 2020 2020  is segment.     
+00027d70: 2020 2020 2020 2073 6567 5f65 6e64 203d         seg_end =
+00027d80: 2069 0a0a 2020 2020 2020 2020 2020 2020   i..            
+00027d90: 2320 4e6f 7720 636f 6d70 7574 6520 7468  # Now compute th
+00027da0: 6520 7363 616c 696e 6720 666f 7220 7468  e scaling for th
+00027db0: 6973 2073 6567 6d65 6e74 0a20 2020 2020  is segment.     
+00027dc0: 2020 2020 2020 2073 5f73 6567 6d65 6e74         s_segment
+00027dd0: 203d 2061 7263 6c65 6e5b 7365 675f 656e   = arclen[seg_en
+00027de0: 642d 315d 202d 2061 7263 6c65 6e5b 7365  d-1] - arclen[se
+00027df0: 675f 7374 6172 745d 0a20 2020 2020 2020  g_start].       
+00027e00: 2020 2020 206f 6666 7365 745b 7365 675f       offset[seg_
+00027e10: 7374 6172 743a 7365 675f 656e 645d 203d  start:seg_end] =
+00027e20: 206d 6178 5f6f 6666 7365 7420 2a20 735f   max_offset * s_
+00027e30: 7365 676d 656e 742f 735f 6375 7276 655b  segment/s_curve[
+00027e40: 2d31 5d20 2a20 5c0a 2020 2020 2020 2020  -1] * \.        
+00027e50: 2020 2020 2020 2020 6e70 2e73 696e 286e          np.sin(n
+00027e60: 702e 7069 202a 2028 6172 636c 656e 5b73  p.pi * (arclen[s
+00027e70: 6567 5f73 7461 7274 3a73 6567 5f65 6e64  eg_start:seg_end
+00027e80: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00027e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00027ea0: 2020 2d20 6172 636c 656e 5b73 6567 5f73    - arclen[seg_s
+00027eb0: 7461 7274 5d29 2f73 5f73 6567 6d65 6e74  tart])/s_segment
+00027ec0: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+00027ed0: 6e20 6f66 6673 6574 0a0a 0a63 6c61 7373  n offset...class
+00027ee0: 2052 6f6f 744c 6f63 7573 5365 7269 6573   RootLocusSeries
+00027ef0: 2843 6f6e 7472 6f6c 4261 7365 5365 7269  (ControlBaseSeri
+00027f00: 6573 293a 0a20 2020 2022 2222 4765 6e65  es):.    """Gene
+00027f10: 7261 7465 7320 6e75 6d65 7269 6361 6c20  rates numerical 
+00027f20: 6461 7461 2066 6f72 2072 6f6f 7420 6c6f  data for root lo
+00027f30: 6375 7320 706c 6f74 2075 7369 6e67 2074  cus plot using t
+00027f40: 6865 2060 6063 6f6e 7472 6f6c 6060 0a20  he ``control``. 
+00027f50: 2020 206d 6f64 756c 652e 0a0a 2020 2020     module...    
+00027f60: 5379 6d62 6f6c 6963 2065 7870 7265 7373  Symbolic express
+00027f70: 696f 6e73 206f 7220 5379 6d50 7927 7320  ions or SymPy's 
+00027f80: 7472 616e 7366 6572 2066 756e 6374 696f  transfer functio
+00027f90: 6e73 2061 7265 2063 6f6e 7665 7274 6564  ns are converted
+00027fa0: 2074 6f0a 2020 2020 6060 636f 6e74 726f   to.    ``contro
+00027fb0: 6c2e 5472 616e 7366 6572 4675 6e63 7469  l.TransferFuncti
+00027fc0: 6f6e 6060 2e20 4966 2061 2069 6e74 6572  on``. If a inter
+00027fd0: 6163 7469 7665 2d77 6964 6765 7420 706c  active-widget pl
+00027fe0: 6f74 2069 7320 6372 6561 7465 642c 0a20  ot is created,. 
+00027ff0: 2020 2061 7420 6561 6368 2077 6964 6765     at each widge
+00028000: 7427 7320 7374 6174 652d 6368 616e 6765  t's state-change
+00028010: 2074 6865 2075 7064 6174 6564 2073 796d   the updated sym
+00028020: 626f 6c69 6320 7472 616e 7366 6572 2066  bolic transfer f
+00028030: 756e 6374 696f 6e0a 2020 2020 7769 6c6c  unction.    will
+00028040: 2062 6520 636f 6e76 6572 7465 6420 746f   be converted to
+00028050: 2060 6063 6f6e 7472 6f6c 2e54 7261 6e73   ``control.Trans
+00028060: 6665 7246 756e 6374 696f 6e60 602e 0a0a  ferFunction``...
+00028070: 2020 2020 4974 2068 6173 2062 6565 6e20      It has been 
+00028080: 7368 6f77 6e20 7468 6174 206e 756d 7079  shown that numpy
+00028090: 2e72 6f6f 7473 2829 2070 726f 6475 6365  .roots() produce
+000280a0: 7320 696e 6163 6375 7261 7465 2072 6573  s inaccurate res
+000280b0: 756c 7473 2069 6e0a 2020 2020 636f 6d70  ults in.    comp
+000280c0: 6172 6973 6f6e 2074 6f20 7379 6d70 792e  arison to sympy.
+000280d0: 726f 6f74 7328 292e 2068 7474 7073 3a2f  roots(). https:/
+000280e0: 2f67 6974 6875 622e 636f 6d2f 7379 6d70  /github.com/symp
+000280f0: 792f 7379 6d70 792f 6973 7375 6573 2f32  y/sympy/issues/2
+00028100: 3532 3334 0a20 2020 2048 6f77 6576 6572  5234.    However
+00028110: 2c20 7765 2061 7265 2064 6561 6c69 6e67  , we are dealing
+00028120: 2077 6974 6820 6120 726f 6f74 206c 6f63   with a root loc
+00028130: 7573 2070 6c6f 742c 2077 6865 7265 2062  us plot, where b
+00028140: 7261 6e63 6865 7320 7374 6172 7420 6672  ranches start fr
+00028150: 6f6d 0a20 2020 2070 6f6c 6573 2061 6e64  om.    poles and
+00028160: 2067 6f65 7320 746f 207a 6572 6f73 2028   goes to zeros (
+00028170: 6f72 2074 6f20 696e 6669 6e69 7479 292e  or to infinity).
+00028180: 2048 656e 6365 2c20 7468 6573 6520 6572   Hence, these er
+00028190: 726f 7273 2061 7265 0a20 2020 206c 696b  rors are.    lik
+000281a0: 656c 7920 746f 2062 6520 6972 7265 6c65  ely to be irrele
+000281b0: 7661 6e74 206f 6e20 6120 7072 6163 7469  vant on a practi
+000281c0: 6361 6c20 6361 7365 2e20 5468 6973 2064  cal case. This d
+000281d0: 6174 6120 7365 7269 6573 2075 7365 730a  ata series uses.
+000281e0: 2020 2020 6060 636f 6e74 726f 6c60 6020      ``control`` 
+000281f0: 2868 656e 6365 206e 756d 7079 2920 666f  (hence numpy) fo
+00028200: 7220 7065 7266 6f72 6d61 6365 2e0a 0a20  r performace... 
+00028210: 2020 2052 6566 6572 656e 6365 730a 2020     References.  
+00028220: 2020 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a 2020    ==========..  
+00028230: 2020 6874 7470 733a 2f2f 6769 7468 7562    https://github
+00028240: 2e63 6f6d 2f70 7974 686f 6e2d 636f 6e74  .com/python-cont
+00028250: 726f 6c2f 7079 7468 6f6e 2d63 6f6e 7472  rol/python-contr
+00028260: 6f6c 0a0a 2020 2020 2222 220a 0a20 2020  ol..    """..   
+00028270: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
+00028280: 6c66 2c20 7466 2c20 6c61 6265 6c3d 2222  lf, tf, label=""
+00028290: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
+000282a0: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
+000282b0: 6e69 745f 5f28 7466 2c20 6c61 6265 6c3d  nit__(tf, label=
+000282c0: 6c61 6265 6c2c 202a 2a6b 7761 7267 7329  label, **kwargs)
+000282d0: 0a20 2020 2020 2020 2073 656c 662e 5f63  .        self._c
+000282e0: 6865 636b 5f66 7328 290a 0a20 2020 2020  heck_fs()..     
+000282f0: 2020 2023 2063 6f6d 7075 7465 2061 7070     # compute app
+00028300: 726f 7072 6961 7465 2061 7869 7320 6c69  ropriate axis li
+00028310: 6d69 7473 2066 726f 6d20 7468 6520 7472  mits from the tr
+00028320: 616e 7366 6572 2066 756e 6374 696f 6e0a  ansfer function.
+00028330: 2020 2020 2020 2020 2320 6173 736f 6369          # associ
+00028340: 6174 6564 2074 6f20 7468 6973 2064 6174  ated to this dat
+00028350: 6120 7365 7269 6573 2e0a 2020 2020 2020  a series..      
+00028360: 2020 7365 6c66 2e5f 786c 696d 203d 204e    self._xlim = N
+00028370: 6f6e 650a 2020 2020 2020 2020 7365 6c66  one.        self
+00028380: 2e5f 796c 696d 203d 204e 6f6e 650a 2020  ._ylim = None.  
+00028390: 2020 2020 2020 2320 7a65 726f 7320 616e        # zeros an
+000283a0: 6420 706f 6c65 7320 6172 6520 6e65 6365  d poles are nece
+000283b0: 7373 6172 7920 696e 206f 7264 6572 2074  ssary in order t
+000283c0: 6f20 7368 6f77 2061 7070 726f 7072 6961  o show appropria
+000283d0: 7465 206d 6172 6b65 7273 2e0a 2020 2020  te markers..    
+000283e0: 2020 2020 7365 6c66 2e5f 7a65 726f 7320      self._zeros 
+000283f0: 3d20 4e6f 6e65 0a20 2020 2020 2020 2073  = None.        s
+00028400: 656c 662e 5f70 6f6c 6573 203d 204e 6f6e  elf._poles = Non
+00028410: 650a 0a20 2020 2020 2020 2073 656c 662e  e..        self.
+00028420: 5f63 6f6e 7472 6f6c 5f6b 775b 2270 6c6f  _control_kw["plo
+00028430: 7422 5d20 3d20 4661 6c73 650a 2020 2020  t"] = False.    
+00028440: 2020 2020 7365 6c66 2e5f 7a65 726f 735f      self._zeros_
+00028450: 726b 203d 206b 7761 7267 732e 6765 7428  rk = kwargs.get(
+00028460: 227a 6572 6f73 5f72 6b22 2c20 6469 6374  "zeros_rk", dict
+00028470: 2829 290a 2020 2020 2020 2020 7365 6c66  ()).        self
+00028480: 2e5f 706f 6c65 735f 726b 203d 206b 7761  ._poles_rk = kwa
+00028490: 7267 732e 6765 7428 2270 6f6c 6573 5f72  rgs.get("poles_r
+000284a0: 6b22 2c20 6469 6374 2829 290a 0a20 2020  k", dict())..   
+000284b0: 2064 6566 205f 5f73 7472 5f5f 2873 656c   def __str__(sel
+000284c0: 6629 3a0a 2020 2020 2020 2020 6578 7072  f):.        expr
+000284d0: 203d 2073 656c 662e 5f65 7870 7220 6966   = self._expr if
+000284e0: 2073 656c 662e 5f65 7870 7220 656c 7365   self._expr else
+000284f0: 2073 656c 662e 5f63 6f6e 7472 6f6c 5f74   self._control_t
+00028500: 660a 2020 2020 2020 2020 7265 7475 726e  f.        return
+00028510: 2022 726f 6f74 206c 6f63 7573 206f 6620   "root locus of 
+00028520: 2220 2b20 7374 7228 6578 7072 290a 0a20  " + str(expr).. 
+00028530: 2020 2064 6566 205f 636f 6d70 7574 655f     def _compute_
+00028540: 6178 6973 5f6c 696d 6974 7328 7365 6c66  axis_limits(self
+00028550: 2c20 726f 6f74 735f 6172 7261 7929 3a0a  , roots_array):.
+00028560: 2020 2020 2020 2020 2222 2241 7474 656d          """Attem
+00028570: 7074 2074 6f20 636f 6d70 7574 6520 6170  pt to compute ap
+00028580: 7072 6f70 7269 6174 6520 6178 6973 206c  propriate axis l
+00028590: 696d 6974 7320 736f 2074 6861 7420 7468  imits so that th
+000285a0: 6520 706c 6f74 0a20 2020 2020 2020 2076  e plot.        v
+000285b0: 6973 7561 6c69 7a65 7320 7468 6520 696d  isualizes the im
+000285c0: 706f 7274 616e 7420 7061 7274 7320 6f66  portant parts of
+000285d0: 2074 6865 2072 6f6f 7420 6c6f 6375 732e   the root locus.
+000285e0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+000285f0: 2020 2020 206e 7020 3d20 696d 706f 7274       np = import
+00028600: 5f6d 6f64 756c 6528 226e 756d 7079 2229  _module("numpy")
+00028610: 0a0a 2020 2020 2020 2020 7466 203d 2073  ..        tf = s
+00028620: 656c 662e 5f63 6f6e 7472 6f6c 5f74 660a  elf._control_tf.
+00028630: 2020 2020 2020 2020 5f62 7020 3d20 7365          _bp = se
+00028640: 6c66 2e5f 6272 6561 6b5f 706f 696e 7473  lf._break_points
+00028650: 280a 2020 2020 2020 2020 2020 2020 6e70  (.            np
+00028660: 2e70 6f6c 7931 6428 7466 2e6e 756d 5b30  .poly1d(tf.num[0
+00028670: 5d5b 305d 292c 0a20 2020 2020 2020 2020  ][0]),.         
+00028680: 2020 206e 702e 706f 6c79 3164 2874 662e     np.poly1d(tf.
+00028690: 6465 6e5b 305d 5b30 5d29 0a20 2020 2020  den[0][0]).     
+000286a0: 2020 2029 5b31 5d0a 0a20 2020 2020 2020     )[1]..       
+000286b0: 2023 2072 6f6f 7420 6c6f 6375 7320 6272   # root locus br
+000286c0: 616e 6368 6573 2073 7461 7274 7320 6672  anches starts fr
+000286d0: 6f6d 2070 6f6c 6573 2061 6e64 2067 6f65  om poles and goe
+000286e0: 7320 746f 207a 6572 6f73 206f 720a 2020  s to zeros or.  
+000286f0: 2020 2020 2020 2320 696e 6669 6e69 7479        # infinity
+00028700: 2e20 4c6f 6f6b 2066 6f72 2074 6865 2062  . Look for the b
+00028710: 7261 6e63 6865 7320 7468 6174 2067 6f65  ranches that goe
+00028720: 7320 746f 207a 6572 6f73 2c20 6669 6e64  s to zeros, find
+00028730: 2074 6865 0a20 2020 2020 2020 2023 206d   the.        # m
+00028740: 6178 696d 756d 2069 6d61 6769 6e61 7279  aximum imaginary
+00028750: 2070 6172 742e 2054 6869 7320 7769 6c6c   part. This will
+00028760: 2062 6520 7573 6564 2074 6f20 636f 6d70   be used to comp
+00028770: 7574 6520 796c 696d 2e0a 2020 2020 2020  ute ylim..      
+00028780: 2020 6d61 785f 6865 6967 6874 7320 3d20    max_heights = 
+00028790: 5b5d 0a20 2020 2020 2020 2066 6f72 2070  [].        for p
+000287a0: 2069 6e20 7365 6c66 2e5f 706f 6c65 733a   in self._poles:
+000287b0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+000287c0: 2063 2069 6e20 726f 6f74 735f 6172 7261   c in roots_arra
+000287d0: 792e 543a 0a20 2020 2020 2020 2020 2020  y.T:.           
+000287e0: 2020 2020 2069 6620 6162 7328 7020 2d20       if abs(p - 
+000287f0: 635b 305d 2920 3c20 3165 2d30 333a 0a20  c[0]) < 1e-03:. 
+00028800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028810: 2020 2069 6620 616e 7928 6162 7328 7a20     if any(abs(z 
+00028820: 2d20 635b 2d31 5d29 203c 2031 652d 3033  - c[-1]) < 1e-03
+00028830: 2066 6f72 207a 2069 6e20 7365 6c66 2e5f   for z in self._
+00028840: 7a65 726f 7329 3a0a 2020 2020 2020 2020  zeros):.        
+00028850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028860: 6920 3d20 6e70 2e61 7267 6d61 7828 6e70  i = np.argmax(np
+00028870: 2e61 6273 2863 2e69 6d61 6729 290a 2020  .abs(c.imag)).  
+00028880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028890: 2020 2020 2020 6d61 785f 6865 6967 6874        max_height
+000288a0: 732e 6170 7065 6e64 2863 5b69 5d29 0a20  s.append(c[i]). 
+000288b0: 2020 2020 2020 206d 696e 5f68 6569 6768         min_heigh
+000288c0: 7473 203d 205b 2d74 2066 6f72 2074 2069  ts = [-t for t i
+000288d0: 6e20 6d61 785f 6865 6967 6874 735d 0a0a  n max_heights]..
+000288e0: 2020 2020 2020 2020 6465 6620 5f68 656c          def _hel
+000288f0: 7065 7228 782c 206d 6172 6769 6e5f 6661  per(x, margin_fa
+00028900: 6374 6f72 5f6c 6f77 6572 2c20 6d61 7267  ctor_lower, marg
+00028910: 696e 5f66 6163 746f 725f 7570 7065 7229  in_factor_upper)
+00028920: 3a0a 2020 2020 2020 2020 2020 2020 6d69  :.            mi
+00028930: 6e5f 782c 206d 6178 5f78 203d 206e 702e  n_x, max_x = np.
+00028940: 6e61 6e6d 696e 2878 292c 206e 702e 6e61  nanmin(x), np.na
+00028950: 6e6d 6178 2878 290a 2020 2020 2020 2020  nmax(x).        
+00028960: 2020 2020 2320 7468 6973 206f 6666 7365      # this offse
+00028970: 7420 616c 6c6f 7773 2074 6f20 6861 7665  t allows to have
+00028980: 2061 206c 6974 746c 6520 6269 7420 6f66   a little bit of
+00028990: 2065 6d70 7479 2073 7061 6365 206f 6e20   empty space on 
+000289a0: 7468 650a 2020 2020 2020 2020 2020 2020  the.            
+000289b0: 2320 4c48 5020 6f66 2072 6f6f 7420 6c6f  # LHP of root lo
+000289c0: 6375 7320 706c 6f74 0a20 2020 2020 2020  cus plot.       
+000289d0: 2020 2020 206f 6666 7365 7420 3d20 302e       offset = 0.
+000289e0: 3235 0a20 2020 2020 2020 2020 2020 206d  25.            m
+000289f0: 696e 5f78 203d 206d 696e 5f78 202d 206f  in_x = min_x - o
+00028a00: 6666 7365 7420 6966 206e 702e 6973 636c  ffset if np.iscl
+00028a10: 6f73 6528 6d69 6e5f 782c 2030 2920 656c  ose(min_x, 0) el
+00028a20: 7365 206d 696e 5f78 0a20 2020 2020 2020  se min_x.       
+00028a30: 2020 2020 206d 6178 5f78 203d 206d 6178       max_x = max
+00028a40: 5f78 202b 206f 6666 7365 7420 6966 206e  _x + offset if n
+00028a50: 702e 6973 636c 6f73 6528 6d61 785f 782c  p.isclose(max_x,
+00028a60: 2030 2920 656c 7365 206d 6178 5f78 0a20   0) else max_x. 
+00028a70: 2020 2020 2020 2020 2020 2023 2070 726f             # pro
+00028a80: 7669 6465 2061 206c 6974 746c 6520 6269  vide a little bi
+00028a90: 7420 6f66 206d 6172 6769 6e0a 2020 2020  t of margin.    
+00028aa0: 2020 2020 2020 2020 6465 6c74 6120 3d20          delta = 
+00028ab0: 6162 7328 6d61 785f 7820 2d20 6d69 6e5f  abs(max_x - min_
+00028ac0: 7829 0a20 2020 2020 2020 2020 2020 206c  x).            l
+00028ad0: 696d 203d 205b 6d69 6e5f 7820 2d20 6465  im = [min_x - de
+00028ae0: 6c74 6120 2a20 6d61 7267 696e 5f66 6163  lta * margin_fac
+00028af0: 746f 725f 6c6f 7765 722c 206d 6178 5f78  tor_lower, max_x
+00028b00: 202b 2064 656c 7461 202a 206d 6172 6769   + delta * margi
+00028b10: 6e5f 6661 6374 6f72 5f75 7070 6572 5d0a  n_factor_upper].
+00028b20: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00028b30: 702e 6973 636c 6f73 6528 2a6c 696d 293a  p.isclose(*lim):
+00028b40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00028b50: 2023 2070 7265 7665 6e74 2061 7869 7320   # prevent axis 
+00028b60: 6c69 6d69 7473 2074 6f20 6265 2074 6865  limits to be the
+00028b70: 2073 616d 650a 2020 2020 2020 2020 2020   same.          
+00028b80: 2020 2020 2020 6c69 6d5b 305d 202d 3d20        lim[0] -= 
+00028b90: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
+00028ba0: 2020 6c69 6d5b 315d 202b 3d20 310a 2020    lim[1] += 1.  
+00028bb0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00028bc0: 206c 696d 0a0a 2020 2020 2020 2020 696d   lim..        im
+00028bd0: 706f 7274 616e 745f 706f 696e 7473 203d  portant_points =
+00028be0: 206e 702e 636f 6e63 6174 656e 6174 6528   np.concatenate(
+00028bf0: 0a20 2020 2020 2020 2020 2020 205b 7365  .            [se
+00028c00: 6c66 2e5f 7a65 726f 732c 2073 656c 662e  lf._zeros, self.
+00028c10: 5f70 6f6c 6573 2c20 5f62 702c 206d 6178  _poles, _bp, max
+00028c20: 5f68 6569 6768 7473 2c20 6d69 6e5f 6865  _heights, min_he
+00028c30: 6967 6874 735d 290a 2020 2020 2020 2020  ights]).        
+00028c40: 7365 6c66 2e5f 786c 696d 203d 205f 6865  self._xlim = _he
+00028c50: 6c70 6572 2869 6d70 6f72 7461 6e74 5f70  lper(important_p
+00028c60: 6f69 6e74 732e 7265 616c 2c20 302e 3135  oints.real, 0.15
+00028c70: 2c20 302e 3035 290a 2020 2020 2020 2020  , 0.05).        
+00028c80: 7365 6c66 2e5f 796c 696d 203d 205f 6865  self._ylim = _he
+00028c90: 6c70 6572 2869 6d70 6f72 7461 6e74 5f70  lper(important_p
+00028ca0: 6f69 6e74 732e 696d 6167 2c20 302e 3035  oints.imag, 0.05
+00028cb0: 2c20 302e 3035 290a 0a20 2020 2040 7072  , 0.05)..    @pr
+00028cc0: 6f70 6572 7479 0a20 2020 2064 6566 207a  operty.    def z
+00028cd0: 6572 6f73 2873 656c 6629 3a0a 2020 2020  eros(self):.    
+00028ce0: 2020 2020 6966 2073 656c 662e 5f7a 6572      if self._zer
+00028cf0: 6f73 2069 7320 4e6f 6e65 3a0a 2020 2020  os is None:.    
+00028d00: 2020 2020 2020 2020 7365 6c66 2e67 6574          self.get
+00028d10: 5f64 6174 6128 290a 2020 2020 2020 2020  _data().        
+00028d20: 7265 7475 726e 2073 656c 662e 5f7a 6572  return self._zer
+00028d30: 6f73 0a0a 2020 2020 4070 726f 7065 7274  os..    @propert
+00028d40: 790a 2020 2020 6465 6620 706f 6c65 7328  y.    def poles(
+00028d50: 7365 6c66 293a 0a20 2020 2020 2020 2069  self):.        i
+00028d60: 6620 7365 6c66 2e5f 706f 6c65 7320 6973  f self._poles is
+00028d70: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00028d80: 2020 2073 656c 662e 6765 745f 6461 7461     self.get_data
+00028d90: 2829 0a20 2020 2020 2020 2072 6574 7572  ().        retur
+00028da0: 6e20 7365 6c66 2e5f 706f 6c65 730a 0a20  n self._poles.. 
+00028db0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00028dc0: 2064 6566 2078 6c69 6d28 7365 6c66 293a   def xlim(self):
+00028dd0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00028de0: 7365 6c66 2e5f 786c 696d 0a0a 2020 2020  self._xlim..    
+00028df0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+00028e00: 6620 796c 696d 2873 656c 6629 3a0a 2020  f ylim(self):.  
+00028e10: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00028e20: 662e 5f79 6c69 6d0a 0a20 2020 2064 6566  f._ylim..    def
+00028e30: 205f 6272 6561 6b5f 706f 696e 7473 2873   _break_points(s
+00028e40: 656c 662c 206e 756d 2c20 6465 6e29 3a0a  elf, num, den):.
+00028e50: 2020 2020 2020 2020 2222 2245 7874 7261          """Extra
+00028e60: 6374 2062 7265 616b 2070 6f69 6e74 7320  ct break points 
+00028e70: 6f76 6572 2072 6561 6c20 6178 6973 2061  over real axis a
+00028e80: 6e64 2067 6169 6e73 2067 6976 656e 2074  nd gains given t
+00028e90: 6865 7365 206c 6f63 6174 696f 6e73 2222  hese locations""
+00028ea0: 220a 2020 2020 2020 2020 2320 7479 7065  ".        # type
+00028eb0: 3a20 286e 702e 706f 6c79 3164 2c20 6e70  : (np.poly1d, np
+00028ec0: 2e70 6f6c 7931 6429 202d 3e20 286e 702e  .poly1d) -> (np.
+00028ed0: 6172 7261 792c 206e 702e 6172 7261 7929  array, np.array)
+00028ee0: 0a20 2020 2020 2020 2064 6e75 6d20 3d20  .        dnum = 
+00028ef0: 6e75 6d2e 6465 7269 7628 6d3d 3129 0a20  num.deriv(m=1). 
+00028f00: 2020 2020 2020 2064 6465 6e20 3d20 6465         dden = de
+00028f10: 6e2e 6465 7269 7628 6d3d 3129 0a20 2020  n.deriv(m=1).   
+00028f20: 2020 2020 2070 6f6c 796e 6f6d 203d 2064       polynom = d
+00028f30: 656e 202a 2064 6e75 6d20 2d20 6e75 6d20  en * dnum - num 
+00028f40: 2a20 6464 656e 0a20 2020 2020 2020 2072  * dden.        r
+00028f50: 6561 6c5f 6272 6561 6b5f 7074 7320 3d20  eal_break_pts = 
+00028f60: 706f 6c79 6e6f 6d2e 720a 2020 2020 2020  polynom.r.      
+00028f70: 2020 2320 646f 6e27 7420 6361 7265 2061    # don't care a
+00028f80: 626f 7574 2069 6e66 696e 6974 6520 6272  bout infinite br
+00028f90: 6561 6b20 706f 696e 7473 0a20 2020 2020  eak points.     
+00028fa0: 2020 2072 6561 6c5f 6272 6561 6b5f 7074     real_break_pt
+00028fb0: 7320 3d20 7265 616c 5f62 7265 616b 5f70  s = real_break_p
+00028fc0: 7473 5b6e 756d 2872 6561 6c5f 6272 6561  ts[num(real_brea
+00028fd0: 6b5f 7074 7329 2021 3d20 305d 0a20 2020  k_pts) != 0].   
+00028fe0: 2020 2020 206b 5f62 7265 616b 203d 202d       k_break = -
+00028ff0: 6465 6e28 7265 616c 5f62 7265 616b 5f70  den(real_break_p
+00029000: 7473 2920 2f20 6e75 6d28 7265 616c 5f62  ts) / num(real_b
+00029010: 7265 616b 5f70 7473 290a 2020 2020 2020  reak_pts).      
+00029020: 2020 6964 7820 3d20 6b5f 6272 6561 6b20    idx = k_break 
+00029030: 3e3d 2069 6e74 2830 2920 2020 2320 6f6e  >= int(0)   # on
+00029040: 6c79 2070 6f73 6974 6976 6573 2067 6169  ly positives gai
+00029050: 6e73 0a20 2020 2020 2020 206b 5f62 7265  ns.        k_bre
+00029060: 616b 203d 206b 5f62 7265 616b 5b69 6478  ak = k_break[idx
+00029070: 5d0a 2020 2020 2020 2020 7265 616c 5f62  ].        real_b
+00029080: 7265 616b 5f70 7473 203d 2072 6561 6c5f  reak_pts = real_
+00029090: 6272 6561 6b5f 7074 735b 6964 785d 0a20  break_pts[idx]. 
+000290a0: 2020 2020 2020 2069 6620 6c65 6e28 6b5f         if len(k_
+000290b0: 6272 6561 6b29 203d 3d20 303a 0a20 2020  break) == 0:.   
+000290c0: 2020 2020 2020 2020 206b 5f62 7265 616b           k_break
+000290d0: 203d 205b 305d 0a20 2020 2020 2020 2020   = [0].         
+000290e0: 2020 2072 6561 6c5f 6272 6561 6b5f 7074     real_break_pt
+000290f0: 7320 3d20 6465 6e2e 726f 6f74 730a 2020  s = den.roots.  
+00029100: 2020 2020 2020 7265 7475 726e 206b 5f62        return k_b
+00029110: 7265 616b 2c20 7265 616c 5f62 7265 616b  reak, real_break
+00029120: 5f70 7473 0a0a 2020 2020 6465 6620 6765  _pts..    def ge
+00029130: 745f 6461 7461 2873 656c 6629 3a0a 2020  t_data(self):.  
+00029140: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00029150: 2020 5265 7475 726e 730a 2020 2020 2020    Returns.      
+00029160: 2020 3d3d 3d3d 3d3d 3d0a 2020 2020 2020    =======.      
+00029170: 2020 726f 6f74 7320 3a20 6e64 6172 7261    roots : ndarra
+00029180: 790a 2020 2020 2020 2020 2020 2020 436c  y.            Cl
+00029190: 6f73 6564 2d6c 6f6f 7020 726f 6f74 206c  osed-loop root l
+000291a0: 6f63 6174 696f 6e73 2c20 6172 7261 6e67  ocations, arrang
+000291b0: 6564 2069 6e20 7768 6963 6820 6561 6368  ed in which each
+000291c0: 2072 6f77 2063 6f72 7265 7370 6f6e 6473   row corresponds
+000291d0: 0a20 2020 2020 2020 2020 2020 2074 6f20  .            to 
+000291e0: 6120 6761 696e 2069 6e20 6761 696e 730a  a gain in gains.
+000291f0: 2020 2020 2020 2020 6761 696e 7320 3a20          gains : 
+00029200: 6e64 6172 7261 790a 2020 2020 2020 2020  ndarray.        
+00029210: 2020 2020 4761 696e 7320 7573 6564 2e20      Gains used. 
+00029220: 2053 616d 6520 6173 206b 7665 6374 206b   Same as kvect k
+00029230: 6579 776f 7264 2061 7267 756d 656e 7420  eyword argument 
+00029240: 6966 2070 726f 7669 6465 642e 0a20 2020  if provided..   
+00029250: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00029260: 2069 6620 7365 6c66 2e69 735f 696e 7465   if self.is_inte
+00029270: 7261 6374 6976 653a 0a20 2020 2020 2020  ractive:.       
+00029280: 2020 2020 2074 6620 3d20 7365 6c66 2e5f       tf = self._
+00029290: 6578 7072 2e73 7562 7328 7365 6c66 2e70  expr.subs(self.p
+000292a0: 6172 616d 7329 0a20 2020 2020 2020 2020  arams).         
+000292b0: 2020 2073 656c 662e 5f63 6f6e 7472 6f6c     self._control
+000292c0: 5f74 6620 3d20 7466 5f74 6f5f 636f 6e74  _tf = tf_to_cont
+000292d0: 726f 6c28 7466 290a 0a20 2020 2020 2020  rol(tf)..       
+000292e0: 2063 7420 3d20 696d 706f 7274 5f6d 6f64   ct = import_mod
+000292f0: 756c 6528 2263 6f6e 7472 6f6c 2229 0a20  ule("control"). 
+00029300: 2020 2020 2020 2073 656c 662e 5f7a 6572         self._zer
+00029310: 6f73 203d 2073 656c 662e 5f63 6f6e 7472  os = self._contr
+00029320: 6f6c 5f74 662e 7a65 726f 7328 290a 2020  ol_tf.zeros().  
+00029330: 2020 2020 2020 7365 6c66 2e5f 706f 6c65        self._pole
+00029340: 7320 3d20 7365 6c66 2e5f 636f 6e74 726f  s = self._contro
+00029350: 6c5f 7466 2e70 6f6c 6573 2829 0a20 2020  l_tf.poles().   
+00029360: 2020 2020 2072 6f6f 7473 5f61 7272 6179       roots_array
+00029370: 2c20 6761 696e 7320 3d20 6374 2e72 6f6f  , gains = ct.roo
+00029380: 745f 6c6f 6375 7328 7365 6c66 2e5f 636f  t_locus(self._co
+00029390: 6e74 726f 6c5f 7466 2c20 2a2a 7365 6c66  ntrol_tf, **self
+000293a0: 2e5f 636f 6e74 726f 6c5f 6b77 290a 2020  ._control_kw).  
+000293b0: 2020 2020 2020 7365 6c66 2e5f 636f 6d70        self._comp
+000293c0: 7574 655f 6178 6973 5f6c 696d 6974 7328  ute_axis_limits(
+000293d0: 726f 6f74 735f 6172 7261 7929 0a20 2020  roots_array).   
+000293e0: 2020 2020 2072 6574 7572 6e20 726f 6f74       return root
+000293f0: 735f 6172 7261 792c 2067 6169 6e73 0a0a  s_array, gains..
+00029400: 0a63 6c61 7373 2053 7973 7465 6d52 6573  .class SystemRes
+00029410: 706f 6e73 6553 6572 6965 7328 436f 6e74  ponseSeries(Cont
+00029420: 726f 6c42 6173 6553 6572 6965 7329 3a0a  rolBaseSeries):.
+00029430: 2020 2020 2222 2252 6570 7265 7365 6e74      """Represent
+00029440: 2061 2073 7973 7465 6d20 7265 7370 6f6e   a system respon
+00029450: 7365 2063 6f6d 7075 7465 6420 7769 7468  se computed with
+00029460: 2074 6865 2060 6063 6f6e 7472 6f6c 6060   the ``control``
+00029470: 206d 6f64 756c 652e 0a0a 2020 2020 436f   module...    Co
+00029480: 6d70 7574 696e 6720 7468 6520 696e 7665  mputing the inve
+00029490: 7273 6520 6c61 706c 6163 6520 7472 616e  rse laplace tran
+000294a0: 7366 6f72 6d20 6f66 2061 2073 7973 7465  sform of a syste
+000294b0: 6d20 7769 7468 2053 796d 5079 2069 7320  m with SymPy is 
+000294c0: 6e6f 740a 2020 2020 7472 6976 6961 6c3a  not.    trivial:
+000294d0: 2073 6f6d 6574 696d 6573 2069 7420 776f   sometimes it wo
+000294e0: 726b 7320 6669 6e65 2c20 6f74 6865 7220  rks fine, other 
+000294f0: 7469 6d65 7320 6974 2070 726f 6475 6365  times it produce
+00029500: 7320 7772 6f6e 6720 7265 7375 6c74 732c  s wrong results,
+00029510: 0a20 2020 206f 7468 6572 2074 696d 6573  .    other times
+00029520: 2069 7420 6a75 7374 2063 6f6e 7375 6d65   it just consume
+00029530: 7320 746f 206d 7563 6820 6d65 6d6f 7279  s to much memory
+00029540: 2065 7665 6e20 666f 7220 7472 6976 6961   even for trivia
+00029550: 6c20 7472 616e 7366 6572 0a20 2020 2066  l transfer.    f
+00029560: 756e 6374 696f 6e73 2e20 5468 6973 2069  unctions. This i
+00029570: 7320 7472 7565 2066 6f72 2062 6f74 6820  s true for both 
+00029580: 7468 6520 7075 626c 6963 2060 6069 6e76  the public ``inv
+00029590: 6572 7365 5f6c 6170 6c61 6365 5f74 7261  erse_laplace_tra
+000295a0: 6e73 666f 726d 6060 0a20 2020 2061 7320  nsform``.    as 
+000295b0: 7765 6c6c 2061 7320 7468 6520 7072 6976  well as the priv
+000295c0: 6174 6520 6060 5f66 6173 745f 696e 7665  ate ``_fast_inve
+000295d0: 7273 655f 6c61 706c 6163 6560 6020 7573  rse_laplace`` us
+000295e0: 6564 2069 6e0a 2020 2020 6060 7370 622e  ed in.    ``spb.
+000295f0: 6772 6170 6869 6373 2e63 6f6e 7472 6f6c  graphics.control
+00029600: 6060 2e0a 0a20 2020 2049 6e20 6f72 6465  ``...    In orde
+00029610: 7220 746f 2061 6464 7265 7373 2074 6865  r to address the
+00029620: 7365 2069 7373 7565 732c 206c 6574 2773  se issues, let's
+00029630: 2065 7661 6c75 6174 6520 7468 6520 7379   evaluate the sy
+00029640: 7374 656d 2077 6974 6820 7468 650a 2020  stem with the.  
+00029650: 2020 6060 636f 6e74 726f 6c60 6020 6d6f    ``control`` mo
+00029660: 6475 6c65 2e20 5375 7265 2c20 6974 2072  dule. Sure, it r
+00029670: 656c 6965 7320 6f6e 206e 756d 6572 6963  elies on numeric
+00029680: 616c 2069 6e74 6567 7261 7469 6f6e 2c20  al integration, 
+00029690: 6865 6e63 6520 6572 726f 7273 2e0a 2020  hence errors..  
+000296a0: 2020 4275 742c 2061 7420 6c65 6173 7420    But, at least 
+000296b0: 6974 2064 6f65 736e 2774 2063 7261 7368  it doesn't crash
+000296c0: 2074 6865 206d 6163 6869 6e65 2061 6e64   the machine and
+000296d0: 2069 7420 6973 2072 656c 6961 626c 652e   it is reliable.
+000296e0: 0a20 2020 2022 2222 0a0a 2020 2020 6465  .    """..    de
+000296f0: 6620 5f5f 6e65 775f 5f28 636c 732c 202a  f __new__(cls, *
+00029700: 6172 6773 2c20 2a2a 6b77 6172 6773 293a  args, **kwargs):
+00029710: 0a20 2020 2020 2020 2063 6620 3d20 6b77  .        cf = kw
+00029720: 6172 6773 2e67 6574 2822 636f 6c6f 725f  args.get("color_
+00029730: 6675 6e63 222c 204e 6f6e 6529 0a20 2020  func", None).   
+00029740: 2020 2020 206c 6320 3d20 6b77 6172 6773       lc = kwargs
+00029750: 2e67 6574 2822 6c69 6e65 5f63 6f6c 6f72  .get("line_color
+00029760: 222c 204e 6f6e 6529 0a20 2020 2020 2020  ", None).       
+00029770: 2069 6620 2863 616c 6c61 626c 6528 6366   if (callable(cf
+00029780: 2920 6f72 2063 616c 6c61 626c 6528 6c63  ) or callable(lc
+00029790: 2920 6f72 2069 7369 6e73 7461 6e63 6528  ) or isinstance(
+000297a0: 6366 2c20 4578 7072 2929 3a0a 2020 2020  cf, Expr)):.    
+000297b0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+000297c0: 7570 6572 2829 2e5f 5f6e 6577 5f5f 2843  uper().__new__(C
+000297d0: 6f6c 6f72 6564 5379 7374 656d 5265 7370  oloredSystemResp
+000297e0: 6f6e 7365 5365 7269 6573 290a 2020 2020  onseSeries).    
+000297f0: 2020 2020 7265 7475 726e 206f 626a 6563      return objec
+00029800: 742e 5f5f 6e65 775f 5f28 636c 7329 0a0a  t.__new__(cls)..
+00029810: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+00029820: 2873 656c 662c 2074 662c 2076 6172 5f73  (self, tf, var_s
+00029830: 7461 7274 5f65 6e64 2c20 6c61 6265 6c3d  tart_end, label=
+00029840: 2222 2c20 2a2a 6b77 6172 6773 293a 0a20  "", **kwargs):. 
+00029850: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+00029860: 5f69 6e69 745f 5f28 7466 2c20 6c61 6265  _init__(tf, labe
+00029870: 6c3d 6c61 6265 6c2c 202a 2a6b 7761 7267  l=label, **kwarg
+00029880: 7329 0a20 2020 2020 2020 2073 656c 662e  s).        self.
+00029890: 7261 6e67 6573 203d 205b 7661 725f 7374  ranges = [var_st
+000298a0: 6172 745f 656e 645d 0a20 2020 2020 2020  art_end].       
+000298b0: 2073 656c 662e 5f63 6865 636b 5f66 7328   self._check_fs(
+000298c0: 290a 2020 2020 2020 2020 2320 6469 7363  ).        # disc
+000298d0: 7265 7469 7a65 2074 6865 2064 6f6d 6169  retize the domai
+000298e0: 6e20 7573 696e 6720 6f6e 6c79 2069 6e74  n using only int
+000298f0: 6567 6572 206e 756d 6265 7273 0a20 2020  eger numbers.   
+00029900: 2020 2020 2073 656c 662e 6f6e 6c79 5f69       self.only_i
+00029910: 6e74 6567 6572 7320 3d20 6b77 6172 6773  ntegers = kwargs
+00029920: 2e67 6574 2822 6f6e 6c79 5f69 6e74 6567  .get("only_integ
+00029930: 6572 7322 2c20 4661 6c73 6529 0a0a 2020  ers", False)..  
+00029940: 2020 2020 2020 7274 203d 206b 7761 7267        rt = kwarg
+00029950: 732e 6765 7428 2272 6573 706f 6e73 655f  s.get("response_
+00029960: 7479 7065 222c 2022 7374 6570 2229 0a20  type", "step"). 
+00029970: 2020 2020 2020 2072 7420 3d20 7274 2e6c         rt = rt.l
+00029980: 6f77 6572 2829 2069 6620 6973 696e 7374  ower() if isinst
+00029990: 616e 6365 2872 742c 2073 7472 2920 656c  ance(rt, str) el
+000299a0: 7365 2072 740a 2020 2020 2020 2020 616c  se rt.        al
+000299b0: 6c6f 7765 645f 7265 7370 6f6e 7365 5f74  lowed_response_t
+000299c0: 7970 6573 203d 205b 2269 6d70 756c 7365  ypes = ["impulse
+000299d0: 222c 2022 7374 6570 222c 2022 7261 6d70  ", "step", "ramp
+000299e0: 225d 0a20 2020 2020 2020 2069 6620 286e  "].        if (n
+000299f0: 6f74 2069 7369 6e73 7461 6e63 6528 7274  ot isinstance(rt
+00029a00: 2c20 7374 7229 2920 6f72 2028 7274 206e  , str)) or (rt n
+00029a10: 6f74 2069 6e20 616c 6c6f 7765 645f 7265  ot in allowed_re
+00029a20: 7370 6f6e 7365 5f74 7970 6573 293a 0a20  sponse_types):. 
+00029a30: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00029a40: 2056 616c 7565 4572 726f 7228 0a20 2020   ValueError(.   
+00029a50: 2020 2020 2020 2020 2020 2020 2022 6060               "``
+00029a60: 7265 7370 6f6e 7365 5f74 7970 6560 6020  response_type`` 
+00029a70: 6d75 7374 2062 6520 6f6e 6520 6f66 2074  must be one of t
+00029a80: 6865 2066 6f6c 6c6f 7769 6e67 3a20 2573  he following: %s
+00029a90: 5c6e 220a 2020 2020 2020 2020 2020 2020  \n".            
+00029aa0: 2020 2020 2252 6563 6569 7665 643a 2025      "Received: %
+00029ab0: 7322 2025 2028 7274 2c20 616c 6c6f 7765  s" % (rt, allowe
+00029ac0: 645f 7265 7370 6f6e 7365 5f74 7970 6573  d_response_types
+00029ad0: 290a 2020 2020 2020 2020 2020 2020 290a  ).            ).
+00029ae0: 2020 2020 2020 2020 7365 6c66 2e5f 7265          self._re
+00029af0: 7370 6f6e 7365 5f74 7970 6520 3d20 7274  sponse_type = rt
+00029b00: 0a0a 2020 2020 2020 2020 7374 6570 7320  ..        steps 
+00029b10: 3d20 6b77 6172 6773 2e67 6574 2822 7374  = kwargs.get("st
+00029b20: 6570 7322 2c20 4e6f 6e65 290a 2020 2020  eps", None).    
+00029b30: 2020 2020 6966 2073 7465 7073 2069 7320      if steps is 
+00029b40: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00029b50: 2020 6966 2073 656c 662e 5f65 7870 7220    if self._expr 
+00029b60: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+00029b70: 2020 2020 2020 2020 2073 656c 662e 7374           self.st
+00029b80: 6570 7320 3d20 7365 6c66 2e5f 636f 6e74  eps = self._cont
+00029b90: 726f 6c5f 7466 2e69 7364 7469 6d65 2829  rol_tf.isdtime()
+00029ba0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+00029bb0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00029bc0: 2020 2073 656c 662e 7374 6570 7320 3d20     self.steps = 
+00029bd0: 4661 6c73 650a 2020 2020 2020 2020 656c  False.        el
+00029be0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00029bf0: 7365 6c66 2e73 7465 7073 203d 2073 7465  self.steps = ste
+00029c00: 7073 0a20 2020 2020 2020 2023 2074 696d  ps.        # tim
+00029c10: 6520 7661 6c75 6573 206f 7665 7220 7768  e values over wh
+00029c20: 6963 6820 7468 6520 6576 616c 7561 7469  ich the evaluati
+00029c30: 6f6e 2077 696c 6c20 6265 2070 6572 666f  on will be perfo
+00029c40: 726d 6564 0a20 2020 2020 2020 2073 656c  rmed.        sel
+00029c50: 662e 5f74 696d 655f 6172 7261 7920 3d20  f._time_array = 
+00029c60: 4e6f 6e65 0a0a 2020 2020 6465 6620 5f5f  None..    def __
+00029c70: 7374 725f 5f28 7365 6c66 293a 0a20 2020  str__(self):.   
+00029c80: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00029c90: 2e5f 7374 725f 6865 6c70 6572 280a 2020  ._str_helper(.  
+00029ca0: 2020 2020 2020 2020 2020 2225 7320 7265            "%s re
+00029cb0: 7370 6f6e 7365 206f 6620 2573 2220 2520  sponse of %s" % 
+00029cc0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00029cd0: 2020 7365 6c66 2e5f 7265 7370 6f6e 7365    self._response
+00029ce0: 5f74 7970 652c 0a20 2020 2020 2020 2020  _type,.         
+00029cf0: 2020 2020 2020 2073 656c 662e 5f65 7870         self._exp
+00029d00: 7220 6966 2073 656c 662e 5f65 7870 7220  r if self._expr 
+00029d10: 656c 7365 2073 656c 662e 5f63 6f6e 7472  else self._contr
+00029d20: 6f6c 5f74 6629 290a 0a20 2020 2064 6566  ol_tf))..    def
+00029d30: 205f 6765 745f 6461 7461 5f68 656c 7065   _get_data_helpe
+00029d40: 7228 7365 6c66 293a 0a20 2020 2020 2020  r(self):.       
+00029d50: 2063 7420 3d20 696d 706f 7274 5f6d 6f64   ct = import_mod
+00029d60: 756c 6528 2263 6f6e 7472 6f6c 2229 0a20  ule("control"). 
+00029d70: 2020 2020 2020 206e 7020 3d20 696d 706f         np = impo
+00029d80: 7274 5f6d 6f64 756c 6528 226e 756d 7079  rt_module("numpy
+00029d90: 2229 0a20 2020 2020 2020 206d 6572 6765  ").        merge
+00029da0: 6465 6570 203d 2069 6d70 6f72 745f 6d6f  deep = import_mo
+00029db0: 6475 6c65 2827 6d65 7267 6564 6565 7027  dule('mergedeep'
+00029dc0: 290a 0a20 2020 2020 2020 2069 6620 7365  )..        if se
+00029dd0: 6c66 2e69 735f 696e 7465 7261 6374 6976  lf.is_interactiv
+00029de0: 653a 0a20 2020 2020 2020 2020 2020 2074  e:.            t
+00029df0: 6620 3d20 7365 6c66 2e5f 6578 7072 2e73  f = self._expr.s
+00029e00: 7562 7328 7365 6c66 2e70 6172 616d 7329  ubs(self.params)
+00029e10: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00029e20: 662e 5f63 6f6e 7472 6f6c 5f74 6620 3d20  f._control_tf = 
+00029e30: 7466 5f74 6f5f 636f 6e74 726f 6c28 7466  tf_to_control(tf
+00029e40: 290a 0a20 2020 2020 2020 2023 2063 7265  )..        # cre
+00029e50: 6174 6520 286f 7220 7570 6461 7465 2920  ate (or update) 
+00029e60: 7468 6520 6469 7363 7265 7469 7a65 6420  the discretized 
+00029e70: 646f 6d61 696e 0a20 2020 2020 2020 205f  domain.        _
+00029e80: 2c20 7374 6172 742c 2065 6e64 203d 2073  , start, end = s
+00029e90: 656c 662e 7261 6e67 6573 5b30 5d0a 2020  elf.ranges[0].  
+00029ea0: 2020 2020 2020 6966 2073 656c 662e 5f69        if self._i
+00029eb0: 6e74 6572 6163 7469 7665 5f72 616e 6765  nteractive_range
+00029ec0: 733a 0a20 2020 2020 2020 2020 2020 2073  s:.            s
+00029ed0: 7461 7274 203d 2073 656c 662e 5f75 7064  tart = self._upd
+00029ee0: 6174 655f 7261 6e67 655f 7661 6c75 6528  ate_range_value(
+00029ef0: 7374 6172 7429 2e72 6561 6c0a 2020 2020  start).real.    
+00029f00: 2020 2020 2020 2020 656e 6420 3d20 7365          end = se
+00029f10: 6c66 2e5f 7570 6461 7465 5f72 616e 6765  lf._update_range
+00029f20: 5f76 616c 7565 2865 6e64 292e 7265 616c  _value(end).real
+00029f30: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00029f40: 2020 2020 2020 2020 2020 2073 7461 7274             start
+00029f50: 2c20 656e 6420 3d20 666c 6f61 7428 7374  , end = float(st
+00029f60: 6172 7429 2c20 666c 6f61 7428 656e 6429  art), float(end)
+00029f70: 0a0a 2020 2020 2020 2020 6966 2028 7365  ..        if (se
+00029f80: 6c66 2e5f 7469 6d65 5f61 7272 6179 2069  lf._time_array i
+00029f90: 7320 4e6f 6e65 2920 6f72 2073 656c 662e  s None) or self.
+00029fa0: 5f69 6e74 6572 6163 7469 7665 5f72 616e  _interactive_ran
+00029fb0: 6765 733a 0a20 2020 2020 2020 2020 2020  ges:.           
+00029fc0: 2069 6620 6e6f 7420 7365 6c66 2e5f 636f   if not self._co
+00029fd0: 6e74 726f 6c5f 7466 2e69 7364 7469 6d65  ntrol_tf.isdtime
+00029fe0: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+00029ff0: 2020 2020 6e20 3d20 7365 6c66 2e6e 5b30      n = self.n[0
+0002a000: 5d0a 2020 2020 2020 2020 2020 2020 656c  ].            el
+0002a010: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0002a020: 2020 2020 6e20 3d20 696e 7428 2865 6e64      n = int((end
+0002a030: 202d 2073 7461 7274 2920 2f20 7365 6c66   - start) / self
+0002a040: 2e5f 636f 6e74 726f 6c5f 7466 2e64 7429  ._control_tf.dt)
+0002a050: 202b 2031 0a20 2020 2020 2020 2020 2020   + 1.           
+0002a060: 2073 656c 662e 5f74 696d 655f 6172 7261   self._time_arra
+0002a070: 7920 3d20 7365 6c66 2e5f 6469 7363 7265  y = self._discre
+0002a080: 7469 7a65 280a 2020 2020 2020 2020 2020  tize(.          
+0002a090: 2020 2020 2020 2020 2020 7374 6172 742c            start,
+0002a0a0: 2065 6e64 2c20 6e2c 2073 656c 662e 7363   end, n, self.sc
+0002a0b0: 616c 6573 5b30 5d2c 2073 656c 662e 6f6e  ales[0], self.on
+0002a0c0: 6c79 5f69 6e74 6567 6572 7329 0a0a 2020  ly_integers)..  
+0002a0d0: 2020 2020 2020 636f 6e74 726f 6c5f 6b77        control_kw
+0002a0e0: 203d 207b 2254 223a 2073 656c 662e 5f74   = {"T": self._t
+0002a0f0: 696d 655f 6172 7261 792c 2022 7371 7565  ime_array, "sque
+0002a100: 657a 6522 3a20 5472 7565 7d0a 0a20 2020  eze": True}..   
+0002a110: 2020 2020 2069 6620 7365 6c66 2e5f 7265       if self._re
+0002a120: 7370 6f6e 7365 5f74 7970 6520 3d3d 2022  sponse_type == "
+0002a130: 7374 6570 223a 0a20 2020 2020 2020 2020  step":.         
+0002a140: 2020 2063 6b77 203d 206d 6572 6765 6465     ckw = mergede
+0002a150: 6570 2e6d 6572 6765 287b 7d2c 2063 6f6e  ep.merge({}, con
+0002a160: 7472 6f6c 5f6b 772c 2073 656c 662e 5f63  trol_kw, self._c
+0002a170: 6f6e 7472 6f6c 5f6b 7729 0a20 2020 2020  ontrol_kw).     
+0002a180: 2020 2020 2020 2078 2c20 7920 3d20 6374         x, y = ct
+0002a190: 2e73 7465 705f 7265 7370 6f6e 7365 2873  .step_response(s
+0002a1a0: 656c 662e 5f63 6f6e 7472 6f6c 5f74 662c  elf._control_tf,
+0002a1b0: 202a 2a63 6b77 290a 2020 2020 2020 2020   **ckw).        
+0002a1c0: 656c 6966 2073 656c 662e 5f72 6573 706f  elif self._respo
+0002a1d0: 6e73 655f 7479 7065 203d 3d20 2269 6d70  nse_type == "imp
+0002a1e0: 756c 7365 223a 0a20 2020 2020 2020 2020  ulse":.         
+0002a1f0: 2020 2063 6b77 203d 206d 6572 6765 6465     ckw = mergede
+0002a200: 6570 2e6d 6572 6765 287b 7d2c 2063 6f6e  ep.merge({}, con
+0002a210: 7472 6f6c 5f6b 772c 2073 656c 662e 5f63  trol_kw, self._c
+0002a220: 6f6e 7472 6f6c 5f6b 7729 0a20 2020 2020  ontrol_kw).     
+0002a230: 2020 2020 2020 2078 2c20 7920 3d20 6374         x, y = ct
+0002a240: 2e69 6d70 756c 7365 5f72 6573 706f 6e73  .impulse_respons
+0002a250: 6528 7365 6c66 2e5f 636f 6e74 726f 6c5f  e(self._control_
+0002a260: 7466 2c20 2a2a 636b 7729 0a20 2020 2020  tf, **ckw).     
+0002a270: 2020 2065 6c69 6620 7365 6c66 2e5f 7265     elif self._re
+0002a280: 7370 6f6e 7365 5f74 7970 6520 3d3d 2022  sponse_type == "
+0002a290: 7261 6d70 223a 0a20 2020 2020 2020 2020  ramp":.         
+0002a2a0: 2020 2072 616d 7020 3d20 7365 6c66 2e5f     ramp = self._
+0002a2b0: 7469 6d65 5f61 7272 6179 0a20 2020 2020  time_array.     
+0002a2c0: 2020 2020 2020 2063 6f6e 7472 6f6c 5f6b         control_k
+0002a2d0: 775b 2255 225d 203d 2072 616d 700a 2020  w["U"] = ramp.  
+0002a2e0: 2020 2020 2020 2020 2020 636b 7720 3d20            ckw = 
+0002a2f0: 6d65 7267 6564 6565 702e 6d65 7267 6528  mergedeep.merge(
+0002a300: 7b7d 2c20 636f 6e74 726f 6c5f 6b77 2c20  {}, control_kw, 
+0002a310: 7365 6c66 2e5f 636f 6e74 726f 6c5f 6b77  self._control_kw
+0002a320: 290a 2020 2020 2020 2020 2020 2020 782c  ).            x,
+0002a330: 2079 203d 2063 742e 666f 7263 6564 5f72   y = ct.forced_r
+0002a340: 6573 706f 6e73 6528 7365 6c66 2e5f 636f  esponse(self._co
+0002a350: 6e74 726f 6c5f 7466 2c20 2a2a 636b 7729  ntrol_tf, **ckw)
+0002a360: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0002a370: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+0002a380: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
+0002a390: 7272 6f72 0a0a 2020 2020 2020 2020 7265  rror..        re
+0002a3a0: 7475 726e 2078 2c20 790a 0a0a 636c 6173  turn x, y...clas
+0002a3b0: 7320 436f 6c6f 7265 6453 7973 7465 6d52  s ColoredSystemR
+0002a3c0: 6573 706f 6e73 6553 6572 6965 7328 5379  esponseSeries(Sy
+0002a3d0: 7374 656d 5265 7370 6f6e 7365 5365 7269  stemResponseSeri
+0002a3e0: 6573 293a 0a20 2020 2022 2222 5265 7072  es):.    """Repr
+0002a3f0: 6573 656e 7420 6120 7379 7374 656d 2072  esent a system r
+0002a400: 6573 706f 6e73 6520 636f 6d70 7574 6564  esponse computed
+0002a410: 2077 6974 6820 7468 6520 6060 636f 6e74   with the ``cont
+0002a420: 726f 6c60 6020 6d6f 6475 6c65 2c0a 2020  rol`` module,.  
+0002a430: 2020 616e 6420 636f 6c6f 7265 6420 6163    and colored ac
+0002a440: 636f 7264 696e 6720 736f 6d65 2063 6f6c  cording some col
+0002a450: 6f72 2066 756e 6374 696f 6e2e 0a20 2020  or function..   
+0002a460: 2022 2222 0a20 2020 2069 735f 7061 7261   """.    is_para
+0002a470: 6d65 7472 6963 203d 2054 7275 650a 0a20  metric = True.. 
+0002a480: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
+0002a490: 7365 6c66 2c20 2a61 7267 732c 202a 2a6b  self, *args, **k
+0002a4a0: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
+0002a4b0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+0002a4c0: 282a 6172 6773 2c20 2a2a 6b77 6172 6773  (*args, **kwargs
+0002a4d0: 290a 2020 2020 2020 2020 7365 6c66 2e75  ).        self.u
+0002a4e0: 7365 5f63 6d20 3d20 6b77 6172 6773 2e67  se_cm = kwargs.g
+0002a4f0: 6574 2822 7573 655f 636d 222c 2054 7275  et("use_cm", Tru
+0002a500: 6529 0a0a 2020 2020 6465 6620 5f67 6574  e)..    def _get
+0002a510: 5f64 6174 615f 6865 6c70 6572 2873 656c  _data_helper(sel
+0002a520: 6629 3a0a 2020 2020 2020 2020 782c 2079  f):.        x, y
+0002a530: 203d 2073 7570 6572 2829 2e5f 6765 745f   = super()._get_
+0002a540: 6461 7461 5f68 656c 7065 7228 290a 2020  data_helper().  
+0002a550: 2020 2020 2020 7265 7475 726e 2078 2c20        return x, 
+0002a560: 792c 2073 656c 662e 6576 616c 5f63 6f6c  y, self.eval_col
+0002a570: 6f72 5f66 756e 6328 782c 2079 290a 0a0a  or_func(x, y)...
+0002a580: 636c 6173 7320 506f 6c65 5a65 726f 436f  class PoleZeroCo
+0002a590: 6d6d 6f6e 3a0a 2020 2020 6465 6620 5f5f  mmon:.    def __
+0002a5a0: 696e 6974 5f5f 2873 656c 662c 202a 6172  init__(self, *ar
+0002a5b0: 6773 2c20 2a2a 6b77 6172 6773 293a 0a20  gs, **kwargs):. 
+0002a5c0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+0002a5d0: 5f69 6e69 745f 5f28 2a61 7267 732c 202a  _init__(*args, *
+0002a5e0: 2a6b 7761 7267 7329 0a20 2020 2020 2020  *kwargs).       
+0002a5f0: 2073 656c 662e 6973 5f70 6f69 6e74 203d   self.is_point =
+0002a600: 2054 7275 650a 2020 2020 2020 2020 7365   True.        se
+0002a610: 6c66 2e72 6574 7572 6e5f 706f 6c65 7320  lf.return_poles 
+0002a620: 3d20 6b77 6172 6773 2e67 6574 2822 7265  = kwargs.get("re
+0002a630: 7475 726e 5f70 6f6c 6573 222c 2054 7275  turn_poles", Tru
+0002a640: 6529 0a20 2020 2020 2020 2073 656c 662e  e).        self.
+0002a650: 706f 6c65 5f63 6f6c 6f72 203d 206b 7761  pole_color = kwa
+0002a660: 7267 732e 6765 7428 2270 6f6c 655f 636f  rgs.get("pole_co
+0002a670: 6c6f 7222 2c20 4e6f 6e65 290a 2020 2020  lor", None).    
+0002a680: 2020 2020 7365 6c66 2e7a 6572 6f5f 636f      self.zero_co
+0002a690: 6c6f 7220 3d20 6b77 6172 6773 2e67 6574  lor = kwargs.get
+0002a6a0: 2822 7a65 726f 5f63 6f6c 6f72 222c 204e  ("zero_color", N
+0002a6b0: 6f6e 6529 0a20 2020 2020 2020 2073 656c  one).        sel
+0002a6c0: 662e 706f 6c65 5f6d 6172 6b65 7273 697a  f.pole_markersiz
+0002a6d0: 6520 3d20 6b77 6172 6773 2e67 6574 2822  e = kwargs.get("
+0002a6e0: 706f 6c65 5f6d 6172 6b65 7273 697a 6522  pole_markersize"
+0002a6f0: 2c20 3130 290a 2020 2020 2020 2020 7365  , 10).        se
+0002a700: 6c66 2e7a 6572 6f5f 6d61 726b 6572 7369  lf.zero_markersi
+0002a710: 7a65 203d 206b 7761 7267 732e 6765 7428  ze = kwargs.get(
+0002a720: 227a 6572 6f5f 6d61 726b 6572 7369 7a65  "zero_markersize
+0002a730: 222c 2037 290a 0a20 2020 2064 6566 205f  ", 7)..    def _
+0002a740: 5f73 7472 5f5f 2873 656c 6629 3a0a 2020  _str__(self):.  
+0002a750: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0002a760: 662e 5f73 7472 5f68 656c 7065 7228 2270  f._str_helper("p
+0002a770: 6f6c 6573 2220 6966 2073 656c 662e 7265  oles" if self.re
+0002a780: 7475 726e 5f70 6f6c 6573 2065 6c73 6520  turn_poles else 
+0002a790: 227a 6572 6f73 2022 290a 0a0a 636c 6173  "zeros ")...clas
+0002a7a0: 7320 506f 6c65 5a65 726f 5769 7468 5379  s PoleZeroWithSy
+0002a7b0: 6d70 7953 6572 6965 7328 506f 6c65 5a65  mpySeries(PoleZe
+0002a7c0: 726f 436f 6d6d 6f6e 2c20 4c69 7374 3244  roCommon, List2D
+0002a7d0: 5365 7269 6573 293a 0a20 2020 2064 6566  Series):.    def
+0002a7e0: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+0002a7f0: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
+0002a800: 3a0a 2020 2020 2020 2020 7375 7065 7228  :.        super(
+0002a810: 292e 5f5f 696e 6974 5f5f 282a 6172 6773  ).__init__(*args
+0002a820: 2c20 2a2a 6b77 6172 6773 290a 0a0a 636c  , **kwargs)...cl
+0002a830: 6173 7320 506f 6c65 5a65 726f 5365 7269  ass PoleZeroSeri
+0002a840: 6573 2850 6f6c 655a 6572 6f43 6f6d 6d6f  es(PoleZeroCommo
+0002a850: 6e2c 2043 6f6e 7472 6f6c 4261 7365 5365  n, ControlBaseSe
+0002a860: 7269 6573 293a 0a20 2020 2022 2222 5265  ries):.    """Re
+0002a870: 7072 6573 656e 7420 6120 7468 6520 706f  present a the po
+0002a880: 6c65 2d7a 6572 6f20 6f66 2061 6e20 4c54  le-zero of an LT
+0002a890: 4920 5349 534f 2073 7973 7465 6d20 636f  I SISO system co
+0002a8a0: 6d70 7574 6564 0a20 2020 2077 6974 6820  mputed.    with 
+0002a8b0: 7468 6520 6060 636f 6e74 726f 6c60 6020  the ``control`` 
+0002a8c0: 6d6f 6475 6c65 2e0a 0a20 2020 2054 6869  module...    Thi
+0002a8d0: 7320 7365 7269 6573 2072 6570 7265 7365  s series represe
+0002a8e0: 6e74 7320 6569 7468 6572 2070 6f6c 6573  nts either poles
+0002a8f0: 206f 7220 7a65 726f 732c 206e 6f74 2062   or zeros, not b
+0002a900: 6f74 6820 6174 2074 6865 2073 616d 6520  oth at the same 
+0002a910: 7469 6d65 2e0a 2020 2020 496e 2073 6f6d  time..    In som
+0002a920: 6520 7365 6e73 652c 2069 7420 6265 6861  e sense, it beha
+0002a930: 7665 7320 6c69 6b65 2061 204c 6973 7432  ves like a List2
+0002a940: 4453 6572 6965 732e 2053 6f2c 2074 6f20  DSeries. So, to 
+0002a950: 7265 7072 6573 656e 7473 2062 6f74 680a  represents both.
+0002a960: 2020 2020 706f 6c65 7320 616e 6420 7a65      poles and ze
+0002a970: 726f 7320 6f66 2061 2074 7261 6e73 6665  ros of a transfe
+0002a980: 7220 6675 6e63 7469 6f6e 2c20 7765 206e  r function, we n
+0002a990: 6565 6420 746f 2069 6e73 7461 7469 6174  eed to instatiat
+0002a9a0: 6520 7477 6f0a 2020 2020 6469 6666 6572  e two.    differ
+0002a9b0: 656e 7420 7365 7269 6573 2070 6173 7369  ent series passi
+0002a9c0: 6e67 2069 6e20 7468 6520 7361 6d65 2074  ng in the same t
+0002a9d0: 7261 6e73 6665 7220 6675 6e63 7469 6f6e  ransfer function
+0002a9e0: 2e0a 0a20 2020 2057 6869 6c65 2063 6f6d  ...    While com
+0002a9f0: 7075 7461 7469 6f6e 616c 6c79 206c 6573  putationally les
+0002aa00: 7320 6566 6669 6369 656e 742c 2074 6869  s efficient, thi
+0002aa10: 7320 6465 7369 676e 2063 686f 6963 6520  s design choice 
+0002aa20: 6861 7665 2062 6565 6e20 6d61 6465 0a20  have been made. 
+0002aa30: 2020 2069 6e20 6f72 6465 7220 746f 2072     in order to r
+0002aa40: 6575 7365 2074 6865 2065 7869 7374 696e  euse the existin
+0002aa50: 6720 4261 7365 4261 636b 656e 6420 6172  g BaseBackend ar
+0002aa60: 6368 6974 6563 7475 7265 2c20 7468 6174  chitecture, that
+0002aa70: 2073 6574 7320 7570 0a20 2020 2074 6865   sets up.    the
+0002aa80: 206e 756d 6265 7220 6f66 2063 6f6c 6f72   number of color
+0002aa90: 7320 6261 7365 6420 6f6e 2074 6865 206e  s based on the n
+0002aaa0: 756d 6265 7220 6f66 2064 6174 6120 7365  umber of data se
+0002aab0: 7269 6573 2c20 6173 2077 656c 6c20 6173  ries, as well as
+0002aac0: 2074 6865 0a20 2020 206c 6f67 6963 2074   the.    logic t
+0002aad0: 6f20 7368 6f77 206f 7220 6869 6465 2074  o show or hide t
+0002aae0: 6865 206c 6567 656e 642e 0a20 2020 2022  he legend..    "
+0002aaf0: 2222 0a20 2020 2064 6566 205f 5f69 6e69  "".    def __ini
+0002ab00: 745f 5f28 7365 6c66 2c20 7466 2c20 6c61  t__(self, tf, la
+0002ab10: 6265 6c3d 2222 2c20 2a2a 6b77 6172 6773  bel="", **kwargs
+0002ab20: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
+0002ab30: 2829 2e5f 5f69 6e69 745f 5f28 7466 2c20  ().__init__(tf, 
+0002ab40: 6c61 6265 6c3d 6c61 6265 6c2c 202a 2a6b  label=label, **k
+0002ab50: 7761 7267 7329 0a20 2020 2020 2020 2073  wargs).        s
+0002ab60: 656c 662e 5f63 6865 636b 5f66 7328 290a  elf._check_fs().
+0002ab70: 0a20 2020 2064 6566 205f 5f73 7472 5f5f  .    def __str__
+0002ab80: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0002ab90: 7072 6520 3d20 2270 6f6c 6573 206f 6620  pre = "poles of 
+0002aba0: 2220 6966 2073 656c 662e 7265 7475 726e  " if self.return
+0002abb0: 5f70 6f6c 6573 2065 6c73 6520 227a 6572  _poles else "zer
+0002abc0: 6f73 206f 6620 220a 2020 2020 2020 2020  os of ".        
+0002abd0: 6578 7072 203d 2073 656c 662e 5f65 7870  expr = self._exp
+0002abe0: 7220 6966 2073 656c 662e 5f65 7870 7220  r if self._expr 
+0002abf0: 6973 206e 6f74 204e 6f6e 6520 656c 7365  is not None else
+0002ac00: 2073 656c 662e 5f63 6f6e 7472 6f6c 5f74   self._control_t
+0002ac10: 660a 2020 2020 2020 2020 7265 7475 726e  f.        return
+0002ac20: 2070 7265 202b 2073 7472 2865 7870 7229   pre + str(expr)
+0002ac30: 0a0a 2020 2020 6465 6620 5f67 6574 5f64  ..    def _get_d
+0002ac40: 6174 615f 6865 6c70 6572 2873 656c 6629  ata_helper(self)
+0002ac50: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+0002ac60: 2020 2020 2020 5265 7475 726e 730a 2020        Returns.  
+0002ac70: 2020 2020 2020 3d3d 3d3d 3d3d 3d0a 2020        =======.  
+0002ac80: 2020 2020 2020 7820 3a20 6e70 2e6e 6461        x : np.nda
+0002ac90: 7272 6179 0a20 2020 2020 2020 2079 203a  rray.        y :
+0002aca0: 206e 702e 6e64 6172 7261 790a 2020 2020   np.ndarray.    
+0002acb0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0002acc0: 6e70 203d 2069 6d70 6f72 745f 6d6f 6475  np = import_modu
+0002acd0: 6c65 2822 6e75 6d70 7922 290a 2020 2020  le("numpy").    
+0002ace0: 2020 2020 6966 2073 656c 662e 6973 5f69      if self.is_i
+0002acf0: 6e74 6572 6163 7469 7665 3a0a 2020 2020  nteractive:.    
+0002ad00: 2020 2020 2020 2020 7466 203d 2073 656c          tf = sel
+0002ad10: 662e 5f65 7870 722e 7375 6273 2873 656c  f._expr.subs(sel
+0002ad20: 662e 7061 7261 6d73 290a 2020 2020 2020  f.params).      
+0002ad30: 2020 2020 2020 7365 6c66 2e5f 636f 6e74        self._cont
+0002ad40: 726f 6c5f 7466 203d 2074 665f 746f 5f63  rol_tf = tf_to_c
+0002ad50: 6f6e 7472 6f6c 2874 6629 0a20 2020 2020  ontrol(tf).     
+0002ad60: 2020 2069 6620 7365 6c66 2e72 6574 7572     if self.retur
+0002ad70: 6e5f 706f 6c65 733a 0a20 2020 2020 2020  n_poles:.       
+0002ad80: 2020 2020 2070 6f69 6e74 7320 3d20 7365       points = se
+0002ad90: 6c66 2e5f 636f 6e74 726f 6c5f 7466 2e70  lf._control_tf.p
+0002ada0: 6f6c 6573 2829 0a20 2020 2020 2020 2065  oles().        e
+0002adb0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0002adc0: 2070 6f69 6e74 7320 3d20 7365 6c66 2e5f   points = self._
+0002add0: 636f 6e74 726f 6c5f 7466 2e7a 6572 6f73  control_tf.zeros
+0002ade0: 2829 0a20 2020 2020 2020 2072 6574 7572  ().        retur
+0002adf0: 6e20 6e70 2e72 6561 6c28 706f 696e 7473  n np.real(points
+0002ae00: 292c 206e 702e 696d 6167 2870 6f69 6e74  ), np.imag(point
+0002ae10: 7329 0a0a 0a63 6c61 7373 204e 4772 6964  s)...class NGrid
+0002ae20: 4c69 6e65 5365 7269 6573 2847 7269 6442  LineSeries(GridB
+0002ae30: 6173 652c 2042 6173 6553 6572 6965 7329  ase, BaseSeries)
+0002ae40: 3a0a 2020 2020 2222 2220 5468 6520 636f  :.    """ The co
+0002ae50: 6465 206f 6620 7468 6973 2063 6c61 7373  de of this class
+0002ae60: 2063 6f6d 6573 2066 726f 6d20 7468 6520   comes from the 
+0002ae70: 6060 636f 6e74 726f 6c60 6020 7061 636b  ``control`` pack
+0002ae80: 6167 652c 2077 6869 6368 2068 6173 0a20  age, which has. 
+0002ae90: 2020 2062 6565 6e20 7265 6172 7261 6e67     been rearrang
+0002aea0: 6564 2074 6f20 776f 726b 2077 6974 6820  ed to work with 
+0002aeb0: 7468 6520 6172 6368 6974 6563 7475 7265  the architecture
+0002aec0: 206f 6620 7468 6973 206d 6f64 756c 652e   of this module.
+0002aed0: 0a20 2020 2022 2222 0a0a 2020 2020 6465  .    """..    de
+0002aee0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
+0002aef0: 2063 6c5f 6d61 6773 3d4e 6f6e 652c 2063   cl_mags=None, c
+0002af00: 6c5f 7068 6173 6573 3d4e 6f6e 652c 206c  l_phases=None, l
+0002af10: 6162 656c 5f63 6c5f 7068 6173 6573 3d46  abel_cl_phases=F
+0002af20: 616c 7365 2c0a 2020 2020 2020 2020 2a2a  alse,.        **
+0002af30: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+0002af40: 2073 7570 6572 2829 2e5f 5f69 6e69 745f   super().__init_
+0002af50: 5f28 2a2a 6b77 6172 6773 290a 2020 2020  _(**kwargs).    
+0002af60: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
+0002af70: 6d6f 6475 6c65 2822 6e75 6d70 7922 290a  module("numpy").
+0002af80: 2020 2020 2020 2020 7365 6c66 2e63 6c5f          self.cl_
+0002af90: 6d61 6773 203d 2063 6c5f 6d61 6773 2069  mags = cl_mags i
+0002afa0: 6620 636c 5f6d 6167 7320 6973 204e 6f6e  f cl_mags is Non
+0002afb0: 6520 656c 7365 206e 702e 6172 7261 7928  e else np.array(
+0002afc0: 636c 5f6d 6167 7329 0a20 2020 2020 2020  cl_mags).       
+0002afd0: 2073 656c 662e 636c 5f70 6861 7365 7320   self.cl_phases 
+0002afe0: 3d20 636c 5f70 6861 7365 7320 6966 2063  = cl_phases if c
+0002aff0: 6c5f 7068 6173 6573 2069 7320 4e6f 6e65  l_phases is None
+0002b000: 2065 6c73 6520 6e70 2e61 7272 6179 2863   else np.array(c
+0002b010: 6c5f 7068 6173 6573 290a 2020 2020 2020  l_phases).      
+0002b020: 2020 7365 6c66 2e6c 6162 656c 5f63 6c5f    self.label_cl_
+0002b030: 7068 6173 6573 203d 206c 6162 656c 5f63  phases = label_c
+0002b040: 6c5f 7068 6173 6573 0a20 2020 2020 2020  l_phases.       
+0002b050: 2073 656c 662e 7368 6f77 5f69 6e5f 6c65   self.show_in_le
+0002b060: 6765 6e64 203d 206b 7761 7267 732e 6765  gend = kwargs.ge
+0002b070: 7428 2273 686f 775f 696e 5f6c 6567 656e  t("show_in_legen
+0002b080: 6422 2c20 4661 6c73 6529 0a20 2020 2020  d", False).     
+0002b090: 2020 2073 656c 662e 7368 6f77 5f63 6c5f     self.show_cl_
+0002b0a0: 6d61 6773 203d 206b 7761 7267 732e 6765  mags = kwargs.ge
+0002b0b0: 7428 2273 686f 775f 636c 5f6d 6167 7322  t("show_cl_mags"
+0002b0c0: 2c20 5472 7565 290a 2020 2020 2020 2020  , True).        
+0002b0d0: 7365 6c66 2e73 686f 775f 636c 5f70 6861  self.show_cl_pha
+0002b0e0: 7365 7320 3d20 6b77 6172 6773 2e67 6574  ses = kwargs.get
+0002b0f0: 2822 7368 6f77 5f63 6c5f 7068 6173 6573  ("show_cl_phases
+0002b100: 222c 2054 7275 6529 0a0a 2020 2020 6465  ", True)..    de
+0002b110: 6620 5f5f 7374 725f 5f28 7365 6c66 293a  f __str__(self):
+0002b120: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0002b130: 226e 2d67 7269 6422 0a0a 2020 2020 4073  "n-grid"..    @s
+0002b140: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
+0002b150: 6465 6620 636c 6f73 6564 5f6c 6f6f 705f  def closed_loop_
+0002b160: 636f 6e74 6f75 7273 2847 636c 5f6d 6167  contours(Gcl_mag
+0002b170: 732c 2047 636c 5f70 6861 7365 7329 3a0a  s, Gcl_phases):.
+0002b180: 2020 2020 2020 2020 2222 2243 6f6e 746f          """Conto
+0002b190: 7572 7320 6f66 2074 6865 2066 756e 6374  urs of the funct
+0002b1a0: 696f 6e20 4763 6c20 3d20 476f 6c2f 2831  ion Gcl = Gol/(1
+0002b1b0: 2b47 6f6c 292c 2077 6865 7265 0a20 2020  +Gol), where.   
+0002b1c0: 2020 2020 2047 6f6c 2069 7320 616e 206f       Gol is an o
+0002b1d0: 7065 6e2d 6c6f 6f70 2074 7261 6e73 6665  pen-loop transfe
+0002b1e0: 7220 6675 6e63 7469 6f6e 2c20 616e 6420  r function, and 
+0002b1f0: 4763 6c20 6973 2061 2063 6f72 7265 7370  Gcl is a corresp
+0002b200: 6f6e 6469 6e67 0a20 2020 2020 2020 2063  onding.        c
+0002b210: 6c6f 7365 642d 6c6f 6f70 2074 7261 6e73  losed-loop trans
+0002b220: 6665 7220 6675 6e63 7469 6f6e 2e0a 0a20  fer function... 
+0002b230: 2020 2020 2020 2050 6172 616d 6574 6572         Parameter
+0002b240: 730a 2020 2020 2020 2020 2d2d 2d2d 2d2d  s.        ------
+0002b250: 2d2d 2d2d 0a20 2020 2020 2020 2047 636c  ----.        Gcl
+0002b260: 5f6d 6167 7320 3a20 6172 7261 792d 6c69  _mags : array-li
+0002b270: 6b65 0a20 2020 2020 2020 2020 2020 2041  ke.            A
+0002b280: 7272 6179 206f 6620 6d61 676e 6974 7564  rray of magnitud
+0002b290: 6573 206f 6620 7468 6520 636f 6e74 6f75  es of the contou
+0002b2a0: 7273 0a20 2020 2020 2020 2047 636c 5f70  rs.        Gcl_p
+0002b2b0: 6861 7365 7320 3a20 6172 7261 792d 6c69  hases : array-li
+0002b2c0: 6b65 0a20 2020 2020 2020 2020 2020 2041  ke.            A
+0002b2d0: 7272 6179 206f 6620 7068 6173 6573 2069  rray of phases i
+0002b2e0: 6e20 7261 6469 616e 7320 6f66 2074 6865  n radians of the
+0002b2f0: 2063 6f6e 746f 7572 730a 0a20 2020 2020   contours..     
+0002b300: 2020 2052 6574 7572 6e73 0a20 2020 2020     Returns.     
+0002b310: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2020     -------.     
+0002b320: 2020 2063 6f6e 746f 7572 7320 3a20 636f     contours : co
+0002b330: 6d70 6c65 7820 6172 7261 790a 2020 2020  mplex array.    
+0002b340: 2020 2020 2020 2020 4172 7261 7920 6f66          Array of
+0002b350: 2063 6f6d 706c 6578 206e 756d 6265 7273   complex numbers
+0002b360: 2063 6f72 7265 7370 6f6e 6469 6e67 2074   corresponding t
+0002b370: 6f20 7468 6520 636f 6e74 6f75 7273 2e0a  o the contours..
+0002b380: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0002b390: 2020 2020 2320 436f 6d70 7574 6520 7468      # Compute th
+0002b3a0: 6520 636f 6e74 6f75 7273 2069 6e20 4763  e contours in Gc
+0002b3b0: 6c2d 7370 6163 652e 2053 696e 6365 2077  l-space. Since w
+0002b3c0: 6527 7265 2067 6976 656e 2063 6c6f 7365  e're given close
+0002b3d0: 642d 6c6f 6f70 0a20 2020 2020 2020 2023  d-loop.        #
+0002b3e0: 206d 6167 6e69 7475 6465 7320 616e 6420   magnitudes and 
+0002b3f0: 7068 6173 6573 2c20 7468 6973 2069 7320  phases, this is 
+0002b400: 6a75 7374 2061 2063 6173 6520 6f66 2063  just a case of c
+0002b410: 6f6e 7665 7274 696e 6720 7468 656d 2069  onverting them i
+0002b420: 6e74 6f0a 2020 2020 2020 2020 2320 6120  nto.        # a 
+0002b430: 636f 6d70 6c65 7820 6e75 6d62 6572 2e0a  complex number..
+0002b440: 2020 2020 2020 2020 6e70 203d 2069 6d70          np = imp
+0002b450: 6f72 745f 6d6f 6475 6c65 2822 6e75 6d70  ort_module("nump
+0002b460: 7922 290a 2020 2020 2020 2020 4763 6c20  y").        Gcl 
+0002b470: 3d20 4763 6c5f 6d61 6773 2a6e 702e 6578  = Gcl_mags*np.ex
+0002b480: 7028 312e 6a2a 4763 6c5f 7068 6173 6573  p(1.j*Gcl_phases
+0002b490: 290a 0a20 2020 2020 2020 2023 2049 6e76  )..        # Inv
+0002b4a0: 6572 7420 4763 6c20 3d20 476f 6c2f 2831  ert Gcl = Gol/(1
+0002b4b0: 2b47 6f6c 2920 746f 206d 6170 2074 6865  +Gol) to map the
+0002b4c0: 2063 6f6e 746f 7572 7320 696e 746f 2074   contours into t
+0002b4d0: 6865 206f 7065 6e2d 6c6f 6f70 2073 7061  he open-loop spa
+0002b4e0: 6365 0a20 2020 2020 2020 2072 6574 7572  ce.        retur
+0002b4f0: 6e20 4763 6c2f 2831 2e30 202d 2047 636c  n Gcl/(1.0 - Gcl
+0002b500: 290a 0a20 2020 2040 7374 6174 6963 6d65  )..    @staticme
+0002b510: 7468 6f64 0a20 2020 2064 6566 206d 5f63  thod.    def m_c
+0002b520: 6972 636c 6573 286d 6167 732c 2070 6861  ircles(mags, pha
+0002b530: 7365 5f6d 696e 3d2d 3335 392e 3735 2c20  se_min=-359.75, 
+0002b540: 7068 6173 655f 6d61 783d 2d30 2e32 3529  phase_max=-0.25)
+0002b550: 3a0a 2020 2020 2020 2020 2222 2243 6f6e  :.        """Con
+0002b560: 7374 616e 742d 6d61 676e 6974 7564 6520  stant-magnitude 
+0002b570: 636f 6e74 6f75 7273 206f 6620 7468 6520  contours of the 
+0002b580: 6675 6e63 7469 6f6e 2047 636c 203d 2047  function Gcl = G
+0002b590: 6f6c 2f28 312b 476f 6c29 2c20 7768 6572  ol/(1+Gol), wher
+0002b5a0: 650a 2020 2020 2020 2020 476f 6c20 6973  e.        Gol is
+0002b5b0: 2061 6e20 6f70 656e 2d6c 6f6f 7020 7472   an open-loop tr
+0002b5c0: 616e 7366 6572 2066 756e 6374 696f 6e2c  ansfer function,
+0002b5d0: 2061 6e64 2047 636c 2069 7320 6120 636f   and Gcl is a co
+0002b5e0: 7272 6573 706f 6e64 696e 670a 2020 2020  rresponding.    
+0002b5f0: 2020 2020 636c 6f73 6564 2d6c 6f6f 7020      closed-loop 
+0002b600: 7472 616e 7366 6572 2066 756e 6374 696f  transfer functio
+0002b610: 6e2e 0a0a 2020 2020 2020 2020 5061 7261  n...        Para
+0002b620: 6d65 7465 7273 0a20 2020 2020 2020 202d  meters.        -
+0002b630: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
+0002b640: 2020 6d61 6773 203a 2061 7272 6179 2d6c    mags : array-l
+0002b650: 696b 650a 2020 2020 2020 2020 2020 2020  ike.            
+0002b660: 4172 7261 7920 6f66 206d 6167 6e69 7475  Array of magnitu
+0002b670: 6465 7320 696e 2064 4220 6f66 2074 6865  des in dB of the
+0002b680: 204d 2d63 6972 636c 6573 0a20 2020 2020   M-circles.     
+0002b690: 2020 2070 6861 7365 5f6d 696e 203a 2064     phase_min : d
+0002b6a0: 6567 7265 6573 0a20 2020 2020 2020 2020  egrees.         
+0002b6b0: 2020 204d 696e 696d 756d 2070 6861 7365     Minimum phase
+0002b6c0: 2069 6e20 6465 6772 6565 7320 6f66 2074   in degrees of t
+0002b6d0: 6865 204e 2d63 6972 636c 6573 0a20 2020  he N-circles.   
+0002b6e0: 2020 2020 2070 6861 7365 5f6d 6178 203a       phase_max :
+0002b6f0: 2064 6567 7265 6573 0a20 2020 2020 2020   degrees.       
+0002b700: 2020 2020 204d 6178 696d 756d 2070 6861       Maximum pha
+0002b710: 7365 2069 6e20 6465 6772 6565 7320 6f66  se in degrees of
+0002b720: 2074 6865 204e 2d63 6972 636c 6573 0a0a   the N-circles..
+0002b730: 2020 2020 2020 2020 5265 7475 726e 730a          Returns.
+0002b740: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d0a          -------.
+0002b750: 2020 2020 2020 2020 636f 6e74 6f75 7273          contours
+0002b760: 203a 2063 6f6d 706c 6578 2061 7272 6179   : complex array
+0002b770: 0a20 2020 2020 2020 2020 2020 2041 7272  .            Arr
+0002b780: 6179 206f 6620 636f 6d70 6c65 7820 6e75  ay of complex nu
+0002b790: 6d62 6572 7320 636f 7272 6573 706f 6e64  mbers correspond
+0002b7a0: 696e 6720 746f 2074 6865 2063 6f6e 746f  ing to the conto
+0002b7b0: 7572 732e 0a20 2020 2020 2020 2022 2222  urs..        """
+0002b7c0: 0a20 2020 2020 2020 2023 2043 6f6e 7665  .        # Conve
+0002b7d0: 7274 206d 6167 6e69 7475 6465 7320 616e  rt magnitudes an
+0002b7e0: 6420 7068 6173 6520 7261 6e67 6520 696e  d phase range in
+0002b7f0: 746f 2061 2067 7269 6420 7375 6974 6162  to a grid suitab
+0002b800: 6c65 2066 6f72 0a20 2020 2020 2020 2023  le for.        #
+0002b810: 2062 7569 6c64 696e 6720 636f 6e74 6f75   building contou
+0002b820: 7273 0a20 2020 2020 2020 206e 7020 3d20  rs.        np = 
+0002b830: 696d 706f 7274 5f6d 6f64 756c 6528 226e  import_module("n
+0002b840: 756d 7079 2229 0a20 2020 2020 2020 2070  umpy").        p
+0002b850: 6861 7365 7320 3d20 6e70 2e72 6164 6961  hases = np.radia
+0002b860: 6e73 286e 702e 6c69 6e73 7061 6365 2870  ns(np.linspace(p
+0002b870: 6861 7365 5f6d 696e 2c20 7068 6173 655f  hase_min, phase_
+0002b880: 6d61 782c 2032 3030 3029 290a 2020 2020  max, 2000)).    
+0002b890: 2020 2020 4763 6c5f 6d61 6773 2c20 4763      Gcl_mags, Gc
+0002b8a0: 6c5f 7068 6173 6573 203d 206e 702e 6d65  l_phases = np.me
+0002b8b0: 7368 6772 6964 2831 302e 302a 2a28 6d61  shgrid(10.0**(ma
+0002b8c0: 6773 2f32 302e 3029 2c20 7068 6173 6573  gs/20.0), phases
+0002b8d0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0002b8e0: 204e 4772 6964 4c69 6e65 5365 7269 6573   NGridLineSeries
+0002b8f0: 2e63 6c6f 7365 645f 6c6f 6f70 5f63 6f6e  .closed_loop_con
+0002b900: 746f 7572 7328 4763 6c5f 6d61 6773 2c20  tours(Gcl_mags, 
+0002b910: 4763 6c5f 7068 6173 6573 290a 0a20 2020  Gcl_phases)..   
+0002b920: 2040 7374 6174 6963 6d65 7468 6f64 0a20   @staticmethod. 
+0002b930: 2020 2064 6566 206e 5f63 6972 636c 6573     def n_circles
+0002b940: 2870 6861 7365 732c 206d 6167 5f6d 696e  (phases, mag_min
+0002b950: 3d2d 3430 2e30 2c20 6d61 675f 6d61 783d  =-40.0, mag_max=
+0002b960: 3132 2e30 293a 0a20 2020 2020 2020 2022  12.0):.        "
+0002b970: 2222 436f 6e73 7461 6e74 2d70 6861 7365  ""Constant-phase
+0002b980: 2063 6f6e 746f 7572 7320 6f66 2074 6865   contours of the
+0002b990: 2066 756e 6374 696f 6e20 4763 6c20 3d20   function Gcl = 
+0002b9a0: 476f 6c2f 2831 2b47 6f6c 292c 2077 6865  Gol/(1+Gol), whe
+0002b9b0: 7265 0a20 2020 2020 2020 2047 6f6c 2069  re.        Gol i
+0002b9c0: 7320 616e 206f 7065 6e2d 6c6f 6f70 2074  s an open-loop t
+0002b9d0: 7261 6e73 6665 7220 6675 6e63 7469 6f6e  ransfer function
+0002b9e0: 2c20 616e 6420 4763 6c20 6973 2061 2063  , and Gcl is a c
+0002b9f0: 6f72 7265 7370 6f6e 6469 6e67 0a20 2020  orresponding.   
+0002ba00: 2020 2020 2063 6c6f 7365 642d 6c6f 6f70       closed-loop
+0002ba10: 2074 7261 6e73 6665 7220 6675 6e63 7469   transfer functi
+0002ba20: 6f6e 2e0a 0a20 2020 2020 2020 2050 6172  on...        Par
+0002ba30: 616d 6574 6572 730a 2020 2020 2020 2020  ameters.        
+0002ba40: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+0002ba50: 2020 2070 6861 7365 7320 3a20 6172 7261     phases : arra
+0002ba60: 792d 6c69 6b65 0a20 2020 2020 2020 2020  y-like.         
+0002ba70: 2020 2041 7272 6179 206f 6620 7068 6173     Array of phas
+0002ba80: 6573 2069 6e20 6465 6772 6565 7320 6f66  es in degrees of
+0002ba90: 2074 6865 204e 2d63 6972 636c 6573 0a20   the N-circles. 
+0002baa0: 2020 2020 2020 206d 6167 5f6d 696e 203a         mag_min :
+0002bab0: 2064 420a 2020 2020 2020 2020 2020 2020   dB.            
+0002bac0: 4d69 6e69 6d75 6d20 6d61 676e 6974 7564  Minimum magnitud
+0002bad0: 6520 696e 2064 4220 6f66 2074 6865 204e  e in dB of the N
+0002bae0: 2d63 6972 636c 6573 0a20 2020 2020 2020  -circles.       
+0002baf0: 206d 6167 5f6d 6178 203a 2064 420a 2020   mag_max : dB.  
+0002bb00: 2020 2020 2020 2020 2020 4d61 7869 6d75            Maximu
+0002bb10: 6d20 6d61 676e 6974 7564 6520 696e 2064  m magnitude in d
+0002bb20: 4220 6f66 2074 6865 204e 2d63 6972 636c  B of the N-circl
+0002bb30: 6573 0a0a 2020 2020 2020 2020 5265 7475  es..        Retu
+0002bb40: 726e 730a 2020 2020 2020 2020 2d2d 2d2d  rns.        ----
+0002bb50: 2d2d 2d0a 2020 2020 2020 2020 636f 6e74  ---.        cont
+0002bb60: 6f75 7273 203a 2063 6f6d 706c 6578 2061  ours : complex a
+0002bb70: 7272 6179 0a20 2020 2020 2020 2020 2020  rray.           
+0002bb80: 2041 7272 6179 206f 6620 636f 6d70 6c65   Array of comple
+0002bb90: 7820 6e75 6d62 6572 7320 636f 7272 6573  x numbers corres
+0002bba0: 706f 6e64 696e 6720 746f 2074 6865 2063  ponding to the c
+0002bbb0: 6f6e 746f 7572 732e 0a20 2020 2020 2020  ontours..       
+0002bbc0: 2022 2222 0a20 2020 2020 2020 2023 2043   """.        # C
+0002bbd0: 6f6e 7665 7274 2070 6861 7365 7320 616e  onvert phases an
+0002bbe0: 6420 6d61 676e 6974 7564 6520 7261 6e67  d magnitude rang
+0002bbf0: 6520 696e 746f 2061 2067 7269 6420 7375  e into a grid su
+0002bc00: 6974 6162 6c65 2066 6f72 0a20 2020 2020  itable for.     
+0002bc10: 2020 2023 2062 7569 6c64 696e 6720 636f     # building co
+0002bc20: 6e74 6f75 7273 0a20 2020 2020 2020 206e  ntours.        n
+0002bc30: 7020 3d20 696d 706f 7274 5f6d 6f64 756c  p = import_modul
+0002bc40: 6528 226e 756d 7079 2229 0a20 2020 2020  e("numpy").     
+0002bc50: 2020 206d 6167 7320 3d20 6e70 2e6c 696e     mags = np.lin
+0002bc60: 7370 6163 6528 3130 2a2a 286d 6167 5f6d  space(10**(mag_m
+0002bc70: 696e 2f32 302e 3029 2c20 3130 2a2a 286d  in/20.0), 10**(m
+0002bc80: 6167 5f6d 6178 2f32 302e 3029 2c20 3230  ag_max/20.0), 20
+0002bc90: 3030 290a 2020 2020 2020 2020 4763 6c5f  00).        Gcl_
+0002bca0: 7068 6173 6573 2c20 4763 6c5f 6d61 6773  phases, Gcl_mags
+0002bcb0: 203d 206e 702e 6d65 7368 6772 6964 286e   = np.meshgrid(n
+0002bcc0: 702e 7261 6469 616e 7328 7068 6173 6573  p.radians(phases
+0002bcd0: 292c 206d 6167 7329 0a20 2020 2020 2020  ), mags).       
+0002bce0: 2072 6574 7572 6e20 4e47 7269 644c 696e   return NGridLin
+0002bcf0: 6553 6572 6965 732e 636c 6f73 6564 5f6c  eSeries.closed_l
+0002bd00: 6f6f 705f 636f 6e74 6f75 7273 2847 636c  oop_contours(Gcl
+0002bd10: 5f6d 6167 732c 2047 636c 5f70 6861 7365  _mags, Gcl_phase
+0002bd20: 7329 0a0a 2020 2020 6465 6620 6765 745f  s)..    def get_
+0002bd30: 6461 7461 2873 656c 6629 3a0a 2020 2020  data(self):.    
+0002bd40: 2020 2020 6e70 203d 2069 6d70 6f72 745f      np = import_
+0002bd50: 6d6f 6475 6c65 2822 6e75 6d70 7922 290a  module("numpy").
+0002bd60: 0a20 2020 2020 2020 2023 2044 6566 6175  .        # Defau
+0002bd70: 6c74 2063 6861 7274 2073 697a 650a 2020  lt chart size.  
+0002bd80: 2020 2020 2020 6f6c 5f70 6861 7365 5f6d        ol_phase_m
+0002bd90: 696e 203d 202d 3335 392e 3939 0a20 2020  in = -359.99.   
+0002bda0: 2020 2020 206f 6c5f 7068 6173 655f 6d61       ol_phase_ma
+0002bdb0: 7820 3d20 302e 300a 2020 2020 2020 2020  x = 0.0.        
+0002bdc0: 6f6c 5f6d 6167 5f6d 696e 203d 202d 3430  ol_mag_min = -40
+0002bdd0: 2e30 0a20 2020 2020 2020 206f 6c5f 6d61  .0.        ol_ma
+0002bde0: 675f 6d61 7820 3d20 6465 6661 756c 745f  g_max = default_
+0002bdf0: 6f6c 5f6d 6167 5f6d 6178 203d 2035 302e  ol_mag_max = 50.
+0002be00: 300a 0a20 2020 2020 2020 2063 6c5f 6d61  0..        cl_ma
+0002be10: 6773 203d 2073 656c 662e 636c 5f6d 6167  gs = self.cl_mag
+0002be20: 730a 2020 2020 2020 2020 636c 5f70 6861  s.        cl_pha
+0002be30: 7365 7320 3d20 7365 6c66 2e63 6c5f 7068  ses = self.cl_ph
+0002be40: 6173 6573 0a20 2020 2020 2020 206c 6162  ases.        lab
+0002be50: 656c 5f63 6c5f 7068 6173 6573 203d 2073  el_cl_phases = s
+0002be60: 656c 662e 6c61 6265 6c5f 636c 5f70 6861  elf.label_cl_pha
+0002be70: 7365 730a 0a20 2020 2020 2020 2023 2046  ses..        # F
+0002be80: 696e 6420 6578 7465 6e74 206f 6620 696e  ind extent of in
+0002be90: 7465 7273 6563 7469 6f6e 2074 6865 2063  tersection the c
+0002bea0: 7572 7265 6e74 2064 6174 6173 6574 206f  urrent dataset o
+0002beb0: 7220 7669 6577 0a20 2020 2020 2020 206f  r view.        o
+0002bec0: 6c5f 7068 6173 655f 6d69 6e2c 206f 6c5f  l_phase_min, ol_
+0002bed0: 7068 6173 655f 6d61 7820 3d20 7365 6c66  phase_max = self
+0002bee0: 2e5f 786c 696d 0a20 2020 2020 2020 206f  ._xlim.        o
+0002bef0: 6c5f 6d61 675f 6d69 6e2c 206f 6c5f 6d61  l_mag_min, ol_ma
+0002bf00: 675f 6d61 7820 3d20 7365 6c66 2e5f 796c  g_max = self._yl
+0002bf10: 696d 0a0a 2020 2020 2020 2020 2320 4d2d  im..        # M-
+0002bf20: 6369 7263 6c65 206d 6167 6e69 7475 6465  circle magnitude
+0002bf30: 732e 0a20 2020 2020 2020 2069 6620 636c  s..        if cl
+0002bf40: 5f6d 6167 7320 6973 204e 6f6e 653a 0a20  _mags is None:. 
+0002bf50: 2020 2020 2020 2020 2020 2023 2044 6566             # Def
+0002bf60: 6175 6c74 2063 6861 7274 206d 6167 6e69  ault chart magni
+0002bf70: 7475 6465 730a 2020 2020 2020 2020 2020  tudes.          
+0002bf80: 2020 2320 5468 6520 6b65 7920 7365 7420    # The key set 
+0002bf90: 6f66 206d 6167 6e69 7475 6465 7320 6172  of magnitudes ar
+0002bfa0: 6520 616c 7761 7973 2067 656e 6572 6174  e always generat
+0002bfb0: 6564 2c20 7369 6e63 6520 7468 6973 0a20  ed, since this. 
+0002bfc0: 2020 2020 2020 2020 2020 2023 2067 7561             # gua
+0002bfd0: 7261 6e74 6565 7320 6120 7265 636f 676e  rantees a recogn
+0002bfe0: 697a 6162 6c65 204e 6963 686f 6c73 2063  izable Nichols c
+0002bff0: 6861 7274 2067 7269 642e 0a20 2020 2020  hart grid..     
+0002c000: 2020 2020 2020 206b 6579 5f63 6c5f 6d61         key_cl_ma
+0002c010: 6773 203d 206e 702e 6172 7261 7928 5b0a  gs = np.array([.
+0002c020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c030: 2d34 302e 302c 202d 3230 2e30 2c20 2d31  -40.0, -20.0, -1
+0002c040: 322e 302c 202d 362e 302c 202d 332e 302c  2.0, -6.0, -3.0,
+0002c050: 202d 312e 302c 202d 302e 352c 0a20 2020   -1.0, -0.5,.   
+0002c060: 2020 2020 2020 2020 2020 2020 2030 2e30               0.0
+0002c070: 2c20 302e 3235 2c20 302e 352c 2031 2e30  , 0.25, 0.5, 1.0
+0002c080: 2c20 332e 302c 2036 2e30 2c20 3132 2e30  , 3.0, 6.0, 12.0
+0002c090: 0a20 2020 2020 2020 2020 2020 205d 290a  .            ]).
+0002c0a0: 0a20 2020 2020 2020 2020 2020 2023 2045  .            # E
+0002c0b0: 7874 656e 6420 7468 6520 7261 6e67 6520  xtend the range 
+0002c0c0: 6f66 206d 6167 6e69 7475 6465 7320 6966  of magnitudes if
+0002c0d0: 206e 6563 6573 7361 7279 2e20 5468 6520   necessary. The 
+0002c0e0: 6578 7465 6e64 6564 2061 7261 6e67 650a  extended arange.
+0002c0f0: 2020 2020 2020 2020 2020 2020 2320 7769              # wi
+0002c100: 6c6c 2065 6e64 2075 7020 656d 7074 7920  ll end up empty 
+0002c110: 6966 206e 6f20 6578 7465 6e73 696f 6e20  if no extension 
+0002c120: 6973 2072 6571 7569 7265 642e 2041 7373  is required. Ass
+0002c130: 756d 6573 2074 6861 740a 2020 2020 2020  umes that.      
+0002c140: 2020 2020 2020 2320 636c 6f73 6564 2d6c        # closed-l
+0002c150: 6f6f 7020 6d61 676e 6974 7564 6573 2061  oop magnitudes a
+0002c160: 7265 2061 7070 726f 7869 6d61 7465 6c79  re approximately
+0002c170: 2061 6c69 676e 6564 2077 6974 6820 6f70   aligned with op
+0002c180: 656e 2d6c 6f6f 700a 2020 2020 2020 2020  en-loop.        
+0002c190: 2020 2020 2320 6d61 676e 6974 7564 6573      # magnitudes
+0002c1a0: 2062 6579 6f6e 6420 7468 6520 7661 6c75   beyond the valu
+0002c1b0: 6520 6f66 206e 702e 6d69 6e28 6b65 795f  e of np.min(key_
+0002c1c0: 636c 5f6d 6167 7329 0a20 2020 2020 2020  cl_mags).       
+0002c1d0: 2020 2020 2063 6c5f 6d61 675f 7374 6570       cl_mag_step
+0002c1e0: 203d 202d 3230 2e30 2020 2320 6442 0a20   = -20.0  # dB. 
+0002c1f0: 2020 2020 2020 2020 2020 2065 7874 656e             exten
+0002c200: 6465 645f 636c 5f6d 6167 7320 3d20 6e70  ded_cl_mags = np
+0002c210: 2e61 7261 6e67 6528 0a20 2020 2020 2020  .arange(.       
+0002c220: 2020 2020 2020 2020 206e 702e 6d69 6e28           np.min(
+0002c230: 6b65 795f 636c 5f6d 6167 7329 2c20 6f6c  key_cl_mags), ol
+0002c240: 5f6d 6167 5f6d 696e 202b 2063 6c5f 6d61  _mag_min + cl_ma
+0002c250: 675f 7374 6570 2c20 636c 5f6d 6167 5f73  g_step, cl_mag_s
+0002c260: 7465 7029 0a20 2020 2020 2020 2020 2020  tep).           
+0002c270: 2063 6c5f 6d61 6773 203d 206e 702e 636f   cl_mags = np.co
+0002c280: 6e63 6174 656e 6174 6528 2865 7874 656e  ncatenate((exten
+0002c290: 6465 645f 636c 5f6d 6167 732c 206b 6579  ded_cl_mags, key
+0002c2a0: 5f63 6c5f 6d61 6773 2929 0a0a 2020 2020  _cl_mags))..    
+0002c2b0: 2020 2020 2320 6120 6d69 6e69 6d75 6d20      # a minimum 
+0002c2c0: 3336 3064 6567 2065 7874 656e 7420 636f  360deg extent co
+0002c2d0: 6e74 6169 6e69 6e67 2074 6865 2070 6861  ntaining the pha
+0002c2e0: 7365 730a 2020 2020 2020 2020 7068 6173  ses.        phas
+0002c2f0: 655f 726f 756e 645f 6d61 7820 3d20 3336  e_round_max = 36
+0002c300: 302e 302a 6e70 2e63 6569 6c28 6f6c 5f70  0.0*np.ceil(ol_p
+0002c310: 6861 7365 5f6d 6178 2f33 3630 2e30 290a  hase_max/360.0).
+0002c320: 2020 2020 2020 2020 7068 6173 655f 726f          phase_ro
+0002c330: 756e 645f 6d69 6e20 3d20 6d69 6e28 7068  und_min = min(ph
+0002c340: 6173 655f 726f 756e 645f 6d61 782d 3336  ase_round_max-36
+0002c350: 302c 0a20 2020 2020 2020 2020 2020 2020  0,.             
+0002c360: 2020 2020 2020 2020 2020 2020 2020 2033                 3
+0002c370: 3630 2e30 2a6e 702e 666c 6f6f 7228 6f6c  60.0*np.floor(ol
+0002c380: 5f70 6861 7365 5f6d 696e 2f33 3630 2e30  _phase_min/360.0
+0002c390: 2929 0a0a 2020 2020 2020 2020 2320 4e2d  ))..        # N-
+0002c3a0: 6369 7263 6c65 2070 6861 7365 7320 2873  circle phases (s
+0002c3b0: 686f 756c 6420 6265 2069 6e20 7468 6520  hould be in the 
+0002c3c0: 7261 6e67 6520 2d33 3630 2074 6f20 3029  range -360 to 0)
+0002c3d0: 0a20 2020 2020 2020 2069 6620 636c 5f70  .        if cl_p
+0002c3e0: 6861 7365 7320 6973 204e 6f6e 653a 0a20  hases is None:. 
+0002c3f0: 2020 2020 2020 2020 2020 2023 2061 696d             # aim
+0002c400: 2066 6f72 2039 206c 696e 6573 2c20 6275   for 9 lines, bu
+0002c410: 7420 616c 7761 7973 2073 686f 7720 282d  t always show (-
+0002c420: 3336 302b 6570 732c 202d 3138 302c 202d  360+eps, -180, -
+0002c430: 6570 7329 0a20 2020 2020 2020 2020 2020  eps).           
+0002c440: 2023 2073 6d61 6c6c 6573 7420 7370 6163   # smallest spac
+0002c450: 696e 6720 6973 2034 352c 2062 6967 6765  ing is 45, bigge
+0002c460: 7374 2069 7320 3138 300a 2020 2020 2020  st is 180.      
+0002c470: 2020 2020 2020 7068 6173 655f 7370 616e        phase_span
+0002c480: 203d 2070 6861 7365 5f72 6f75 6e64 5f6d   = phase_round_m
+0002c490: 6178 202d 2070 6861 7365 5f72 6f75 6e64  ax - phase_round
+0002c4a0: 5f6d 696e 0a20 2020 2020 2020 2020 2020  _min.           
+0002c4b0: 2073 7061 6369 6e67 203d 206e 702e 636c   spacing = np.cl
+0002c4c0: 6970 2872 6f75 6e64 2870 6861 7365 5f73  ip(round(phase_s
+0002c4d0: 7061 6e20 2f20 3820 2f20 3435 2920 2a20  pan / 8 / 45) * 
+0002c4e0: 3435 2c20 3435 2c20 3138 3029 0a20 2020  45, 45, 180).   
+0002c4f0: 2020 2020 2020 2020 206b 6579 5f63 6c5f           key_cl_
+0002c500: 7068 6173 6573 203d 206e 702e 6172 7261  phases = np.arra
+0002c510: 7928 5b2d 302e 3235 2c20 2d33 3539 2e37  y([-0.25, -359.7
+0002c520: 355d 290a 2020 2020 2020 2020 2020 2020  5]).            
+0002c530: 6f74 6865 725f 636c 5f70 6861 7365 7320  other_cl_phases 
+0002c540: 3d20 6e70 2e61 7261 6e67 6528 2d73 7061  = np.arange(-spa
+0002c550: 6369 6e67 2c20 2d33 3630 2e30 2c20 2d73  cing, -360.0, -s
+0002c560: 7061 6369 6e67 290a 2020 2020 2020 2020  pacing).        
+0002c570: 2020 2020 636c 5f70 6861 7365 7320 3d20      cl_phases = 
+0002c580: 6e70 2e75 6e69 7175 6528 6e70 2e63 6f6e  np.unique(np.con
+0002c590: 6361 7465 6e61 7465 2828 6b65 795f 636c  catenate((key_cl
+0002c5a0: 5f70 6861 7365 732c 206f 7468 6572 5f63  _phases, other_c
+0002c5b0: 6c5f 7068 6173 6573 2929 290a 2020 2020  l_phases))).    
+0002c5c0: 2020 2020 656c 6966 206e 6f74 2028 282d      elif not ((-
+0002c5d0: 3336 3020 3c20 6e70 2e6d 696e 2863 6c5f  360 < np.min(cl_
+0002c5e0: 7068 6173 6573 2929 2061 6e64 2028 6e70  phases)) and (np
+0002c5f0: 2e6d 6178 2863 6c5f 7068 6173 6573 2920  .max(cl_phases) 
+0002c600: 3c20 302e 3029 293a 0a20 2020 2020 2020  < 0.0)):.       
+0002c610: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+0002c620: 4572 726f 7228 2763 6c5f 7068 6173 6573  Error('cl_phases
+0002c630: 206d 7573 7420 6265 7477 6565 6e20 2d33   must between -3
+0002c640: 3630 2061 6e64 2030 2c20 6578 636c 7573  60 and 0, exclus
+0002c650: 6976 6527 290a 0a20 2020 2020 2020 2073  ive')..        s
+0002c660: 656c 662e 636c 5f6d 6167 7320 3d20 636c  elf.cl_mags = cl
+0002c670: 5f6d 6167 730a 2020 2020 2020 2020 7365  _mags.        se
+0002c680: 6c66 2e63 6c5f 7068 6173 6573 203d 2063  lf.cl_phases = c
+0002c690: 6c5f 7068 6173 6573 0a0a 2020 2020 2020  l_phases..      
+0002c6a0: 2020 2320 4669 6e64 2074 6865 204d 2d63    # Find the M-c
+0002c6b0: 6f6e 746f 7572 730a 2020 2020 2020 2020  ontours.        
+0002c6c0: 6d20 3d20 7365 6c66 2e6d 5f63 6972 636c  m = self.m_circl
+0002c6d0: 6573 280a 2020 2020 2020 2020 2020 2020  es(.            
+0002c6e0: 636c 5f6d 6167 732c 2070 6861 7365 5f6d  cl_mags, phase_m
+0002c6f0: 696e 3d6e 702e 6d69 6e28 636c 5f70 6861  in=np.min(cl_pha
+0002c700: 7365 7329 2c20 7068 6173 655f 6d61 783d  ses), phase_max=
+0002c710: 6e70 2e6d 6178 2863 6c5f 7068 6173 6573  np.max(cl_phases
+0002c720: 2929 0a20 2020 2020 2020 206d 5f6d 6167  )).        m_mag
+0002c730: 203d 2032 302a 6e70 2e6c 6f67 3130 286e   = 20*np.log10(n
+0002c740: 702e 6162 7328 6d29 290a 2020 2020 2020  p.abs(m)).      
+0002c750: 2020 6d5f 7068 6173 6520 3d20 6e70 2e6d    m_phase = np.m
+0002c760: 6f64 286e 702e 6465 6772 6565 7328 6e70  od(np.degrees(np
+0002c770: 2e61 6e67 6c65 286d 2929 2c20 2d33 3630  .angle(m)), -360
+0002c780: 2e30 2920 2023 2055 6e77 7261 700a 0a20  .0)  # Unwrap.. 
+0002c790: 2020 2020 2020 2023 2046 696e 6420 7468         # Find th
+0002c7a0: 6520 4e2d 636f 6e74 6f75 7273 0a20 2020  e N-contours.   
+0002c7b0: 2020 2020 206e 203d 2073 656c 662e 6e5f       n = self.n_
+0002c7c0: 6369 7263 6c65 7328 636c 5f70 6861 7365  circles(cl_phase
+0002c7d0: 732c 206d 6167 5f6d 696e 3d6e 702e 6d69  s, mag_min=np.mi
+0002c7e0: 6e28 636c 5f6d 6167 7329 2c20 6d61 675f  n(cl_mags), mag_
+0002c7f0: 6d61 783d 6e70 2e6d 6178 2863 6c5f 6d61  max=np.max(cl_ma
+0002c800: 6773 2929 0a20 2020 2020 2020 206e 5f6d  gs)).        n_m
+0002c810: 6167 203d 2032 302a 6e70 2e6c 6f67 3130  ag = 20*np.log10
+0002c820: 286e 702e 6162 7328 6e29 290a 2020 2020  (np.abs(n)).    
+0002c830: 2020 2020 6e5f 7068 6173 6520 3d20 6e70      n_phase = np
+0002c840: 2e6d 6f64 286e 702e 6465 6772 6565 7328  .mod(np.degrees(
+0002c850: 6e70 2e61 6e67 6c65 286e 2929 2c20 2d33  np.angle(n)), -3
+0002c860: 3630 2e30 2920 2023 2055 6e77 7261 700a  60.0)  # Unwrap.
+0002c870: 0a20 2020 2020 2020 2023 2050 6c6f 7420  .        # Plot 
+0002c880: 7468 6520 636f 6e74 6f75 7273 2062 6568  the contours beh
+0002c890: 696e 6420 6f74 6865 7220 706c 6f74 2065  ind other plot e
+0002c8a0: 6c65 6d65 6e74 732e 0a20 2020 2020 2020  lements..       
+0002c8b0: 2023 2054 6865 2022 7068 6173 6520 6f66   # The "phase of
+0002c8c0: 6673 6574 2220 6973 2075 7365 6420 746f  fset" is used to
+0002c8d0: 2070 726f 6475 6365 2063 6f70 6965 7320   produce copies 
+0002c8e0: 6f66 2074 6865 2063 6861 7274 2074 6861  of the chart tha
+0002c8f0: 7420 636f 7665 720a 2020 2020 2020 2020  t cover.        
+0002c900: 2320 7468 6520 656e 7469 7265 2072 616e  # the entire ran
+0002c910: 6765 206f 6620 7468 6520 706c 6f74 7465  ge of the plotte
+0002c920: 6420 6461 7461 2c20 7374 6172 7469 6e67  d data, starting
+0002c930: 2066 726f 6d20 6120 6261 7365 2063 6861   from a base cha
+0002c940: 7274 2063 6f6d 7075 7465 640a 2020 2020  rt computed.    
+0002c950: 2020 2020 2320 6f76 6572 2074 6865 2072      # over the r
+0002c960: 616e 6765 202d 3336 3020 3c20 7068 6173  ange -360 < phas
+0002c970: 6520 3c20 302e 2047 6976 656e 2074 6865  e < 0. Given the
+0002c980: 2072 616e 6765 0a20 2020 2020 2020 2023   range.        #
+0002c990: 2074 6865 2062 6173 6520 6368 6172 7420   the base chart 
+0002c9a0: 6973 2063 6f6d 7075 7465 6420 6f76 6572  is computed over
+0002c9b0: 2c20 7468 6520 7068 6173 6520 6f66 6673  , the phase offs
+0002c9c0: 6574 2073 686f 756c 6420 6265 2030 0a20  et should be 0. 
+0002c9d0: 2020 2020 2020 2023 2066 6f72 202d 3336         # for -36
+0002c9e0: 3020 3c20 6f6c 5f70 6861 7365 5f6d 696e  0 < ol_phase_min
+0002c9f0: 203c 2030 2e0a 2020 2020 2020 2020 7068   < 0..        ph
+0002ca00: 6173 655f 6f66 6673 6574 7320 3d20 3336  ase_offsets = 36
+0002ca10: 3020 2b20 6e70 2e61 7261 6e67 6528 7068  0 + np.arange(ph
+0002ca20: 6173 655f 726f 756e 645f 6d69 6e2c 2070  ase_round_min, p
+0002ca30: 6861 7365 5f72 6f75 6e64 5f6d 6178 2c20  hase_round_max, 
+0002ca40: 3336 302e 3029 0a20 2020 2020 2020 2072  360.0).        r
+0002ca50: 6574 7572 6e20 6d5f 6d61 672c 206d 5f70  eturn m_mag, m_p
+0002ca60: 6861 7365 2c20 6e5f 6d61 672c 206e 5f70  hase, n_mag, n_p
+0002ca70: 6861 7365 2c20 7068 6173 655f 6f66 6673  hase, phase_offs
+0002ca80: 6574 730a 0a0a 636c 6173 7320 4d43 6972  ets...class MCir
+0002ca90: 636c 6573 5365 7269 6573 2847 7269 6442  clesSeries(GridB
+0002caa0: 6173 652c 2042 6173 6553 6572 6965 7329  ase, BaseSeries)
+0002cab0: 3a0a 2020 2020 6465 6620 5f5f 696e 6974  :.    def __init
+0002cac0: 5f5f 2873 656c 662c 206d 6167 6e69 7475  __(self, magnitu
+0002cad0: 6465 735f 6462 2c20 6d61 676e 6974 7564  des_db, magnitud
+0002cae0: 6573 2c20 2a2a 6b77 6172 6773 293a 0a20  es, **kwargs):. 
+0002caf0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+0002cb00: 5f69 6e69 745f 5f28 2a2a 6b77 6172 6773  _init__(**kwargs
+0002cb10: 290a 2020 2020 2020 2020 7365 6c66 2e6d  ).        self.m
+0002cb20: 6167 6e69 7475 6465 735f 6462 203d 2054  agnitudes_db = T
+0002cb30: 7570 6c65 282a 6d61 676e 6974 7564 6573  uple(*magnitudes
+0002cb40: 5f64 6229 0a20 2020 2020 2020 2073 656c  _db).        sel
+0002cb50: 662e 6d61 676e 6974 7564 6573 203d 2073  f.magnitudes = s
+0002cb60: 656c 662e 5f65 7870 7220 3d20 5475 706c  elf._expr = Tupl
+0002cb70: 6528 2a6d 6167 6e69 7475 6465 7329 0a20  e(*magnitudes). 
+0002cb80: 2020 2020 2020 2073 656c 662e 7368 6f77         self.show
+0002cb90: 5f6d 696e 7573 5f6f 6e65 203d 206b 7761  _minus_one = kwa
+0002cba0: 7267 732e 6765 7428 2273 686f 775f 6d69  rgs.get("show_mi
+0002cbb0: 6e75 735f 6f6e 6522 2c20 4661 6c73 6529  nus_one", False)
+0002cbc0: 0a0a 2020 2020 6465 6620 6765 745f 6461  ..    def get_da
+0002cbd0: 7461 2873 656c 6629 3a0a 2020 2020 2020  ta(self):.      
+0002cbe0: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
+0002cbf0: 7475 726e 730a 2020 2020 2020 2020 3d3d  turns.        ==
+0002cc00: 3d3d 3d3d 3d0a 0a20 2020 2020 2020 2064  =====..        d
+0002cc10: 6174 6120 3a20 6c69 7374 0a20 2020 2020  ata : list.     
+0002cc20: 2020 2020 2020 2045 6163 6820 656c 656d         Each elem
+0002cc30: 656e 7420 6f66 2074 6865 206c 6973 7420  ent of the list 
+0002cc40: 6861 7320 7468 6520 666f 726d 3a0a 2020  has the form:.  
+0002cc50: 2020 2020 2020 2020 2020 6060 5b6d 6167            ``[mag
+0002cc60: 6e69 7475 6465 5f64 622c 2078 5f63 6f6f  nitude_db, x_coo
+0002cc70: 7264 732c 2079 5f63 6f6f 7264 735d 6060  rds, y_coords]``
+0002cc80: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+0002cc90: 2020 2020 2020 6e70 203d 2069 6d70 6f72        np = impor
+0002cca0: 745f 6d6f 6475 6c65 2822 6e75 6d70 7922  t_module("numpy"
+0002ccb0: 290a 2020 2020 2020 2020 6461 7461 203d  ).        data =
+0002ccc0: 205b 5d0a 2020 2020 2020 2020 6d61 676e   [].        magn
+0002ccd0: 6974 7564 6573 203d 2073 656c 662e 6d61  itudes = self.ma
+0002cce0: 676e 6974 7564 6573 0a20 2020 2020 2020  gnitudes.       
+0002ccf0: 206d 6167 6e69 7475 6465 735f 6462 203d   magnitudes_db =
+0002cd00: 2073 656c 662e 6d61 676e 6974 7564 6573   self.magnitudes
+0002cd10: 5f64 620a 2020 2020 2020 2020 6966 2073  _db.        if s
+0002cd20: 656c 662e 6973 5f69 6e74 6572 6163 7469  elf.is_interacti
+0002cd30: 7665 3a0a 2020 2020 2020 2020 2020 2020  ve:.            
+0002cd40: 6d61 676e 6974 7564 6573 203d 206d 6167  magnitudes = mag
+0002cd50: 6e69 7475 6465 732e 7375 6273 2873 656c  nitudes.subs(sel
+0002cd60: 662e 7061 7261 6d73 290a 2020 2020 2020  f.params).      
+0002cd70: 2020 2020 2020 6d61 676e 6974 7564 6573        magnitudes
+0002cd80: 5f64 6220 3d20 6d61 676e 6974 7564 6573  _db = magnitudes
+0002cd90: 5f64 622e 7375 6273 2873 656c 662e 7061  _db.subs(self.pa
+0002cda0: 7261 6d73 290a 2020 2020 2020 2020 6d61  rams).        ma
+0002cdb0: 676e 6974 7564 6573 203d 206e 702e 6172  gnitudes = np.ar
+0002cdc0: 7261 7928 6d61 676e 6974 7564 6573 2c20  ray(magnitudes, 
+0002cdd0: 6474 7970 653d 666c 6f61 7429 0a20 2020  dtype=float).   
+0002cde0: 2020 2020 206d 6167 6e69 7475 6465 735f       magnitudes_
+0002cdf0: 6462 203d 206e 702e 6172 7261 7928 6d61  db = np.array(ma
+0002ce00: 676e 6974 7564 6573 5f64 622c 2064 7479  gnitudes_db, dty
+0002ce10: 7065 3d66 6c6f 6174 290a 0a20 2020 2020  pe=float)..     
+0002ce20: 2020 2074 6865 7461 203d 206e 702e 6c69     theta = np.li
+0002ce30: 6e73 7061 6365 2830 2c20 322a 6e70 2e70  nspace(0, 2*np.p
+0002ce40: 692c 2034 3030 290a 2020 2020 2020 2020  i, 400).        
+0002ce50: 6374 203d 206e 702e 636f 7328 7468 6574  ct = np.cos(thet
+0002ce60: 6129 0a20 2020 2020 2020 2073 7420 3d20  a).        st = 
+0002ce70: 6e70 2e73 696e 2874 6865 7461 290a 2020  np.sin(theta).  
+0002ce80: 2020 2020 2020 666f 7220 6d64 622c 206d        for mdb, m
+0002ce90: 2069 6e20 7a69 7028 6d61 676e 6974 7564   in zip(magnitud
+0002cea0: 6573 5f64 622c 206d 6167 6e69 7475 6465  es_db, magnitude
+0002ceb0: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+0002cec0: 6966 206e 6f74 206e 702e 6973 636c 6f73  if not np.isclos
+0002ced0: 6528 6d64 622c 2030 293a 0a20 2020 2020  e(mdb, 0):.     
+0002cee0: 2020 2020 2020 2020 2020 2072 203d 206d             r = m
+0002cef0: 202f 2028 3120 2d20 6d2a 2a32 290a 2020   / (1 - m**2).  
+0002cf00: 2020 2020 2020 2020 2020 2020 2020 7820                x 
+0002cf10: 3d20 6d2a 2a32 202f 2028 3120 2d20 6d2a  = m**2 / (1 - m*
+0002cf20: 2a32 2920 2b20 7220 2a20 6374 0a20 2020  *2) + r * ct.   
+0002cf30: 2020 2020 2020 2020 2020 2020 2079 203d               y =
+0002cf40: 2072 202a 2073 740a 2020 2020 2020 2020   r * st.        
+0002cf50: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0002cf60: 2020 2020 2020 2020 2020 7820 3d20 5b2d            x = [-
+0002cf70: 302e 355d 0a20 2020 2020 2020 2020 2020  0.5].           
+0002cf80: 2020 2020 2079 203d 205b 305d 0a20 2020       y = [0].   
+0002cf90: 2020 2020 2020 2020 2064 6174 612e 6170           data.ap
+0002cfa0: 7065 6e64 285b 6d64 622c 2078 2c20 795d  pend([mdb, x, y]
+0002cfb0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0002cfc0: 2064 6174 610a                            data.
```

### Comparing `sympy_plot_backends-3.1.1/spb/utils.py` & `sympy_plot_backends-3.2.0/spb/utils.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 from spb.defaults import cfg
 from sympy import (
     Tuple, sympify, Expr, Dummy, sin, cos, Symbol, Indexed, ImageSet,
-    FiniteSet, Basic, Float, Integer, Rational, Poly, fraction, exp
+    FiniteSet, Basic, Float, Integer, Rational, Poly, fraction, exp,
+    NumberSymbol
 )
 from sympy.vector import BaseScalar
 from sympy.core.function import AppliedUndef
 from sympy.core.relational import Relational
 from sympy.logic.boolalg import BooleanFunction
 from sympy.external import import_module
 import warnings
@@ -677,18 +678,19 @@
         s = FiniteSet(*[next(it) for n in range(0, n)])
         set_sol = set_sol.subs(im, s)
     return set_sol
 
 
 def is_number(t, allow_complex=True):
     if allow_complex:
-        number_types = (Float, Integer, Rational, float, int, complex)
+        number_types = (NumberSymbol, Float, Integer, Rational,
+            float, int, complex)
     else:
-        number_types = (Float, Integer, Rational, float, int)
-    return isinstance(t, number_types)
+        number_types = (NumberSymbol, Float, Integer, Rational, float, int)
+    return isinstance(t, number_types) or (isinstance(t, Expr) and t.is_number)
 
 
 def tf_to_control(tf, gen=None):
     """Convert a transfer function to a ``control.TransferFunction``.
 
     Parameters
     ==========
```

### Comparing `sympy_plot_backends-3.1.1/spb/wegert.py` & `sympy_plot_backends-3.2.0/spb/wegert.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/sympy_plot_backends.egg-info/PKG-INFO` & `sympy_plot_backends-3.2.0/sympy_plot_backends.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sympy_plot_backends
-Version: 3.1.1
+Version: 3.2.0
 Summary: Backends for plotting with SymPy
 Home-page: https://github.com/Davide-sd/sympy-plot-backends
 Author: Davide Sandona
 Author-email: sandona.davide@gmail.com
 License: BSD License
 Keywords: sympy plot plotting backend plotly bokeh mayavi k3d panel
 Classifier: Development Status :: 5 - Production/Stable
```

### Comparing `sympy_plot_backends-3.1.1/sympy_plot_backends.egg-info/SOURCES.txt` & `sympy_plot_backends-3.2.0/sympy_plot_backends.egg-info/SOURCES.txt`

 * *Files 3% similar despite different names*

```diff
@@ -23,15 +23,23 @@
 spb/backends/bokeh/renderers/arrow2d.py
 spb/backends/bokeh/renderers/complex.py
 spb/backends/bokeh/renderers/contour.py
 spb/backends/bokeh/renderers/generic.py
 spb/backends/bokeh/renderers/geometry.py
 spb/backends/bokeh/renderers/hvline.py
 spb/backends/bokeh/renderers/line2d.py
+spb/backends/bokeh/renderers/mcircles.py
+spb/backends/bokeh/renderers/ngrid.py
+spb/backends/bokeh/renderers/nichols.py
+spb/backends/bokeh/renderers/nyquist.py
+spb/backends/bokeh/renderers/polezero.py
+spb/backends/bokeh/renderers/root_locus.py
+spb/backends/bokeh/renderers/sgrid.py
 spb/backends/bokeh/renderers/vector2d.py
+spb/backends/bokeh/renderers/zgrid.py
 spb/backends/k3d/__init__.py
 spb/backends/k3d/k3d.py
 spb/backends/k3d/renderers/__init__.py
 spb/backends/k3d/renderers/arrow3d.py
 spb/backends/k3d/renderers/complex.py
 spb/backends/k3d/renderers/geometry.py
 spb/backends/k3d/renderers/implicit3d.py
@@ -49,15 +57,17 @@
 spb/backends/matplotlib/renderers/geometry.py
 spb/backends/matplotlib/renderers/hvline.py
 spb/backends/matplotlib/renderers/implicit2d.py
 spb/backends/matplotlib/renderers/line2d.py
 spb/backends/matplotlib/renderers/line3d.py
 spb/backends/matplotlib/renderers/mcircles.py
 spb/backends/matplotlib/renderers/ngrid.py
+spb/backends/matplotlib/renderers/nichols.py
 spb/backends/matplotlib/renderers/nyquist.py
+spb/backends/matplotlib/renderers/polezero.py
 spb/backends/matplotlib/renderers/renderer.py
 spb/backends/matplotlib/renderers/root_locus.py
 spb/backends/matplotlib/renderers/sgrid.py
 spb/backends/matplotlib/renderers/surface.py
 spb/backends/matplotlib/renderers/vector2d.py
 spb/backends/matplotlib/renderers/vector3d.py
 spb/backends/matplotlib/renderers/zgrid.py
@@ -130,13 +140,17 @@
 tests/graphics/test_complex_analysis.py
 tests/graphics/test_control.py
 tests/graphics/test_control_min_module.py
 tests/graphics/test_functions_2d.py
 tests/graphics/test_functions_3d.py
 tests/graphics/test_graphics.py
 tests/graphics/test_vectors.py
+tests/interactive/__init__.py
+tests/interactive/test_interactive.py
+tests/interactive/test_ipywidgets.py
+tests/interactive/test_panel.py
 tests/plot_functions/__init__.py
 tests/plot_functions/test_complex.py
 tests/plot_functions/test_control.py
 tests/plot_functions/test_functions_2d.py
 tests/plot_functions/test_functions_3d.py
 tests/plot_functions/test_vectors.py
```

### Comparing `sympy_plot_backends-3.1.1/tests/backends/__init__.py` & `sympy_plot_backends-3.2.0/tests/backends/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/backends/make_tests.py` & `sympy_plot_backends-3.2.0/tests/backends/make_tests.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,25 +1,26 @@
 from spb import (
     plot, plot_parametric, plot_polar, plot_list, plot_implicit,
     plot_contour, plot_piecewise, plot_geometry,
     plot3d_parametric_line, plot3d, plot3d_list,
     plot3d_implicit, plot3d_parametric_surface,
     plot_vector, plot_complex, plot_real_imag, plot_riemann_sphere,
     graphics, arrow_2d, arrow_3d, plot_root_locus, plot_pole_zero,
-    ngrid, sgrid, zgrid
+    ngrid, sgrid, zgrid, mcircles, surface, surface_parametric, line
 )
 from spb.series import (
-    SurfaceOver2DRangeSeries, ParametricSurfaceSeries, LineOver1DRangeSeries
+    SurfaceOver2DRangeSeries, ParametricSurfaceSeries, LineOver1DRangeSeries,
+    HVLineSeries
 )
 from sympy import (
     symbols, sin, cos, pi, exp, Matrix, sqrt, Heaviside, Piecewise, Eq, I,
     Circle, Line, Polygon, Ellipse, Curve, Point2D, Segment, Rational,
     Point3D, Line3D, Plane, log, gamma, tan
 )
-from sympy.abc import a, b, c, x, y, z, u, v, t
+from sympy.abc import a, b, c, x, y, z, u, v, s, t
 import numpy as np
 
 
 def options():
     return dict(n=5, adaptive=False, show=False)
 
 
@@ -48,73 +49,67 @@
         (cos(x**2 + y**2), (x, 2, 3), (y, -3, 3)),
         use_cm=False,
         backend=B,
         **opts
     )
 
 
-def make_plot_1(B, rendering_kw, use_latex=False):
+def make_test_plot(B, rendering_kw, use_latex=False):
     return plot(
-        sin(x),
-        cos(x),
+        sin(a * x),
+        cos(b * x),
         rendering_kw=rendering_kw,
         backend=B,
         legend=True,
         use_latex=use_latex,
+        params={a: (1, 0, 2), b: (1, 0, 2)},
         **options()
     )
 
 
-def make_plot_parametric_1(B, rendering_kw):
+def make_test_plot_parametric(B, use_cm, rendering_kw={}):
     return plot_parametric(
-        cos(x), sin(x),
+        cos(a * x), sin(b * x),
         (x, 0, 1.5 * pi),
+        use_cm=use_cm,
         backend=B,
         rendering_kw=rendering_kw,
         use_latex=False,
+        params={a: (1, 0, 2), b: (1, 0, 2)},
         **options()
     )
 
 
-def make_plot3d_parametric_line_1(B, rendering_kw, show=False):
+def make_test_plot3d_parametric_line(B, rendering_kw, use_latex, use_cm, show=False):
     opts = options()
     opts["show"] = show
     return plot3d_parametric_line(
-        cos(x), sin(x), x,
+        cos(a * x), sin(b * x), x,
         (x, -pi, pi),
         backend=B,
         rendering_kw=rendering_kw,
-        use_latex=False,
+        use_latex=use_latex,
+        use_cm=use_cm,
+        params={a: (1, 0, 2), b: (1, 0, 2)},
         **opts
     )
 
 
-def make_plot3d_1(B, rendering_kw, show=False):
+def make_test_plot3d(B, rendering_kw, use_cm, use_latex, show=False):
     opts = options()
     opts["show"] = show
     return plot3d(
-        cos(x**2 + y**2),
+        cos(a * x**2 + y**2),
+        sin(b * x**2 + y**2),
         (x, -3, 3), (y, -3, 3),
-        use_cm=False,
+        use_latex=use_latex,
+        use_cm=use_cm,
         backend=B,
         rendering_kw=rendering_kw,
-        **opts
-    )
-
-
-def make_plot3d_2(B, show=False):
-    opts = options()
-    opts["show"] = show
-    return plot3d(
-        cos(x**2 + y**2),
-        sin(x**2 + y**2),
-        (x, -3, 3), (y, -3, 3),
-        use_cm=True,
-        backend=B,
-        use_latex=False,
+        params={a: (1, 0, 2), b: (1, 0, 2)},
         **opts
     )
 
 
 def make_plot3d_wireframe_1(B, wf=True):
     return plot3d(
         cos(x**2 + y**2), (x, -2, 2), (y, -3, 3),
@@ -218,209 +213,151 @@
         wireframe=wf,
         wf_n1=5,
         wf_n2=6,
         **opts
     )
 
 
-def make_plot_contour_1(B, rendering_kw):
+def make_test_plot_contour(B, rendering_kw, use_latex):
     return plot_contour(
-        cos(x**2 + y**2), (x, -3, 3), (y, -3, 3),
+        cos(a * x**2 + y**2), (x, -3, 3), (y, -3, 3),
         backend=B,
         rendering_kw=rendering_kw,
-        use_latex=False,
+        use_latex=use_latex,
+        params={a: (1, 0, 2)},
         **options()
     )
 
 
 def make_plot_contour_is_filled(B, is_filled):
     return plot_contour(
         cos(x**2 + y**2), (x, -3, 3), (y, -3, 3),
         backend=B,
         use_latex=False,
         is_filled=is_filled,
         **options()
     )
 
 
-def make_plot_vector_2d_quiver(B, contour_kw, quiver_kw):
+def make_test_plot_vector_2d_quiver(B, contour_kw, quiver_kw):
     return plot_vector(
-        Matrix([x, y]),
+        Matrix([a * x, y]),
         (x, -5, 5), (y, -4, 4),
         backend=B,
         quiver_kw=quiver_kw,
         contour_kw=contour_kw,
         use_latex=False,
+        params={a: (1, 0, 2)},
         **options()
     )
 
 
-def make_plot_vector_2d_streamlines_1(B, stream_kw, contour_kw):
-    return plot_vector(
-        Matrix([x, y]),
-        (x, -5, 5), (y, -4, 4),
-        backend=B,
-        stream_kw=stream_kw,
-        contour_kw=contour_kw,
-        scalar=(x + y),
-        streamlines=True,
-        use_latex=False,
-        **options()
-    )
-
-
-def make_plot_vector_2d_streamlines_2(B, stream_kw, contour_kw):
+def make_test_plot_vector_2d_streamlines(
+    B, stream_kw, contour_kw, scalar, use_latex=False
+):
     return plot_vector(
-        Matrix([x, y]),
+        Matrix([a * x, y]),
         (x, -5, 5), (y, -4, 4),
         backend=B,
         stream_kw=stream_kw,
         contour_kw=contour_kw,
-        scalar=[(x + y), "test"],
+        scalar=scalar,
         streamlines=True,
-        use_latex=False,
+        use_latex=use_latex,
+        params={a: (1, 0, 2)},
         **options()
     )
 
 
-def make_plot_vector_3d_quiver(B, quiver_kw, show=False, **kwargs):
+def make_test_plot_vector_3d_quiver_streamlines(
+    B, streamlines, quiver_kw={}, stream_kw={}, show=False, **kwargs
+):
     opts = options()
     opts["show"] = show
     opts.pop("adaptive")
     return plot_vector(
-        Matrix([z, y, x]),
+        Matrix([a * z, y, x]),
         (x, -5, 5), (y, -4, 4), (z, -3, 3),
         backend=B,
         quiver_kw=quiver_kw,
-        use_latex=False,
-        **opts,
-        **kwargs
-    )
-
-
-def make_plot_vector_3d_streamlines_1(B, stream_kw, show=False, kwargs=dict()):
-    opts = options()
-    opts["show"] = show
-    opts.pop("adaptive")
-    return plot_vector(
-        Matrix([z, y, x]),
-        (x, -5, 5), (y, -4, 4), (z, -3, 3),
-        backend=B,
         stream_kw=stream_kw,
-        streamlines=True,
-        use_latex=False,
+        streamlines=streamlines,
+        params={a: (1, 0, 2)},
         **opts,
         **kwargs
     )
 
 
-def make_plot_vector_2d_normalize_1(B, norm):
-    opts = options()
-    opts.pop("adaptive")
-    return plot_vector(
-        [-sin(y), cos(x)],
-        (x, -2, 2), (y, -2, 2),
-        backend=B,
-        normalize=norm,
-        scalar=False,
-        use_cm=False,
-        **opts
-    )
-
-
-def make_plot_vector_2d_normalize_2(B, norm):
+def make_test_plot_vector_2d_normalize(B, norm):
     opts = options()
     opts.pop("adaptive")
     return plot_vector(
         [-u * sin(y), cos(x)],
         (x, -2, 2), (y, -2, 2),
         backend=B,
         normalize=norm,
         scalar=False,
         use_cm=False,
         params={u: (1, 0, 2)},
         **options()
     )
 
 
-def make_plot_vector_3d_normalize_1(B, norm):
-    opts = options()
-    opts.pop("adaptive")
-    return plot_vector(
-        [z, -x, y],
-        (x, -2, 2), (y, -2, 2), (z, -2, 2),
-        backend=B,
-        normalize=norm,
-        use_cm=False,
-        **opts
-    )
-
-
-def make_plot_vector_3d_normalize_2(B, norm):
+def make_test_plot_vector_3d_normalize(B, norm):
     opts = options()
     opts.pop("adaptive")
     return plot_vector(
         [u * z, -x, y],
         (x, -2, 2), (y, -2, 2), (z, -2, 2),
         backend=B,
         normalize=norm,
         use_cm=False,
         params={u: (1, 0, 2)},
         **opts
     )
 
 
-def make_plot_vector_2d_quiver_color_func_1(B, cf):
-    opts = options()
-    opts.pop("adaptive")
+def make_test_plot_vector_2d_color_func(B, streamlines, cf):
     return plot_vector(
-        (-y, x), (x, -2, 2), (y, -2, 2),
+        (-a * y, x), (x, -2, 2), (y, -2, 2),
         scalar=False,
+        streamlines=streamlines,
         use_cm=True,
         color_func=cf,
+        show=False,
         backend=B,
-        **opts
-    )
-
-
-def make_plot_vector_3d_quiver_color_func_1(B, cf):
-    opts = options()
-    opts.pop("adaptive")
-    return plot_vector(
-        Matrix([z, y, x]),
-        (x, -2, 2), (y, -2, 2), (z, -2, 2),
-        backend=B,
-        color_func=cf,
-        **opts
+        n=3,
+        params={a: (1, 0, 2)},
     )
 
 
-def make_plot_vector_3d_quiver_color_func_2(B, cf):
+def make_test_plot_vector_3d_quiver_color_func(B, cf):
     opts = options()
     opts.pop("adaptive")
     return plot_vector(
         Matrix([a * z, a * y, a * x]),
         (x, -2, 2), (y, -2, 2), (z, -2, 2),
         backend=B,
         color_func=cf,
         params={a: (1, 0, 2)},
         **opts
     )
 
 
-def make_plot_vector_3d_streamlines_color_func(B, cf):
+def make_test_plot_vector_3d_streamlines_color_func(B, cf):
     # NOTE: better keep a decent number of discretization points in order to
     # be sure to have streamlines
     return plot_vector(
-        Matrix([z, y, x]),
+        Matrix([a*z, y, x]),
         (x, -2, 2), (y, -2, 2), (z, -2, 2),
         streamlines=True,
         show=False,
         backend=B,
         color_func=cf,
+        params={a: (1, 0, 2)},
         n=7,
     )
 
 
 def make_test_plot_implicit_adaptive_true(B, rendering_kw):
     return plot_implicit(
         x > y, (x, -5, 5), (y, -4, 4),
@@ -440,40 +377,41 @@
         adaptive=False,
         show=False,
         rendering_kw=rendering_kw,
         use_latex=False,
     )
 
 
-def make_test_real_imag(B, rendering_kw):
+def make_test_real_imag(B, rendering_kw, use_latex):
     return plot_real_imag(
         sqrt(x), (x, -5, 5),
         backend=B,
         rendering_kw=rendering_kw,
-        use_latex=False,
+        use_latex=use_latex,
         **options()
     )
 
 
-def make_test_plot_complex_1d(B, rendering_kw):
+def make_test_plot_complex_1d(B, rendering_kw, use_latex):
     return plot_complex(
         sqrt(x), (x, -5, 5),
-        backend=B, rendering_kw=rendering_kw,
+        backend=B, rendering_kw=rendering_kw, use_latex=use_latex,
         **options()
     )
 
 
-def make_test_plot_complex_2d(B, rendering_kw):
+def make_test_plot_complex_2d(B, rendering_kw, use_latex=False):
     opts = options()
     opts.pop("adaptive")
     return plot_complex(
         sqrt(x), (x, -5 - 5 * I, 5 + 5 * I),
         backend=B,
         coloring="a",
         rendering_kw=rendering_kw,
+        use_latex=use_latex,
         **opts
     )
 
 
 def make_test_plot_complex_3d(B, rendering_kw):
     opts = options()
     opts.pop("adaptive")
@@ -483,33 +421,21 @@
         rendering_kw=rendering_kw,
         threed=True,
         use_cm=False,
         **opts
     )
 
 
-def make_test_plot_list_is_filled_false(B):
-    return plot_list(
-        [1, 2, 3],
-        [1, 2, 3],
-        backend=B,
-        is_point=True,
-        is_filled=False,
-        show=False,
-        use_latex=False,
-    )
-
-
-def make_test_plot_list_is_filled_true(B):
+def make_test_plot_list_is_filled(B, is_filled):
     return plot_list(
         [1, 2, 3],
         [1, 2, 3],
         backend=B,
         is_point=True,
-        is_filled=True,
+        is_filled=is_filled,
         show=False,
         use_latex=False,
     )
 
 
 def make_test_plot_list_color_func(B):
     return plot_list(
@@ -583,26 +509,14 @@
         (Line3D(Point3D(-2, -3, -4), Point3D(2, 3, 4)), "line"),
         (Plane((0, 0, 0), (1, 1, 1)), (x, -5, 5), (y, -4, 4), (z, -10, 10)),
         show=False,
         backend=B,
     )
 
 
-def make_test_vectors_3d_update_interactive(B):
-    return plot_vector(
-        [a * z, b * y, c * x],
-        (x, -5, 5), (y, -5, 5), (z, -5, 5),
-        params={a: (1, 0, 2), b: (1, 0, 2), c: (1, 0, 2)},
-        streamlines=True,
-        n=5,
-        backend=B,
-        show=False,
-    )
-
-
 def make_test_aspect_ratio_2d_issue_11764(B, aspect="auto"):
     return plot_parametric(
         cos(x), sin(x), (x, 0, 2 * pi), backend=B, aspect=aspect, **options()
     )
 
 
 def make_test_aspect_ratio_3d(B, aspect="auto", show=False):
@@ -641,171 +555,14 @@
         cos(x1**2 + x2**2), (x1, -1, 1), (x2, -1, 1),
         backend=B,
         use_latex=use_latex,
         **opts
     )
 
 
-def make_test_plot_use_latex(B):
-    return plot(
-        sin(x), cos(x),
-        backend=B, legend=True, use_latex=True,
-        **options()
-    )
-
-
-def make_test_plot_parametric_use_latex(B):
-    return plot_parametric(
-        cos(x), sin(x), (x, 0, 1.5 * pi),
-        backend=B, use_latex=True,
-        **options()
-    )
-
-
-def make_test_plot_contour_use_latex(B):
-    return plot_contour(
-        cos(x**2 + y**2),
-        (x, -3, 3), (y, -3, 3),
-        backend=B,
-        use_latex=True,
-        **options()
-    )
-
-
-def make_test_plot3d_parametric_line_use_latex(B, show=False):
-    opts = options()
-    opts["show"] = show
-    return plot3d_parametric_line(
-        cos(x), sin(x), x, (x, -pi, pi), backend=B, use_latex=True, **opts
-    )
-
-
-def make_test_plot3d_use_latex(B, show=False):
-    opts = options()
-    opts["show"] = show
-    return plot3d(
-        cos(x**2 + y**2),
-        sin(x**2 + y**2),
-        (x, -3, 3), (y, -3, 3),
-        use_cm=True,
-        backend=B,
-        use_latex=True,
-        **opts
-    )
-
-
-def make_test_plot_vector_2d_quivers_use_latex(B):
-    return plot_vector(
-        Matrix([x, y]), (x, -5, 5), (y, -4, 4),
-        backend=B, **options()
-    )
-
-
-def make_test_plot_vector_2d_streamlines_custom_scalar_field_use_latex(B):
-    return plot_vector(
-        Matrix([x, y]),
-        (x, -5, 5), (y, -4, 4),
-        backend=B,
-        scalar=(x + y),
-        streamlines=True,
-        use_latex=True,
-        **options()
-    )
-
-
-def make_test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex(B):
-    return plot_vector(
-        Matrix([x, y]),
-        (x, -5, 5), (y, -4, 4),
-        backend=B,
-        scalar=[(x + y), "test"],
-        streamlines=True,
-        use_latex=True,
-        **options()
-    )
-
-
-def make_test_plot_vector_2d_use_latex_colorbar(B, scalar, streamlines):
-    opts = options()
-    opts.pop("adaptive")
-    return plot_vector(
-        Matrix([x, y]),
-        (x, -5, 5), (y, -4, 4),
-        backend=B,
-        scalar=scalar,
-        streamlines=streamlines,
-        use_cm=True,
-        use_latex=True,
-        **opts
-    )
-
-
-def make_test_plot_vector_3d_quivers_use_latex(B, show=False):
-    opts = options()
-    opts["show"] = show
-    opts.pop("adaptive")
-    return plot_vector(
-        Matrix([z, y, x]),
-        (x, -5, 5), (y, -4, 4), (z, -3, 3),
-        backend=B,
-        use_cm=True,
-        use_latex=True,
-        **opts
-    )
-
-
-def make_test_plot_vector_3d_streamlines_use_latex(B, show=False):
-    opts = options()
-    opts["show"] = show
-    opts.pop("adaptive")
-    return plot_vector(
-        Matrix([z, y, x]),
-        (x, -5, 5), (y, -4, 4), (z, -3, 3),
-        backend=B,
-        streamlines=True,
-        use_latex=True,
-        **opts
-    )
-
-
-def make_test_plot_complex_use_latex_1(B):
-    return plot_complex(
-        cos(x) + sin(I * x), (x, -2, 2),
-        use_latex=True, backend=B,
-        **options()
-    )
-
-
-def make_test_plot_complex_use_latex_2(B):
-    opts = options()
-    opts.pop("adaptive")
-    return plot_complex(
-        gamma(z), (z, -3 - 3 * I, 3 + 3 * I),
-        use_latex=True, backend=B,
-        **opts
-    )
-
-
-def make_test_plot_real_imag_use_latex(B):
-    return plot_real_imag(
-        sqrt(x), (x, -3, 3),
-        backend=B, use_latex=True,
-        **options()
-    )
-
-
-def make_test_plot3d_use_cm(B, use_cm, show=False):
-    opts = options()
-    opts["show"] = show
-    return plot3d(
-        cos(x**2 + y**2), (x, -1, 1), (y, -1, 1),
-        backend=B, use_cm=use_cm, **opts
-    )
-
-
 def make_test_plot_polar(B, pa=False):
     return plot_polar(
         1 + sin(10 * x) / 10, (x, 0, 2 * pi),
         backend=B,
         polar_axis=pa,
         aspect="equal",
         **options()
@@ -831,95 +588,58 @@
     return plot3d_implicit(
         x**2 + y**3 - z**2,
         (x, -2, 2), (y, -2, 2), (z, -2, 2),
         backend=B, **opts
     )
 
 
-def make_test_surface_color_func_1(B, col, show=False):
-    opts = options()
-    opts["show"] = show
-    return plot3d(
-        cos(x**2 + y**2), (x, -3, 3), (y, -3, 3),
-        backend=B,
-        color_func=col,
-        use_cm=True,
-        **opts
-    )
-
-
-def make_test_surface_color_func_2(B, col, show=False):
-    opts = options()
-    opts["show"] = show
-    opts.pop("adaptive")
-    r = 2 + sin(7 * u + 5 * v)
-    expr = (r * cos(u) * sin(v), r * sin(u) * sin(v), r * cos(v))
-    return plot3d_parametric_surface(
-        *expr, (u, 0, 2 * pi), (v, 0, pi),
-        use_cm=True,
-        backend=B,
-        color_func=col,
-        **opts
-    )
-
-
-def make_test_surface_interactive_color_func(B):
+def make_test_surface_color_func(B):
     expr1 = t * cos(x**2 + y**2)
     r = 2 + sin(7 * u + 5 * v)
     expr2 = (t * r * cos(u) * sin(v), r * sin(u) * sin(v), r * cos(v))
+    params = {t: (1, 0, 2)}
 
-    s1 = SurfaceOver2DRangeSeries(
-        expr1, (x, -5, 5), (y, -5, 5),
-        n1=5, n2=5,
-        params={t: 1},
-        use_cm=True,
-        color_func=lambda x, y, z: z,
-    )
-    s2 = SurfaceOver2DRangeSeries(
-        expr1, (x, -5, 5), (y, -5, 5),
-        n1=5, n2=5,
-        params={t: 1},
-        use_cm=True,
-        color_func=lambda x, y, z: np.sqrt(x**2 + y**2),
-    )
-    s3 = ParametricSurfaceSeries(
-        *expr2, (u, -5, 5), (v, -5, 5),
-        n1=5, n2=5,
-        params={t: 1},
-        use_cm=True,
-        color_func=lambda x, y, z, u, v: z
-    )
-    s4 = ParametricSurfaceSeries(
-        *expr2, (u, -5, 5), (v, -5, 5),
-        n1=5, n2=5,
-        params={t: 1},
-        use_cm=True,
-        color_func=lambda x, y, z, u, v: np.sqrt(x**2 + y**2)
-    )
-    return B(s1, s2, s3, s4)
-
-
-def make_test_line_color_func(B, col):
-    return plot(
-        cos(x), (x, -3, 3),
-        backend=B, color_func=col, legend=True,
-        **options()
+    return graphics(
+        surface(expr1, (x, -5, 5), (y, -5, 5),
+            n1=5, n2=5,
+            params=params,
+            use_cm=True,
+            color_func=lambda x, y, z: z),
+        surface(expr1, (x, -5, 5), (y, -5, 5),
+            n1=5, n2=5,
+            params=params,
+            use_cm=True,
+            color_func=lambda x, y, z: np.sqrt(x**2 + y**2)),
+        surface_parametric(
+            *expr2, (u, -5, 5), (v, -5, 5),
+            n1=5, n2=5,
+            params=params,
+            use_cm=True,
+            color_func=lambda x, y, z, u, v: z
+        ),
+        surface_parametric(
+            *expr2, (u, -5, 5), (v, -5, 5),
+            n1=5, n2=5,
+            params=params,
+            use_cm=True,
+            color_func=lambda x, y, z, u, v: np.sqrt(x**2 + y**2)
+        ),
+        backend=B, show=False
     )
 
 
-def make_test_line_interactive_color_func(B):
+def make_test_line_color_func(B):
     expr = t * cos(x * t)
-    s1 = LineOver1DRangeSeries(
-        expr, (x, -3, 3), n=5, params={t: 1}, color_func=None
-    )
-    s2 = LineOver1DRangeSeries(
-        expr, (x, -3, 3), n=5, params={t: 1},
-        color_func=lambda x, y: np.cos(x)
+    params = {t: (1, 0, 2)}
+    return graphics(
+        line(expr, (x, -3, 3), n=5, params=params, color_func=None),
+        line(expr, (x, -3, 3), n=5, params=params,
+            color_func=lambda x, y: np.cos(x)),
+        backend=B, show=False
     )
-    return B(s1, s2)
 
 
 def make_test_line_color_plot(B, lc):
     return plot(sin(x), line_color=lc, backend=B, **options())
 
 
 def make_test_line_color_plot3d_parametric_line(B, lc, use_cm, show=False):
@@ -943,78 +663,44 @@
         backend=B,
         use_cm=use_cm,
         legend=True,
         **opts
     )
 
 
-def make_test_plot3d_list_use_cm_False(B, is_point, is_filled=False):
-    x = [0, 1, 2, 3, 4, 5]
-    y = [5, 4, 3, 2, 1, 0]
-    z = [1, 3, 2, 4, 6, 5]
-
-    return plot3d_list(
-        x, y, z,
+def make_test_plot3d_list(B, is_filled, cf):
+    z1 = np.linspace(0, 6 * np.pi, 10)
+    c = np.cos(z1)
+    s = np.sin(z1)
+    x1 = z1 * c
+    y1 = z1 * s
+
+    p1 = plot3d_list(x1, y1, z1, show=False, backend=B, is_point=False,
+        use_cm=False)
+    p2 = plot3d_list(x1, y1, z1, show=False, backend=B, is_point=True,
+        is_filled=is_filled, use_cm=False)
+    p3 = plot3d_list(
+        [t * coeff1*coeff2 for coeff1, coeff2 in zip(c, z1)],
+        [t * coeff1*coeff2 for coeff1, coeff2 in zip(s, z1)],
+        [t * coeff for coeff in z1],
+        params={t: (1, 0, 6 * pi)},
         backend=B,
-        is_point=is_point,
-        is_filled=is_filled,
-        use_cm=False,
         show=False,
-    )
-
-
-def make_test_plot3d_list_use_cm_color_func(
-    B, is_point, is_filled=False, cf=None
-):
-    x = [0, 1, 2, 3, 4, 5]
-    y = [5, 4, 3, 2, 1, 0]
-    z = [1, 3, 2, 4, 6, 5]
-
-    return plot3d_list(
-        (x, y, z),
-        (z, y, x),
-        backend=B,
-        is_point=is_point,
+        is_point=True,
         is_filled=is_filled,
         use_cm=True,
-        show=False,
         color_func=cf,
     )
+    return p3 + p2 + p1
 
 
-def make_test_plot3d_list_interactive(B):
-    z1 = np.linspace(0, 6 * np.pi, 10)
-    x1 = z1 * np.cos(z1)
-    y1 = z1 * np.sin(z1)
-
-    p1 = plot3d_list(x1, y1, z1, show=False, backend=B, is_point=False)
-    p2 = plot3d_list(
-        [t * cos(t)], [t * sin(t)], [t],
-        params={t: (0, 0, 6 * pi)},
-        backend=B,
-        show=False,
-        is_point=True,
-    )
-    return p2 + p1
-
-
-def make_test_contour_show_clabels_1(B, clabels):
-    return plot_contour(
-        cos(x * y), (x, -2, 2), (y, -2, 2),
-        backend=B,
-        is_filled=False,
-        clabels=clabels,
-        **options()
-    )
-
-
-def make_test_contour_show_clabels_2(B, clabels):
+def make_test_contour_show_clabels(B, clabels):
     return plot_contour(
-        cos(u * x * y), (x, -2, 2), (y, -2, 2),
-        params={u: (1, 0, 1)},
+        cos(a * x * y), (x, -2, 2), (y, -2, 2),
+        params={a: (1, 0, 1)},
         backend=B,
         is_filled=False,
         clabels=clabels,
         **options()
     )
 
 
@@ -1040,14 +726,23 @@
         use_cm=True,
         color_func=sqrt(x**2 + y**2),
         params={u: (1, 0, 1)},
         **options()
     )
 
 
+def make_test_plot3d_use_cm(B, use_cm, show=False):
+    opts = options()
+    opts["show"] = show
+    return plot3d(
+        cos(x**2 + y**2), (x, -1, 1), (y, -1, 1),
+        backend=B, use_cm=use_cm, **opts
+    )
+
+
 def make_test_domain_coloring_2d(B, at_infinity):
     return plot_complex(
         (z - 1) / (z**2 + z + 1),
         (z, -3 - 3 * I, 3 + 3 * I),
         at_infinity=at_infinity,
         n=10, backend=B, show=False,
     )
@@ -1187,47 +882,56 @@
             ylabel=("test b={:.2f}", b),
             zlabel=("test a={:.2f}, b={:.2f}", a, b),
         ),
     )
 
 
 def make_test_arrow_2d(B, lbl, rkw, sil):
+    params = {a: (3, 0, 5), b: (4, 0, 5)}
     return graphics(
         arrow_2d(
-            (1, 2), (3, 4), label=lbl, rendering_kw=rkw, show_in_legend=sil),
+            (1, 2), (a, b), label=lbl, rendering_kw=rkw,
+            show_in_legend=sil, params=params),
         show=False, backend=B, legend=True
     )
 
 
 def make_test_arrow_3d(B, lbl, rkw, sil):
+    params = {a: (4, 0, 6), b: (5, 0, 6), c: (6, 0, 6)}
     return graphics(
         arrow_3d(
-            (1, 2, 3), (4, 5, 6), label=lbl, rendering_kw=rkw, show_in_legend=sil),
+            (1, 2, 3), (a, b, c), label=lbl, rendering_kw=rkw,
+            show_in_legend=sil, params=params),
         show=False, backend=B, legend=True
     )
 
 
 def make_test_root_locus_1(B, sgrid, zgrid):
-    s = symbols("s")
-    G = (s**2 + 1) / (s**3 + 2*s**2 + 3*s + 4)
+    G = (a * s**2 + 1) / (s**3 + 2*s**2 + 3*s + 4)
     return plot_root_locus(G, backend=B, show=False,
-        sgrid=sgrid, zgrid=zgrid)
+        sgrid=sgrid, zgrid=zgrid, params={a: (1, 0, 2)})
 
 
 def make_test_root_locus_2(B):
-    s = symbols("s")
     G1 = (s**2 + 1) / (s**3 + 2*s**2 + 3*s + 4)
     G2 = (s**2 - 4) / (s**3 + 2*s - 3)
     return plot_root_locus((G1, "a"), (G2, "b"), backend=B, show=False)
 
 
+def make_test_plot_pole_zero(B, sgrid, zgrid, T, is_filled):
+    G = (a * s**2 + 1) / (s**4 + 4*s**3 + 6*s**2 + 5*s + 2)
+    return plot_pole_zero(G, show=False, backend=B,
+        params={a: (1, 0, 2)}, T=T, sgrid=sgrid, zgrid=zgrid,
+        is_filled=is_filled)
+
+
 def make_test_poles_zeros_sgrid(B):
-    s = symbols("s")
-    G = (s**2 + 1) / (s**4 + 4*s**3 + 6*s**2 + 5*s + 2)
-    return plot_pole_zero(G, sgrid=True, show=False, backend=B)
+    G = (a * s**2 + 1) / (s**4 + 4*s**3 + 6*s**2 + 5*s + 2)
+    return plot_pole_zero(G, sgrid=True, show=False, backend=B,
+        params={a: (1, 0, 2)})
 
 
 def make_test_ngrid(B, cl_mags, cl_phases, label_cl_phases):
     return graphics(
         ngrid(cl_mags, cl_phases, label_cl_phases),
         grid=False, show=False, backend=B
     )
@@ -1243,7 +947,22 @@
 
 def make_test_zgrid(B, xi, wn, tp, ts, show_control_axis, **kwargs):
     return graphics(
         zgrid(xi, wn, tp, ts,
             show_control_axis=show_control_axis, **kwargs),
         grid=False, show=False, backend=B
     )
+
+
+def make_test_mcircles(B, mag):
+    return graphics(
+        mcircles(mag), backend=B, show=False, grid=False
+    )
+
+
+def make_test_hvlines(B):
+    p = {a: (1, 0, 5), b: (2, 0, 5)}
+    return graphics(
+        HVLineSeries(a, horizontal=True, params=p),
+        HVLineSeries(b, horizontal=False, params=p),
+        backend=B, show=False
+    )
```

### Comparing `sympy_plot_backends-3.1.1/tests/backends/test_bokeh.py` & `sympy_plot_backends-3.2.0/tests/backends/test_bokeh.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,85 +1,85 @@
 import pytest
 from pytest import raises
 bokeh = pytest.importorskip("bokeh")
-from bokeh.models import ColumnDataSource, Span, Arrow
+from bokeh.models import (
+    ColumnDataSource, Span, Arrow, LabelSet, Label, Line as BLine, Scatter,
+    MultiLine
+)
 import os
 from tempfile import TemporaryDirectory
 import numpy as np
 from spb import (
     BB, plot, plot_complex, plot_vector, plot_contour,
-    plot_parametric, plot_geometry,
+    plot_parametric, plot_geometry, plot_nyquist, plot_nichols
 )
+from spb.series import RootLocusSeries, SGridLineSeries, ZGridLineSeries
 from sympy import (
     sin, cos, I, pi, Circle, Polygon, sqrt, Matrix, Line, latex, symbols
 )
-from sympy.abc import x, y, z, u, t
+from sympy.abc import a, b, c, x, y, z, u, t
+from sympy.external import import_module
 from .make_tests import (
     custom_colorloop_1,
-    make_plot_1,
-    make_plot_parametric_1,
-    make_plot3d_parametric_line_1,
-    make_plot3d_1,
-    make_plot3d_2,
+    make_test_plot,
+    make_test_plot_parametric,
+    make_test_plot3d_parametric_line,
+    make_test_plot3d,
     make_plot3d_wireframe_1,
     make_plot3d_wireframe_2,
     make_plot3d_wireframe_3,
-    make_plot_contour_1,
-    make_plot_vector_2d_quiver,
-    make_plot_vector_2d_streamlines_1,
-    make_plot_vector_2d_streamlines_2,
-    make_plot_vector_3d_quiver,
-    make_plot_vector_3d_streamlines_1,
-    make_plot_vector_2d_normalize_1,
-    make_plot_vector_2d_normalize_2,
-    make_plot_vector_2d_quiver_color_func_1,
+    make_test_plot_contour,
+    make_test_plot_vector_2d_quiver,
+    make_test_plot_vector_2d_streamlines,
+    make_test_plot_vector_3d_quiver_streamlines,
+    make_test_plot_vector_2d_normalize,
+    make_test_plot_vector_2d_color_func,
     make_test_plot_implicit_adaptive_true,
     make_test_plot_implicit_adaptive_false,
     make_test_plot_complex_1d,
     make_test_plot_complex_2d,
     make_test_plot_complex_3d,
-    make_test_plot_list_is_filled_false,
-    make_test_plot_list_is_filled_true,
+    make_test_plot_list_is_filled,
     make_test_plot_piecewise_single_series,
     make_test_plot_piecewise_multiple_series,
     make_test_plot_geometry_1,
     make_test_plot_geometry_2,
     make_test_aspect_ratio_2d_issue_11764,
     make_test_plot_size,
     make_test_plot_scale_lin_log,
     make_test_backend_latex_labels_1,
-    make_test_plot_use_latex,
-    make_test_plot_parametric_use_latex,
-    make_test_plot_contour_use_latex,
-    make_test_plot_vector_2d_quivers_use_latex,
-    make_test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex,
-    make_test_plot_vector_2d_streamlines_custom_scalar_field_use_latex,
-    make_test_plot_vector_2d_use_latex_colorbar,
-    make_test_plot_complex_use_latex_1,
-    make_test_plot_complex_use_latex_2,
-    make_test_plot_real_imag_use_latex,
     make_test_plot_polar,
     make_test_plot_polar_use_cm,
     make_test_plot3d_implicit,
-    make_test_line_interactive_color_func,
     make_test_line_color_plot,
     make_test_color_func_expr_1,
     make_test_legend_plot_sum_1,
     make_test_legend_plot_sum_2,
     make_test_domain_coloring_2d,
     make_test_show_in_legend_2d,
     make_test_detect_poles,
     make_test_detect_poles_interactive,
     make_test_plot_riemann_sphere,
     make_test_parametric_texts_2d,
     make_test_line_color_func,
     make_test_plot_list_color_func,
     make_test_real_imag,
-    make_test_arrow_2d
+    make_test_arrow_2d,
+    make_test_root_locus_1,
+    make_test_root_locus_2,
+    make_test_plot_pole_zero,
+    make_test_poles_zeros_sgrid,
+    make_test_ngrid,
+    make_test_sgrid,
+    make_test_zgrid,
+    make_test_mcircles,
+    make_test_hvlines
 )
+ipy = import_module("ipywidgets")
+ct = import_module("control")
 
 
 # NOTE
 # While BB, PB, KB creates the figure at instantiation, MB creates the figure
 # once the `show()` method is called. All backends do not populate the figure
 # at instantiation. Numerical data is added only when `show()` or `fig` is
 # called.
@@ -88,37 +88,25 @@
 # or `draw()`.
 
 
 class BBchild(BB):
     colorloop = ["red", "green", "blue"]
 
 
-def test_colorloop_colormaps():
-    # verify that backends exposes important class attributes enabling
-    # automatic coloring
-
-    assert hasattr(BB, "colorloop")
-    assert isinstance(BB.colorloop, (list, tuple))
-    assert hasattr(BB, "colormaps")
-    assert isinstance(BB.colormaps, (list, tuple))
-
-
 def test_bokeh_tools():
     # verify tools and tooltips on empty Bokeh figure (populated figure
     # might have different tooltips, tested later on)
 
     f = plot(backend=BB, show=False).fig
-    assert len(f.toolbar.tools) == 6
+    assert len(f.toolbar.tools) == 5
     assert isinstance(f.toolbar.tools[0], bokeh.models.PanTool)
     assert isinstance(f.toolbar.tools[1], bokeh.models.WheelZoomTool)
     assert isinstance(f.toolbar.tools[2], bokeh.models.BoxZoomTool)
     assert isinstance(f.toolbar.tools[3], bokeh.models.ResetTool)
-    assert isinstance(f.toolbar.tools[4], bokeh.models.HoverTool)
-    assert isinstance(f.toolbar.tools[5], bokeh.models.SaveTool)
-    assert f.toolbar.tools[4].tooltips == [("x", "$x"), ("y", "$y")]
+    assert isinstance(f.toolbar.tools[4], bokeh.models.SaveTool)
 
 
 def test_custom_colorloop():
     # verify that it is possible to modify the backend's class attributes
     # in order to change custom coloring
 
     assert len(BBchild.colorloop) != len(BB.colorloop)
@@ -134,86 +122,92 @@
         [isinstance(t.glyph, bokeh.models.glyphs.Line) for t in f2.renderers]
     )
     # there are 6 unique colors in _p1 and 3 unique colors in _p2
     assert len(set([r.glyph.line_color for r in f1.renderers])) == 6
     assert len(set([r.glyph.line_color for r in f2.renderers])) == 3
 
 
-def test_plot():
+@pytest.mark.parametrize(
+    "use_latex, xlabel, ylabel", [
+        (False, "x", "f(x)"),
+        (True, "$x$", "$f\\left(x\\right)$")
+    ]
+)
+def test_plot_1(use_latex, xlabel, ylabel, label_func):
     # verify that the backends produce the expected results when `plot()`
     # is called and `rendering_kw` overrides the default line settings
 
-    p = make_plot_1(BB, rendering_kw=dict(line_color="red"))
-    assert len(p.series) == 2
+    p = make_test_plot(BB, rendering_kw=dict(line_color="red"),
+        use_latex=use_latex)
+    assert len(p.backend.series) == 2
     f = p.fig
     assert len(f.renderers) == 2
     assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.Line)
-    assert f.legend[0].items[0].label["value"] == "sin(x)"
+    assert f.legend[0].items[0].label["value"] == label_func(use_latex, sin(a * x))
     assert f.renderers[0].glyph.line_color == "red"
     assert isinstance(f.renderers[1].glyph, bokeh.models.glyphs.Line)
-    assert f.legend[0].items[1].label["value"] == "cos(x)"
+    assert f.legend[0].items[1].label["value"] == label_func(use_latex, cos(b * x))
     assert f.renderers[1].glyph.line_color == "red"
     assert f.legend[0].visible is True
-
-    p = make_plot_1(BB, rendering_kw=dict(line_color="red"), use_latex=True)
-    f = p.fig
-    assert f.legend[0].items[0].label["value"] == "$\\sin{\\left(x \\right)}$"
+    assert f.xaxis.axis_label == xlabel
+    assert f.yaxis.axis_label == ylabel
+    p.backend.update_interactive({a: 2, b: 2})
 
 
 def test_plot_parametric():
     # verify that the backends produce the expected results when
     # `plot_parametric()` is called and `rendering_kw` overrides the default
     # line settings
 
-    p = make_plot_parametric_1(BB, rendering_kw=dict(line_color="red"))
-    assert len(p.series) == 1
+    p = make_test_plot_parametric(BB, rendering_kw=dict(line_color="red"),
+        use_cm=False)
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.renderers) == 1
-    assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.MultiLine)
+    assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.Line)
     assert f.renderers[0].glyph.line_color == "red"
+    p.backend.update_interactive({a: 2, b: 2})
+
+    # TODO: would love to pass in a colormap, but it's not possible :(
+    # Hence, test just a line color
+    p = make_test_plot_parametric(BB, rendering_kw=dict(line_color="red"),
+        use_cm=True)
+    assert len(p.backend.series) == 1
+    f = p.fig
+    assert len(f.renderers) == 1
+    assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.MultiLine)
     # 1 colorbar
     assert len(f.right) == 1
     assert f.right[0].title == "x"
-    assert f.toolbar.tools[-2].tooltips == [("x", "$x"), ("y", "$y"), ("u", "@us")]
+    assert f.toolbar.tools[-1].tooltips == [("x", "@xs"), ("y", "@ys"), ("u", "@us")]
 
 
 def test_plot3d_parametric_line():
     # verify that the backends produce the expected results when
     # `plot3d_parametric_line()` is called and `rendering_kw` overrides the
     # default line settings
 
     # Bokeh doesn't support 3D plots
-    raises(
-        NotImplementedError,
-        lambda: make_plot3d_parametric_line_1(
-            BB, rendering_kw=dict(line_color="red")
-        ).draw(),
+    p = make_test_plot3d_parametric_line(
+        BB, dict(line_color="red"), False, False
     )
+    raises(NotImplementedError, lambda: p.fig)
 
 
-def test_plot3d():
+def test_plot3d_1():
     # verify that the backends produce the expected results when
     # `plot3d()` is called and `rendering_kw` overrides the default surface
     # settings
 
     # Bokeh doesn't support 3D plots
-    raises(
-        NotImplementedError,
-        lambda: make_plot3d_1(
-            BB, rendering_kw=dict(colorscale=[[0, "cyan"], [1, "cyan"]])
-        ).draw(),
+    p = make_test_plot3d(
+        BB, dict(colorscale=[[0, "cyan"], [1, "cyan"]]),
+        False, False
     )
-
-
-def test_plot3d_2():
-    # verify that the backends uses string labels when `plot3d()` is called
-    # with `use_latex=False` and `use_cm=True`
-
-    # Bokeh doesn't support 3D plots
-    raises(NotImplementedError, lambda: make_plot3d_2(BB).draw())
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot3d_wireframe():
     # verify that wireframe=True is going to add the expected number of line
     # data series and that appropriate keyword arguments work as expected
 
     # Bokeh doesn't support 3D plots
@@ -224,134 +218,137 @@
     )
     raises(
         NotImplementedError,
         lambda: make_plot3d_wireframe_3(BB, {}).draw()
     )
 
 
-def test_plot_contour():
+@pytest.mark.parametrize(
+    "use_latex, xl, yl", [
+        (False, "x", "y"),
+        (True, "$x$", "$y$")
+    ]
+)
+def test_plot_contour(use_latex, xl, yl, label_func):
     # verify that the backends produce the expected results when
     # `plot_contour()` is called and `rendering_kw` overrides the default
     # surface settings
 
     # Bokeh doesn't use rendering_kw dictionary. Nothing to customize yet.
-    p = make_plot_contour_1(BB, rendering_kw=dict())
-    assert len(p.series) == 1
+    p = make_test_plot_contour(BB, rendering_kw=dict(), use_latex=use_latex)
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.renderers) == 1
     assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.Image)
     # 1 colorbar
     assert len(f.right) == 1
-    assert f.right[0].title == str(cos(x**2 + y**2))
+    assert f.right[0].title == label_func(use_latex, cos(a*x**2 + y**2))
+    assert f.xaxis.axis_label == xl
+    assert f.yaxis.axis_label == yl
 
 
-def test_plot_vector_2d_quivers():
+@pytest.mark.parametrize(
+    "pivot, success", [
+        ("mid", True),
+        ("tip", True),
+        ("tail", True),
+        ("asd", False),
+    ]
+)
+def test_plot_vector_2d_quivers(pivot, success):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `contour_kw`/`quiver_kw` overrides the
     # default settings
 
-    p = make_plot_vector_2d_quiver(
-        BB, contour_kw=dict(), quiver_kw=dict(line_color="red")
+    p = make_test_plot_vector_2d_quiver(
+        BB, contour_kw=dict(), quiver_kw=dict(line_color="red", pivot=pivot)
     )
-    assert len(p.series) == 2
-    f = p.fig
-    assert len(f.renderers) == 2
-    assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.Image)
-    assert isinstance(f.renderers[1].glyph, bokeh.models.glyphs.Segment)
-    # 1 colorbar
-    assert len(f.right) == 1
-    assert f.right[0].title == "Magnitude"
-    assert f.renderers[1].glyph.line_color == "red"
-
-
-def test_plot_vector_2d_streamlines_custom_scalar_field():
+    if success:
+        assert len(p.backend.series) == 2
+        f = p.fig
+        assert len(f.renderers) == 2
+        assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.Image)
+        assert isinstance(f.renderers[1].glyph, bokeh.models.glyphs.Segment)
+        # 1 colorbar
+        assert len(f.right) == 1
+        assert f.right[0].title == "Magnitude"
+        assert f.renderers[1].glyph.line_color == "red"
+    else:
+        raises(ValueError, lambda: p.fig)
+
+
+@pytest.mark.parametrize(
+    "scalar, use_latex, expected_label", [
+        (True, False, "Magnitude"),
+        (True, True, "Magnitude"),
+        (x + y, False, "x + y"),
+        (x + y, True, "$x + y$"),
+        ([(x + y), "test"], False, "test"),
+        ([(x + y), "test"], True, "test")
+    ]
+)
+def test_plot_vector_2d_streamlines_custom_scalar_field(
+    scalar, use_latex, expected_label
+):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `contour_kw`/`stream_kw` overrides the
     # default settings
 
-    p = make_plot_vector_2d_streamlines_1(
-        BB, stream_kw=dict(line_color="red"), contour_kw=dict()
+    p = make_test_plot_vector_2d_streamlines(
+        BB, stream_kw=dict(line_color="red"), contour_kw=dict(),
+        scalar=scalar, use_latex=use_latex
     )
-    assert len(p.series) == 2
+    assert len(p.backend.series) == 2
     f = p.fig
     assert len(f.renderers) == 2
     assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.Image)
     assert isinstance(f.renderers[1].glyph, bokeh.models.glyphs.MultiLine)
     # 1 colorbar
     assert len(f.right) == 1
-    assert f.right[0].title == "x + y"
+    assert f.right[0].title == expected_label
     assert f.renderers[1].glyph.line_color == "red"
 
 
-def test_plot_vector_2d_streamlines_custom_scalar_field_custom_label():
-    # verify that the backends produce the expected results when
-    # `plot_vector()` is called and `contour_kw`/`stream_kw` overrides the
-    # default settings
-
-    p = make_plot_vector_2d_streamlines_2(
-        BB, stream_kw=dict(line_color="red"), contour_kw=dict()
-    )
-    f = p.fig
-    assert f.right[0].title == "test"
-
-
-def test_plot_vector_3d_quivers():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_vector_3d_quivers(use_latex):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `quiver_kw` overrides the
     # default settings
 
     # Bokeh doesn't support 3D plots
-    raises(
-        NotImplementedError,
-        lambda: make_plot_vector_3d_quiver(
-            BB, quiver_kw=dict(sizeref=5)).draw(),
-    )
+    p = make_test_plot_vector_3d_quiver_streamlines(
+            BB, False, quiver_kw=dict(sizeref=5), use_latex=use_latex)
+    raises(NotImplementedError, lambda: p.fig)
 
 
-def test_plot_vector_3d_streamlines():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_vector_3d_streamlines(use_latex):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `stream_kw` overrides the
     # default settings
 
     # Bokeh doesn't support 3D plots
-    raises(
-        NotImplementedError,
-        lambda: make_plot_vector_3d_streamlines_1(
-            BB, stream_kw=dict(colorscale=[[0, "red"], [1, "red"]])
-        ).draw(),
-    )
+    p = make_test_plot_vector_3d_quiver_streamlines(
+            BB, True, quiver_kw=dict(sizeref=5), use_latex=use_latex)
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_vector_2d_normalize():
     # verify that backends are capable of normalizing a vector field before
     # plotting it. Since all backend are different from each other, let's test
     # that data in the figures is different in the two cases normalize=True
     # and normalize=False
 
-    p1 = make_plot_vector_2d_normalize_1(BB, False)
-    p2 = make_plot_vector_2d_normalize_1(BB, True)
-    x01 = p1.fig.renderers[0].data_source.data["x0"]
-    x11 = p1.fig.renderers[0].data_source.data["x1"]
-    y01 = p1.fig.renderers[0].data_source.data["y0"]
-    y11 = p1.fig.renderers[0].data_source.data["y1"]
-    m1 = p1.fig.renderers[0].data_source.data["color_val"]
-    x02 = p2.fig.renderers[0].data_source.data["x0"]
-    x12 = p2.fig.renderers[0].data_source.data["x1"]
-    y02 = p2.fig.renderers[0].data_source.data["y0"]
-    y12 = p2.fig.renderers[0].data_source.data["y1"]
-    m2 = p2.fig.renderers[0].data_source.data["color_val"]
-    assert not np.allclose(x01, x02)
-    assert not np.allclose(x11, x12)
-    assert not np.allclose(y01, y02)
-    assert not np.allclose(y11, y12)
-    assert np.allclose(m1, m2)
-
-    p1 = make_plot_vector_2d_normalize_2(BB, False)
+    p1 = make_test_plot_vector_2d_normalize(BB, False)
     p1.backend.update_interactive({u: 1.5})
-    p2 = make_plot_vector_2d_normalize_2(BB, True)
+    p2 = make_test_plot_vector_2d_normalize(BB, True)
     p2.backend.update_interactive({u: 1.5})
     x01 = p1.fig.renderers[0].data_source.data["x0"]
     x11 = p1.fig.renderers[0].data_source.data["x1"]
     y01 = p1.fig.renderers[0].data_source.data["y0"]
     y11 = p1.fig.renderers[0].data_source.data["y1"]
     m1 = p1.fig.renderers[0].data_source.data["color_val"]
     x02 = p2.fig.renderers[0].data_source.data["x0"]
@@ -365,19 +362,22 @@
     assert not np.allclose(y11, y12)
     assert np.allclose(m1, m2)
 
 
 def test_plot_vector_2d_quiver_color_func():
     # verify that color_func gets applied to 2D quivers
 
-    p1 = make_plot_vector_2d_quiver_color_func_1(BB, None)
-    p2 = make_plot_vector_2d_quiver_color_func_1(BB, lambda x, y, u, v: x)
+    p1 = make_test_plot_vector_2d_color_func(BB, False, None)
+    p2 = make_test_plot_vector_2d_color_func(BB, False, lambda x, y, u, v: u)
+    p3 = make_test_plot_vector_2d_color_func(BB, False, lambda x, y, u, v: u)
+    p3.backend.update_interactive({a: 1.5})
     a1 = p1.fig.renderers[0].data_source.data["color_val"]
     a2 = p2.fig.renderers[0].data_source.data["color_val"]
-    assert not np.allclose(a1, a2)
+    a3 = p3.fig.renderers[0].data_source.data["color_val"]
+    assert (not np.allclose(a1, a2)) and (not np.allclose(a2, a3))
 
 
 def test_plot_implicit_adaptive_true():
     # verify that the backends produce the expected results when
     # `plot_implicit()` is called with `adaptive=True`
 
     # BokehBackend doesn't support 2D plots
@@ -397,60 +397,78 @@
     raises(
         NotImplementedError,
         lambda: make_test_plot_implicit_adaptive_false(
             BB, rendering_kw=dict()).draw(),
     )
 
 
-def test_plot_real_imag():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_real_imag(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot_real_imag()` is called and `rendering_kw` overrides the default
     # settings
 
-    p = make_test_real_imag(BB, rendering_kw=dict(line_color="red"))
+    p = make_test_real_imag(BB, rendering_kw=dict(line_color="red"),
+        use_latex=use_latex)
     assert len(p.series) == 2
     f = p.fig
     assert len(f.renderers) == 2
     assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.Line)
     assert f.legend[0].items[0].label["value"] == "Re(sqrt(x))"
     assert f.renderers[0].glyph.line_color == "red"
     assert isinstance(f.renderers[1].glyph, bokeh.models.glyphs.Line)
     assert f.legend[0].items[1].label["value"] == "Im(sqrt(x))"
     assert f.renderers[1].glyph.line_color == "red"
     assert f.legend[0].visible is True
+    assert f.xaxis.axis_label == label_func(use_latex, x)
+    assert f.yaxis.axis_label == r"$f\left(x\right)$" if use_latex else "f(x)"
 
 
-def test_plot_complex_1d():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_complex_1d(use_latex):
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
-    p = make_test_plot_complex_1d(BB, rendering_kw=dict(line_color="red"))
+    p = make_test_plot_complex_1d(BB, rendering_kw=dict(line_color="red"),
+        use_latex=use_latex)
     assert len(p.series) == 1
     f = p.fig
     assert len(f.renderers) == 1
     assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.MultiLine)
     assert f.renderers[0].glyph.line_color == "red"
     # 1 colorbar
     assert len(f.right) == 1
     assert f.right[0].title == "Arg(sqrt(x))"
+    assert f.xaxis.axis_label == "Real"
+    assert f.yaxis.axis_label == "Abs"
 
 
-def test_plot_complex_2d():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_complex_2d(use_latex):
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
-    p = make_test_plot_complex_2d(BB, rendering_kw=dict())
+    p = make_test_plot_complex_2d(BB, rendering_kw=dict(),
+        use_latex=use_latex)
     assert len(p.series) == 1
     f = p.fig
     assert len(f.renderers) == 1
     assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.ImageRGBA)
     assert f.right[0].title == "Argument"
-    assert f.toolbar.tools[-2].tooltips == [
+    assert f.xaxis.axis_label == "Re"
+    assert f.yaxis.axis_label == "Im"
+    assert f.toolbar.tools[-1].tooltips == [
         ("x", "$x"),
         ("y", "$y"),
         ("Abs", "@abs"),
         ("Arg", "@arg"),
     ]
 
 
@@ -462,34 +480,27 @@
     # Bokeh doesn't support 3D plots
     raises(
         NotImplementedError,
         lambda: make_test_plot_complex_3d(BB, rendering_kw=dict()).draw(),
     )
 
 
-def test_plot_list_is_filled_false():
+@pytest.mark.parametrize(
+    "is_filled", [True, False]
+)
+def test_plot_list_is_filled(is_filled):
     # verify that the backends produce the expected results when
     # `plot_list()` is called with `is_filled=False`
 
-    p = make_test_plot_list_is_filled_false(BB)
+    p = make_test_plot_list_is_filled(BB, is_filled)
     assert len(p.series) == 1
     f = p.fig
     assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.Scatter)
-    assert f.renderers[0].glyph.line_color != f.renderers[0].glyph.fill_color
-
-
-def test_plot_list_is_filled_true():
-    # verify that the backends produce the expected results when
-    # `plot_list()` is called with `is_filled=True`
-
-    p = make_test_plot_list_is_filled_true(BB)
-    assert len(p.series) == 1
-    f = p.fig
-    assert isinstance(f.renderers[0].glyph, bokeh.models.glyphs.Scatter)
-    assert f.renderers[0].glyph.line_color == f.renderers[0].glyph.fill_color
+    test = f.renderers[0].glyph.line_color == f.renderers[0].glyph.fill_color
+    assert test is is_filled
 
 
 def test_plot_list_color_func():
     # verify that the backends produce the expected results when
     # `plot_list()` is called with `color_func`
 
     p = make_test_plot_list_color_func(BB)
@@ -537,91 +548,47 @@
     )
     assert f.legend[0].items[0].label["value"] == str(Line((1, 2), (5, 4)))
     assert f.legend[0].items[1].label["value"] == str(Circle((0, 0), 4))
     assert f.legend[0].items[2].label["value"] == str(Polygon((2, 2), 3, n=6))
     assert len(f.legend[0].items) == 3
 
 
-def test_plot_geometry_2():
+@pytest.mark.parametrize(
+    "is_filled, n_lines, n_multiline, n_patches, n_scatt, n_legend", [
+        (False, 4, 1, 0, 1, 5),
+        (True, 1, 1, 3, 4, 5),
+    ]
+)
+def test_plot_geometry_2(
+    is_filled, n_lines, n_multiline, n_patches, n_scatt, n_legend
+):
     # verify that is_filled works correctly
 
-    p = make_test_plot_geometry_2(BB, False)
-    assert (
-        len(
-            [
-                t.glyph
-                for t in p.fig.renderers
-                if isinstance(t.glyph, bokeh.models.glyphs.Line)
-            ]
-        )
-        == 4
-    )
-    assert (
-        len(
-            [
-                t.glyph
-                for t in p.fig.renderers
-                if isinstance(t.glyph, bokeh.models.glyphs.MultiLine)
-            ]
-        )
-        == 1
-    )
+    p = make_test_plot_geometry_2(BB, is_filled)
     assert (
-        len(
-            [
-                t.glyph
-                for t in p.fig.renderers
-                if isinstance(t.glyph, bokeh.models.glyphs.Scatter)
-            ]
-        )
-        == 1
+        len([t.glyph for t in p.fig.renderers
+            if isinstance(t.glyph, bokeh.models.glyphs.Line)])
+        == n_lines
     )
-    assert len(p.fig.legend[0].items) == 5
-    p = make_test_plot_geometry_2(BB, True)
     assert (
-        len(
-            [
-                t.glyph
-                for t in p.fig.renderers
-                if isinstance(t.glyph, bokeh.models.glyphs.Line)
-            ]
-        )
-        == 1
+        len([t.glyph for t in p.fig.renderers
+            if isinstance(t.glyph, bokeh.models.glyphs.MultiLine)])
+        == n_multiline
     )
     assert (
-        len(
-            [
-                t.glyph
-                for t in p.fig.renderers
-                if isinstance(t.glyph, bokeh.models.glyphs.Patch)
-            ]
-        )
-        == 3
+        len([t.glyph for t in p.fig.renderers
+            if isinstance(t.glyph, bokeh.models.glyphs.Patch)])
+        == n_patches
     )
     assert (
-        len(
-            [
-                t.glyph
-                for t in p.fig.renderers
-                if isinstance(t.glyph, bokeh.models.glyphs.MultiLine)
-            ]
-        )
-        == 1
-    )
-    assert (
-        len(
-            [
-                t.glyph
-                for t in p.fig.renderers
-                if isinstance(t.glyph, bokeh.models.glyphs.Scatter)
-            ]
-        )
-        == 1
+        len([t.glyph for t in p.fig.renderers
+            if isinstance(t.glyph, bokeh.models.glyphs.Scatter)])
+        == n_scatt
     )
-    assert len(p.fig.legend[0].items) == 5
+    assert len(p.fig.legend[0].items) == n_legend
 
 
 def test_save(mocker):
     # Verify the save method. Note that:
     #    Bokeh and Plotly should not be able to save static pictures because
     #    by default they need additional libraries. See the documentation of
     #    the save methods for each backends to see what is required.
@@ -706,112 +673,14 @@
     p2 = make_test_backend_latex_labels_1(BB, False)
     assert p1.xlabel == p1.fig.xaxis.axis_label == "$x^{2}_{1}$"
     assert p2.xlabel == p2.fig.xaxis.axis_label == "x_1^2"
     assert p1.ylabel == p1.fig.yaxis.axis_label == "$f\\left(x^{2}_{1}\\right)$"
     assert p2.ylabel == p2.fig.yaxis.axis_label == "f(x_1^2)"
 
 
-def test_plot_use_latex():
-    # verify that the backends produce the expected results when `plot()`
-    # is called and `rendering_kw` overrides the default line settings
-
-    p = make_test_plot_use_latex(BB)
-    f = p.fig
-    assert f.legend[0].items[0].label["value"] == "$\\sin{\\left(x \\right)}$"
-    assert f.legend[0].items[1].label["value"] == "$\\cos{\\left(x \\right)}$"
-    assert f.legend[0].visible is True
-
-
-def test_plot_parametric_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_parametric_use_latex(BB)
-    f = p.fig
-    # 1 colorbar
-    assert len(f.right) == 1
-    assert f.right[0].title == "$x$"
-
-
-def test_plot_contour_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_contour_use_latex(BB)
-    f = p.fig
-    assert f.right[0].title == "$%s$" % latex(cos(x**2 + y**2))
-
-
-def test_plot_vector_2d_quivers_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_quivers_use_latex(BB)
-    f = p.fig
-    assert f.right[0].title == "Magnitude"
-
-
-def test_plot_vector_2d_streamlines_custom_scalar_field_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_streamlines_custom_scalar_field_use_latex(BB)
-    f = p.fig
-    assert f.right[0].title == "$x + y$"
-
-
-def test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex(
-        BB
-    )
-    f = p.fig
-    assert f.right[0].title == "test"
-
-
-def test_plot_vector_2d_use_latex_colorbar():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_use_latex_colorbar(BB, True, False)
-    assert p.fig.right[0].title == "Magnitude"
-
-    p = make_test_plot_vector_2d_use_latex_colorbar(BB, True, True)
-    assert p.fig.right[0].title == "Magnitude"
-
-    p = make_test_plot_vector_2d_use_latex_colorbar(BB, False, False)
-    assert p.fig.right[0].title == "$\\left( x, \\  y\\right)$"
-
-    # Bokeh doesn't support gradient streamlines, hence no colorbar
-    p = make_test_plot_vector_2d_use_latex_colorbar(BB, False, True)
-
-
-@pytest.mark.filterwarnings("ignore::RuntimeWarning")
-def test_plot_complex_use_latex():
-    # complex plot function should return the same result (for axis labels)
-    # wheter use_latex is True or False
-
-    p = make_test_plot_complex_use_latex_1(BB)
-    assert p.fig.right[0].title == "Arg(cos(x) + I*sinh(x))"
-    assert p.fig.xaxis.axis_label == "Real"
-    assert p.fig.yaxis.axis_label == "Abs"
-
-    p = make_test_plot_complex_use_latex_2(BB)
-    assert p.fig.right[0].title == "Argument"
-    assert p.fig.xaxis.axis_label == "Re"
-    assert p.fig.yaxis.axis_label == "Im"
-
-
-def test_plot_real_imag_use_latex():
-    # real/imag plot function should return the same result (for axis labels)
-    # wheter use_latex is True or False
-
-    p = make_test_plot_real_imag_use_latex(BB)
-    assert p.fig.xaxis.axis_label == "$x$"
-    assert p.fig.yaxis.axis_label == r"$f\left(x\right)$"
-    assert p.fig.legend[0].items[0].label["value"] == "Re(sqrt(x))"
-    assert p.fig.legend[0].items[1].label["value"] == "Im(sqrt(x))"
-
-
 def test_plot_polar():
     # verify that 2D polar plot can create plots with cartesian axis and
     #  polar axis
 
     p3 = make_test_plot_polar(BB, False)
     plotly_data = p3[0].get_data()
     bokeh_data = p3.fig.renderers[0].data_source.data
@@ -839,29 +708,19 @@
 def test_plot3d_implicit():
     # verify that plot3d_implicit don't raise errors
 
     raises(NotImplementedError, lambda: make_test_plot3d_implicit(BB).draw())
 
 
 def test_line_color_func():
-    # Verify that backends do not raise errors when plotting lines and that
-    # the color function is applied.
-
-    p1 = make_test_line_color_func(BB, None)
-    p2 = make_test_line_color_func(BB, lambda x, y: np.cos(x))
-    assert isinstance(p1.fig.renderers[0].glyph, bokeh.models.glyphs.Line)
-    assert isinstance(p2.fig.renderers[0].glyph, bokeh.models.glyphs.MultiLine)
-
-
-def test_line_interactive_color_func():
     # Verify that backends do not raise errors when updating lines and a
     # color function is applied.
 
-    p = make_test_line_interactive_color_func(BB)
-    p.update_interactive({t: 2})
+    p = make_test_line_color_func(BB)
+    p.backend.update_interactive({t: 2})
     assert isinstance(p.fig.renderers[0].glyph, bokeh.models.glyphs.Line)
     assert isinstance(p.fig.renderers[1].glyph, bokeh.models.glyphs.MultiLine)
 
 
 def test_line_color_plot():
     # verify back-compatibility with old sympy.plotting module when using
     # line_color
@@ -876,116 +735,81 @@
 def test_update_interactive():
     # quick round down of test to verify that _update_interactive doesn't
     # raise errors
 
     u, v, x, y, z = symbols("u, v, x:z")
 
     p = plot(
-        sin(u * x),
-        (x, -pi, pi),
-        adaptive=False,
-        n=5,
-        backend=BB,
-        show=False,
+        sin(u * x), (x, -pi, pi),
+        adaptive=False, n=5, backend=BB, show=False,
         params={u: (1, 0, 2)},
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
 
     p = plot_parametric(
-        cos(u * x),
-        sin(u * x),
-        (x, 0, 2 * pi),
-        adaptive=False,
-        n=5,
-        backend=BB,
-        show=False,
+        cos(u * x), sin(u * x), (x, 0, 2 * pi),
+        adaptive=False, n=5, backend=BB, show=False,
         params={u: (1, 0, 2)},
         use_cm=True,
         is_point=False,
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
 
     p = plot_parametric(
-        cos(u * x),
-        sin(u * x),
-        (x, 0, 2 * pi),
-        adaptive=False,
-        n=5,
-        backend=BB,
-        show=False,
+        cos(u * x), sin(u * x), (x, 0, 2 * pi),
+        adaptive=False, n=5, backend=BB, show=False,
         params={u: (1, 0, 2)},
         use_cm=True,
         is_point=True,
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
 
     p = plot_parametric(
-        cos(u * x),
-        sin(u * x),
-        (x, 0, 2 * pi),
-        adaptive=False,
-        n=5,
-        backend=BB,
-        show=False,
+        cos(u * x), sin(u * x), (x, 0, 2 * pi),
+        adaptive=False, n=5, backend=BB, show=False,
         params={u: (1, 0, 2)},
         use_cm=False,
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
 
     p = plot_contour(
-        cos(u * x**2 + y**2),
-        (x, -2, 2),
-        (y, -2, 2),
-        backend=BB,
-        show=False,
-        adaptive=False,
+        cos(u * x**2 + y**2), (x, -2, 2), (y, -2, 2),
+        backend=BB, show=False, adaptive=False,
         n=5,
         params={u: (1, 0, 2)},
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
 
     p = plot_vector(
-        Matrix([-u * y, x]),
-        (x, -5, 5),
-        (y, -4, 4),
-        backend=BB,
-        n=4,
-        show=False,
+        Matrix([-u * y, x]), (x, -5, 5), (y, -4, 4),
+        backend=BB, n=4, show=False,
         params={u: (1, 0, 2)},
         streamlines=True,
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
 
     p = plot_vector(
-        Matrix([-u * y, x]),
-        (x, -5, 5),
-        (y, -4, 4),
-        backend=BB,
-        n=4,
-        show=False,
+        Matrix([-u * y, x]), (x, -5, 5), (y, -4, 4),
+        backend=BB, n=4, show=False,
         params={u: (1, 0, 2)},
         streamlines=False,
         scalar=True,
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
 
     p = plot_vector(
-        Matrix([-u * y, x]),
-        (x, -5, 5),
-        (y, -4, 4),
-        backend=BB,
-        n=4,
-        show=False,
+        Matrix([-u * y, x]), (x, -5, 5), (y, -4, 4),
+        backend=BB, n=4, show=False,
         params={u: (1, 0, 2)},
         streamlines=False,
         scalar=False,
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
 
@@ -1275,20 +1099,22 @@
     p.backend.update_interactive({y: 1.5, z: 2})
     assert p.fig.title.text == "y=1.5, z=2.000"
     assert p.fig.xaxis.axis_label == "test y+z=3.50"
     assert p.fig.yaxis.axis_label == "test z=2.00"
 
 
 def test_arrow_2d():
+    a, b = symbols("a, b")
     p = make_test_arrow_2d(BB, "test", {"line_color": "red"}, True)
-    p.fig
-    assert len(p.fig.center) == 3
+    fig = p.fig
+    assert len(fig.center) == 3
     arrows = [t for t in p.fig.center if isinstance(t, Arrow)]
     assert len(arrows) == 1
     assert arrows[0].line_color == "red"
+    p.backend.update_interactive({a: 4, b: 5})
 
 
 def test_existing_figure_lines():
     # verify that user can provide an existing figure containing lines
     # and plot over it
 
     from bokeh.plotting import figure
@@ -1303,7 +1129,384 @@
         backend=BB, show=False, fig=fig, legend=True)
     assert p.fig is fig
     assert len(fig.renderers) == 2
     assert fig.right[0].items[0].label.value == "l1"
     assert fig.renderers[0].glyph.line_color == '#1f77b4'
     assert fig.right[0].items[1].label.value == "l2"
     assert fig.renderers[1].glyph.line_color == '#ff7f0e'
+
+
+@pytest.mark.parametrize("update_event", [
+    False,
+    True
+])
+def test_bokeh_update_ranges(update_event):
+    # verify that `update_event` doesn't raise errors
+
+    class Event:
+        def __init__(self, x0, x1, y0, y1):
+            self.x0 = x0
+            self.x1 = x1
+            self.y0 = y0
+            self.y1 = y1
+
+    x, y = symbols("x, y")
+    p = plot(cos(x), (x, -pi, pi), n=10, backend=BB,
+        show=False, update_event=update_event)
+
+    if update_event:
+        p._ranges_update(Event(-1, 1, -2, 2))
+
+    p = plot_contour(cos(x**2+y**2), (x, -pi, pi), (y, -pi, pi),
+        n=10, backend=BB, show=False, update_event=update_event)
+
+    if update_event:
+        p._ranges_update(Event(-1, 1, -2, 2))
+
+
+@pytest.mark.parametrize(
+    "xi, wn, tp, ts, show_control_axis, params, n_lines, n_hvlines, n_lblsets, n_texts",
+    [
+        (None, None, None, None, True, None, 30, 2, 4, [10, 10, 0, 0]),
+        (None, None, None, None, False, None, 30, 0, 4, [10, 10, 0, 0]),
+        (0.5, False, None, None, False, None, 2, 0, 4, [1, 0, 0, 0]),
+        ([0.5, 0.75], False, None, None, False, None, 4, 0, 4, [2, 0, 0, 0]),
+        (False, 2/3, None, None, False, None, 1, 0, 4, [0, 1, 0, 0]),
+        (False, [2/3, 3/4], None, None, False, None, 2, 0, 4, [0, 2, 0, 0]),
+        (False, False, 2, None, False, None, 1, 0, 4, [0, 0, 1, 0]),
+        (False, False, None, 3, False, None, 1, 0, 4, [0, 0, 0, 1]),
+        (False, False, 2, 3, False, None, 2, 0, 4, [0, 0, 1, 1]),
+        (False, False, [2, 3], 3, False, None, 3, 0, 4, [0, 0, 2, 1]),
+        (False, False, [2, 3], [3, 4], False, None, 4, 0, 4, [0, 0, 2, 2]),
+        (x, y, z, x+y, False,
+            {x:(0.5, 0, 1), y:(0.75, 0, 4), z: (0.8, 0, 5)},
+            5, 0, 4, [1, 1, 1, 1])
+    ]
+)
+def test_zgrid(
+    xi, wn, tp, ts, show_control_axis, params, n_lines, n_hvlines, n_lblsets, n_texts
+):
+    kw = {}
+    if params:
+        if ipy is None:
+            return
+        kw["params"] = params
+
+    p = make_test_zgrid(BB, xi, wn, tp, ts, show_control_axis, **kw)
+    fig = p.backend.fig if params else p.fig
+    assert len(fig.renderers) == n_lines
+    assert len([t for t in fig.center if isinstance(t, Span)]) == n_hvlines
+    assert len([t for t in fig.center if isinstance(t, LabelSet)]) == n_lblsets
+    assert np.allclose(
+        [len(t.source.data["x"]) for t in fig.center if isinstance(t, LabelSet)],
+        n_texts
+    )
+    if params:
+        p.backend.update_interactive({x: 0.75, y: 0.8, z: 0.85})
+
+
+@pytest.mark.parametrize(
+    "xi, wn, tp, ts, auto, show_control_axis, params, n_lines, n_hvlines, n_lblsets, n_texts",
+    [
+        (None, None, None, None, False, True, None, 32, 2, 2, [11, 10]),
+        (None, None, None, None, False, False, None, 35, 0, 2, [11, 10]),
+        (None, None, None, None, True, True, None, 15, 2, 2, [5, 5]),
+        (None, None, None, None, True, False, None, 18, 0, 2, [5, 5]),
+        (0.5, False, None, None, False, False, None, 2, 0, 2, [1, 0]),
+        ([0.5, 0.75], False, None, None, False, False, None, 4, 0, 2, [2, 0]),
+        (False, 2, None, None, False, False, None, 1, 0, 2, [0, 1]),
+        (False, [2, 3], None, None, False, False, None, 2, 0, 2, [0, 2]),
+        (False, False, 2, None, False, False, None, 0, 1, 2, [0, 0]),
+        (False, False, None, 3, False, False, None, 0, 1, 2, [0, 0]),
+        (False, False, 2, 3, False, False, None, 0, 2, 2, [0, 0]),
+        (False, False, [2, 3], 3, False, False, None, 0, 3, 2, [0, 0]),
+        (False, False, [2, 3], [3, 4], False, False, None, 0, 4, 2, [0, 0]),
+        (x, y, z, x+y, False, False,
+            {x:(0.5, 0, 1), y:(2, 0, 4), z: (3, 0, 5)},
+            3, 2, 2, [1, 1])
+    ]
+)
+def test_sgrid(
+    xi, wn, tp, ts, auto, show_control_axis, params, n_lines, n_hvlines,
+    n_lblsets, n_texts
+):
+    kw = {}
+    if params:
+        if ipy is None:
+            return
+        kw["params"] = params
+
+    p = make_test_sgrid(BB, xi, wn, tp, ts, auto, show_control_axis, **kw)
+    fig = p.backend.fig if params else p.fig
+    assert len(fig.renderers) == n_lines
+    assert len([t for t in fig.center if isinstance(t, Span)]) == n_hvlines
+    assert len([t for t in fig.center if isinstance(t, LabelSet)]) == n_lblsets
+    assert np.allclose(
+        [len(t.source.data["x"]) for t in fig.center if isinstance(t, LabelSet)],
+        n_texts
+    )
+    if params:
+        p.backend.update_interactive({x: 0.75, y: 0.8, z: 0.85})
+
+
+@pytest.mark.parametrize(
+    "cl_mags, cl_phases, label_cl_phases, n_lines, n_texts",
+    [
+        (None, None, False, 27, 17),
+        (None, None, True, 27, 26),
+        (-30, False, False, 2, 1),
+        (False, -200, False, 2, 0),
+    ]
+)
+def test_ngrid(cl_mags, cl_phases, label_cl_phases, n_lines, n_texts):
+    p = make_test_ngrid(BB, cl_mags, cl_phases, label_cl_phases)
+    fig = p.fig
+    assert len(fig.renderers) == n_lines
+    assert len([t for t in fig.center if isinstance(t, Label)]) == n_texts
+
+
+@pytest.mark.parametrize(
+    "sgrid, zgrid, T, is_filled", [
+        (True, False, None, True),
+        (False, True, None, True),
+        (True, False, 0.05, True),
+        (False, True, 0.05, True),
+        (False, False, None, False),
+    ]
+)
+def test_plot_pole_zero(sgrid, zgrid, T, is_filled):
+    a = symbols("a")
+    p = make_test_plot_pole_zero(BB, sgrid=sgrid, zgrid=zgrid, T=T,
+        is_filled=is_filled)
+    fig = p.fig
+    p.backend.update_interactive({a: 2})
+
+
+@pytest.mark.filterwarnings("ignore::UserWarning")
+def test_plot_poles_zeros_sgrid():
+    # verify that SGridLineSeries is rendered with "proper" axis limits
+
+    a = symbols("a")
+    p = make_test_poles_zeros_sgrid(BB)
+    fig = p.backend.fig
+    xlim = fig.x_range.start, fig.x_range.end
+    ylim = fig.y_range.start, fig.y_range.end
+    assert (xlim is not None) and (ylim is not None)
+    # these are eyeball numbers, it should allows a little bit of tweeking at
+    # the code for better positioning the grid...
+    assert xlim[0] > -5 and xlim[1] < 2
+    assert ylim[0] > -5 and ylim[1] < 5
+    p.backend.update_interactive({a: 2})
+
+
+@pytest.mark.skipif(ct is None, reason="control is not installed")
+@pytest.mark.parametrize(
+    "sgrid, zgrid, n_renderers, n_lines, n_texts, instance", [
+        (True, False, 18, 16, 2, SGridLineSeries),
+        (False, True, 33, 31, 4, ZGridLineSeries),
+    ]
+)
+def test_plot_root_locus_1(
+    sgrid, zgrid, n_renderers, n_lines, n_texts, instance
+):
+    a = symbols("a")
+    p = make_test_root_locus_1(BB, sgrid, zgrid)
+    assert isinstance(p.backend, BB)
+    assert len(p.backend.series) == 2
+    # NOTE: the backend is going to reorder data series such that grid
+    # series are placed at the end.
+    assert isinstance(p.backend[0], RootLocusSeries)
+    assert isinstance(p.backend[1], instance)
+    fig = p.backend.fig
+    assert len(fig.renderers) == n_renderers
+    assert len([t for t in fig.renderers if isinstance(t.glyph, BLine)]) == n_lines
+    assert len([t for t in fig.renderers if isinstance(t.glyph, Scatter)]) == 2
+    assert len([t for t in fig.center if isinstance(t, LabelSet)]) == n_texts
+    assert len([t for t in fig.center if isinstance(t, Span)]) == 2
+    line_colors = {'#1f77b4', '#aaa'}
+    assert all(t.glyph.line_color in line_colors for t in fig.renderers)
+    p.backend.update_interactive({a: 2})
+
+
+@pytest.mark.skipif(ct is None, reason="control is not installed")
+def test_plot_root_locus_2():
+    p = make_test_root_locus_2(BB)
+    assert isinstance(p, BB)
+    assert len(p.series) == 3
+    assert isinstance(p[0], RootLocusSeries)
+    assert isinstance(p[1], RootLocusSeries)
+    assert isinstance(p[2], SGridLineSeries)
+    fig = p.fig
+    assert len(fig.renderers) == 21
+    assert len([t for t in fig.renderers if isinstance(t.glyph, BLine)]) == 17
+    assert len([t for t in fig.renderers if isinstance(t.glyph, Scatter)]) == 4
+    assert len([t for t in fig.center if isinstance(t, LabelSet)]) == 2
+    assert len([t for t in fig.center if isinstance(t, Span)]) == 2
+    line_colors = {'#1f77b4', '#ff7f0e', '#aaa'}
+    assert all(t.glyph.line_color in line_colors for t in fig.renderers)
+    assert fig.legend[0].items[0].label["value"] == "a"
+    assert fig.legend[0].items[1].label["value"] == "b"
+    p.update_interactive({})
+
+
+@pytest.mark.parametrize(
+    "mag, n_lines, n_vlines, n_labels",
+    [
+        (None, 11, 1, 11),
+        (-3, 2, 0, 1),
+        (0, 1, 1, 1),
+    ]
+)
+def test_mcircles(mag, n_lines, n_vlines, n_labels):
+    p = make_test_mcircles(BB, mag)
+    fig = p.fig
+    assert len(fig.renderers) == n_lines
+    assert len([t for t in fig.center if isinstance(t, Span)]) == n_vlines
+    assert len([t for t in fig.center if isinstance(t, Label)]) == n_labels
+
+
+@pytest.mark.skipif(ct is None, reason="control is not installed")
+@pytest.mark.parametrize(
+    "m_circles, start_marker, mirror_style, arrows, n_lines, n_vlines, "
+    "n_arrows_sets, n_arrows, n_texts",
+    [
+        (False, "+", None, None, 3, 0, 2, 0, 0),  # no m-circles, no arrows
+        (False, None, None, None, 2, 0, 2, 0, 0), # no m-circles, no arrows, no start marker
+        (False, "+", None, 2, 3, 0, 2, 2, 0),     # no m-circles
+        (False, "+", False, 2, 2, 0, 1, 2, 0),    # no m-circles, no mirror image
+        (True, "+", None, 3, 14, 1, 2, 3, 11),    # m-circles, mirror image, arrows, start marker
+    ]
+)
+def test_plot_nyquist_bokeh(
+    m_circles, start_marker, mirror_style, arrows, n_lines, n_vlines,
+    n_arrows_sets, n_arrows, n_texts
+):
+    # verify that plot_nyquist adds the necessary objects to the plot
+
+    s = symbols("s")
+    tf1 = 1 / (s**2 + 0.5*s + 2)
+
+    p = plot_nyquist(tf1, show=False, n=10, m_circles=m_circles, arrows=arrows,
+        mirror_style=mirror_style, start_marker=start_marker, backend=BB)
+    fig = p.fig
+    assert len(p.fig.renderers) == n_lines
+    assert len([t for t in p.fig.center if isinstance(t, Span)]) == n_vlines
+    assert len([t for t in p.fig.center if isinstance(t, Arrow)]) == n_arrows_sets
+    ad = [t for t in p.fig.center if isinstance(t, Arrow)][0].source.data
+    assert len(ad["x_start"]) == n_arrows
+    assert len([t for t in p.fig.center if isinstance(t, Label)]) == n_texts
+
+
+@pytest.mark.skipif(ct is None, reason="control is not installed")
+@pytest.mark.parametrize(
+    "primary_style, mirror_style",
+    [
+        ("solid", "dotted"),
+        (["solid", "dashdot"], ["dashed", "dotted"]),
+        ({"line_dash": "solid"}, {"line_dash": "dotted"}),
+        (
+            [{"line_dash": "solid"}, {"line_dash": "dotted"}],
+            [{"line_dash": "dashed"}, {"line_dash": "dashdot"}]
+        ),
+        (2, 2),
+    ]
+)
+def test_plot_nyquist_bokeh_linestyles(primary_style, mirror_style):
+    s = symbols("s")
+    tf1 = 1 / (s**2 + 0.5*s + 2)
+
+    p = plot_nyquist(tf1, show=False, n=10,
+        primary_style=primary_style, mirror_style=mirror_style, backend=BB)
+    if not isinstance(primary_style, int):
+        fig = p.fig
+    else:
+        raises(ValueError, lambda: p.fig)
+
+
+@pytest.mark.skipif(ct is None, reason="control is not installed")
+def test_plot_nyquist_bokeh_interactive():
+    # verify that interactive update doesn't raise errors
+
+    a, s = symbols("a, s")
+    tf = 1 / (s + a)
+    pl = plot_nyquist(
+        tf, xlim=(-2, 1), ylim=(-1, 1),
+        aspect="equal", m_circles=True,
+        params={a: (1, 0, 2)},
+        arrows=4, n=10, show=False, backend=BB
+    )
+    fig = pl.backend.fig # force first draw
+    pl.backend.update_interactive({a: 2}) # update with new value
+
+
+
+def test_plot_nichols():
+    s = symbols("s")
+    tf = (5 * (s - 1)) / (s**2 * (s**2 + s + 4))
+
+    # with nichols grid lines
+    p = plot_nichols(tf, ngrid=True, show=False, n=10, backend=BB)
+    fig = p.fig
+    assert len(p.fig.renderers) > 2
+    assert len([t for t in p.fig.center if isinstance(t, Label)]) > 0
+
+    # no nichols grid lines
+    p = plot_nichols(tf, ngrid=False, show=False, n=10, backend=BB)
+    fig = p.fig
+    assert len(p.fig.renderers) == 1
+    assert len([t for t in p.fig.center if isinstance(t, Label)]) == 0
+
+
+@pytest.mark.parametrize(
+    "arrows, n_arrows",
+    [
+        (True, 3),
+        (False, 0),
+        (None, 0),
+        (4, 4),
+        ([0.2, 0.5, 0.8], 3)
+    ]
+)
+def test_plot_nichols_arrows(arrows, n_arrows):
+    s = symbols("s")
+    tf = (5 * (s - 1)) / (s**2 * (s**2 + s + 4))
+    p = plot_nichols(tf, ngrid=False, show=False, n=10,
+        backend=BB, arrows=arrows)
+    fig = p.fig
+    arrows_glyphs = [t for t in p.fig.center if isinstance(t, Arrow)]
+    assert len(arrows_glyphs) == 1
+    data = arrows_glyphs[0].source.data
+    k = list(data.keys())[0]
+    assert len(data[k]) == n_arrows
+
+
+@pytest.mark.parametrize(
+    "scatter, use_cm, instance", [
+        (False, False, BLine),
+        (False, True, MultiLine),
+        (True, False, Scatter),
+        (True, True, Scatter),
+    ]
+)
+def test_plot_nichols_lines_scatter(scatter, use_cm, instance):
+    # no errors are raised with different types of line
+    a, s = symbols("a, s")
+    tf = (a * (s - 1)) / (s**2 * (s**2 + s + 4))
+
+    # with nichols grid lines
+    p = plot_nichols(tf, ngrid=False, show=False, n=10, backend=BB,
+        scatter=scatter, use_cm=use_cm, params={a: (5, 0, 10)})
+    fig = p.backend.fig
+    assert len(fig.renderers) == 1
+    assert isinstance(fig.renderers[0].glyph, instance)
+    p.backend.update_interactive({a: 6})
+
+
+def test_hvlines():
+    a, b = symbols("a, b")
+    p = make_test_hvlines(BB)
+    p.fig
+    lines = [t for t in p.fig.center if isinstance(t, Span)]
+    assert len(lines) == 2
+    assert lines[0].dimension == "width"
+    assert lines[1].dimension == "height"
+    p.backend.update_interactive({a: 3, b: 4})
```

### Comparing `sympy_plot_backends-3.1.1/tests/backends/test_color_utils.py` & `sympy_plot_backends-3.2.0/tests/backends/test_color_utils.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/backends/test_k3d.py` & `sympy_plot_backends-3.2.0/tests/backends/test_k3d.py`

 * *Files 12% similar despite different names*

```diff
@@ -13,65 +13,53 @@
 from sympy import (
     sin, cos, I, pi, sqrt, Matrix,
     symbols
 )
 from sympy.abc import x, y, z, u, t, a, b, c
 from .make_tests import (
     custom_colorloop_2,
-    make_plot_1,
-    make_plot_parametric_1,
-    make_plot3d_parametric_line_1,
-    make_plot3d_1,
-    make_plot3d_2,
+    make_test_plot,
+    make_test_plot_parametric,
+    make_test_plot3d_parametric_line,
+    make_test_plot3d,
     make_plot3d_wireframe_1,
     make_plot3d_wireframe_2,
     make_plot3d_wireframe_3,
-    make_plot_contour_1,
-    make_plot_vector_2d_quiver,
-    make_plot_vector_2d_streamlines_1,
-    make_plot_vector_3d_quiver,
-    make_plot_vector_3d_streamlines_1,
-    make_plot_vector_3d_normalize_1,
-    make_plot_vector_3d_normalize_2,
-    make_plot_vector_3d_quiver_color_func_1,
-    make_plot_vector_3d_quiver_color_func_2,
-    make_plot_vector_3d_streamlines_color_func,
+    make_test_plot_contour,
+    make_test_plot_vector_2d_quiver,
+    make_test_plot_vector_2d_streamlines,
+    make_test_plot_vector_3d_quiver_streamlines,
+    make_test_plot_vector_3d_normalize,
+    make_test_plot_vector_3d_quiver_color_func,
+    make_test_plot_vector_3d_streamlines_color_func,
     make_test_plot_implicit_adaptive_true,
     make_test_plot_implicit_adaptive_false,
     make_test_plot_complex_1d,
     make_test_plot_complex_2d,
     make_test_plot_complex_3d,
-    make_test_plot_list_is_filled_false,
-    make_test_plot_list_is_filled_true,
+    make_test_plot_list_is_filled,
     make_test_plot_piecewise_single_series,
     make_test_plot_piecewise_multiple_series,
     make_test_plot_geometry_1,
     make_test_plot_geometry_3d,
     make_test_backend_latex_labels_2,
-    make_test_plot_vector_3d_quivers_use_latex,
-    make_test_plot_vector_3d_streamlines_use_latex,
-    make_test_plot3d_use_cm,
+    make_test_plot_polar,
     make_test_plot3d_implicit,
-    make_test_surface_color_func_1,
-    make_test_surface_color_func_2,
-    make_test_surface_interactive_color_func,
+    make_test_surface_color_func,
+    make_test_line_color_plot,
     make_test_line_color_plot3d_parametric_line,
     make_test_surface_color_plot3d,
-    make_test_plot3d_list_use_cm_False,
-    make_test_plot3d_list_use_cm_color_func,
-    make_test_plot3d_list_interactive,
+    make_test_plot3d_list,
     make_test_color_func_expr_2,
     make_test_analytic_landscape,
+    make_test_detect_poles,
     make_test_parametric_texts_3d,
-    make_test_plot3d_parametric_line_use_latex,
-    make_test_plot3d_use_latex,
-    make_test_vectors_3d_update_interactive,
     make_test_plot_list_color_func,
     make_test_real_imag,
-    make_test_arrow_3d
+    make_test_arrow_3d,
 )
 
 
 # NOTE
 # While BB, PB, KB creates the figure at instantiation, MB creates the figure
 # once the `show()` method is called. All backends do not populate the figure
 # at instantiation. Numerical data is added only when `show()` or `fig` is
@@ -84,24 +72,14 @@
 KB.skip_notebook_check = True
 
 
 class KBchild1(KB):
     colorloop = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]
 
 
-def test_colorloop_colormaps():
-    # verify that backends exposes important class attributes enabling
-    # automatic coloring
-
-    assert hasattr(KB, "colorloop")
-    assert isinstance(KB.colorloop, (list, tuple))
-    assert hasattr(KB, "colormaps")
-    assert isinstance(KB.colormaps, (list, tuple))
-
-
 def test_custom_colorloop():
     # verify that it is possible to modify the backend's class attributes
     # in order to change custom coloring
 
     assert len(KB.colorloop) != len(KBchild1.colorloop)
     _p1 = custom_colorloop_2(KB)
     _p2 = custom_colorloop_2(KBchild1)
@@ -111,75 +89,90 @@
     assert all([isinstance(t, k3d.objects.Mesh) for t in f1.objects])
     assert all([isinstance(t, k3d.objects.Mesh) for t in f2.objects])
     # there are 6 unique colors in _p1 and 3 unique colors in _p2
     assert len(set([o.color for o in f1.objects])) == 6
     assert len(set([o.color for o in f2.objects])) == 3
 
 
-def test_plot():
+def test_plot_1():
     # verify that the backends produce the expected results when `plot()`
     # is called and `rendering_kw` overrides the default line settings
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_plot_1(KB, rendering_kw=dict(line_color="red")).draw(),
-    )
+    p = make_test_plot(KB, rendering_kw=dict(line_color="red"))
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_parametric():
     # verify that the backends produce the expected results when
     # `plot_parametric()` is called and `rendering_kw` overrides the default
     # line settings
 
-    raises(
-        NotImplementedError,
-        lambda: make_plot_parametric_1(
-            KB, rendering_kw=dict(line_color="red")
-        ).draw(),
-    )
+    # K3D doesn't support 2D plots
+    p = make_test_plot_parametric(
+        KB, rendering_kw=dict(line_color="red"), use_cm=False)
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot3d_parametric_line():
     # verify that the backends produce the expected results when
     # `plot3d_parametric_line()` is called and `rendering_kw` overrides the
     # default line settings
 
-    p = make_plot3d_parametric_line_1(KB, rendering_kw=dict(color=16711680))
-    assert len(p.series) == 1
+    p = make_test_plot3d_parametric_line(
+        KB, rendering_kw=dict(color=16711680), use_latex=False, use_cm=False)
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.objects) == 1
     assert isinstance(f.objects[0], k3d.objects.Line)
     assert f.objects[0].color == 16711680
     assert f.objects[0].name is None
+    p.backend.update_interactive({a: 2, b: 2})
 
-
-def test_plot3d():
+    p1 = make_test_plot3d_parametric_line(
+        KB, rendering_kw=dict(), use_latex=False, use_cm=True)
+    p1.backend.update_interactive({a: 2, b: 2})
+    p2 = make_test_plot3d_parametric_line(
+        KB, rendering_kw=dict(color_map=k3d.basic_color_maps.Blues),
+        use_latex=False, use_cm=True)
+    p2.backend.update_interactive({a: 2, b: 2})
+    assert len(p1.fig.objects[0].color_map) != len(p2.fig.objects[0].color_map)
+
+
+@pytest.mark.parametrize(
+    "use_latex, xl, yl, zl", [
+        (True, "x", "y", "f\\left(x, y\\right)"),
+        (False, "x", "y", "f(x, y)"),
+    ]
+)
+def test_plot3d_1(use_latex, xl, yl, zl):
     # verify that the backends produce the expected results when
     # `plot3d()` is called and `rendering_kw` overrides the default surface
     # settings
 
-    p = make_plot3d_1(KB, rendering_kw=dict(color=16711680))
-    assert len(p.series) == 1
+    p = make_test_plot3d(KB, rendering_kw=dict(color=16711680),
+        use_cm=False, use_latex=use_latex)
+    assert len(p.backend.series) == 2
     f = p.fig
-    assert len(f.objects) == 1
+    assert len(f.objects) == 2
     assert isinstance(f.objects[0], k3d.objects.Mesh)
     assert f.objects[0].color == 16711680
     assert f.objects[0].name is None
+    assert p.fig.axes == [xl, yl, zl]
+    p.backend.update_interactive({a: 2, b: 2})
 
-
-def test_plot3d_2():
-    # verify that the backends uses string labels when `plot3d()` is called
-    # with `use_latex=False` and `use_cm=True`
-
-    p = make_plot3d_2(KB)
-    assert len(p.series) == 2
+    p = make_test_plot3d(KB,
+        rendering_kw=dict(color_map=k3d.basic_color_maps.Blues),
+        use_cm=True, use_latex=use_latex)
+    assert len(p.backend.series) == 2
     f = p.fig
     assert len(f.objects) == 2
-    assert p.fig.axes == ["x", "y", "f(x, y)"]
+    assert np.allclose(f.objects[0].color_map, f.objects[1].color_map)
+    assert p.fig.axes == [xl, yl, zl]
+    p.backend.update_interactive({a: 2, b: 2})
 
 
 def test_plot3d_wireframe():
     # verify that wireframe=True is going to add the expected number of line
     # data series and that appropriate keyword arguments work as expected
 
     p2 = make_plot3d_wireframe_1(KB)
@@ -203,203 +196,211 @@
 
 def test_plot_contour():
     # verify that the backends produce the expected results when
     # `plot_contour()` is called and `rendering_kw` overrides the default
     # surface settings
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_plot_contour_1(KB, rendering_kw=dict()).draw()
-    )
+    p = make_test_plot_contour(KB, rendering_kw=dict(), use_latex=False)
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_vector_2d_quivers():
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `contour_kw`/`quiver_kw` overrides the
     # default settings
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_plot_vector_2d_quiver(
-            KB, quiver_kw=dict(), contour_kw=dict()
-        ).draw(),
-    )
+    p = make_test_plot_vector_2d_quiver(
+        KB, quiver_kw=dict(), contour_kw=dict())
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_vector_2d_streamlines_custom_scalar_field():
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `contour_kw`/`stream_kw` overrides the
     # default settings
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_plot_vector_2d_streamlines_1(
-            KB, stream_kw=dict(), contour_kw=dict()
-        ).draw(),
-    )
+    p = make_test_plot_vector_2d_streamlines(
+            KB, stream_kw=dict(), contour_kw=dict(), scalar=True,
+            use_latex=False)
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_vector_3d_quivers():
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `quiver_kw` overrides the
     # default settings
 
-    p = make_plot_vector_3d_quiver(
-        KB, quiver_kw=dict(scale=0.5, color=16711680), use_cm=False
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        KB, False, quiver_kw=dict(scale=0.5, color=16711680), use_cm=False,
+        use_latex=False
     )
-    assert len(p.series) == 1
+    assert len(p.backend.series) == 1
+    f = p.fig
+    assert len(f.objects) == 1
+    assert isinstance(f.objects[0], k3d.objects.Vectors)
+    c1 = f.objects[0].colors
+    assert all([c == 16711680 for c in c1])
+    p.backend.update_interactive({a: 2})
+
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        KB, False, quiver_kw=dict(color_map=k3d.basic_color_maps.Blues),
+        use_cm=True, use_latex=False
+    )
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.objects) == 1
     assert isinstance(f.objects[0], k3d.objects.Vectors)
-    assert all([c == 16711680 for c in f.objects[0].colors])
+    c2 = f.objects[0].colors
+    assert not np.allclose(c1, c2)
+    p.backend.update_interactive({a: 2})
 
 
 def test_plot_vector_3d_streamlines():
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `stream_kw` overrides the
     # default settings
 
-    p = make_plot_vector_3d_streamlines_1(KB, stream_kw=dict(color=16711680))
-    assert len(p.series) == 1
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        KB, True, stream_kw=dict(color=16711680), use_latex=False)
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.objects) == 1
     assert isinstance(f.objects[0], k3d.objects.Line)
     assert f.objects[0].color == 16711680
+    raises(NotImplementedError, lambda: p.backend.update_interactive({a: 2}))
 
     # test different combinations for streamlines: it should not raise errors
-    p = make_plot_vector_3d_streamlines_1(KB, stream_kw=dict(starts=True))
-    p = make_plot_vector_3d_streamlines_1(
-        KB,
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        KB, True, stream_kw=dict(starts=True))
+    raises(NotImplementedError, lambda: p.backend.update_interactive({a: 2}))
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        KB, True,
         stream_kw=dict(
             starts={
                 "x": np.linspace(-5, 5, 10),
                 "y": np.linspace(-4, 4, 10),
                 "z": np.linspace(-3, 3, 10),
             }
         ),
     )
+    raises(NotImplementedError, lambda: p.backend.update_interactive({a: 2}))
 
     # other keywords: it should not raise errors
-    p = make_plot_vector_3d_streamlines_1(
-        KB, stream_kw=dict(), kwargs=dict(use_cm=False)
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        KB, True, stream_kw=dict(), kwargs=dict(use_cm=False)
     )
+    raises(NotImplementedError, lambda: p.backend.update_interactive({a: 2}))
 
 
 @pytest.mark.filterwarnings("ignore::RuntimeWarning")
 def test_plot_vector_3d_normalize():
     # verify that backends are capable of normalizing a vector field before
     # plotting it. Since all backend are different from each other, let's test
     # that data in the figures is different in the two cases normalize=True
     # and normalize=False
 
-    p1 = make_plot_vector_3d_normalize_1(KB, False)
-    p2 = make_plot_vector_3d_normalize_1(KB, True)
+    p1 = make_test_plot_vector_3d_normalize(KB, False)
+    p2 = make_test_plot_vector_3d_normalize(KB, True)
     assert not np.allclose(
         p1.fig.objects[0].vectors, p2.fig.objects[0].vectors
     )
 
-    p1 = make_plot_vector_3d_normalize_2(KB, False)
+    p1 = make_test_plot_vector_3d_normalize(KB, False)
     p1.backend.update_interactive({u: 1.5})
-    p2 = make_plot_vector_3d_normalize_2(KB, True)
+    p2 = make_test_plot_vector_3d_normalize(KB, True)
     p2.backend.update_interactive({u: 1.5})
     assert not np.allclose(
         p1.fig.objects[0].vectors, p2.fig.objects[0].vectors
     )
 
 
 def test_plot_vector_3d_quivers_color_func():
     # verify that color_func gets applied to 3D quivers
 
-    p1 = make_plot_vector_3d_quiver_color_func_1(KB, None)
-    p2 = make_plot_vector_3d_quiver_color_func_1(
+    p1 = make_test_plot_vector_3d_quiver_color_func(KB, None)
+    p2 = make_test_plot_vector_3d_quiver_color_func(
         KB, lambda x, y, z, u, v, w: x)
     assert not np.allclose(p1.fig.objects[0].colors, p2.fig.objects[0].colors)
+    p1.backend.update_interactive({a: 2})
+    p2.backend.update_interactive({a: 2})
 
-    p1 = make_plot_vector_3d_quiver_color_func_2(KB, None)
-    p2 = make_plot_vector_3d_quiver_color_func_2(
+    p1 = make_test_plot_vector_3d_quiver_color_func(KB, None)
+    p2 = make_test_plot_vector_3d_quiver_color_func(
         KB, lambda x, y, z, u, v, w: np.cos(u))
-    p3 = make_plot_vector_3d_quiver_color_func_2(
+    p3 = make_test_plot_vector_3d_quiver_color_func(
         KB, lambda x, y, z, u, v, w: np.cos(u))
     assert not np.allclose(p1.fig.objects[0].colors, p2.fig.objects[0].colors)
     p3.backend.update_interactive({a: 2})
     assert not np.allclose(p2.fig.objects[0].colors, p3.fig.objects[0].colors)
 
 
 def test_plot_vector_3d_streamlines_color_func():
     # verify that color_func gets applied to 3D quivers
 
-    p1 = make_plot_vector_3d_streamlines_color_func(KB, None)
-    p2 = make_plot_vector_3d_streamlines_color_func(KB, lambda x, y, z, u, v, w: x)
+    p1 = make_test_plot_vector_3d_streamlines_color_func(KB, None)
+    p2 = make_test_plot_vector_3d_streamlines_color_func(KB, lambda x, y, z, u, v, w: x)
     assert not np.allclose(
         p1.fig.objects[0].attribute, p2.fig.objects[0].attribute
     )
+    raises(NotImplementedError, lambda: p1.backend.update_interactive({a: 2}))
+    raises(NotImplementedError, lambda: p2.backend.update_interactive({a: 2}))
 
 
 def test_plot_implicit_adaptive_true():
     # verify that the backends produce the expected results when
     # `plot_implicit()` is called with `adaptive=True`
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_test_plot_implicit_adaptive_true(
-            KB, rendering_kw=dict()
-        ).draw()
+    p = make_test_plot_implicit_adaptive_true(
+        KB, rendering_kw=dict()
     )
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_implicit_adaptive_false():
     # verify that the backends produce the expected results when
     # `plot_implicit()` is called with `adaptive=True` and `contour_kw`
     # overrides the default settings
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_test_plot_implicit_adaptive_false(KB, rendering_kw=dict()).draw(),
-    )
+    p = make_test_plot_implicit_adaptive_false(KB, rendering_kw=dict())
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_real_imag():
     # verify that the backends produce the expected results when
     # `plot_real_imag()` is called and `rendering_kw` overrides the default
     # settings
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_test_real_imag(KB, rendering_kw=dict()).draw()
-    )
+    p = make_test_real_imag(KB, rendering_kw=dict(), use_latex=False)
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_complex_1d():
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_test_plot_complex_1d(KB, rendering_kw=dict()).draw(),
-    )
+    p = make_test_plot_complex_1d(KB, rendering_kw=dict(), use_latex=False)
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_complex_2d():
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_test_plot_complex_2d(KB, rendering_kw=dict()).draw(),
-    )
+    p = make_test_plot_complex_2d(KB, rendering_kw=dict())
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_complex_3d():
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
@@ -407,45 +408,33 @@
     assert len(p.series) == 1
     f = p.fig
     assert len(f.objects) == 1
     assert isinstance(f.objects[0], k3d.objects.Mesh)
     assert f.objects[0].name is None
 
 
-def test_plot_list_is_filled_false():
+@pytest.mark.parametrize(
+    "is_filled", [True, False]
+)
+def test_plot_list(is_filled):
     # verify that the backends produce the expected results when
     # `plot_list()` is called with `is_filled=False`
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_test_plot_list_is_filled_false(KB).draw()
-    )
-
-
-def test_plot_list_is_filled_true():
-    # verify that the backends produce the expected results when
-    # `plot_list()` is called with `is_filled=True`
-
-    # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_test_plot_list_is_filled_true(KB).draw()
-    )
+    p = make_test_plot_list_is_filled(KB, is_filled=is_filled)
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_list_color_func():
     # verify that the backends produce the expected results when
     # `plot_list()` is called with `color_func`
 
     # K3D doesn't support 2D plots
-    raises(
-        NotImplementedError,
-        lambda: make_test_plot_list_color_func(KB).draw()
-    )
+    p = make_test_plot_list_color_func(KB)
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_piecewise_single_series():
     # verify that plot_piecewise plotting 1 piecewise composed of N
     # sub-expressions uses only 1 color
 
     # K3D doesn't support 2D plots
@@ -467,15 +456,16 @@
 
 
 def test_plot_geometry_1():
     # verify that the backends produce the expected results when
     # `plot_geometry()` is called
 
     # K3D doesn't support 2D plots
-    raises(NotImplementedError, lambda: make_test_plot_geometry_1(KB).draw())
+    p = make_test_plot_geometry_1(KB)
+    raises(NotImplementedError, lambda: p.fig)
 
 
 def test_plot_geometry_3d():
     # verify that no errors are raised when 3d geometric entities are plotted
 
     p = make_test_plot_geometry_3d(KB)
     p.draw()
@@ -522,83 +512,28 @@
             lambda: p.save(
                 os.path.join(tmpdir, filename),
                 include_js=True, parameter=True
             ),
         )
 
 
-def test_vectors_3d_update_interactive():
-    # Some backends do not support streamlines with iplot. Test that the
-    # backends raise error.
-
-    p = make_test_vectors_3d_update_interactive(KB)
-    raises(
-        NotImplementedError,
-        lambda: p.backend.update_interactive({a: 2, b: 2, c: 2})
-    )
-
-
 def test_backend_latex_labels():
     # verify that backends are going to set axis latex-labels in the
     # 2D and 3D case
 
     p1 = make_test_backend_latex_labels_2(KB, True)
     p2 = make_test_backend_latex_labels_2(KB, False)
     assert p1.xlabel == p1.fig.axes[0] == "x^{2}_{1}"
     assert p1.ylabel == p1.fig.axes[1] == "x_{2}"
     assert p1.zlabel == p1.fig.axes[2] == "f\\left(x^{2}_{1}, x_{2}\\right)"
     assert p2.xlabel == p2.fig.axes[0] == "x_1^2"
     assert p2.ylabel == p2.fig.axes[1] == "x_2"
     assert p2.zlabel == p2.fig.axes[2] == "f(x_1^2, x_2)"
 
 
-def test_plot3d_parametric_line_use_latex():
-    # verify that the colorbar uses latex label
-
-    # NOTE: K3D doesn't show a label to colorbar
-    make_test_plot3d_parametric_line_use_latex(KB)
-
-
-def test_plot3d_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot3d_use_latex(KB)
-    p.fig
-    assert p.fig.axes == ["x", "y", "f\\left(x, y\\right)"]
-
-
-def test_plot_vector_3d_quivers_use_latex():
-    # verify that the colorbar uses latex label
-
-    # K3D doesn't show label on colorbar
-    p = make_test_plot_vector_3d_quivers_use_latex(KB)
-    assert len(p.series) == 1
-
-
-def test_plot_vector_3d_streamlines_use_latex():
-    # verify that the colorbar uses latex label
-
-    # K3D doesn't show labels on colorbar
-    p = make_test_plot_vector_3d_streamlines_use_latex(KB)
-    assert len(p.series) == 1
-
-
-def test_plot3d_use_cm():
-    # verify that use_cm produces the expected results on plot3d
-
-    p1 = make_test_plot3d_use_cm(KB, True)
-    p2 = make_test_plot3d_use_cm(KB, False)
-    n1 = len(p1.fig.objects[0].color_map)
-    n2 = len(p2.fig.objects[0].color_map)
-    if n1 == n2:
-        assert not np.allclose(
-            p1.fig.objects[0].color_map, p2.fig.objects[0].color_map
-        )
-
-
 def test_k3d_vector_pivot():
     # verify that K3DBackend accepts quiver_kw={"pivot": "something"} and
     # produces different results
     x, y, z = symbols("x, y, z")
 
     _plot_vector = lambda pivot: plot_vector(
         Matrix([z, y, x]),
@@ -636,45 +571,22 @@
 
 def test_surface_color_func():
     # After the addition of `color_func`, `SurfaceOver2DRangeSeries` and
     # `ParametricSurfaceSeries` returns different elements.
     # Verify that backends do not raise errors when plotting surfaces and that
     # the color function is applied.
 
-    p1 = make_test_surface_color_func_1(KB, lambda x, y, z: z)
-    p2 = make_test_surface_color_func_1(
-        KB, lambda x, y, z: np.sqrt(x**2 + y**2)
-    )
-    assert not np.allclose(
-        p1.fig.objects[0].attribute, p2.fig.objects[0].attribute
-    )
-
-    p1 = make_test_surface_color_func_2(KB, lambda x, y, z, u, v: z)
-    p2 = make_test_surface_color_func_2(
-        KB, lambda x, y, z, u, v: np.sqrt(x**2 + y**2)
-    )
-    assert not np.allclose(
-        p1.fig.objects[0].attribute, p2.fig.objects[0].attribute
-    )
-
-
-def test_surface_interactive_color_func():
-    # After the addition of `color_func`, `SurfaceInteractiveSeries` and
-    # `ParametricSurfaceInteractiveSeries` returns different elements.
-    # Verify that backends do not raise errors when updating surfaces and a
-    # color function is applied.
-
-    p = make_test_surface_interactive_color_func(KB)
-    p.update_interactive({t: 2})
+    p = make_test_surface_color_func(KB)
     assert not np.allclose(
         p.fig.objects[0].attribute, p.fig.objects[1].attribute
     )
     assert not np.allclose(
         p.fig.objects[2].attribute, p.fig.objects[3].attribute
     )
+    p.backend.update_interactive({t: 2})
 
 
 def test_line_color_plot3d_parametric_line():
     # verify back-compatibility with old sympy.plotting module when using
     # line_color
 
     p = make_test_line_color_plot3d_parametric_line(KB, 0xFF0000, False)
@@ -810,61 +722,47 @@
         n=5,
         params={u: (1, 0, 2)},
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
 
 
-def test_plot3d_list_use_cm_False():
+def test_plot3d_list():
     # verify that plot3d_list produces the expected results when no color map
     # is required
 
-    # solid color line
-    p = make_test_plot3d_list_use_cm_False(KB, False, False)
-    assert isinstance(p.fig.objects[0], k3d.objects.Line)
-
-    # solid color markers with empty faces
     # NOTE: k3d doesn't support is_filled
-    p = make_test_plot3d_list_use_cm_False(KB, True, False)
-    assert isinstance(p.fig.objects[0], k3d.objects.Points)
 
-    # solid color markers with filled faces
-    # NOTE: k3d doesn't support is_filled
-    p = make_test_plot3d_list_use_cm_False(KB, True, True)
+    p = make_test_plot3d_list(KB, False, None)
+    assert len(p.fig.objects) == 3
     assert isinstance(p.fig.objects[0], k3d.objects.Points)
+    assert isinstance(p.fig.objects[1], k3d.objects.Points)
+    assert isinstance(p.fig.objects[2], k3d.objects.Line)
+    a1 = p.fig.objects[0].attribute
+    assert np.allclose(a1, 0)
+    assert len(p.fig.objects[1].attribute) == 0
+    assert len(p.fig.objects[2].attribute) == 0
+    assert p.fig.objects[0].color == 2062260
+    assert p.fig.objects[1].color == 16744206
+    assert p.fig.objects[2].color == 2924588
+    p.backend.update_interactive({t: 2})
 
-
-def test_plot3d_list_use_cm_color_func():
-    # verify that use_cm=True and color_func do their job
-
-    # NOTE: k3d doesn't support is_filled
-
-    # line with colormap
-    # if color_func is not provided, the same parameter will be used
-    # for all points
-    p1 = make_test_plot3d_list_use_cm_color_func(KB, False, False, None)
-    c1 = p1.fig.objects[0].attribute
-    p2 = make_test_plot3d_list_use_cm_color_func(KB, False, False, lambda x, y, z: x)
-    c2 = p2.fig.objects[0].attribute
-    assert not np.allclose(c1, c2)
-
-    # markers with empty faces
-    p1 = make_test_plot3d_list_use_cm_color_func(KB, False, False, None)
-    c1 = p1.fig.objects[0].attribute
-    p2 = make_test_plot3d_list_use_cm_color_func(
-        KB, False, False, lambda xx, yy, zz: xx)
-    c2 = p2.fig.objects[0].attribute
-    assert not np.allclose(c1, c2)
-
-
-def test_plot3d_list_interactive():
-    # verify that no errors are raises while updating a plot3d_list
-
-    p = make_test_plot3d_list_interactive(KB)
-    p.backend.update_interactive({t: 1})
+    p = make_test_plot3d_list(KB, False, lambda x, y, z: x)
+    assert len(p.fig.objects) == 3
+    assert isinstance(p.fig.objects[0], k3d.objects.Points)
+    assert isinstance(p.fig.objects[1], k3d.objects.Points)
+    assert isinstance(p.fig.objects[2], k3d.objects.Line)
+    a2 = p.fig.objects[0].attribute
+    assert not np.allclose(a2, 0)
+    assert len(p.fig.objects[1].attribute) == 0
+    assert len(p.fig.objects[2].attribute) == 0
+    assert p.fig.objects[0].color == 2062260
+    assert p.fig.objects[1].color == 16744206
+    assert p.fig.objects[2].color == 2924588
+    p.backend.update_interactive({t: 2})
 
 
 def test_color_func_expr():
     # verify that passing an expression to color_func is supported
 
     p3 = make_test_color_func_expr_2(KB)
     # compute the original figure: no errors should be raised
@@ -946,13 +844,15 @@
         backend=KB, fig=fig, show=False)
     assert p.fig is fig
     assert len(fig.objects) == 2
     assert fig.objects[0].color != fig.objects[1].color
 
 
 def test_arrow_3d():
+    a, b, c = symbols("a, b, c")
     p = make_test_arrow_3d(KB, "test",
         {"head_color": 0xff0000, "origin_color": 0xff0000}, True)
-    p.fig
-    assert len(p.fig.objects) == 1
-    assert p.fig.objects[0].origin_color == 0xff0000
-    assert p.fig.objects[0].head_color == 0xff0000
+    fig = p.fig
+    assert len(fig.objects) == 1
+    assert fig.objects[0].origin_color == 0xff0000
+    assert fig.objects[0].head_color == 0xff0000
+    p.backend.update_interactive({a: 4, b: 5, c: 6})
```

### Comparing `sympy_plot_backends-3.1.1/tests/backends/test_matplotlib.py` & `sympy_plot_backends-3.2.0/tests/backends/test_matplotlib.py`

 * *Files 13% similar despite different names*

```diff
@@ -8,122 +8,97 @@
 import os
 from tempfile import TemporaryDirectory
 from spb import (
     MB, plot, plot_riemann_sphere, plot_real_imag, plot_complex,
     plot_vector, plot3d_revolution, plot3d_spherical,
     plot3d_parametric_surface, plot_contour, plot3d, plot3d_parametric_line,
     plot_parametric, plot_implicit, plot_list, plot_geometry,
-    plot_complex_list, graphics, vector_field_2d
+    plot_complex_list, graphics, vector_field_2d, plot_nyquist, plot_nichols,
+    plot_step_response
 )
 from spb.series import RootLocusSeries, SGridLineSeries, ZGridLineSeries
 from spb.series import SurfaceOver2DRangeSeries
 from sympy import (
     sin, cos, I, pi, Eq, exp, Circle, Polygon, sqrt, Matrix, Line, Segment,
     latex, log
 )
 from sympy.abc import x, y, z, u, t, a, b, c
 from sympy.external import import_module
 from .make_tests import (
     custom_colorloop_1,
-    make_plot_1,
-    make_plot_parametric_1,
-    make_plot3d_parametric_line_1,
-    make_plot3d_1,
-    make_plot3d_2,
+    make_test_plot,
+    make_test_plot_parametric,
+    make_test_plot3d_parametric_line,
+    make_test_plot3d,
     make_plot3d_wireframe_1,
     make_plot3d_wireframe_2,
     make_plot3d_wireframe_3,
-    make_plot_contour_1,
+    make_test_plot_contour,
     make_plot_contour_is_filled,
-    make_plot_vector_2d_quiver,
-    make_plot_vector_2d_streamlines_1,
-    make_plot_vector_2d_streamlines_2,
-    make_plot_vector_3d_quiver,
-    make_plot_vector_3d_streamlines_1,
-    make_plot_vector_2d_normalize_1,
-    make_plot_vector_2d_normalize_2,
-    make_plot_vector_3d_normalize_1,
-    make_plot_vector_3d_normalize_2,
-    make_plot_vector_2d_quiver_color_func_1,
-    make_plot_vector_3d_quiver_color_func_1,
-    make_plot_vector_3d_quiver_color_func_2,
-    make_plot_vector_3d_streamlines_color_func,
+    make_test_plot_vector_2d_quiver,
+    make_test_plot_vector_2d_streamlines,
+    make_test_plot_vector_3d_quiver_streamlines,
+    make_test_plot_vector_2d_normalize,
+    make_test_plot_vector_3d_normalize,
+    make_test_plot_vector_2d_color_func,
+    make_test_plot_vector_3d_quiver_color_func,
+    make_test_plot_vector_3d_streamlines_color_func,
     make_test_plot_implicit_adaptive_true,
     make_test_plot_implicit_adaptive_false,
     make_test_plot_complex_1d,
     make_test_plot_complex_2d,
     make_test_plot_complex_3d,
-    make_test_plot_list_is_filled_false,
-    make_test_plot_list_is_filled_true,
+    make_test_plot_list_is_filled,
     make_test_plot_piecewise_single_series,
     make_test_plot_piecewise_multiple_series,
     make_test_plot_geometry_1,
     make_test_plot_geometry_2,
     make_test_plot_geometry_3d,
     make_test_aspect_ratio_2d_issue_11764,
     make_test_aspect_ratio_3d,
     make_test_plot_size,
     make_test_plot_scale_lin_log,
     make_test_backend_latex_labels_1,
     make_test_backend_latex_labels_2,
-    make_test_plot_use_latex,
-    make_test_plot_parametric_use_latex,
-    make_test_plot_contour_use_latex,
-    make_test_plot_vector_2d_quivers_use_latex,
-    make_test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex,
-    make_test_plot_vector_2d_streamlines_custom_scalar_field_use_latex,
-    make_test_plot_vector_2d_use_latex_colorbar,
-    make_test_plot_vector_3d_quivers_use_latex,
-    make_test_plot_vector_3d_streamlines_use_latex,
-    make_test_plot_complex_use_latex_1,
-    make_test_plot_complex_use_latex_2,
-    make_test_plot_real_imag_use_latex,
-    make_test_plot3d_use_cm,
     make_test_plot_polar,
     make_test_plot_polar_use_cm,
     make_test_plot3d_implicit,
-    make_test_surface_color_func_1,
-    make_test_surface_color_func_2,
-    make_test_surface_interactive_color_func,
-    make_test_line_interactive_color_func,
+    make_test_surface_color_func,
     make_test_line_color_plot,
     make_test_line_color_plot3d_parametric_line,
     make_test_surface_color_plot3d,
-    make_test_plot3d_list_use_cm_False,
-    make_test_plot3d_list_use_cm_color_func,
-    make_test_plot3d_list_interactive,
-    make_test_contour_show_clabels_1,
-    make_test_contour_show_clabels_2,
+    make_test_plot3d_list,
+    make_test_contour_show_clabels,
     make_test_color_func_expr_1,
     make_test_color_func_expr_2,
     make_test_legend_plot_sum_1,
     make_test_legend_plot_sum_2,
     make_test_domain_coloring_2d,
     make_test_show_in_legend_2d,
     make_test_show_in_legend_3d,
     make_test_analytic_landscape,
     make_test_detect_poles,
     make_test_detect_poles_interactive,
     make_test_plot_riemann_sphere,
     make_test_parametric_texts_2d,
     make_test_parametric_texts_3d,
     make_test_line_color_func,
-    make_test_plot3d_parametric_line_use_latex,
-    make_test_plot3d_use_latex,
-    make_test_vectors_3d_update_interactive,
     make_test_plot_list_color_func,
     make_test_real_imag,
     make_test_arrow_2d,
     make_test_arrow_3d,
     make_test_root_locus_1,
     make_test_root_locus_2,
+    make_test_plot_pole_zero,
     make_test_poles_zeros_sgrid,
     make_test_ngrid,
     make_test_sgrid,
-    make_test_zgrid
+    make_test_zgrid,
+    make_test_mcircles,
+    make_test_hvlines
 )
 
 ct = import_module("control")
 ipy = import_module("ipywidgets")
 scipy = import_module("scipy")
 vtk = import_module("vtk", catch=(RuntimeError,))
 
@@ -138,29 +113,18 @@
 # or `draw()`.
 
 
 class MBchild(MB):
     colorloop = ["red", "green", "blue"]
 
 
-def test_colorloop_colormaps():
-    # verify that backends exposes important class attributes enabling
-    # automatic coloring
-
-    assert hasattr(MB, "colorloop")
-    assert isinstance(MB.colorloop, (list, tuple))
-    assert hasattr(MB, "colormaps")
-    assert isinstance(MB.colormaps, (list, tuple))
-
-
 def test_MatplotlibBackend():
     # verify that MB keeps track of the handles and a few other important
     # keyword arguments
 
-    # `_handle` is needed in order to correctly update the data with iplot
     x, y = symbols("x, y")
     p = plot3d(
         cos(x**2 + y**2),
         backend=MB, show=False, n1=5, n2=5, use_cm=True
     )
     p.draw()
     assert len(p.renderers) == 1
@@ -181,113 +145,166 @@
     assert len(f1.axes[0].lines) == 6
     assert len(f2.axes[0].lines) == 6
     # there are 6 unique colors in _p1 and 3 unique colors in _p2
     assert len(set([l.get_color() for l in f1.axes[0].lines])) == 6
     assert len(set([l.get_color() for l in f2.axes[0].lines])) == 3
 
 
-def test_plot():
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+@pytest.mark.parametrize(
+    "use_latex, xlabel, ylabel", [
+        (False, "x", "f(x)"),
+        (True, "$x$", "$f\\left(x\\right)$")
+    ]
+)
+def test_plot_1(use_latex, xlabel, ylabel, label_func):
     # verify that the backends produce the expected results when `plot()`
     # is called and `rendering_kw` overrides the default line settings
 
-    p = make_plot_1(MB, rendering_kw=dict(color="red"))
-    assert len(p.series) == 2
+    p = make_test_plot(MB, rendering_kw=dict(color="red"), use_latex=use_latex)
+    assert len(p.backend.series) == 2
     f = p.fig
     ax = f.axes[0]
     assert isinstance(ax, matplotlib.axes.Axes)
     assert len(ax.get_lines()) == 2
-    assert ax.get_lines()[0].get_label() == "sin(x)"
+    assert ax.get_lines()[0].get_label() == label_func(use_latex, sin(a * x))
     assert ax.get_lines()[0].get_color() == "red"
-    assert ax.get_lines()[1].get_label() == "cos(x)"
+    assert ax.get_lines()[1].get_label() == label_func(use_latex, cos(b * x))
     assert ax.get_lines()[1].get_color() == "red"
-    assert ax.get_xlabel() == "x"
-    assert ax.get_ylabel() == "f(x)"
-    p.close()
-
-    p = make_plot_1(MB, rendering_kw=dict(color="red"), use_latex=True)
-    f = p.fig
-    ax = f.axes[0]
-    assert ax.get_lines()[0].get_label() == "$\\sin{\\left(x \\right)}$"
-    assert ax.get_xlabel() == "$x$"
-    assert ax.get_ylabel() == "$f\\left(x\\right)$"
+    assert ax.get_xlabel() == xlabel
+    assert ax.get_ylabel() == ylabel
+    p.backend.update_interactive({a: 2, b: 2})
+    p.backend.close()
 
 
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_plot_parametric():
     # verify that the backends produce the expected results when
     # `plot_parametric()` is called and `rendering_kw` overrides the default
     # line settings
 
-    p = make_plot_parametric_1(MB, rendering_kw=dict(color="red"))
-    assert len(p.series) == 1
+    p = make_test_plot_parametric(MB, rendering_kw=dict(color="red"),
+        use_cm=False)
+    assert len(p.backend.series) == 1
     f = p.fig
     ax = f.axes[0]
+    assert ax.get_lines()[0].get_label() == "(cos(a*x), sin(b*x))"
+    assert ax.get_lines()[0].get_color() == "red"
+    p.backend.update_interactive({a: 2, b: 2})
+    p.backend.close()
+
     # parametric plot with use_cm=True -> LineCollection
-    assert len(ax.collections) == 1
-    assert isinstance(ax.collections[0], matplotlib.collections.LineCollection)
-    assert f.axes[1].get_ylabel() == "x"
-    assert all(*(ax.collections[0].get_color() - np.array([1.0, 0.0, 0.0, 1.0])) == 0)
-    p.close()
+    p1 = make_test_plot_parametric(MB, rendering_kw={},
+        use_cm=True)
+    p2 = make_test_plot_parametric(MB, rendering_kw=dict(cmap="autumn"),
+        use_cm=True)
+    f1, f2 = p1.fig, p2.fig
+    ax1, ax2 = f1.axes[0], f2.axes[0]
+    assert len(ax1.collections) == 1
+    assert isinstance(ax1.collections[0], matplotlib.collections.LineCollection)
+    assert f1.axes[1].get_ylabel() == "x"
+    # TODO: how to test for different colormaps?
+    # assert not np.allclose(
+    #     ax1.collections[0].get_colors(),
+    #     ax2.collections[0].get_colors()
+    # )
+    p1.backend.update_interactive({a: 2, b: 2})
+    p2.backend.update_interactive({a: 2, b: 2})
+    p1.backend.close()
+    p2.backend.close()
 
 
-def test_plot3d_parametric_line():
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+@pytest.mark.parametrize(
+    "use_latex", [False, True]
+)
+def test_plot3d_parametric_line(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot3d_parametric_line()` is called and `rendering_kw` overrides the
     # default line settings
 
-    p = make_plot3d_parametric_line_1(MB, rendering_kw=dict(color="red"))
-    assert len(p.series) == 1
+    p = make_test_plot3d_parametric_line(
+        MB, rendering_kw=dict(color="red"), use_latex=use_latex, use_cm=False)
+    assert len(p.backend.series) == 1
     f = p.fig
     ax = f.axes[0]
-    assert len(ax.collections) == 1
+    assert ax.get_lines()[0].get_label() == label_func(
+        use_latex, (cos(a * x), sin(b * x), x))
+    assert ax.get_lines()[0].get_color() == "red"
+    p.backend.update_interactive({a: 2, b: 2})
+    p.backend.close()
+
+    p2 = make_test_plot3d_parametric_line(
+        MB, rendering_kw={}, use_latex=use_latex, use_cm=True)
+    p1 = make_test_plot3d_parametric_line(
+        MB, rendering_kw=dict(cmap="autumn"), use_latex=use_latex, use_cm=True)
+    f1, f2 = p1.fig, p2.fig
+    ax1, ax2 = f1.axes[0], f2.axes[0]
+    assert len(ax1.collections) == 1
     assert isinstance(
-        ax.collections[0],
-        mpl_toolkits.mplot3d.art3d.Line3DCollection
-    )
-    assert f.axes[1].get_ylabel() == "x"
-    assert all(*(ax.collections[0].get_color() - np.array([1.0, 0.0, 0.0, 1.0])) == 0)
-    p.close()
+        ax1.collections[0], mpl_toolkits.mplot3d.art3d.Line3DCollection)
+    assert f1.axes[1].get_ylabel() == f2.axes[1].get_ylabel() == label_func(
+        use_latex, x
+    )
+    # TODO: how to test for different colormaps?
+    p1.backend.update_interactive({a: 2, b: 2})
+    p2.backend.update_interactive({a: 2, b: 2})
+    p1.backend.close()
+    p2.backend.close()
 
 
-def test_plot3d():
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+@pytest.mark.parametrize(
+    "use_latex, xl, yl, zl", [
+        (False, "x", "y", "f(x, y)"),
+        (True, "$x$", "$y$", r"$f\left(x, y\right)$")
+    ]
+)
+def test_plot3d_1(use_latex, xl, yl, zl, label_func):
     # verify that the backends produce the expected results when
     # `plot3d()` is called and `rendering_kw` overrides the default surface
     # settings
 
     # use_cm=False will force to apply a default solid color to the mesh.
     # Here, I override that solid color with a custom color.
-    p = make_plot3d_1(MB, rendering_kw=dict(color="red"))
-    assert len(p.series) == 1
-    f = p.fig
-    ax = f.axes[0]
-    assert len(ax.collections) == 1
-    assert isinstance(
-        ax.collections[0],
-        mpl_toolkits.mplot3d.art3d.Poly3DCollection
-    )
-    # TODO: apparently, without showing the plot, the colors are not applied
-    # to a Poly3DCollection...
-    p.close()
-
-
-def test_plot3d_2():
-    # verify that the backends uses string labels when `plot3d()` is called
-    # with `use_latex=False` and `use_cm=True`
-
-    p = make_plot3d_2(MB)
-    assert len(p.series) == 2
+    p = make_test_plot3d(MB, rendering_kw=dict(color="red"), use_cm=False,
+        use_latex=use_latex)
+    assert len(p.backend.series) == 2
     f = p.fig
     ax = f.axes[0]
     assert len(ax.collections) == 2
-    assert ax.get_xlabel() == "x"
-    assert ax.get_ylabel() == "y"
-    assert ax.get_zlabel() == "f(x, y)"
-    assert len(f.axes) == 3
-    assert f.axes[1].get_ylabel() == str(cos(x**2 + y**2))
-    assert f.axes[2].get_ylabel() == str(sin(x**2 + y**2))
-    p.close()
+    assert all(isinstance(
+        c, mpl_toolkits.mplot3d.art3d.Poly3DCollection) for c in ax.collections
+    )
+    assert ax.get_xlabel() == xl
+    assert ax.get_ylabel() == yl
+    assert ax.get_zlabel() == zl
+    assert (
+        ax.get_legend().legend_handles[0].get_label()
+        == label_func(use_latex, cos(a*x**2 + y**2))
+    )
+    assert (
+        ax.get_legend().legend_handles[1].get_label()
+        == label_func(use_latex, sin(b*x**2 + y**2))
+    )
+    assert "cmap" not in p.backend.renderers[0].handles[0][1].keys()
+    # TODO: how to test for different colormaps?
+    p.backend.update_interactive({a: 2, b: 2})
+    p.backend.close()
+
+
+    p = make_test_plot3d(MB, rendering_kw=dict(cmap="autumn"), use_cm=True,
+        use_latex=use_latex)
+    f = p.fig
+    assert f.axes[1].get_ylabel() == label_func(use_latex, cos(a*x**2 + y**2))
+    assert f.axes[2].get_ylabel() == label_func(use_latex, sin(b*x**2 + y**2))
+    # TODO: how to test for different colormaps?
+    assert "cmap" in p.backend.renderers[0].handles[0][1].keys()
+    p.backend.update_interactive({a: 2, b: 2})
+    p.backend.close()
 
 
 def test_plot3d_wireframe():
     # verify that wireframe=True is going to add the expected number of line
     # data series and that appropriate keyword arguments work as expected
 
     p0 = make_plot3d_wireframe_1(MB, False)
@@ -302,27 +319,39 @@
     assert all(s.n[0] == 12 for s in p3.series[1:])
 
     p4 = make_plot3d_wireframe_3(MB, {"lw": "0.5"})
     assert len(p4.series) == 1 + 20 + 40
     assert all(s.rendering_kw == {"lw": "0.5"} for s in p3.series[1:])
 
 
-def test_plot_contour():
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+@pytest.mark.parametrize(
+    "use_latex, xl, yl", [
+        (False, "x", "y"),
+        (True, "$x$", "$y$")
+    ]
+)
+def test_plot_contour(use_latex, xl, yl, label_func):
     # verify that the backends produce the expected results when
     # `plot_contour()` is called and `rendering_kw` overrides the default
     # surface settings
 
-    p = make_plot_contour_1(MB, rendering_kw=dict(cmap="jet"))
-    assert len(p.series) == 1
+    p = make_test_plot_contour(MB, rendering_kw=dict(cmap="jet"),
+        use_latex=use_latex)
+    assert len(p.backend.series) == 1
     f = p.fig
     ax = f.axes[0]
     assert len(ax.collections) > 0
-    assert f.axes[1].get_ylabel() == str(cos(x**2 + y**2))
-    # TODO: how to retrieve the colormap from a contour series?????
-    p.close()
+    assert ax.get_xlabel() == xl
+    assert ax.get_ylabel() == yl
+    assert "cmap" in p.backend.renderers[0].handles[0][1].keys()
+    assert f.axes[1].get_ylabel() == label_func(use_latex, cos(a*x**2 + y**2))
+    # TODO: how to test for different colormaps?
+    p.backend.update_interactive({a: 2})
+    p.backend.close()
 
 
 def test_plot_contour_is_filled():
     # verify that is_filled=True produces different results than
     # is_filled=False
     x, y = symbols("x, y")
 
@@ -331,128 +360,116 @@
     p2 = make_plot_contour_is_filled(MB, False)
     p2.draw()
     assert p1.renderers[0].handles[0][-1] is None
     assert hasattr(p2.renderers[0].handles[0][-1], "__iter__")
     assert len(p2.renderers[0].handles[0][-1]) > 0
 
 
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_plot_vector_2d_quivers():
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `contour_kw`/`quiver_kw` overrides the
     # default settings
 
-    p = make_plot_vector_2d_quiver(
+    p = make_test_plot_vector_2d_quiver(
         MB, quiver_kw=dict(color="red"), contour_kw=dict(cmap="jet")
     )
-    assert len(p.series) == 2
+    assert len(p.backend.series) == 2
     f = p.fig
     ax = f.axes[0]
     assert len(ax.collections) > 0
     assert isinstance(ax.collections[-1], matplotlib.quiver.Quiver)
     assert f.axes[1].get_ylabel() == "Magnitude"
-    # TODO: how to retrieve the colormap from a contour series?????
-    p.close()
-
-
-def test_plot_vector_2d_streamlines_custom_scalar_field():
-    # verify that the backends produce the expected results when
-    # `plot_vector()` is called and `contour_kw`/`stream_kw` overrides the
-    # default settings
-
-    p = make_plot_vector_2d_streamlines_1(
-        MB, stream_kw=dict(color="red"), contour_kw=dict(cmap="jet")
-    )
-    assert len(p.series) == 2
-    f = p.fig
-    ax = f.axes[0]
-    assert len(ax.collections) > 0
-    assert isinstance(ax.collections[-1], matplotlib.collections.LineCollection)
-    assert f.axes[1].get_ylabel() == "x + y"
-    assert all(*(ax.collections[-1].get_color() - np.array([1.0, 0.0, 0.0, 1.0])) == 0)
-    p.close()
+    # TODO: how to test for different colormaps?
+    p.backend.update_interactive({a: 2})
+    p.backend.close()
 
 
-def test_plot_vector_2d_streamlines_custom_scalar_field_custom_label():
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+@pytest.mark.parametrize(
+    "scalar, use_latex, expected_label", [
+        (True, False, "Magnitude"),
+        (True, True, "Magnitude"),
+        (x + y, False, "x + y"),
+        (x + y, True, "$x + y$"),
+        ([(x + y), "test"], False, "test"),
+        ([(x + y), "test"], True, "test")
+    ]
+)
+def test_plot_vector_2d_streamlines_custom_scalar_field(
+    scalar, use_latex, expected_label
+):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `contour_kw`/`stream_kw` overrides the
     # default settings
 
-    p = make_plot_vector_2d_streamlines_2(
-        MB, stream_kw=dict(color="red"), contour_kw=dict(cmap="jet")
+    p = make_test_plot_vector_2d_streamlines(
+        MB, stream_kw=dict(color="red"), contour_kw=dict(cmap="jet"),
+        scalar=scalar, use_latex=use_latex
     )
-    assert len(p.series) == 2
+    assert len(p.backend.series) == 2
     f = p.fig
     ax = f.axes[0]
     assert len(ax.collections) > 0
     assert isinstance(ax.collections[-1], matplotlib.collections.LineCollection)
-    assert f.axes[1].get_ylabel() == "test"
-    assert all(*(ax.collections[-1].get_color() - np.array([1.0, 0.0, 0.0, 1.0])) == 0)
-    p.close()
+    assert f.axes[1].get_ylabel() == expected_label
+    # TODO: how to test for different colormaps?
+    raises(NotImplementedError, lambda :p.backend.update_interactive({a: 2}))
+    p.backend.close()
 
 
-def test_plot_vector_2d_matplotlib():
+@pytest.mark.parametrize(
+    "scalar, streamlines, use_cm, n_series, n_axes, n_collections, "
+    "use_latex, label, greater", [
+        # contours + quivers: 1 colorbar for the contours
+        (True, False, None, 2, 2, 1, False, "Magnitude", True),
+        (True, False, None, 2, 2, 1, True, "Magnitude", True),
+        # contours + streamlines: 1 colorbar for the contours
+        (True, True, None, 2, 2, 1, False, "Magnitude", True),
+        (True, True, None, 2, 2, 1, True, "Magnitude", True),
+        # only quivers: 1 colorbar for the quivers
+        (False, False, None, 1, 2, 1, False, "(x, y)", False),
+        (False, False, None, 1, 2, 1, True, r"$\left( x, \  y\right)$", False),
+        # only streamlines: 1 colorbar for the streamlines
+        (False, True, None, 1, 2, 1, False, "(x, y)", False),
+        (False, True, None, 1, 2, 1, True, r"$\left( x, \  y\right)$", False),
+        # only quivers with solid color
+        (False, False, False, 1, 1, 1, False, "", False),
+        (False, False, False, 1, 1, 1, True, "", False),
+        # only streamlines with solid color
+        (False, True, False, 1, 1, 1, False, "", False),
+        (False, True, False, 1, 1, 1, True, "", False),
+    ]
+)
+def test_plot_vector_2d_matplotlib(
+    scalar, streamlines, use_cm, n_series, n_axes, n_collections,
+    use_latex, label, greater
+):
     # verify that when scalar=False, quivers/streamlines comes together with
     # a colorbar
 
     x, y = symbols("x, y")
-    def _plot_vector_1(scalar, streamlines, use_cm=None):
-        kwargs = {"scalar": scalar, "streamlines": streamlines}
-        if use_cm is not None:
-            kwargs["use_cm"] = use_cm
-        return plot_vector(
-            Matrix([x, y]),
-            (x, -5, 5),
-            (y, -4, 4),
-            backend=MB,
-            show=False,
-            use_latex=False,
-            n1=5,
-            n2=8,
-            **kwargs
-        )
+    kwargs = {"scalar": scalar, "streamlines": streamlines}
+    if use_cm is not None:
+        kwargs["use_cm"] = use_cm
+    p = plot_vector(
+        Matrix([x, y]), (x, -5, 5), (y, -4, 4),
+        backend=MB, show=False, use_latex=use_latex, n1=5, n2=8,
+        **kwargs
+    )
 
     # contours + quivers: 1 colorbar for the contours
-    p = _plot_vector_1(True, False)
-    assert len(p.series) == 2
-    assert len(p.fig.axes) == 2
-    assert len(p.fig.axes[0].collections) > 1
-    assert p.fig.axes[1].get_ylabel() == "Magnitude"
-
-    # contours + streamlines: 1 colorbar for the contours
-    p = _plot_vector_1(True, True)
-    assert len(p.series) == 2
-    assert len(p.fig.axes) == 2
-    assert len(p.fig.axes[0].collections) > 1
-    assert p.fig.axes[1].get_ylabel() == "Magnitude"
-
-    # only quivers: 1 colorbar for the quivers
-    p = _plot_vector_1(False, False)
-    assert len(p.series) == 1
-    assert len(p.fig.axes) == 2
-    assert len(p.fig.axes[0].collections) == 1
-    assert p.fig.axes[1].get_ylabel() == "(x, y)"
-
-    # only streamlines: 1 colorbar for the streamlines
-    p = _plot_vector_1(False, False)
-    assert len(p.series) == 1
-    assert len(p.fig.axes) == 2
-    assert len(p.fig.axes[0].collections) == 1
-    assert p.fig.axes[1].get_ylabel() == "(x, y)"
-
-    # only quivers with solid color
-    p = _plot_vector_1(False, False, False)
-    assert len(p.series) == 1
-    assert len(p.fig.axes) == 1
-    assert len(p.fig.axes[0].collections) == 1
-
-    # only streamlines with solid color
-    p = _plot_vector_1(False, False, False)
-    assert len(p.series) == 1
-    assert len(p.fig.axes) == 1
-    assert len(p.fig.axes[0].collections) == 1
+    assert len(p.series) == n_series
+    assert len(p.fig.axes) == n_axes
+    if greater:
+        assert len(p.fig.axes[0].collections) > n_collections
+    else:
+        assert len(p.fig.axes[0].collections) == n_collections
+    idx = 1 if use_cm is None else 0
+    assert p.fig.axes[idx].get_ylabel() == label
 
 
 def test_vector_2d_multiple_series():
     # In the following example there is one contour series and 2 vector series
     # using solid colors. There should be two entries on the legend.
 
     x, y = symbols("x, y")
@@ -466,261 +483,207 @@
         vector_field_2d(2 * y, x, (x, -5, 5), (y, -3, 3), n=10,
             scalar=False, quiver_kw={"color": "r"}, use_cm=False),
         aspect="equal", grid=False, xlabel="x", ylabel="y", show=False)
 
     assert len(g.ax.get_legend().legend_handles) == 2
 
 
-def test_plot_vector_3d_quivers():
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_vector_3d_quivers(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `quiver_kw` overrides the
     # default settings
 
-    p = make_plot_vector_3d_quiver(MB, quiver_kw=dict(cmap="jet"))
-    assert len(p.series) == 1
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        MB, False, quiver_kw=dict(cmap="jet"), use_latex=use_latex)
+    assert len(p.backend.series) == 1
     f = p.fig
     ax = f.axes[0]
     assert len(ax.collections) == 1
     assert isinstance(
         ax.collections[0],
         mpl_toolkits.mplot3d.art3d.Line3DCollection
     )
     assert ax.collections[0].cmap.name == "jet"
-    assert f.axes[1].get_ylabel() == str((z, y, x))
-    p.close()
+    assert f.axes[1].get_ylabel() == label_func(use_latex, (a * z, y, x))
+    p.backend.update_interactive({a: 2})
+    p.backend.close()
 
-    p = make_plot_vector_3d_quiver(
-        MB, quiver_kw=dict(cmap=None, color="red"), use_cm=False
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        MB, False, quiver_kw=dict(cmap=None, color="red"), use_cm=False
     )
-    assert len(p.series) == 1
+    assert len(p.backend.series) == 1
     f = p.fig
     ax = f.axes[0]
     assert len(ax.collections) == 1
     assert isinstance(
         ax.collections[0],
         mpl_toolkits.mplot3d.art3d.Line3DCollection
     )
     assert np.allclose(
         ax.collections[0].get_color(),
         np.array([[1.0, 0.0, 0.0, 1.0]])
         )
-    p.close()
+    p.backend.update_interactive({a: 2})
+    p.backend.close()
 
 
 @pytest.mark.skipif(vtk is None, reason="vtk is not installed")
-def test_plot_vector_3d_streamlines():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_vector_3d_streamlines(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `stream_kw` overrides the
     # default settings
 
-    p = make_plot_vector_3d_streamlines_1(MB, stream_kw=dict())
-    assert len(p.series) == 1
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        MB, True, stream_kw=dict(), use_latex=use_latex)
+    assert len(p.backend.series) == 1
     f = p.fig
     ax = f.axes[0]
     assert len(ax.collections) == 1
     assert isinstance(ax.collections[0], mpl_toolkits.mplot3d.art3d.Line3DCollection)
-    assert f.axes[1].get_ylabel() == str((z, y, x))
-    p.close()
+    assert f.axes[1].get_ylabel() == label_func(use_latex, (a*z, y, x))
+    raises(
+        NotImplementedError,
+        lambda: p.backend.update_interactive({a: 2})
+    )
+    p.backend.close()
 
     # test different combinations for streamlines: it should not raise errors
-    p = make_plot_vector_3d_streamlines_1(MB, stream_kw=dict(starts=True))
-    p = make_plot_vector_3d_streamlines_1(
-        MB,
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        MB, True, stream_kw=dict(starts=True))
+    p.backend.close()
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        MB, True,
         stream_kw=dict(
             starts={
                 "x": np.linspace(-5, 5, 10),
                 "y": np.linspace(-4, 4, 10),
                 "z": np.linspace(-3, 3, 10),
             }
         ),
     )
-    p.close()
+    p.backend.close()
 
     # other keywords: it should not raise errors
-    p = make_plot_vector_3d_streamlines_1(
-        MB, stream_kw=dict(), kwargs=dict(use_cm=False)
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        MB, True, stream_kw=dict(), use_cm=False
     )
     f = p.fig
     ax = f.axes[0]
     assert len(ax.lines) == 1
     assert ax.lines[0].get_color() == "#1f77b4"
-    p.close()
-
-
-def test_plot_vector_2d_normalize():
-    # verify that backends are capable of normalizing a vector field before
-    # plotting it. Since all backend are different from each other, let's test
-    # that data in the figures is different in the two cases normalize=True
-    # and normalize=False
-
-    p1 = make_plot_vector_2d_normalize_1(MB, False)
-    p2 = make_plot_vector_2d_normalize_1(MB, True)
-    uu1 = p1.fig.axes[0].collections[0].U
-    vv1 = p1.fig.axes[0].collections[0].V
-    uu2 = p2.fig.axes[0].collections[0].U
-    vv2 = p2.fig.axes[0].collections[0].V
-    assert not np.allclose(uu1, uu2)
-    assert not np.allclose(vv1, vv2)
-    assert not np.allclose(np.sqrt(uu1**2 + vv1**2), 1)
-    assert np.allclose(np.sqrt(uu2**2 + vv2**2), 1)
+    p.backend.close()
 
 
 @pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
-def test_plot_vector_2d_normalize_interactive():
+def test_plot_vector_2d_normalize():
     # verify that backends are capable of normalizing a vector field before
     # plotting it. Since all backend are different from each other, let's test
     # that data in the figures is different in the two cases normalize=True
     # and normalize=False
-    p1 = make_plot_vector_2d_normalize_2(MB, False)
+    p1 = make_test_plot_vector_2d_normalize(MB, False)
     p1.backend.update_interactive({u: 1.5})
-    p2 = make_plot_vector_2d_normalize_2(MB, True)
+    p2 = make_test_plot_vector_2d_normalize(MB, True)
     p2.backend.update_interactive({u: 1.5})
     uu1 = p1.backend.fig.axes[0].collections[0].U
     vv1 = p1.backend.fig.axes[0].collections[0].V
     uu2 = p2.backend.fig.axes[0].collections[0].U
     vv2 = p2.backend.fig.axes[0].collections[0].V
     assert not np.allclose(uu1, uu2)
     assert not np.allclose(vv1, vv2)
     assert not np.allclose(np.sqrt(uu1**2 + vv1**2), 1)
     assert np.allclose(np.sqrt(uu2**2 + vv2**2), 1)
-
-
-@pytest.mark.filterwarnings("ignore::RuntimeWarning")
-def test_plot_vector_3d_normalize():
-    # verify that backends are capable of normalizing a vector field before
-    # plotting it. Since all backend are different from each other, let's test
-    # that data in the figures is different in the two cases normalize=True
-    # and normalize=False
-
-    p1 = make_plot_vector_3d_normalize_1(MB, False)
-    p2 = make_plot_vector_3d_normalize_1(MB, True)
-    seg1 = np.array(p1.fig.axes[0].collections[0].get_segments())
-    seg2 = np.array(p2.fig.axes[0].collections[0].get_segments())
-    # TODO: how can I test that these two quivers are different?
-    # assert not np.allclose(seg1, seg2)
+    p1.backend.close()
+    p2.backend.close()
 
 
 @pytest.mark.skipif(ct is None, reason="control is not installed")
 @pytest.mark.filterwarnings("ignore::RuntimeWarning")
-def test_plot_vector_3d_normalize_interactive():
+def test_plot_vector_3d_normalize():
     # verify that backends are capable of normalizing a vector field before
     # plotting it. Since all backend are different from each other, let's test
     # that data in the figures is different in the two cases normalize=True
     # and normalize=False
 
-    p1 = make_plot_vector_3d_normalize_2(MB, False)
+    p1 = make_test_plot_vector_3d_normalize(MB, False)
     p1.backend.update_interactive({u: 1.5})
-    p2 = make_plot_vector_3d_normalize_2(MB, True)
+    p2 = make_test_plot_vector_3d_normalize(MB, True)
     p2.backend.update_interactive({u: 1.5})
     seg1 = np.array(p1.fig.axes[0].collections[0].get_segments())
     seg2 = np.array(p2.fig.axes[0].collections[0].get_segments())
     # TODO: how can I test that these two quivers are different?
     # assert not np.allclose(seg1, seg2)
-
-
-def test_plot_vector_2d_quiver_color_func():
-    # verify that color_func gets applied to 2D quivers
-
-    p1 = make_plot_vector_2d_quiver_color_func_1(MB, None)
-    p2 = make_plot_vector_2d_quiver_color_func_1(MB, lambda x, y, u, v: x)
-    a1 = p1.fig.axes[0].collections[0].get_array()
-    a2 = p2.fig.axes[0].collections[0].get_array()
-    assert not np.allclose(a1, a2)
+    p1.backend.close()
+    p2.backend.close()
 
 
 @pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
-def test_plot_vector_2d_quiver_color_func_interactive():
+def test_plot_vector_2d_quiver_color_func():
     # verify that color_func gets applied to 2D quivers
 
-    x, y, a = symbols("x y a")
-    _pv2 = lambda B, cf: plot_vector(
-        (-a * y, x),
-        (x, -2, 2),
-        (y, -2, 2),
-        scalar=False,
-        use_cm=True,
-        color_func=cf,
-        show=False,
-        backend=B,
-        n=3,
-        params={a: (1, 0, 2)},
-    )
-
-    p1 = _pv2(MB, None)
-    p2 = _pv2(MB, lambda x, y, u, v: u)
-    p3 = _pv2(MB, lambda x, y, u, v: u)
+    p1 = make_test_plot_vector_2d_color_func(MB, False, None)
+    p2 = make_test_plot_vector_2d_color_func(MB, False, lambda x, y, u, v: u)
+    p3 = make_test_plot_vector_2d_color_func(MB, False, lambda x, y, u, v: u)
     p3.backend.update_interactive({a: 1.5})
     a1 = p1.fig.axes[0].collections[0].get_array()
     a2 = p2.fig.axes[0].collections[0].get_array()
     a3 = p3.fig.axes[0].collections[0].get_array()
     assert (not np.allclose(a1, a2)) and (not np.allclose(a2, a3))
+    p1.backend.close()
+    p2.backend.close()
+    p3.backend.close()
 
 
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_plot_vector_2d_streamline_color_func():
     # verify that color_func gets applied to 2D streamlines
 
-    x, y, a = symbols("x, y, a")
-
-    _pv = lambda cf: plot_vector(
-        (-y, x),
-        (x, -2, 2),
-        (y, -2, 2),
-        scalar=False,
-        streamlines=True,
-        use_cm=True,
-        color_func=cf,
-        show=False,
-        backend=MB,
-        n=3,
-    )
-
     # TODO: seems like streamline colors get applied only after the plot is
     # show... How do I perform this test?
-    p1 = _pv(None)
-    p2 = _pv(lambda x, y, u, v: x)
+    p1 = make_test_plot_vector_2d_color_func(MB, True, None)
+    p2 = make_test_plot_vector_2d_color_func(MB, True, lambda x, y, u, v: x)
     c1 = p1.fig.axes[0].collections[0].get_colors()
     c2 = p2.fig.axes[0].collections[0].get_colors()
     # assert not np.allclose(c1, c2)
-
-
-def test_plot_vector_3d_quivers_color_func():
-    # verify that color_func gets applied to 3D quivers
-
-    # TODO: is it possible to check matplotlib colors without showing the plot?
-    p1 = make_plot_vector_3d_quiver_color_func_1(MB, None)
-    p2 = make_plot_vector_3d_quiver_color_func_1(
-        MB, lambda x, y, z, u, v, w: x)
-    p1.draw()
-    p2.draw()
+    p1.backend.close()
+    p2.backend.close()
 
 
 @pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_plot_vector_3d_quivers_color_func_interactive():
     # verify that color_func gets applied to 3D quivers
 
-    p1 = make_plot_vector_3d_quiver_color_func_2(MB, None)
-    p2 = make_plot_vector_3d_quiver_color_func_2(
-        MB, lambda x, y, z, u, v, w: np.cos(u))
-    p3 = make_plot_vector_3d_quiver_color_func_2(
+    p1 = make_test_plot_vector_3d_quiver_color_func(MB, None)
+    p2 = make_test_plot_vector_3d_quiver_color_func(
         MB, lambda x, y, z, u, v, w: np.cos(u))
-    p1.backend.update_interactive({a: 0})
-    p2.backend.update_interactive({a: 0})
-    p3.backend.update_interactive({a: 2})
+    # TODO: is it possible to check matplotlib colors without showing the plot?
+    p1.backend.update_interactive({a: 2})
+    p2.backend.update_interactive({a: 2})
+    p1.backend.close()
+    p2.backend.close()
 
 
 @pytest.mark.skipif(vtk is None, reason="vtk is not installed")
 def test_plot_vector_3d_streamlines_color_func():
     # verify that color_func gets applied to 3D quivers
 
     # TODO: is it possible to check matplotlib colors without showing the plot?
-    p1 = make_plot_vector_3d_streamlines_color_func(MB, None)
-    p2 = make_plot_vector_3d_streamlines_color_func(
+    p1 = make_test_plot_vector_3d_streamlines_color_func(MB, None)
+    p2 = make_test_plot_vector_3d_streamlines_color_func(
         MB, lambda x, y, z, u, v, w: x)
-    p1.draw()
-    p2.draw()
+    p1.fig
+    p2.fig
+    raises(NotImplementedError, lambda: p1.backend.update_interactive({a: 2}))
+    raises(NotImplementedError, lambda: p2.backend.update_interactive({a: 2}))
 
 
 def test_plot_implicit_adaptive_true():
     # verify that the backends produce the expected results when
     # `plot_implicit()` is called with `adaptive=True`
 
     p = make_test_plot_implicit_adaptive_true(MB, rendering_kw=dict(color="r"))
@@ -740,15 +703,15 @@
 
     p = make_test_plot_implicit_adaptive_false(
         MB, rendering_kw=dict(cmap="jet"))
     assert len(p.series) == 1
     f = p.fig
     ax = f.axes[0]
     assert len(ax.collections) > 0
-    # TODO: how to retrieve the colormap from a contour series?????
+    # TODO: how to test for different colormaps?
     p.close()
 
 
 def test_plot_implicit_multiple_expressions():
     # verify that legend show multiple entries when multiple expressions are
     # plotted on the same plot.
 
@@ -761,66 +724,86 @@
     legend = [
         t for t in p3.ax.get_children()
         if isinstance(t, matplotlib.legend.Legend)
     ][0]
     assert len(legend.get_lines()) > 0
 
 
-def test_plot_real_imag():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_real_imag(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot_real_imag()` is called and `rendering_kw` overrides the default
     # settings
 
-    p = make_test_real_imag(MB, rendering_kw=dict(color="red"))
+    p = make_test_real_imag(MB, rendering_kw=dict(color="red"),
+        use_latex=use_latex)
     assert len(p.series) == 2
     f = p.fig
     ax = f.axes[0]
     assert len(ax.get_lines()) == 2
     assert ax.get_lines()[0].get_label() == "Re(sqrt(x))"
     assert ax.get_lines()[0].get_color() == "red"
     assert ax.get_lines()[1].get_label() == "Im(sqrt(x))"
     assert ax.get_lines()[1].get_color() == "red"
+    assert ax.get_xlabel() == label_func(use_latex, x)
+    assert ax.get_ylabel() == r"$f\left(x\right)$" if use_latex else "f(x)"
+
     p.close()
 
 
-def test_plot_complex_1d():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_complex_1d(use_latex):
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
-    p = make_test_plot_complex_1d(MB, rendering_kw=dict(color="red"))
+    p = make_test_plot_complex_1d(
+        MB, rendering_kw=dict(cmap="autumn"), use_latex=use_latex)
     assert len(p.series) == 1
     f = p.fig
     ax = f.axes[0]
     assert len(ax.collections) == 1
     assert isinstance(ax.collections[0], matplotlib.collections.LineCollection)
     assert f.axes[1].get_ylabel() == "Arg(sqrt(x))"
-    assert all(*(ax.collections[0].get_color() - np.array([1.0, 0.0, 0.0, 1.0])) == 0)
+    assert f.axes[0].get_xlabel() == "Real"
+    assert f.axes[0].get_ylabel() == "Abs"
+    # TODO: how to test for different colormaps?
     p.close()
 
 
-def test_plot_complex_2d():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_complex_2d(use_latex):
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
-    p = make_test_plot_complex_2d(MB, rendering_kw=dict())
+    p = make_test_plot_complex_2d(MB, rendering_kw=dict(), use_latex=use_latex)
     assert len(p.series) == 1
     f = p.fig
     ax = f.axes[0]
     assert len(ax.images) == 1
+    assert f.axes[0].get_xlabel() == "Re"
+    assert f.axes[0].get_ylabel() == "Im"
     assert f.axes[1].get_ylabel() == "Argument"
     assert ax.images[0].get_extent() == [-5.0, 5.0, -5.0, 5.0]
     p.close()
 
     p = make_test_plot_complex_2d(MB, rendering_kw=dict(extent=[-6, 6, -7, 7]))
     assert len(p.series) == 1
     f = p.fig
     ax = f.axes[0]
     assert len(ax.images) == 1
+    assert f.axes[0].get_xlabel() == "Re"
+    assert f.axes[0].get_ylabel() == "Im"
     assert f.axes[1].get_ylabel() == "Argument"
     assert ax.images[0].get_extent() == [-6, 6, -7, 7]
     p.close()
 
 
 def test_plot_complex_3d():
     # verify that the backends produce the expected results when
@@ -841,35 +824,27 @@
 
 def test_plot_complex_list():
     # verify that no errors are raise when plotting lists of complex points
     p = plot_complex_list(3 + 2 * I, 4 * I, 2, backend=MB, show=False)
     p.fig
 
 
-def test_plot_list_is_filled_false():
+@pytest.mark.parametrize(
+    "is_filled", [True, False]
+)
+def test_plot_list_is_filled(is_filled):
     # verify that the backends produce the expected results when
     # `plot_list()` is called with `is_filled=False`
 
-    p = make_test_plot_list_is_filled_false(MB)
-    f = p.fig
-    ax = f.axes[0]
-    assert len(ax.lines) == 1
-    assert ax.lines[0].get_markeredgecolor() != ax.lines[0].get_markerfacecolor()
-    p.close()
-
-
-def test_plot_list_is_filled_true():
-    # verify that the backends produce the expected results when
-    # `plot_list()` is called with `is_filled=True`
-
-    p = make_test_plot_list_is_filled_true(MB)
+    p = make_test_plot_list_is_filled(MB, is_filled)
     f = p.fig
     ax = f.axes[0]
     assert len(ax.lines) == 1
-    assert ax.lines[0].get_markeredgecolor() == ax.lines[0].get_markerfacecolor()
+    test = ax.lines[0].get_markeredgecolor() == ax.lines[0].get_markerfacecolor()
+    assert test is is_filled
     p.close()
 
 
 def test_plot_list_color_func():
     # verify that the backends produce the expected results when
     # `plot_list()` is called with `color_func`
 
@@ -890,28 +865,30 @@
     ax = f.axes[0]
     assert len(ax.lines) == 4
     colors = set()
     for l in ax.lines:
         colors.add(l.get_color())
     assert len(colors) == 1
     assert not p.legend
+    p.close()
 
 
 def test_plot_piecewise_multiple_series():
     # verify that plot_piecewise plotting N piecewise expressions uses
     # only N different colors
 
     p = make_test_plot_piecewise_multiple_series(MB)
     f = p.fig
     ax = f.axes[0]
     assert len(ax.lines) == 9
     colors = set()
     for l in ax.lines:
         colors.add(l.get_color())
     assert len(colors) == 2
+    p.close()
 
 
 def test_plot_geometry_1():
     # verify that the backends produce the expected results when
     # `plot_geometry()` is called
 
     p = make_test_plot_geometry_1(MB)
@@ -922,45 +899,49 @@
     assert ax.get_lines()[0].get_label() == str(Line((1, 2), (5, 4)))
     assert ax.get_lines()[1].get_label() == str(Circle((0, 0), 4))
     assert ax.get_lines()[2].get_label() == str(Polygon((2, 2), 3, n=6))
     assert len(p.ax.get_legend().legend_handles) == 3
     p.close()
 
 
-def test_plot_geometry_2():
+@pytest.mark.parametrize(
+    "is_filled, n_lines, n_coll, n_patches, n_legend", [
+        (False, 5, 1, 0, 5),
+        (True, 2, 1, 3, 5),
+    ]
+)
+def test_plot_geometry_2(is_filled, n_lines, n_coll, n_patches, n_legend):
     # verify that is_filled works correctly
 
-    p = make_test_plot_geometry_2(MB, False)
-    assert len(p.fig.axes[0].lines) == 5
-    assert len(p.fig.axes[0].collections) == 1
-    assert len(p.fig.axes[0].patches) == 0
-    assert len(p.ax.get_legend().legend_handles) == 5
-    p = make_test_plot_geometry_2(MB, True)
-    assert len(p.fig.axes[0].lines) == 2
-    assert len(p.fig.axes[0].collections) == 1
-    assert len(p.fig.axes[0].patches) == 3
-    assert len(p.ax.get_legend().legend_handles) == 5
+    p = make_test_plot_geometry_2(MB, is_filled)
+    assert len(p.fig.axes[0].lines) == n_lines
+    assert len(p.fig.axes[0].collections) == n_coll
+    assert len(p.fig.axes[0].patches) == n_patches
+    assert len(p.ax.get_legend().legend_handles) == n_legend
+    p.close()
 
 
 def test_plot_geometry_3d():
     # verify that no errors are raised when 3d geometric entities are plotted
 
     p = make_test_plot_geometry_3d(MB)
     p.draw()
+    p.close()
 
 
 def test_plot_geometry_rendering_kw():
     # verify that rendering_kw works fine
     p = plot_geometry(
         Segment((0, 0), (1, 0)), "r", {"color": "red"},
         show=False
     )
     assert p[0].rendering_kw == {"color": "red"}
     p.draw()
     assert p.ax.lines[0].get_color() == "red"
+    p.close()
 
 
 def test_save():
     # Verify that the save method accepts keyword arguments.
 
     x, y, z = symbols("x:z")
     options = dict(backend=MB, show=False, adaptive=False, n=5)
@@ -983,299 +964,110 @@
 
         p = plot3d(cos(x**2 + y**2), (x, -3, 3), (y, -3, 3), **options)
         filename = "test_mpl_save_4.pdf"
         p.save(os.path.join(tmpdir, filename), dpi=150)
         p.close()
 
 
-@pytest.mark.skipif(ct is None, reason="control is not installed")
-def test_vectors_3d_update_interactive():
-    # Some backends do not support streamlines with iplot. Test that the
-    # backends raise error.
-
-    p = make_test_vectors_3d_update_interactive(MB)
-    raises(
-        NotImplementedError,
-        lambda: p.backend.update_interactive({a: 2, b: 2, c: 2})
-    )
-
-
-def test_aspect_ratio_2d_issue_11764():
+@pytest.mark.parametrize(
+    "aspect, expected", [
+        ("auto", "auto"),
+        ((1, 1), 1),
+        ("equal", 1),
+    ]
+)
+def test_aspect_ratio_2d_issue_11764(aspect, expected):
     # verify that the backends apply the provided aspect ratio.
     # NOTE: read the backend docs to understand which options are available.
 
-    p = make_test_aspect_ratio_2d_issue_11764(MB)
-    assert p.aspect == "auto"
-    assert p.fig.axes[0].get_aspect() == "auto"
-    p.close()
-
-    p = make_test_aspect_ratio_2d_issue_11764(MB, (1, 1))
-    assert p.aspect == (1, 1)
-    assert p.fig.axes[0].get_aspect() == 1
-    p.close()
-
-    p = make_test_aspect_ratio_2d_issue_11764(MB, "equal")
-    assert p.aspect == "equal"
-    assert p.fig.axes[0].get_aspect() == 1
+    p = make_test_aspect_ratio_2d_issue_11764(MB, aspect)
+    assert p.aspect == aspect
+    assert p.fig.axes[0].get_aspect() == expected
     p.close()
 
 
 def test_aspect_ratio_3d():
     # verify that the backends apply the provided aspect ratio.
     # NOTE:
     # 1. read the backend docs to understand which options are available.
     # 2. K3D doesn't use the `aspect` keyword argument.
     x, y = symbols("x, y")
 
     p = make_test_aspect_ratio_3d(MB)
     assert p.aspect == "auto"
+    p.close()
 
     # Matplotlib 3D axis requires a string-valued aspect ratio
     # depending on the version, it raises one of the following errors
     raises(
         (NotImplementedError, ValueError),
         lambda: make_test_aspect_ratio_3d(MB, (1, 1)).draw(),
     )
 
 
 def test_plot_size():
     # verify that the keyword `size` is doing it's job
-    # NOTE: K3DBackend doesn't support custom size
 
     x, y = symbols("x, y")
 
     p = make_test_plot_size(MB, (8, 4))
     s = p.fig.get_size_inches()
     assert (s[0] == 8) and (s[1] == 4)
     p.close()
 
-    p = make_test_plot_size(MB, (10, 5))
-    s = p.fig.get_size_inches()
-    assert (s[0] == 10) and (s[1] == 5)
-    p.close()
-
 
 @pytest.mark.filterwarnings("ignore::RuntimeWarning")
-def test_plot_scale_lin_log():
+@pytest.mark.parametrize(
+    "xscale, yscale", [
+        ("linear", "linear"),
+        ("log", "linear"),
+        ("linear", "log"),
+        ("log", "log"),
+    ]
+)
+def test_plot_scale_lin_log(xscale, yscale):
     # verify that backends are applying the correct scale to the axes
     # NOTE: none of the 3D libraries currently support log scale.
 
     x, y = symbols("x, y")
 
-    p = make_test_plot_scale_lin_log(MB, "linear", "linear")
-    assert p.fig.axes[0].get_xscale() == "linear"
-    assert p.fig.axes[0].get_yscale() == "linear"
-    p.close()
-
-    p = make_test_plot_scale_lin_log(MB, "log", "linear")
-    assert p.fig.axes[0].get_xscale() == "log"
-    assert p.fig.axes[0].get_yscale() == "linear"
-    p.close()
-
-    p = make_test_plot_scale_lin_log(MB, "linear", "log")
-    assert p.fig.axes[0].get_xscale() == "linear"
-    assert p.fig.axes[0].get_yscale() == "log"
+    p = make_test_plot_scale_lin_log(MB, xscale, yscale)
+    assert p.fig.axes[0].get_xscale() == xscale
+    assert p.fig.axes[0].get_yscale() == yscale
     p.close()
 
 
 def test_backend_latex_labels():
     # verify that backends are going to set axis latex-labels in the
     # 2D and 3D case
 
     p1 = make_test_backend_latex_labels_1(MB, True)
     p2 = make_test_backend_latex_labels_1(MB, False)
     assert p1.xlabel == p1.fig.axes[0].get_xlabel() == "$x^{2}_{1}$"
     assert p2.xlabel == p2.fig.axes[0].get_xlabel() == "x_1^2"
     assert p1.ylabel == p1.fig.axes[0].get_ylabel() == "$f\\left(x^{2}_{1}\\right)$"
     assert p2.ylabel == p2.fig.axes[0].get_ylabel() == "f(x_1^2)"
+    p1.close()
+    p2.close()
 
     p1 = make_test_backend_latex_labels_2(MB, True)
     p2 = make_test_backend_latex_labels_2(MB, False)
     assert p1.xlabel == p1.fig.axes[0].get_xlabel() == "$x^{2}_{1}$"
     assert p1.ylabel == p1.fig.axes[0].get_ylabel() == "$x_{2}$"
     assert (
         p1.zlabel == p1.fig.axes[0].get_zlabel() == "$f\\left(x^{2}_{1}, x_{2}\\right)$"
     )
     assert p2.xlabel == p2.fig.axes[0].get_xlabel() == "x_1^2"
     assert p2.ylabel == p2.fig.axes[0].get_ylabel() == "x_2"
     assert p2.zlabel == p2.fig.axes[0].get_zlabel() == "f(x_1^2, x_2)"
+    p1.close()
+    p2.close()
 
 
-def test_plot_use_latex():
-    # verify that the backends produce the expected results when `plot()`
-    # is called and `rendering_kw` overrides the default line settings
-
-    p = make_test_plot_use_latex(MB)
-    f = p.fig
-    ax = f.axes[0]
-    assert ax.get_lines()[0].get_label() == "$\\sin{\\left(x \\right)}$"
-    assert ax.get_lines()[1].get_label() == "$\\cos{\\left(x \\right)}$"
-    p.close()
-
-
-def test_plot_parametric_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_parametric_use_latex(MB)
-    assert len(p.series) == 1
-    f = p.fig
-    assert f.axes[1].get_ylabel() == "$x$"
-    p.close()
-
-
-def test_plot_contour_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_contour_use_latex(MB)
-    assert len(p.series) == 1
-    f = p.fig
-    assert f.axes[1].get_ylabel() == "$%s$" % latex(cos(x**2 + y**2))
-
-
-def test_plot3d_parametric_line_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot3d_parametric_line_use_latex(MB)
-    assert len(p.series) == 1
-    f = p.fig
-    assert f.axes[1].get_ylabel() == "$x$"
-    p.close()
-
-
-def test_plot3d_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot3d_use_latex(MB)
-    f = p.fig
-    assert len(f.axes) == 3
-    assert f.axes[1].get_ylabel() == "$%s$" % latex(cos(x**2 + y**2))
-    assert f.axes[2].get_ylabel() == "$%s$" % latex(sin(x**2 + y**2))
-    p.close()
-
-
-def test_plot_vector_2d_quivers_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_quivers_use_latex(MB)
-    f = p.fig
-    assert f.axes[1].get_ylabel() == "Magnitude"
-    p.close()
-
-
-def test_plot_vector_2d_streamlines_custom_scalar_field_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_streamlines_custom_scalar_field_use_latex(MB)
-    f = p.fig
-    assert f.axes[1].get_ylabel() == "$x + y$"
-    p.close()
-
-
-def test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex(
-        MB
-    )
-    f = p.fig
-    assert f.axes[1].get_ylabel() == "test"
-
-
-def test_plot_vector_2d_use_latex_colorbar():
-    # verify that the colorbar uses latex label
-
-    # contours + quivers: 1 colorbar for the contours
-    p = make_test_plot_vector_2d_use_latex_colorbar(MB, True, False)
-    assert p.fig.axes[1].get_ylabel() == "Magnitude"
-    p.close()
-
-    # contours + streamlines: 1 colorbar for the contours
-    p = make_test_plot_vector_2d_use_latex_colorbar(MB, True, True)
-    assert p.fig.axes[1].get_ylabel() == "Magnitude"
-    p.close()
-
-    # only quivers: 1 colorbar for the quivers
-    p = make_test_plot_vector_2d_use_latex_colorbar(MB, False, False)
-    assert p.fig.axes[1].get_ylabel() == "$\\left( x, \\  y\\right)$"
-    p.close()
-
-    # only streamlines: 1 colorbar for the streamlines
-    p = make_test_plot_vector_2d_use_latex_colorbar(MB, False, True)
-    assert p.fig.axes[1].get_ylabel() == "$\\left( x, \\  y\\right)$"
-    p.close()
-
-
-def test_plot_vector_3d_quivers_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_3d_quivers_use_latex(MB)
-    assert len(p.fig.axes) == 2
-    assert p.fig.axes[1].get_ylabel() == "$\\left( z, \\  y, \\  x\\right)$"
-    p.close()
-
-
-@pytest.mark.skipif(vtk is None, reason="vtk is not installed")
-def test_plot_vector_3d_streamlines_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_3d_streamlines_use_latex(MB)
-    assert p.fig.axes[1].get_ylabel() == "$\\left( z, \\  y, \\  x\\right)$"
-    p.close()
-
-
-@pytest.mark.filterwarnings("ignore::RuntimeWarning")
-def test_plot_complex_use_latex_1():
-    # complex plot function should return the same result (for axis labels)
-    # wheter use_latex is True or False
-
-    p = make_test_plot_complex_use_latex_1(MB)
-    assert p.fig.axes[0].get_xlabel() == "Real"
-    assert p.fig.axes[0].get_ylabel() == "Abs"
-    assert p.fig.axes[1].get_ylabel() == "Arg(cos(x) + I*sinh(x))"
-    p.close()
-
-
-@pytest.mark.skipif(scipy is None, reason="scipy is not installed")
-@pytest.mark.filterwarnings("ignore::RuntimeWarning")
-def test_plot_complex_use_latex_2():
-    # complex plot function should return the same result (for axis labels)
-    # wheter use_latex is True or False
-
-    p = make_test_plot_complex_use_latex_2(MB)
-    assert p.fig.axes[0].get_xlabel() == "Re"
-    assert p.fig.axes[0].get_ylabel() == "Im"
-    assert p.fig.axes[1].get_ylabel() == "Argument"
-    p.close()
-
-
-def test_plot_real_imag_use_latex():
-    # real/imag plot function should return the same result (for axis labels)
-    # wheter use_latex is True or False
-
-    p = make_test_plot_real_imag_use_latex(MB)
-    assert p.fig.axes[0].get_xlabel() == "$x$"
-    assert p.fig.axes[0].get_ylabel() == r"$f\left(x\right)$"
-    assert p.fig.axes[0].lines[0].get_label() == "Re(sqrt(x))"
-    assert p.fig.axes[0].lines[1].get_label() == "Im(sqrt(x))"
-    p.close()
-
-
-def test_plot3d_use_cm():
-    # verify that use_cm produces the expected results on plot3d
-
-    x, y = symbols("x, y")
-    p1 = make_test_plot3d_use_cm(MB, True)
-    p2 = make_test_plot3d_use_cm(MB, False)
-    p1.draw()
-    p2.draw()
-    assert "cmap" in p1.renderers[0].handles[0][1].keys()
-    assert "cmap" not in p2.renderers[0].handles[0][1].keys()
-
-
-def test_plot3dupdate_interactive():
+def test_plot3d_update_interactive():
     # verify that MB._update_interactive applies the original color/colormap
     # each time it gets called
     # Since matplotlib doesn't apply color/colormaps until the figure is shown,
     # verify that the correct keyword arguments are into _handles.
 
     x, y, u = symbols("x, y, u")
 
@@ -1295,14 +1087,15 @@
     p.draw()
     kw, _, _ = p.renderers[0].handles[0][1:]
     c1 = kw["color"]
     p.update_interactive({u: 2})
     kw, _, _ = p.renderers[0].handles[0][1:]
     c2 = kw["color"]
     assert c1 == c2
+    p.close()
 
     s = SurfaceOver2DRangeSeries(
         u * cos(x**2 + y**2),
         (x, -5, 5),
         (y, -5, 5),
         "test",
         threed=True,
@@ -1316,138 +1109,113 @@
     p.draw()
     kw, _, _ = p.renderers[0].handles[0][1:]
     c1 = kw["cmap"]
     p.update_interactive({u: 2})
     kw, _, _ = p.renderers[0].handles[0][1:]
     c2 = kw["cmap"]
     assert c1 == c2
+    p.close()
 
 
 def test_plot_polar():
     # verify that 2D polar plot can create plots with cartesian axis and
     #  polar axis
 
     # test for cartesian axis
     p1 = make_test_plot_polar(MB, False)
     assert not isinstance(
         p1.fig.axes[0], matplotlib.projections.polar.PolarAxes)
+    p1.close()
 
     # polar axis
     p1 = make_test_plot_polar(MB, True)
     assert isinstance(p1.fig.axes[0], matplotlib.projections.polar.PolarAxes)
+    p1.close()
 
 
 def test_plot_polar_use_cm():
     # verify the correct behavior of plot_polar when color_func
     # or use_cm are applied
 
     # cartesian axis, no colormap
     p = make_test_plot_polar_use_cm(MB, False, False)
     assert len(p.ax.lines) > 0
     assert len(p.ax.collections) == 0
+    p.close()
 
     # cartesian axis, with colormap
     p = make_test_plot_polar_use_cm(MB, False, True)
     assert len(p.ax.lines) == 0
     assert len(p.ax.collections) > 0
+    p.close()
 
     # polar axis, no colormap
     p = make_test_plot_polar_use_cm(MB, True, False)
     assert len(p.ax.lines) > 0
     assert len(p.ax.collections) == 0
+    p.close()
 
     # polar axis, with colormap
     p = make_test_plot_polar_use_cm(MB, True, True, lambda t: t)
     assert len(p.ax.lines) == 0
     assert len(p.ax.collections) > 0
+    p.close()
 
 
 def test_plot3d_implicit():
     # verify that plot3d_implicit don't raise errors
 
     raises(NotImplementedError, lambda: make_test_plot3d_implicit(MB).draw())
 
 
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_surface_color_func():
     # After the addition of `color_func`, `SurfaceOver2DRangeSeries` and
     # `ParametricSurfaceSeries` returns different elements.
     # Verify that backends do not raise errors when plotting surfaces and that
     # the color function is applied.
 
-    p1 = make_test_surface_color_func_1(MB, lambda x, y, z: z)
-    p1.draw()
-    p2 = make_test_surface_color_func_1(
-        MB, lambda x, y, z: np.sqrt(x**2 + y**2))
-    p2.draw()
-
-    p1 = make_test_surface_color_func_2(MB, lambda x, y, z, u, v: z)
-    p1.draw()
-    p2 = make_test_surface_color_func_2(
-        MB, lambda x, y, z, u, v: np.sqrt(x**2 + y**2)
-    )
-    p2.draw()
-
-
-def test_surface_interactive_color_func():
-    # After the addition of `color_func`, `SurfaceInteractiveSeries` and
-    # `ParametricSurfaceInteractiveSeries` returns different elements.
-    # Verify that backends do not raise errors when updating surfaces and a
-    # color function is applied.
-
-    p = make_test_surface_interactive_color_func(MB)
-    p.draw()
-    p.update_interactive({t: 2})
+    p = make_test_surface_color_func(MB)
+    fig = p.fig
+    p.backend.update_interactive({t: 2})
+    p.backend.close()
 
 
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_line_color_func():
-    # Verify that backends do not raise errors when plotting lines and that
-    # the color function is applied.
-
-    p1 = make_test_line_color_func(MB, None)
-    p1.draw()
-    p2 = make_test_line_color_func(MB, lambda x, y: np.cos(x))
-    p2.draw()
-    assert len(p1.fig.axes[0].lines) == 1
-    assert isinstance(
-        p2.fig.axes[0].collections[0], matplotlib.collections.LineCollection
-    )
-    assert np.allclose(
-        p2.fig.axes[0].collections[0].get_array(),
-        np.cos(np.linspace(-3, 3, 5))
-    )
-
-
-def test_line_interactive_color_func():
     # Verify that backends do not raise errors when updating lines and a
     # color function is applied.
 
-    p = make_test_line_interactive_color_func(MB)
-    p.draw()
-    p.update_interactive({t: 2})
+    p = make_test_line_color_func(MB)
+    p.backend.draw()
+    p.backend.update_interactive({t: 2})
     assert len(p.fig.axes[0].lines) == 1
     assert isinstance(
         p.fig.axes[0].collections[0], matplotlib.collections.LineCollection
     )
     assert np.allclose(
         p.fig.axes[0].collections[0].get_array(),
         np.cos(np.linspace(-3, 3, 5))
     )
+    p.backend.close()
 
 
 def test_line_color_plot():
     # verify back-compatibility with old sympy.plotting module when using
     # line_color
 
     p = make_test_line_color_plot(MB, "red")
     f = p.fig
     ax = f.axes[0]
     assert ax.get_lines()[0].get_color() == "red"
+    p.close()
     p = make_test_line_color_plot(MB, lambda x: -x)
     f = p.fig
     assert len(p.fig.axes) == 2  # there is a colorbar
+    p.close()
 
 
 def test_line_color_plot3d_parametric_line():
     # verify back-compatibility with old sympy.plotting module when using
     # line_color
 
     p = make_test_line_color_plot3d_parametric_line(MB, "red", False)
@@ -1477,277 +1245,190 @@
     p[0].label = "a"
     p[1].label = "$b^{2}$"
     f = p.fig
     assert f.axes[0].lines[0].get_label() == "a"
     assert f.axes[0].lines[1].get_label() == "$b^{2}$"
 
 
-@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
-def test_update_interactive():
-    # quick round down of test to verify that _update_interactive doesn't
-    # raise errors
+def test_min_install():
+    # quick round down of test to verify that ordinay plots don't
+    # raise errors. Useful to test minimum installation of the module
 
-    u, v, x, y, z = symbols("u, v, x:z")
+    x, y, z = symbols("x:z")
+    options = dict(adaptive=False, n=5, backend=MB, show=False)
+    options2 = dict(n=5, backend=MB, show=False)
 
-    p = plot(
-        sin(u * x),
-        (x, -pi, pi),
-        adaptive=False,
-        n=5,
-        backend=MB,
-        show=False,
-        params={u: (1, 0, 2)},
-    )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p = plot(sin(x), (x, -pi, pi), **options)
+    p.draw()
+    p.close()
 
     p = plot_parametric(
-        cos(u * x),
-        sin(u * x),
-        (x, 0, 2 * pi),
-        adaptive=False,
-        n=5,
-        backend=MB,
-        show=False,
-        params={u: (1, 0, 2)},
-        use_cm=True,
-        is_point=False,
+        cos(x), sin(x), (x, 0, 2 * pi),
+        use_cm=True, is_point=False, **options
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     p = plot_parametric(
-        cos(u * x),
-        sin(u * x),
-        (x, 0, 2 * pi),
-        adaptive=False,
-        n=5,
-        backend=MB,
-        show=False,
-        params={u: (1, 0, 2)},
-        use_cm=True,
-        is_point=True,
+        cos(x), sin(x), (x, 0, 2 * pi),
+        use_cm=True, is_point=True, **options
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     p = plot_parametric(
-        cos(u * x),
-        sin(u * x),
-        (x, 0, 2 * pi),
-        adaptive=False,
-        n=5,
-        backend=MB,
-        show=False,
-        params={u: (1, 0, 2)},
-        use_cm=False,
+        cos(x), sin(x), (x, 0, 2 * pi),
+        use_cm=False, **options
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     p = plot_implicit(
-        x**2 + y**2 - 4,
-        (x, -5, 5),
-        (y, -5, 5),
-        adaptive=False,
-        n=5,
-        show=False,
-        backend=MB,
+        x**2 + y**2 - 4, (x, -5, 5), (y, -5, 5),
+        **options
     )
+    p.draw()
+    p.close()
 
     # points
     p = plot3d_parametric_line(
-        cos(u * x),
-        sin(x),
-        x,
-        (x, -pi, pi),
-        backend=MB,
-        is_point=True,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
+        cos(x), sin(x), x, (x, -pi, pi),
+        is_point=True, **options2
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     # line with colormap
     p = plot3d_parametric_line(
-        cos(u * x),
-        sin(x),
-        x,
-        (x, -pi, pi),
-        backend=MB,
-        is_point=False,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-        use_cm=True,
+        cos(x), sin(x), x, (x, -pi, pi),
+        is_point=False, use_cm=True, **options
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     # line with solid color
     p = plot3d_parametric_line(
-        cos(u * x),
-        sin(x),
-        x,
-        (x, -pi, pi),
-        backend=MB,
-        is_point=False,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-        use_cm=False,
+        cos(x), sin(x), x, (x, -pi, pi),
+        is_point=False, use_cm=False, **options
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     p = plot3d_parametric_line(
-        cos(u * x),
-        sin(x),
-        x,
-        (x, -pi, pi),
-        backend=MB,
-        is_point=False,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-        use_cm=True,
+        cos(x), sin(x), x, (x, -pi, pi),
+        is_point=False, use_cm=True, **options
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     p = plot3d(
-        cos(u * x**2 + y**2),
-        (x, -2, 2),
-        (y, -2, 2),
-        backend=MB,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
+        cos(x**2 + y**2), (x, -2, 2), (y, -2, 2),
+        **options
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     p = plot_contour(
-        cos(u * x**2 + y**2),
-        (x, -2, 2),
-        (y, -2, 2),
-        backend=MB,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-        is_filled=False,
+        cos(x**2 + y**2), (x, -2, 2), (y, -2, 2),
+        is_filled=False, **options
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     p = plot_contour(
-        cos(u * x**2 + y**2),
-        (x, -2, 2),
-        (y, -2, 2),
-        backend=MB,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-        is_filled=True,
+        cos(x**2 + y**2), (x, -2, 2), (y, -2, 2),
+        is_filled=True, **options
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     u, v = symbols("u, v")
-    fx = (1 + v / 2 * cos(u / 2)) * cos(x * u)
-    fy = (1 + v / 2 * cos(u / 2)) * sin(x * u)
+    fx = (1 + v / 2 * cos(u / 2)) * cos(u)
+    fy = (1 + v / 2 * cos(u / 2)) * sin(u)
     fz = v / 2 * sin(u / 2)
     p = plot3d_parametric_surface(
-        fx,
-        fy,
-        fz,
-        (u, 0, 2 * pi),
-        (v, -1, 1),
-        backend=MB,
-        use_cm=True,
-        n1=5,
-        n2=5,
-        show=False,
-        params={x: (1, 0, 2)},
+        fx, fy, fz, (u, 0, 2 * pi), (v, -1, 1),
+        use_cm=True, **options2
     )
-    p.backend.draw()
-    p.backend.update_interactive({x: 2})
+    p.draw()
+    p.close()
 
     p = plot_vector(
-        Matrix([-u * y, x]),
-        (x, -5, 5),
-        (y, -4, 4),
-        backend=MB,
-        n=4,
-        show=False,
-        params={u: (1, 0, 2)},
-        scalar=True,
+        Matrix([-y, x]), (x, -5, 5), (y, -4, 4),
+        scalar=True, **options2
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     p = plot_vector(
-        Matrix([-u * y, x]),
-        (x, -5, 5),
-        (y, -4, 4),
-        backend=MB,
-        n=4,
-        show=False,
-        params={u: (1, 0, 2)},
-        scalar=False,
+        Matrix([-y, x]), (x, -5, 5), (y, -4, 4),
+        scalar=False, **options2
     )
-    p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.draw()
+    p.close()
 
     p = plot_vector(
-        Matrix([u * z, y, x]),
-        (x, -5, 5),
-        (y, -4, 4),
-        (z, -3, 3),
-        backend=MB,
-        n=4,
-        show=False,
-        params={u: (1, 0, 2)},
+        Matrix([z, y, x]), (x, -5, 5), (y, -4, 4), (z, -3, 3),
+        **options2
+    )
+    p.draw()
+    p.close()
+
+    p = plot_complex(
+        sqrt(x), (x, -5 - 5 * I, 5 + 5 * I),
+        threed=False, **options2
+    )
+    p.draw()
+    p.close()
+
+    p = plot_complex(
+        sqrt(x), (x, -5 - 5 * I, 5 + 5 * I),
+        threed=True, use_cm=True, **options2
+    )
+    p.draw()
+    p.close()
+
+
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+def test_update_interactive():
+    # quick round down of test to verify that update_interactive doesn't
+    # raise errors
+
+    u, v, x, y, z = symbols("u, v, x:z")
+
+    u, v = symbols("u, v")
+    fx = (1 + v / 2 * cos(u / 2)) * cos(x * u)
+    fy = (1 + v / 2 * cos(u / 2)) * sin(x * u)
+    fz = v / 2 * sin(u / 2)
+    p = plot3d_parametric_surface(
+        fx, fy, fz, (u, 0, 2 * pi), (v, -1, 1),
+        backend=MB, use_cm=True, n1=5, n2=5, show=False,
+        params={x: (1, 0, 2)},
     )
     p.backend.draw()
-    p.backend.update_interactive({u: 2})
+    p.backend.update_interactive({x: 2})
+    p.backend.close()
 
     p = plot_complex(
-        sqrt(u * x),
-        (x, -5 - 5 * I, 5 + 5 * I),
-        show=False,
-        backend=MB,
-        threed=False,
-        n=5,
+        sqrt(u * x), (x, -5 - 5 * I, 5 + 5 * I),
+        show=False, backend=MB, threed=False, n=5,
         params={u: (1, 0, 2)},
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
+    p.backend.close()
 
     p = plot_complex(
-        sqrt(u * x),
-        (x, -5 - 5 * I, 5 + 5 * I),
-        show=False,
-        backend=MB,
-        threed=True,
-        use_cm=True,
-        n=5,
+        sqrt(u * x), (x, -5 - 5 * I, 5 + 5 * I),
+        show=False, backend=MB, threed=True, use_cm=True, n=5,
         params={u: (1, 0, 2)},
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
+    p.backend.close()
 
     from sympy.geometry import Line as SymPyLine
 
     p = plot_geometry(
         SymPyLine((u, 2), (5, 4)),
         Circle((0, 0), u),
         Polygon((2, u), 3, n=6),
@@ -1756,28 +1437,30 @@
         is_filled=False,
         use_latex=False,
         params={u: (1, 0, 2)},
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
     p.backend.update_interactive({u: 3})
+    p.backend.close()
 
     p = plot_geometry(
         SymPyLine((u, 2), (5, 4)),
         Circle((0, 0), u),
         Polygon((2, u), 3, n=6),
         backend=MB,
         show=False,
         is_filled=True,
         use_latex=False,
         params={u: (1, 0, 2)},
     )
     p.backend.draw()
     p.backend.update_interactive({u: 2})
     p.backend.update_interactive({u: 3})
+    p.backend.close()
 
 
 def test_generic_data_series():
     # verify that backends do not raise errors when generic data series
     # are used
 
     x = symbols("x")
@@ -1791,85 +1474,88 @@
         annotations=[{"text": "test", "xy": (0, 0)}],
         fill=[{"x": [0, 1, 2, 3], "y1": [0, 1, 2, 3]}],
         rectangles=[{"xy": (0, 0), "width": 5, "height": 1}],
     )
     p.draw()
 
 
-def test_axis_center():
+@pytest.mark.parametrize("ac", ["center", "auto", (0, 0)])
+def test_axis_center(ac):
     # verify that axis_center doesn't raise any errors
 
     x = symbols("x")
-    _plot = lambda ac: plot(
+    p = plot(
         sin(x),
         adaptive=False, n=5,
         backend=MB, show=False, axis_center=ac
     )
-
-    _plot("center").draw()
-    _plot("auto").draw()
-    _plot((0, 0)).draw()
-
-
-def test_plot3d_list_use_cm_False():
-    # verify that plot3d_list produces the expected results when no color map
-    # is required
-
-    # solid color line
-    p = make_test_plot3d_list_use_cm_False(MB, False, False)
     p.draw()
-    assert len(p.series) == 1
-    assert len(p.ax.lines) == 1
-    assert p.ax.lines[0].get_color() == "#1f77b4"
-
-    # solid color markers with empty faces
-    p = make_test_plot3d_list_use_cm_False(MB, True, False)
-    p.draw()
-    assert len(p.ax.collections) == 1
-    assert p.ax.collections[0].get_facecolors().size == 0
-
-    # solid color markers with filled faces
-    p = make_test_plot3d_list_use_cm_False(MB, True, True)
-    p.draw()
-    assert len(p.ax.collections) == 1
-    assert p.ax.collections[0].get_facecolors().size > 0
+    p.close()
 
 
-def test_plot3d_list_use_cm_color_func():
-    # verify that use_cm=True and color_func do their job
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+def test_plot3d_list():
+    # verify that no errors are raises while updating a plot3d_list
 
-    # line with colormap
-    # if color_func is not provided, the same parameter will be used
-    # for all points
-    p1 = make_test_plot3d_list_use_cm_color_func(MB, False, False, None)
-    p1.draw()
-    c1 = p1.ax.collections[0].get_array()
-    p2 = make_test_plot3d_list_use_cm_color_func(
-        MB, False, False, lambda x, y, z: x)
-    p2.draw()
-    c2 = p2.ax.collections[0].get_array()
-    assert not np.allclose(c1, c2)
+    p = make_test_plot3d_list(MB, False, None)
+    ax = p.backend.ax
+    d1 = p.backend[0].get_data()
+    assert len(ax.lines) == 1
+    assert len(ax.collections) == 2
+    c1, c2 = ax.collections
+    arr1 = c1.get_array()
+    # TODO: when use_cm=True, is_filled=False, this shouldn't happen. Bug.
+    assert len(c1.get_edgecolor()) == len(c1.get_facecolor())
+    assert len(c2.get_edgecolor()) != len(c2.get_facecolor())
+    p.backend.update_interactive({t: 1})
+    p.backend.close()
 
-    # markers with empty faces
-    p1 = make_test_plot3d_list_use_cm_color_func(MB, True, False, None)
-    p1.draw()
-    c1 = p1.ax.collections[0].get_array()
-    p2 = make_test_plot3d_list_use_cm_color_func(
-        MB, False, False, lambda x, y, z: x)
-    p2.draw()
-    c2 = p2.ax.collections[0].get_array()
-    assert not np.allclose(c1, c2)
+    p = make_test_plot3d_list(MB, True, None)
+    ax = p.backend.ax
+    d2 = p.backend[0].get_data()
+    assert len(ax.lines) == 1
+    assert len(ax.collections) == 2
+    c1, c2 = ax.collections
+    arr2 = c1.get_array()
+    assert len(c1.get_edgecolor()) == len(c1.get_facecolor())
+    assert len(c2.get_edgecolor()) == len(c2.get_facecolor())
+    p.backend.update_interactive({t: 1})
+    p.backend.close()
 
+    p = make_test_plot3d_list(MB, False, lambda x, y, z: x)
+    ax = p.backend.ax
+    d3 = p.backend[0].get_data()
+    assert len(ax.lines) == 1
+    assert len(ax.collections) == 2
+    c1, c2 = ax.collections
+    arr3 = c1.get_array()
+    # TODO: when use_cm=True, is_filled=False, this shouldn't happen. Bug.
+    assert len(c1.get_edgecolor()) == len(c1.get_facecolor())
+    assert len(c2.get_edgecolor()) != len(c2.get_facecolor())
+    p.backend.update_interactive({t: 1})
+    p.backend.close()
 
-@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
-def test_plot3d_list_interactive():
-    # verify that no errors are raises while updating a plot3d_list
+    assert len(d1) != len(d3)
+    assert not np.allclose(arr1, arr3)
 
-    p = make_test_plot3d_list_interactive(MB)
+    p = make_test_plot3d_list(MB, True, lambda x, y, z: x)
+    ax = p.backend.ax
+    d4 = p.backend[0].get_data()
+    assert len(ax.lines) == 1
+    assert len(ax.collections) == 2
+    c1, c2 = ax.collections
+    arr4 = c1.get_array()
+    # TODO: when use_cm=True, is_filled=False, this shouldn't happen. Bug.
+    assert len(c1.get_edgecolor()) == len(c1.get_facecolor())
+    assert len(c2.get_edgecolor()) == len(c2.get_facecolor())
     p.backend.update_interactive({t: 1})
+    p.backend.close()
+
+    assert len(d2) != len(d4)
+    assert not np.allclose(arr2, arr4)
 
 
 def test_contour_and_3d():
     # verify that it's possible to combine contour and 3d plots, but that
     # combining a 2d line plot with contour and 3d plot raises an error.
 
     x, y = symbols("x, y")
@@ -1891,39 +1577,37 @@
     p = p1 + p2
     p.draw()
     p = p2 + p1
     p.draw()
     p = p2 + p3
     with warns(UserWarning, match="The following kwargs were not used by contour"):
         p.draw()
+    p.close()
     p = p1 + p3
     raises(ValueError, lambda: p.draw())
+    p.close()
     p = p1 + p2 + p3
     raises(ValueError, lambda: p.draw())
+    p.close()
     p = p2 + p1 + p3
     raises(ValueError, lambda: p.draw())
+    p.close()
 
 
-# this test fails on matplotlib 3.4.2
-# guess they changed api in the newer releases
-@pytest.mark.xfail
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_contour_show_clabels():
-    p = make_test_contour_show_clabels_1(MB, False)
-    assert len(p.ax.texts) == 0
-
-    p = make_test_contour_show_clabels_1(MB, True)
-    assert len(p.ax.texts) > 0
-
-    p = make_test_contour_show_clabels_2(MB, False)
-    p.backend.update_interactive({Symbol("u"): 2})
+    p = make_test_contour_show_clabels(MB, False)
+    p.backend.update_interactive({a: 2})
     assert len(p.backend.ax.texts) == 0
+    p.backend.close()
 
-    p = make_test_contour_show_clabels_2(MB, True)
-    p.backend.update_interactive({Symbol("u"): 2})
+    p = make_test_contour_show_clabels(MB, True)
+    p.backend.update_interactive({a: 2})
     assert len(p.backend.ax.texts) > 0
+    p.backend.close()
 
 
 @pytest.mark.filterwarnings("ignore:The provided expression contains Boolean functions")
 def test_plot_implicit_legend_artists():
     # verify that plot_implicit sets appropriate plot artists
 
     # 2 expressions plotted with contour lines -> 2 lines in legend
@@ -1935,39 +1619,42 @@
     labels = ["L = %s" % L_val for L_val in L_array]
     p = plot_implicit(
         *expr_list, (t, 0, 3), (V, 0, 1000),
         n=50, label=labels, show=False, backend=MB
     )
     assert len(p.ax.get_legend().get_lines()) == 2
     assert len(p.ax.get_legend().get_patches()) == 0
+    p.close()
 
     # 2 expressions plotted with contourf -> 2 rectangles in legend
     p = plot_implicit(
         y > x**2,
         y < -(x**2) + 1,
         (x, -5, 5),
         grid=False,
         backend=MB,
         n=20,
         show=False,
     )
     assert len(p.ax.get_legend().get_lines()) == 0
     assert len(p.ax.get_legend().get_patches()) == 2
+    p.close()
 
     # two expressions plotted with fill -> 2 rectangles in legend
     p = plot_implicit(
         Eq(y, sin(x)) & (y > 0),
         Eq(y, sin(x)) & (y < 0),
         (x, -2 * pi, 2 * pi),
         (y, -4, 4),
         backend=MB,
         show=False,
     )
     assert len(p.ax.get_legend().get_lines()) == 0
     assert len(p.ax.get_legend().get_patches()) == 2
+    p.close()
 
 
 @pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_color_func_expr():
     # verify that passing an expression to color_func is supported
 
     p1 = make_test_color_func_expr_1(MB, False)
@@ -1977,44 +1664,53 @@
     # compute the original figure: no errors should be raised
     p1.fig
     p2.fig
     p3.fig
 
     # update the figure with new parameters: no errors should be raised
     p1.backend.update_interactive({u: 0.5})
+    p1.backend.close()
     # interactive plots with streamlines are not implemented
     raises(
         NotImplementedError,
         lambda: p2.backend.update_interactive({u: 0.5})
     )
+    p2.backend.close()
     p3.backend.update_interactive({u: 0.5})
+    p3.backend.close()
 
 
 def test_legend_plot_sum():
     # when summing up plots together, the first plot dictates if legend
     # is visible or not
 
     # first case: legend is specified on the first plot
     # if legend is not specified, the resulting plot will show the legend
     p = make_test_legend_plot_sum_1(MB, None)
     assert len(p.ax.get_legend().legend_handles) == 3
+    p.close()
     p = make_test_legend_plot_sum_1(MB, True)
     assert len(p.ax.get_legend().legend_handles) == 3
+    p.close()
     # first plot has legend=False: output plot won't show the legend
     p = make_test_legend_plot_sum_1(MB, False)
     assert p.ax.get_legend() is None
+    p.close()
 
     # second case: legend is specified on the second plot
     # the resulting plot will always show the legend
     p = make_test_legend_plot_sum_2(MB, None)
     assert len(p.ax.get_legend().legend_handles) == 3
+    p.close()
     p = make_test_legend_plot_sum_2(MB, True)
     assert len(p.ax.get_legend().legend_handles) == 3
+    p.close()
     p = make_test_legend_plot_sum_2(MB, False)
     assert len(p.ax.get_legend().legend_handles) == 3
+    p.close()
 
     # because plot_implicit creates custom proxy artists to show on the legend,
     # need to make sure that every legend artists is shown when combining
     # plot_implicit with some other plot type.
 
     x, y = symbols("x, y")
     p1 = plot_implicit(
@@ -2036,28 +1732,31 @@
         ylim=(-1.2, 1.5),
         aspect="equal",
         show=False,
     )
     p3 = p1 + p2
     handles = p3.ax.get_legend().legend_handles
     assert len(handles) == 2
+    p3.close()
 
 
 def test_domain_coloring_2d():
     # verify that at_infinity=True flips the image
 
     p1 = make_test_domain_coloring_2d(MB, False)
     _, _, _, _, img1a, _ = p1[0].get_data()
     img1b = p1.ax.images[0].get_array()
     assert np.allclose(img1a, img1b)
+    p1.close()
 
     p2 = make_test_domain_coloring_2d(MB, True)
     _, _, _, _, img2a, _ = p2[0].get_data()
     img2b = p2.ax.images[0].get_array()
     assert np.allclose(img2b, np.flip(np.flip(img2a, axis=0), axis=1))
+    p2.close()
 
 
 @pytest.mark.filterwarnings("ignore::RuntimeWarning")
 @pytest.mark.filterwarnings("ignore:The following keyword arguments are unused.")
 @pytest.mark.filterwarnings("ignore:NumPy is unable to evaluate with complex numbers")
 def test_show_hide_colorbar():
     x, y, z = symbols("x, y, z")
@@ -2210,23 +1909,28 @@
     p1, p2 = make_test_show_in_legend_2d(MB)
     p3, p4 = make_test_show_in_legend_3d(MB)
 
     assert len(p1.ax.get_legend().legend_handles) == 2
     assert len(p2.ax.get_legend().legend_handles) == 2
     assert len(p3.ax.get_legend().legend_handles) == 2
     assert len(p4.ax.get_legend().legend_handles) == 2
+    p1.close()
+    p2.close()
+    p3.close()
+    p4.close()
 
 
 @pytest.mark.filterwarnings("ignore::RuntimeWarning")
 def test_make_analytic_landscape_black_and_white():
     # verify that the backend doesn't raise an error when grayscale coloring
     # schemes are required
 
     p = make_test_analytic_landscape(MB)
     p.fig
+    p.close()
 
 
 def test_axis_limits():
     # when lines using colormaps or surface (both with colormaps or
     # solid colors), axis limits must be set in order to get the correct
     # visualization. Axis limits can't be NaN or Inf.
     # The following examples shouldn't raise any error.
@@ -2241,46 +1945,52 @@
         detect_poles=True,
         n=1000,
         eps=1e-04,
         color_func=lambda x, y: x,
         show=False,
     )
     p.draw()
+    p.close()
 
 
 def test_xaxis_inverted():
     # verify that for a plot containing a LineOver1DRangeSeries,
     # if range is given as (symb, max, min) then x-axis is inverted.
 
     x = symbols("x")
     p = plot(sin(x), (x, 0, 3), backend=MB, show=False, n=10)
     assert not p.ax.xaxis.get_inverted()
+    p.close()
 
     p = plot(sin(x), (x, 3, 0), backend=MB, show=False, n=10)
     assert p.ax.xaxis.get_inverted()
+    p.close()
 
 
 def test_detect_poles():
     # no detection: only one line is visible
     p = make_test_detect_poles(MB, False)
     p.draw()
     assert len(p.ax.lines) == 1
+    p.close()
 
     # detection is done only with numerical data
     # only one line is visible
     p = make_test_detect_poles(MB, True)
     p.draw()
     assert len(p.ax.lines) == 1
+    p.close()
 
     # detection is done only both with numerical data
     # and symbolic analysis. Multiple lines are visible
     p = make_test_detect_poles(MB, "symbolic")
     p.draw()
     assert len(p.ax.lines) > 1
     assert all(l.get_color() == "k" for l in p.ax.lines[1:])
+    p.close()
 
 
 @pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_detect_poles_interactive():
     # no detection: only one line is visible
     ip = make_test_detect_poles_interactive(MB, False)
     p = ip.backend
@@ -2310,69 +2020,75 @@
     p.update_interactive({y: 1})
     assert len(p.ax.lines) == 8
 
     p.update_interactive({y: -1})
     assert len(p.ax.lines) == 8
 
 
-def test_plot_riemann_sphere():
-    p = make_test_plot_riemann_sphere(MB, True)
-    fig = p.fig
-    ax1 = fig.axes[0]
-    ax2 = fig.axes[1]
-    assert len(ax1.images) == len(ax2.images) == 1
-    assert len(ax1.lines) == len(ax2.lines) == 3
-    assert len(ax1.texts) == len(ax2.texts) == 4
-
-    p = make_test_plot_riemann_sphere(MB, False)
+@pytest.mark.parametrize(
+    "annotate, n_imgs, n_lines, n_texts", [
+        (True, 1, 3, 4),
+        (False, 1, 1, 0)
+    ]
+)
+def test_plot_riemann_sphere(annotate, n_imgs, n_lines, n_texts):
+    p = make_test_plot_riemann_sphere(MB, annotate)
     fig = p.fig
     ax1 = fig.axes[0]
     ax2 = fig.axes[1]
-    assert len(ax1.images) == len(ax2.images) == 1
-    assert len(ax1.lines) == len(ax2.lines) == 1
-    assert len(ax1.texts) == len(ax2.texts) == 0
+    assert len(ax1.images) == len(ax2.images) == n_imgs
+    assert len(ax1.lines) == len(ax2.lines) == n_lines
+    assert len(ax1.texts) == len(ax2.texts) == n_texts
+    p.close()
 
 
 @pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_parametric_texts():
     # verify that xlabel, ylabel, zlabel, title accepts parametric texts
     x, y, p = make_test_parametric_texts_2d(MB)
     assert p.backend.ax.get_title() == "y=1.0, z=0.000"
     assert p.backend.ax.get_xlabel() == "test y+z=1.00"
     assert p.backend.ax.get_ylabel() == "test z=0.00"
     p.backend.update_interactive({y: 1.5, z: 2})
     assert p.backend.ax.get_title() == "y=1.5, z=2.000"
     assert p.backend.ax.get_xlabel() == "test y+z=3.50"
     assert p.backend.ax.get_ylabel() == "test z=2.00"
+    p.backend.close()
 
     a, b, p = make_test_parametric_texts_3d(MB)
     assert p.backend.ax.get_title() == "a=1.0, a+b=1.000"
     assert p.backend.ax.get_xlabel() == "test a=1.00"
     assert p.backend.ax.get_ylabel() == "test b=0.00"
     assert p.backend.ax.get_zlabel() == "test a=1.00, b=0.00"
     p.backend.update_interactive({a: 1.5, b: 2})
     assert p.backend.ax.get_title() == "a=1.5, a+b=3.500"
     assert p.backend.ax.get_xlabel() == "test a=1.50"
     assert p.backend.ax.get_ylabel() == "test b=2.00"
     assert p.backend.ax.get_zlabel() == "test a=1.50, b=2.00"
+    p.backend.close()
 
 
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_arrow_2d():
+    a, b = symbols("a, b")
     p = make_test_arrow_2d(MB, "test", {"color": "r"}, True)
-    p.fig
-    assert isinstance(p.ax, Axes)
-    assert len(p.ax.patches) == 1
-    assert len(p.ax.get_legend().legend_handles) == 1
-    assert p.ax.get_legend().legend_handles[0].get_label() == "$test$"
-    assert p.ax.get_legend().legend_handles[0].get_color() == "r"
+    ax = p.backend.ax
+    assert isinstance(ax, Axes)
+    assert len(ax.patches) == 1
+    assert len(ax.get_legend().legend_handles) == 1
+    assert ax.get_legend().legend_handles[0].get_label() == "$test$"
+    assert ax.get_legend().legend_handles[0].get_color() == "r"
+    p.backend.update_interactive({a: 4, b: 5})
+    p.backend.close()
 
     p = make_test_arrow_2d(MB, "test", {"color": "r"}, False)
-    p.fig
-    assert len(p.ax.patches) == 1
-    assert p.ax.get_legend() is None
+    ax = p.backend.ax
+    assert len(ax.patches) == 1
+    assert ax.get_legend() is None
+    p.backend.close()
 
 
 def test_existing_figure_lines():
     # verify that user can provide an existing figure containing lines
     # and plot over it
 
     fig, ax = matplotlib.pyplot.subplots()
@@ -2386,14 +2102,15 @@
         backend=MB, show=False, ax=ax)
     assert p.ax is ax
     assert len(ax.lines) == 2
     assert ax.lines[0].get_label() == "l1"
     assert ax.lines[0].get_color() == '#1f77b4'
     assert ax.lines[1].get_label() == "l2"
     assert ax.lines[1].get_color() == '#ff7f0e'
+    p.close()
 
 
 def test_existing_figure_surfaces():
     # verify that user can provide an existing figure containing surfaces
     # and plot over it
 
     fig = matplotlib.pyplot.figure()
@@ -2409,66 +2126,67 @@
     assert len(ax.collections) == 2
     # the two surfaces are identical. Here, I'm just interested to see
     # different colors
     assert not np.allclose(
         ax.collections[0].get_facecolors()[0],
         ax.collections[1].get_facecolors()[0]
     )
+    p.close()
 
 
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 def test_arrow_3d():
+    a, b, c = symbols("a, b, c")
     p = make_test_arrow_3d(MB, "test", {"color": "r"}, True)
-    p.fig
-    assert isinstance(p.ax, mpl_toolkits.mplot3d.axes3d.Axes3D)
-    assert len(p.ax.patches) == 1
-    assert len(p.ax.get_legend().legend_handles) == 1
-    assert p.ax.get_legend().legend_handles[0].get_label() == "$test$"
-    assert p.ax.get_legend().legend_handles[0].get_color() == "r"
+    ax = p.backend.ax
+    assert isinstance(ax, mpl_toolkits.mplot3d.axes3d.Axes3D)
+    assert len(ax.patches) == 1
+    assert len(ax.get_legend().legend_handles) == 1
+    assert ax.get_legend().legend_handles[0].get_label() == "$test$"
+    assert ax.get_legend().legend_handles[0].get_color() == "r"
     # only way to test if it renders what it's supposed to
-    assert np.allclose(p.ax.patches[0]._xyz, [1, 2, 3])
-    assert np.allclose(p.ax.patches[0]._dxdydz, [4, 5, 6])
+    assert np.allclose(ax.patches[0]._xyz, [1, 2, 3])
+    assert np.allclose(ax.patches[0]._dxdydz, [4, 5, 6])
+    p.backend.update_interactive({a: 4, b: 5, c: 6})
+    p.backend.close()
 
     p = make_test_arrow_3d(MB, "test", {"color": "r"}, False)
-    p.fig
-    assert len(p.ax.patches) == 1
-    assert p.ax.get_legend() is None
+    ax = p.backend.ax
+    assert len(ax.patches) == 1
+    assert ax.get_legend() is None
     # only way to test if it renders what it's supposed to
-    assert np.allclose(p.ax.patches[0]._xyz, [1, 2, 3])
-    assert np.allclose(p.ax.patches[0]._dxdydz, [4, 5, 6])
+    assert np.allclose(ax.patches[0]._xyz, [1, 2, 3])
+    assert np.allclose(ax.patches[0]._dxdydz, [4, 5, 6])
+    p.backend.close()
 
 
 @pytest.mark.skipif(ct is None, reason="control is not installed")
-def test_plot_root_locus_1():
-    p = make_test_root_locus_1(MB, True, False)
-    assert isinstance(p, MB)
-    assert len(p.series) == 2
+@pytest.mark.parametrize(
+    "sgrid, zgrid, n_lines, n_texts, instance", [
+        (True, False, 18, 10, SGridLineSeries),
+        (False, True, 33, 20, ZGridLineSeries),
+    ]
+)
+def test_plot_root_locus_1(sgrid, zgrid, n_lines, n_texts, instance):
+    a = symbols("a")
+    p = make_test_root_locus_1(MB, sgrid, zgrid)
+    assert isinstance(p.backend, MB)
+    assert len(p.backend.series) == 2
     # NOTE: the backend is going to reorder data series such that grid
     # series are placed at the end.
-    assert isinstance(p[0], RootLocusSeries)
-    assert isinstance(p[1], SGridLineSeries)
-    ax = p.ax
-    assert len(ax.lines) == 18
-    assert ax.get_legend() is None
-    assert len(p.ax.texts) == 10 # number of sgrid labels on the plot
-    line_colors = {'#1f77b4', '0.75'}
-    assert all(l.get_color() in line_colors for l in ax.lines)
-    p.update_interactive({})
-
-    p = make_test_root_locus_1(MB, False, True)
-    assert isinstance(p, MB)
-    assert len(p.series) == 2
-    assert isinstance(p[0], RootLocusSeries)
-    assert isinstance(p[1], ZGridLineSeries)
-    ax = p.ax
-    assert len(ax.lines) == 33
+    assert isinstance(p.backend[0], RootLocusSeries)
+    assert isinstance(p.backend[1], instance)
+    ax = p.backend.ax
+    assert len(ax.lines) == n_lines
     assert ax.get_legend() is None
-    assert len(p.ax.texts) == 20 # number of sgrid labels on the plot
+    assert len(ax.texts) == n_texts # number of sgrid labels on the plot
     line_colors = {'#1f77b4', '0.75'}
     assert all(l.get_color() in line_colors for l in ax.lines)
-    p.update_interactive({})
+    p.backend.update_interactive({a: 2})
+    p.backend.close()
 
 
 @pytest.mark.skipif(ct is None, reason="control is not installed")
 def test_plot_root_locus_2():
     p = make_test_root_locus_2(MB)
     assert isinstance(p, MB)
     assert len(p.series) == 3
@@ -2479,47 +2197,69 @@
     assert len(ax.lines) == 19
     assert len(ax.get_legend().texts) == 2
     assert p.ax.get_legend().texts[0].get_text() == "a"
     assert p.ax.get_legend().texts[1].get_text() == "b"
     assert len(p.ax.texts) == 10 # number of sgrid labels on the plot
     line_colors = {'#1f77b4', '#ff7f0e', '0.75'}
     assert all(l.get_color() in line_colors for l in ax.lines)
-    p.update_interactive({})
+    p.close()
 
 
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+@pytest.mark.parametrize(
+    "sgrid, zgrid, T, is_filled", [
+        (True, False, None, True),
+        (False, True, None, True),
+        (True, False, 0.05, True),
+        (False, True, 0.05, True),
+        (False, False, None, False),
+    ]
+)
+def test_plot_pole_zero(sgrid, zgrid, T, is_filled):
+    a = symbols("a")
+    p = make_test_plot_pole_zero(MB, sgrid=sgrid, zgrid=zgrid, T=T,
+        is_filled=is_filled)
+    fig = p.fig
+    p.backend.update_interactive({a: 2})
+    p.backend.close()
+
+
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
 @pytest.mark.filterwarnings("ignore::UserWarning")
 def test_plot_poles_zeros_sgrid():
     # verify that SGridLineSeries is rendered with "proper" axis limits
 
+    a = symbols("a")
     p = make_test_poles_zeros_sgrid(MB)
-    ax = p.ax
-    xlim = p.ax.get_xlim()
-    ylim = p.ax.get_ylim()
+    ax = p.backend.ax
+    xlim = ax.get_xlim()
+    ylim = ax.get_ylim()
     assert (xlim is not None) and (ylim is not None)
     # these are eyeball numbers, it should allows a little bit of tweeking at
     # the code for better positioning the grid...
     assert xlim[0] > -5 and xlim[1] < 2
     assert ylim[0] > -5 and ylim[1] < 5
-    p.update_interactive({})
+    p.backend.update_interactive({a: 2})
+    p.backend.close()
 
 
 @pytest.mark.skipif(ct is None, reason="control is not installed")
 def test_plot_root_locus_sgrid():
     # verify that SGridLineSeries is rendered with "proper" axis limits
 
     p = make_test_root_locus_1(MB, True, False)
-    ax = p.ax
-    xlim = p.ax.get_xlim()
-    ylim = p.ax.get_ylim()
+    ax = p.backend.ax
+    xlim = ax.get_xlim()
+    ylim = ax.get_ylim()
     assert (xlim is not None) and (ylim is not None)
     # these are eyeball numbers, it should allows a little bit of tweeking at
     # the code for better positioning the grid...
     assert xlim[0] > -5 and xlim[1] < 2
     assert ylim[0] > -5 and ylim[1] < 5
-    p.update_interactive({})
+    p.backend.close()
 
 
 @pytest.mark.parametrize(
     "cl_mags, cl_phases, label_cl_phases, n_lines, n_texts",
     [
         (None, None, False, 27, 17),
         (None, None, True, 27, 26),
@@ -2528,14 +2268,15 @@
     ]
 )
 def test_ngrid(cl_mags, cl_phases, label_cl_phases, n_lines, n_texts):
     p = make_test_ngrid(MB, cl_mags, cl_phases, label_cl_phases)
     ax = p.ax
     assert len(ax.lines) == n_lines
     assert len(ax.texts) == n_texts
+    p.close()
 
 
 @pytest.mark.parametrize(
     "xi, wn, tp, ts, auto, show_control_axis, params, n_lines, n_texts",
     [
         (None, None, None, None, False, True, None, 34, 21),
         (None, None, None, None, False, False, None, 35, 21),
@@ -2559,19 +2300,22 @@
     kw = {}
     if params:
         if ipy is None:
             return
         kw["params"] = params
 
     p = make_test_sgrid(MB, xi, wn, tp, ts, auto, show_control_axis, **kw)
-    ax = p._backend.ax if params else p.ax
+    ax = p.backend.ax if params else p.ax
     assert len(ax.lines) == n_lines
     assert len(ax.texts) == n_texts
     if params:
-        p._backend.update_interactive({x: 0.75, y: 0.8, z: 0.85})
+        p.backend.update_interactive({x: 0.75, y: 0.8, z: 0.85})
+        p.backend.close()
+    else:
+        p.close()
 
 
 @pytest.mark.parametrize(
     "xi, wn, tp, ts, show_control_axis, params, n_lines, n_texts",
     [
         (None, None, None, None, True, None, 32, 20),
         (None, None, None, None, False, None, 30, 20),
@@ -2593,12 +2337,232 @@
     kw = {}
     if params:
         if ipy is None:
             return
         kw["params"] = params
 
     p = make_test_zgrid(MB, xi, wn, tp, ts, show_control_axis, **kw)
-    ax = p._backend.ax if params else p.ax
+    ax = p.backend.ax if params else p.ax
     assert len(ax.lines) == n_lines
     assert len(ax.texts) == n_texts
     if params:
-        p._backend.update_interactive({x: 0.75, y: 0.8, z: 0.85})
+        p.backend.update_interactive({x: 0.75, y: 0.8, z: 0.85})
+        p.backend.close()
+    else:
+        p.close()
+
+
+# On Github, it fails on the minimum installation version,
+# with Matplotlib 3.8.3. On local machine it works fine. Why???
+@pytest.mark.xfail
+@pytest.mark.parametrize("update_event, num_callbacks", [
+    (False, 2),
+    (True, 3)
+])
+def test_matplotlib_update_ranges(update_event, num_callbacks):
+    # verify that `update_event` doesn't raise errors
+
+    x, y = symbols("x, y")
+    p = plot(cos(x), (x, -pi, pi), n=10, backend=MB,
+        show=False, update_event=update_event)
+    assert len(p.fig._canvas_callbacks.callbacks["button_release_event"]) == num_callbacks
+
+    if update_event:
+        p._update_axis_limits("button_release_event")
+    p.close()
+
+    p = plot_contour(cos(x**2+y**2), (x, -pi, pi), (y, -pi, pi),
+        n=10, backend=MB, show=False, update_event=update_event)
+    assert len(p.fig._canvas_callbacks.callbacks["button_release_event"]) == num_callbacks
+
+    if update_event:
+        p._update_axis_limits("button_release_event")
+    p.close()
+
+
+@pytest.mark.parametrize(
+    "mag, n_lines, n_labels",
+    [
+        (None, 12, 11),
+        (-3, 2, 1),
+        (0, 2, 1),
+    ]
+)
+def test_mcircles(mag, n_lines, n_labels):
+    p = make_test_mcircles(MB, mag)
+    ax = p.ax
+    assert len(ax.lines) == n_lines
+    assert len(ax.texts) == n_labels
+    p.close()
+
+
+@pytest.mark.skipif(ct is None, reason="control is not installed")
+@pytest.mark.parametrize(
+    "m_circles, start_marker, mirror_style, arrows, n_lines, n_patches, n_texts",
+    [
+        (False, "+", None, None, 5, 0, 0),  # no m-circles, no arrows
+        (False, None, None, None, 4, 0, 0), # no m-circles, no arrows, no start marker
+        (False, "+", None, 2, 5, 4, 0),     # no m-circles
+        (False, "+", False, 2, 3, 2, 0),    # no m-circles, no mirror image
+        (True, "+", None, 3, 17, 6, 11),    # m-circles, mirror image, arrows, start marker
+    ]
+)
+def test_plot_nyquist_matplotlib(
+    m_circles, start_marker, mirror_style, arrows, n_lines, n_patches, n_texts
+):
+    # verify that plot_nyquist adds the necessary objects to the plot
+
+    s = symbols("s")
+    tf1 = 1 / (s**2 + 0.5*s + 2)
+
+    p = plot_nyquist(tf1, show=False, n=10, m_circles=m_circles, arrows=arrows,
+        mirror_style=mirror_style, start_marker=start_marker)
+    ax = p.ax
+    assert len(ax.lines) == n_lines
+    assert len(ax.patches) == n_patches
+    assert len(ax.texts) == n_texts
+    p.close()
+
+
+@pytest.mark.skipif(ct is None, reason="control is not installed")
+@pytest.mark.parametrize(
+    "primary_style, mirror_style",
+    [
+        ("-", ":"),
+        (["-", "-."], ["--", ":"]),
+        ({"linestyle": "-"}, {"linestyle": ":"}),
+        ([{"linestyle": "-"}, {"linestyle": ":"}], [{"linestyle": "--"}, {"linestyle": "-."}]),
+        (2, 2),
+    ]
+)
+def test_plot_nyquist_matplotlib_linestyles(primary_style, mirror_style):
+    s = symbols("s")
+    tf1 = 1 / (s**2 + 0.5*s + 2)
+
+    p = plot_nyquist(tf1, show=False, n=10,
+        primary_style=primary_style, mirror_style=mirror_style)
+    if not isinstance(primary_style, int):
+        ax = p.ax
+    else:
+        raises(ValueError, lambda: p.ax)
+    p.close()
+
+
+@pytest.mark.skipif(ct is None, reason="control is not installed")
+def test_plot_nyquist_matplotlib_interactive():
+    # verify that interactive update doesn't raise errors
+
+    a, s = symbols("a, s")
+    tf = 1 / (s + a)
+    pl = plot_nyquist(
+        tf, xlim=(-2, 1), ylim=(-1, 1),
+        aspect="equal", m_circles=True,
+        params={a: (1, 0, 2)},
+        arrows=4, n=10, show=False
+    )
+    ax = pl.backend.ax # force first draw
+    pl.backend.update_interactive({a: 2}) # update with new value
+    pl.backend.close()
+
+
+def test_plot_nichols():
+    s = symbols("s")
+    tf = (5 * (s - 1)) / (s**2 * (s**2 + s + 4))
+
+    # with nichols grid lines
+    p = plot_nichols(tf, ngrid=True, show=False, n=10)
+    ax = p.ax
+    assert len(ax.lines) > 2
+    assert len(ax.texts) > 0
+    p.close()
+
+    # no nichols grid lines
+    p = plot_nichols(tf, ngrid=False, show=False, n=10)
+    ax = p.ax
+    assert len(ax.lines) == 1
+    assert len(ax.texts) == 0
+    p.close()
+
+
+@pytest.mark.parametrize(
+    "arrows, n_arrows",
+    [
+        (True, 3),
+        (False, 0),
+        (None, 0),
+        (4, 4),
+        ([0.2, 0.5, 0.8], 3)
+    ]
+)
+def test_plot_nichols_arrows(arrows, n_arrows):
+    s = symbols("s")
+    tf = (5 * (s - 1)) / (s**2 * (s**2 + s + 4))
+    p = plot_nichols(tf, ngrid=False, show=False, n=10, arrows=arrows)
+    ax = p.ax
+    assert len(ax.patches) == n_arrows
+    p.close()
+
+
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+@pytest.mark.parametrize(
+    "scatter, use_cm, n_lines, n_collections", [
+        (False, False, 1, 0),
+        (False, True, 0, 1),
+        (True, False, 1, 0),
+        (True, True, 0, 1),
+    ]
+)
+def test_plot_nichols_lines_scatter(scatter, use_cm, n_lines, n_collections):
+    # no errors are raised with different types of line
+    a, s = symbols("a, s")
+    tf = (a * (s - 1)) / (s**2 * (s**2 + s + 4))
+
+    # with nichols grid lines
+    p = plot_nichols(tf, ngrid=False, show=False, n=10, backend=MB,
+        scatter=scatter, use_cm=use_cm, params={a: (5, 0, 10)})
+    ax = p.backend.ax
+    assert len(ax.lines) == n_lines
+    assert len(ax.collections) == n_collections
+    p.backend.update_interactive({a: 6})
+    p.backend.close()
+
+
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+@pytest.mark.filterwarnings("ignore::UserWarning")
+def test_plot_step_response():
+    # this should not raise any errors during updates
+
+    a, b, c, d, e, f, g, s = symbols("a, b, c, d, e, f, g, s")
+    tf1 = (8*s**2 + 18*s + 32) / (s**3 + 6*s**2 + 14*s + 24)
+    tf2 = (s**2 + a*s + b) / (s**3 + c*s**2 + d*s + e)
+    p = plot_step_response(
+        (tf1, "A"), (tf2, "B"), lower_limit=f, upper_limit=g,
+        control=True,
+        params={
+            a: (3.7, 0, 5),
+            b: (10, 0, 20),
+            c: (7, 0, 8),
+            d: (6, 0, 25),
+            e: (16, 0, 25),
+            f: (0, 0, 10, 50, "lower limit"),
+            g: (10, 0, 25, 50, "upper limit"),
+        },
+        backend=MB, n=10, show=False
+    )
+    fig = p.fig
+    p.backend.update_interactive({
+        a: 4, b: 11, c:6, d: 8, e: 18, f: 5, g: 20
+    })
+    p.backend.close()
+
+
+@pytest.mark.skipif(ipy is None, reason="ipywidgets is not installed")
+def test_hvlines():
+    a, b = symbols("a, b")
+    p = make_test_hvlines(MB)
+    ax = p.backend.ax
+    assert len(ax.lines) == 2
+    assert not np.allclose(
+        ax.lines[0].get_data(), ax.lines[1].get_data()
+    )
+    p.backend.update_interactive({a: 3, b: 4})
+    p.backend.close()
```

### Comparing `sympy_plot_backends-3.1.1/tests/backends/test_plotly.py` & `sympy_plot_backends-3.2.0/tests/backends/test_plotly.py`

 * *Files 8% similar despite different names*

```diff
@@ -16,102 +16,77 @@
 from spb.series import SurfaceOver2DRangeSeries, ParametricSurfaceSeries
 from sympy import (
     sin, cos, I, pi, Circle, Polygon, sqrt, Matrix, Line, latex, symbols
 )
 from sympy.abc import x, y, z, u, t, a, b, c
 from .make_tests import (
     custom_colorloop_1,
-    make_plot_1,
-    make_plot_parametric_1,
-    make_plot3d_parametric_line_1,
-    make_plot3d_1,
-    make_plot3d_2,
+    make_test_plot,
+    make_test_plot_parametric,
+    make_test_plot3d_parametric_line,
+    make_test_plot3d,
     make_plot3d_wireframe_1,
     make_plot3d_wireframe_2,
     make_plot3d_wireframe_3,
     make_plot3d_wireframe_4,
     make_plot3d_wireframe_5,
     make_plot3d_parametric_surface_wireframe_1,
     make_plot3d_parametric_surface_wireframe_2,
-    make_plot_contour_1,
+    make_test_plot3d_use_cm,
+    make_test_plot_contour,
     make_plot_contour_is_filled,
-    make_plot_vector_2d_quiver,
-    make_plot_vector_2d_streamlines_1,
-    make_plot_vector_2d_streamlines_2,
-    make_plot_vector_3d_quiver,
-    make_plot_vector_3d_streamlines_1,
-    make_plot_vector_2d_normalize_1,
-    make_plot_vector_2d_normalize_2,
-    make_plot_vector_3d_normalize_1,
-    make_plot_vector_3d_normalize_2,
+    make_test_plot_vector_2d_quiver,
+    make_test_plot_vector_2d_streamlines,
+    make_test_plot_vector_3d_quiver_streamlines,
+    make_test_plot_vector_2d_normalize,
+    make_test_plot_vector_3d_normalize,
+    make_test_plot_vector_2d_color_func,
     make_test_plot_implicit_adaptive_true,
     make_test_plot_implicit_adaptive_false,
     make_test_plot_complex_1d,
     make_test_plot_complex_2d,
     make_test_plot_complex_3d,
-    make_test_plot_list_is_filled_false,
-    make_test_plot_list_is_filled_true,
+    make_test_plot_list_is_filled,
     make_test_plot_piecewise_single_series,
     make_test_plot_piecewise_multiple_series,
     make_test_plot_geometry_1,
     make_test_plot_geometry_2,
     make_test_plot_geometry_3d,
     make_test_aspect_ratio_2d_issue_11764,
     make_test_aspect_ratio_3d,
     make_test_plot_size,
     make_test_plot_scale_lin_log,
     make_test_backend_latex_labels_1,
     make_test_backend_latex_labels_2,
-    make_test_plot_use_latex,
-    make_test_plot_parametric_use_latex,
-    make_test_plot_contour_use_latex,
-    make_test_plot_vector_2d_quivers_use_latex,
-    make_test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex,
-    make_test_plot_vector_2d_streamlines_custom_scalar_field_use_latex,
-    make_test_plot_vector_2d_use_latex_colorbar,
-    make_test_plot_vector_3d_quivers_use_latex,
-    make_test_plot_vector_3d_streamlines_use_latex,
-    make_test_plot_complex_use_latex_1,
-    make_test_plot_complex_use_latex_2,
-    make_test_plot_real_imag_use_latex,
-    make_test_plot3d_use_cm,
     make_test_plot_polar,
     make_test_plot_polar_use_cm,
     make_test_plot3d_implicit,
-    make_test_surface_color_func_1,
-    make_test_surface_color_func_2,
-    make_test_surface_interactive_color_func,
-    make_test_line_interactive_color_func,
+    make_test_surface_color_func,
     make_test_line_color_plot,
     make_test_line_color_plot3d_parametric_line,
     make_test_surface_color_plot3d,
-    make_test_plot3d_list_use_cm_False,
-    make_test_plot3d_list_use_cm_color_func,
-    make_test_plot3d_list_interactive,
-    make_test_contour_show_clabels_1,
-    make_test_contour_show_clabels_2,
+    make_test_plot3d_list,
+    make_test_contour_show_clabels,
     make_test_color_func_expr_2,
     make_test_legend_plot_sum_1,
     make_test_legend_plot_sum_2,
     make_test_domain_coloring_2d,
     make_test_show_in_legend_2d,
     make_test_show_in_legend_3d,
     make_test_analytic_landscape,
     make_test_detect_poles,
     make_test_detect_poles_interactive,
     make_test_plot_riemann_sphere,
     make_test_parametric_texts_2d,
     make_test_parametric_texts_3d,
     make_test_line_color_func,
-    make_test_plot3d_parametric_line_use_latex,
-    make_test_plot3d_use_latex,
-    make_test_vectors_3d_update_interactive,
     make_test_plot_list_color_func,
     make_test_real_imag,
-    make_test_arrow_2d
+    make_test_arrow_2d,
+    make_test_hvlines
 )
 
 
 # NOTE
 # While BB, PB, KB creates the figure at instantiation, MB creates the figure
 # once the `show()` method is called. All backends do not populate the figure
 # at instantiation. Numerical data is added only when `show()` or `fig` is
@@ -121,26 +96,14 @@
 # or `draw()`.
 
 
 class PBchild(PB):
     colorloop = ["red", "green", "blue"]
 
 
-def test_colorloop_colormaps():
-    # verify that backends exposes important class attributes enabling
-    # automatic coloring
-
-    assert hasattr(PB, "colorloop")
-    assert isinstance(PB.colorloop, (list, tuple))
-    assert hasattr(PB, "colormaps")
-    assert isinstance(PB.colormaps, (list, tuple))
-    assert hasattr(PB, "quivers_colors")
-    assert isinstance(PB.quivers_colors, (list, tuple))
-
-
 def test_custom_colorloop():
     # verify that it is possible to modify the backend's class attributes
     # in order to change custom coloring
 
     assert len(PBchild.colorloop) != len(PB.colorloop)
     _p1 = custom_colorloop_1(PB)
     _p2 = custom_colorloop_1(PBchild)
@@ -150,106 +113,136 @@
     assert all([isinstance(t, go.Scatter) for t in f1.data])
     assert all([isinstance(t, go.Scatter) for t in f2.data])
     # there are 6 unique colors in _p1 and 3 unique colors in _p2
     assert len(set([d["line"]["color"] for d in f1.data])) == 6
     assert len(set([d["line"]["color"] for d in f2.data])) == 3
 
 
-def test_plot():
+@pytest.mark.parametrize(
+    "use_latex, xlabel, ylabel", [
+        (False, "x", "f(x)"),
+        (True, "$x$", "$f\\left(x\\right)$")
+    ]
+)
+def test_plot_1(use_latex, xlabel, ylabel, label_func):
     # verify that the backends produce the expected results when `plot()`
     # is called and `rendering_kw` overrides the default line settings
 
-    p = make_plot_1(PB, rendering_kw=dict(line_color="red"))
-    assert len(p.series) == 2
+    p = make_test_plot(PB, rendering_kw=dict(line_color="red"),
+        use_latex=use_latex)
+    assert len(p.backend.series) == 2
     f = p.fig
     assert len(f.data) == 2
     assert isinstance(f.data[0], go.Scatter)
-    assert f.data[0]["name"] == "sin(x)"
+    assert f.data[0]["name"] == label_func(use_latex, sin(a * x))
     assert f.data[0]["line"]["color"] == "red"
     assert isinstance(f.data[1], go.Scatter)
-    assert f.data[1]["name"] == "cos(x)"
+    assert f.data[1]["name"] == label_func(use_latex, cos(b * x))
     assert f.data[1]["line"]["color"] == "red"
     assert f.layout["showlegend"] is True
     # PB separates the data generation from the layout creation. Make sure
     # the layout has been processed
-    assert f.layout["xaxis"]["title"]["text"] == "x"
-    assert f.layout["yaxis"]["title"]["text"] == "f(x)"
-
-    p = make_plot_1(PB, rendering_kw=dict(line_color="red"), use_latex=True)
-    f = p.fig
-    assert f.data[0]["name"] == "$\\sin{\\left(x \\right)}$"
-    assert f.layout["xaxis"]["title"]["text"] == "$x$"
-    assert f.layout["yaxis"]["title"]["text"] == "$f\\left(x\\right)$"
+    assert f.layout["xaxis"]["title"]["text"] == xlabel
+    assert f.layout["yaxis"]["title"]["text"] == ylabel
+    p.backend.update_interactive({a: 2, b: 2})
 
 
 def test_plot_parametric():
     # verify that the backends produce the expected results when
     # `plot_parametric()` is called and `rendering_kw` overrides the default
     # line settings
 
-    p = make_plot_parametric_1(PB, rendering_kw=dict(line_color="red"))
-    assert len(p.series) == 1
+    p = make_test_plot_parametric(PB, rendering_kw=dict(line_color="red"),
+        use_cm=False)
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.data) == 1
     assert isinstance(f.data[0], go.Scatter)
-    assert f.data[0]["name"] == "x"
+    assert f.data[0]["name"] == "(cos(a*x), sin(b*x))"
     assert f.data[0]["line"]["color"] == "red"
+    assert f.data[0]["marker"]["colorbar"]["title"]["text"] is None
+    assert f.data[0]["marker"]["colorscale"] is None
+    p.backend.update_interactive({a: 2, b: 2})
+
+    p = make_test_plot_parametric(PB, rendering_kw=dict(line_color="red"),
+        use_cm=True)
+    assert len(p.backend.series) == 1
+    f = p.fig
+    assert f.data[0]["name"] == "x"
     assert f.data[0]["marker"]["colorbar"]["title"]["text"] == "x"
+    p.backend.update_interactive({a: 2, b: 2})
 
 
-def test_plot3d_parametric_line():
+@pytest.mark.parametrize(
+    "use_latex", [False, True]
+)
+def test_plot3d_parametric_line(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot3d_parametric_line()` is called and `rendering_kw` overrides the
     # default line settings
 
-    p = make_plot3d_parametric_line_1(PB, rendering_kw=dict(line_color="red"))
-    assert len(p.series) == 1
+    p = make_test_plot3d_parametric_line(PB,
+        rendering_kw=dict(line_color="red"),
+        use_latex=use_latex, use_cm=False)
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.data) == 1
     assert isinstance(f.data[0], go.Scatter3d)
     assert f.data[0]["line"]["color"] == "red"
-    assert f.data[0]["name"] == "x"
-    assert f.data[0]["line"]["colorbar"]["title"]["text"] == "x"
+    assert f.data[0]["name"] == label_func(
+        use_latex, (cos(a * x), sin(b * x), x))
+    assert f.data[0]["line"]["colorbar"]["title"]["text"] is None
+    p.backend.update_interactive({a: 2, b: 2})
+
+    p = make_test_plot3d_parametric_line(PB,
+        rendering_kw=dict(line_color="red"),
+        use_latex=use_latex, use_cm=True)
+    assert len(p.backend.series) == 1
+    f = p.fig
+    assert len(f.data) == 1
+    assert isinstance(f.data[0], go.Scatter3d)
+    assert f.data[0]["line"]["color"] == "red"
+    assert f.data[0]["name"] == label_func(
+        use_latex, x)
+    assert f.data[0]["line"]["colorbar"]["title"]["text"] == label_func(
+        use_latex, x)
+    p.backend.update_interactive({a: 2, b: 2})
 
 
-def test_plot3d():
+@pytest.mark.parametrize(
+    "use_latex, xl, yl, zl", [
+        (False, "x", "y", "f(x, y)"),
+        (True, "$x$", "$y$", r"$f\left(x, y\right)$")
+    ]
+)
+def test_plot3d_1(use_latex, xl, yl, zl, label_func):
     # verify that the backends produce the expected results when
     # `plot3d()` is called and `rendering_kw` overrides the default surface
     # settings
 
-    p = make_plot3d_1(
-        PB, rendering_kw=dict(colorscale=[[0, "cyan"], [1, "cyan"]]))
-    assert len(p.series) == 1
+    p = make_test_plot3d(
+        PB, rendering_kw=dict(colorscale=[[0, "cyan"], [1, "cyan"]]),
+        use_cm=False, use_latex=use_latex)
+    assert len(p.backend.series) == 2
     f = p.fig
-    assert len(f.data) == 1
-    assert isinstance(f.data[0], go.Surface)
-    assert f.data[0]["name"] == "cos(x**2 + y**2)"
+    assert len(f.data) == 2
+    assert p.fig.layout.scene.xaxis.title.text == xl
+    assert p.fig.layout.scene.yaxis.title.text == yl
+    assert p.fig.layout.scene.zaxis.title.text == zl
+    assert all(isinstance(d, go.Surface) for d in f.data)
+    assert f.data[0]["name"] == label_func(use_latex, cos(a*x**2 + y**2))
+    assert f.data[1]["name"] == label_func(use_latex, sin(b*x**2 + y**2))
     assert not f.data[0]["showscale"]
+    assert not f.data[1]["showscale"]
     assert f.data[0]["colorscale"] == ((0, "cyan"), (1, "cyan"))
-    assert not f.layout["showlegend"]
-    assert f.data[0]["colorbar"]["title"]["text"] == "cos(x**2 + y**2)"
-
-
-def test_plot3d_2():
-    # verify that the backends uses string labels when `plot3d()` is called
-    # with `use_latex=False` and `use_cm=True`
-
-    p = make_plot3d_2(PB)
-    assert len(p.series) == 2
-    f = p.fig
-    assert len(f.data) == 2
-    assert p.fig.layout.scene.xaxis.title.text == "x"
-    assert p.fig.layout.scene.yaxis.title.text == "y"
-    assert p.fig.layout.scene.zaxis.title.text == "f(x, y)"
-    assert f.data[0].colorbar.title.text == str(cos(x**2 + y**2))
-    assert f.data[1].colorbar.title.text == str(sin(x**2 + y**2))
-    assert f.data[0].name == str(cos(x**2 + y**2))
-    assert f.data[1].name == str(sin(x**2 + y**2))
-    assert f.data[0]["showscale"]
-    assert f.layout["showlegend"] is False
+    assert f.data[1]["colorscale"] == ((0, "cyan"), (1, "cyan"))
+    assert f.layout["showlegend"]
+    assert f.data[0]["colorbar"]["title"]["text"] == label_func(use_latex, cos(a*x**2 + y**2))
+    assert f.data[1]["colorbar"]["title"]["text"] == label_func(use_latex, sin(b*x**2 + y**2))
+    p.backend.update_interactive({a: 2, b: 2})
 
 
 def test_plot3d_wireframe():
     # verify that wireframe=True is going to add the expected number of line
     # data series and that appropriate keyword arguments work as expected
 
     p0 = make_plot3d_wireframe_1(PB, False)
@@ -387,27 +380,38 @@
         [
             np.isclose(k[0], 0) and np.isclose(k[-1], 2 * np.pi)
             for k in [t.get_data()[-1] for t in p1.series[6:]]
         ]
     )
 
 
-def test_plot_contour():
+@pytest.mark.parametrize(
+    "use_latex, xl, yl", [
+        (False, "x", "y"),
+        (True, "$x$", "$y$")
+    ]
+)
+def test_plot_contour(use_latex, xl, yl, label_func):
     # verify that the backends produce the expected results when
     # `plot_contour()` is called and `rendering_kw` overrides the default
     # surface settings
 
-    p = make_plot_contour_1(
-        PB, rendering_kw=dict(contours=dict(coloring="lines")))
-    assert len(p.series) == 1
+    p = make_test_plot_contour(
+        PB, rendering_kw=dict(contours=dict(coloring="lines")),
+        use_latex=use_latex)
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.data) == 1
     assert isinstance(f.data[0], go.Contour)
     assert f.data[0]["contours"]["coloring"] == "lines"
-    assert f.data[0]["colorbar"]["title"]["text"] == str(cos(x**2 + y**2))
+    assert f.data[0]["colorbar"]["title"]["text"] == label_func(
+        use_latex, cos(a*x**2 + y**2))
+    assert f.layout["xaxis"]["title"]["text"] == xl
+    assert f.layout["yaxis"]["title"]["text"] == yl
+    p.backend.update_interactive({a: 2})
 
 
 def test_plot_contour_is_filled():
     # verify that is_filled=True produces different results than
     # is_filled=False
 
     p1 = make_plot_contour_is_filled(PB, True)
@@ -421,136 +425,153 @@
 
 
 def test_plot_vector_2d_quivers():
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `contour_kw`/`quiver_kw` overrides the
     # default settings
 
-    p = make_plot_vector_2d_quiver(
+    p = make_test_plot_vector_2d_quiver(
         PB,
         quiver_kw=dict(line_color="red"),
         contour_kw=dict(contours=dict(coloring="lines")),
     )
-    assert len(p.series) == 2
+    assert len(p.backend.series) == 2
     f = p.fig
     assert len(f.data) == 2
     assert isinstance(f.data[0], go.Contour)
     assert isinstance(f.data[1], go.Scatter)
     assert f.data[0]["contours"]["coloring"] == "lines"
     assert f.data[0]["colorbar"]["title"]["text"] == "Magnitude"
     assert f.data[1]["line"]["color"] == "red"
+    p.backend.update_interactive({a: 2})
 
 
-def test_plot_vector_2d_streamlines_custom_scalar_field():
+@pytest.mark.parametrize(
+    "scalar, use_latex, expected_label", [
+        (True, False, "Magnitude"),
+        (True, True, "Magnitude"),
+        (x + y, False, "x + y"),
+        (x + y, True, "$x + y$"),
+        ([(x + y), "test"], False, "test"),
+        ([(x + y), "test"], True, "test")
+    ]
+)
+def test_plot_vector_2d_streamlines_custom_scalar_field(scalar, use_latex, expected_label):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `contour_kw`/`stream_kw` overrides the
     # default settings
 
-    p = make_plot_vector_2d_streamlines_1(
+    p = make_test_plot_vector_2d_streamlines(
         PB,
         stream_kw=dict(line_color="red"),
         contour_kw=dict(contours=dict(coloring="lines")),
+        scalar=scalar, use_latex=use_latex
     )
-    assert len(p.series) == 2
+    assert len(p.backend.series) == 2
     f = p.fig
     assert len(f.data) == 2
     assert isinstance(f.data[0], go.Contour)
     assert isinstance(f.data[1], go.Scatter)
     assert f.data[0]["contours"]["coloring"] == "lines"
-    assert f.data[0]["colorbar"]["title"]["text"] == "x + y"
+    assert f.data[0]["colorbar"]["title"]["text"] == expected_label
     assert f.data[1]["line"]["color"] == "red"
+    raises(NotImplementedError, lambda :p.backend.update_interactive({a: 2}))
 
 
-def test_plot_vector_2d_streamlines_custom_scalar_field_custom_label():
-    # verify that the backends produce the expected results when
-    # `plot_vector()` is called and `contour_kw`/`stream_kw` overrides the
-    # default settings
-
-    p = make_plot_vector_2d_streamlines_2(
-        PB,
-        stream_kw=dict(line_color="red"),
-        contour_kw=dict(contours=dict(coloring="lines")),
-    )
-    f = p.fig
-    assert f.data[0]["colorbar"]["title"]["text"] == "test"
-
-
-def test_plot_vector_3d_quivers():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_vector_3d_quivers(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `quiver_kw` overrides the
     # default settings
 
-    p = make_plot_vector_3d_quiver(PB, quiver_kw=dict(sizeref=5))
-    assert len(p.series) == 1
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        PB, False, quiver_kw=dict(sizeref=5),
+        use_latex=use_latex)
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.data) == 1
     assert isinstance(f.data[0], go.Cone)
     assert f.data[0]["sizeref"] == 5
-    assert f.data[0]["colorbar"]["title"]["text"] == str((z, y, x))
-
+    assert f.data[0]["colorbar"]["title"]["text"] == label_func(
+        use_latex, (a * z, y, x))
     cs1 = f.data[0]["colorscale"]
+    p.backend.update_interactive({a: 2})
 
-    p = make_plot_vector_3d_quiver(PB, quiver_kw=dict(colorscale="reds"))
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        PB, False, quiver_kw=dict(colorscale="reds"),
+        use_latex=use_latex)
     f = p.fig
     cs2 = f.data[0]["colorscale"]
     assert len(cs1) != len(cs2)
 
 
-def test_plot_vector_3d_streamlines():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_vector_3d_streamlines(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot_vector()` is called and `stream_kw` overrides the
     # default settings
 
-    p = make_plot_vector_3d_streamlines_1(
-        PB, stream_kw=dict(colorscale=[[0, "red"], [1, "red"]])
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        PB, True, stream_kw=dict(colorscale=[[0, "red"], [1, "red"]]),
+        use_latex=use_latex
     )
-    assert len(p.series) == 1
+    assert len(p.backend.series) == 1
     f = p.fig
     assert len(f.data) == 1
     assert isinstance(f.data[0], go.Streamtube)
     assert f.data[0]["colorscale"] == ((0, "red"), (1, "red"))
-    assert f.data[0]["colorbar"]["title"]["text"] == str((z, y, x))
+    assert f.data[0]["colorbar"]["title"]["text"] == label_func(
+        use_latex, (a*z, y, x))
+    raises(
+        NotImplementedError,
+        lambda: p.backend.update_interactive({a: 2})
+    )
 
     # test different combinations for streamlines: it should not raise errors
-    p = make_plot_vector_3d_streamlines_1(PB, stream_kw=dict(starts=True))
-    p = make_plot_vector_3d_streamlines_1(
-        PB,
+    p = make_test_plot_vector_3d_quiver_streamlines(PB, True,
+        stream_kw=dict(starts=True))
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        PB, True,
         stream_kw=dict(
             starts={
                 "x": np.linspace(-5, 5, 10),
                 "y": np.linspace(-4, 4, 10),
                 "z": np.linspace(-3, 3, 10),
             }
         ),
     )
 
     # other keywords: it should not raise errors
-    p = make_plot_vector_3d_streamlines_1(
-        PB, stream_kw=dict(), kwargs=dict(use_cm=False)
+    p = make_test_plot_vector_3d_quiver_streamlines(
+        PB, True, stream_kw=dict(), kwargs=dict(use_cm=False)
     )
 
 
 def test_plot_vector_2d_normalize():
     # verify that backends are capable of normalizing a vector field before
     # plotting it. Since all backend are different from each other, let's test
     # that data in the figures is different in the two cases normalize=True
     # and normalize=False
 
-    p1 = make_plot_vector_2d_normalize_1(PB, False)
-    p2 = make_plot_vector_2d_normalize_1(PB, True)
+    p1 = make_test_plot_vector_2d_normalize(PB, False)
+    p2 = make_test_plot_vector_2d_normalize(PB, True)
     d1x = np.array(p1.fig.data[0].x).astype(float)
     d1y = np.array(p1.fig.data[0].y).astype(float)
     d2x = np.array(p2.fig.data[0].x).astype(float)
     d2y = np.array(p2.fig.data[0].y).astype(float)
     assert not np.allclose(d1x, d2x, equal_nan=True)
     assert not np.allclose(d1y, d2y, equal_nan=True)
 
-    p1 = make_plot_vector_2d_normalize_2(PB, False)
+    p1 = make_test_plot_vector_2d_normalize(PB, False)
     p1.backend.update_interactive({u: 1.5})
-    p2 = make_plot_vector_2d_normalize_2(PB, True)
+    p2 = make_test_plot_vector_2d_normalize(PB, True)
     p2.backend.update_interactive({u: 1.5})
     d1x = np.array(p1.fig.data[0].x).astype(float)
     d1y = np.array(p1.fig.data[0].y).astype(float)
     d2x = np.array(p2.fig.data[0].x).astype(float)
     d2y = np.array(p2.fig.data[0].y).astype(float)
     assert not np.allclose(d1x, d2x, equal_nan=True)
     assert not np.allclose(d1y, d2y, equal_nan=True)
@@ -559,23 +580,23 @@
 @pytest.mark.filterwarnings("ignore::RuntimeWarning")
 def test_plot_vector_3d_normalize():
     # verify that backends are capable of normalizing a vector field before
     # plotting it. Since all backend are different from each other, let's test
     # that data in the figures is different in the two cases normalize=True
     # and normalize=False
 
-    p1 = make_plot_vector_3d_normalize_1(PB, False)
-    p2 = make_plot_vector_3d_normalize_1(PB, True)
+    p1 = make_test_plot_vector_3d_normalize(PB, False)
+    p2 = make_test_plot_vector_3d_normalize(PB, True)
     assert not np.allclose(p1.fig.data[0]["u"], p2.fig.data[0]["u"])
     assert not np.allclose(p1.fig.data[0]["v"], p2.fig.data[0]["v"])
     assert not np.allclose(p1.fig.data[0]["w"], p2.fig.data[0]["w"])
 
-    p1 = make_plot_vector_3d_normalize_2(PB, False)
+    p1 = make_test_plot_vector_3d_normalize(PB, False)
     p1.backend.update_interactive({u: 1.5})
-    p2 = make_plot_vector_3d_normalize_2(PB, True)
+    p2 = make_test_plot_vector_3d_normalize(PB, True)
     p2.backend.update_interactive({u: 1.5})
     assert not np.allclose(p1.fig.data[0]["u"], p2.fig.data[0]["u"])
     assert not np.allclose(p1.fig.data[0]["v"], p2.fig.data[0]["v"])
     assert not np.allclose(p1.fig.data[0]["w"], p2.fig.data[0]["w"])
 
 
 def test_plot_implicit_adaptive_true():
@@ -599,60 +620,79 @@
     raises(
         NotImplementedError,
         lambda: make_test_plot_implicit_adaptive_false(
             PB, rendering_kw=dict()).draw(),
     )
 
 
-def test_plot_real_imag():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_real_imag(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot_real_imag()` is called and `rendering_kw` overrides the default
     # settings
 
-    p = make_test_real_imag(PB, rendering_kw=dict(line_color="red"))
+    p = make_test_real_imag(PB, rendering_kw=dict(line_color="red"),
+        use_latex=use_latex)
     assert len(p.series) == 2
     f = p.fig
     assert len(f.data) == 2
     assert isinstance(f.data[0], go.Scatter)
     assert f.data[0]["name"] == "Re(sqrt(x))"
     assert f.data[0]["line"]["color"] == "red"
     assert isinstance(f.data[1], go.Scatter)
     assert f.data[1]["name"] == "Im(sqrt(x))"
     assert f.data[1]["line"]["color"] == "red"
     assert f.layout["showlegend"] is True
+    assert f.layout["xaxis"]["title"]["text"] == label_func(use_latex, x)
+    assert f.layout["yaxis"]["title"]["text"] == r"$f\left(x\right)$" if use_latex else "f(x)"
 
 
-def test_plot_complex_1d():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_complex_1d(use_latex):
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
-    p = make_test_plot_complex_1d(PB, rendering_kw=dict(line_color="red"))
+    p = make_test_plot_complex_1d(PB, rendering_kw=dict(line_color="red"),
+        use_latex=use_latex)
     assert len(p.series) == 1
     f = p.fig
     assert len(f.data) == 1
     assert isinstance(f.data[0], go.Scatter)
     assert f.data[0]["name"] == "Arg(sqrt(x))"
     assert f.data[0]["line"]["color"] == "red"
     assert p.fig.data[0]["marker"]["colorbar"]["title"]["text"] == "Arg(sqrt(x))"
+    assert f.layout["xaxis"]["title"]["text"] == "Real"
+    assert f.layout["yaxis"]["title"]["text"] == "Abs"
 
 
-def test_plot_complex_2d():
+@pytest.mark.parametrize(
+    "use_latex", [True, False]
+)
+def test_plot_complex_2d(use_latex, label_func):
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
-    p = make_test_plot_complex_2d(PB, rendering_kw=dict())
+    p = make_test_plot_complex_2d(PB, rendering_kw=dict(),
+        use_latex=use_latex)
     assert len(p.series) == 1
     f = p.fig
     assert len(f.data) == 2
     assert isinstance(f.data[0], go.Image)
-    assert f.data[0]["name"] == "sqrt(x)"
+    # TODO: there must be some bugs here with the wrapper $$
+    assert f.data[0]["name"] == "$sqrt(x)$" if use_latex else "sqrt(x)"
     assert isinstance(f.data[1], go.Scatter)
     assert f.data[1]["marker"]["colorbar"]["title"]["text"] == "Argument"
+    assert f.layout["xaxis"]["title"]["text"] == "Re"
+    assert f.layout["yaxis"]["title"]["text"] == "Im"
 
 
 def test_plot_complex_3d():
     # verify that the backends produce the expected results when
     # `plot_complex()` is called and `rendering_kw` overrides the default
     # settings
 
@@ -662,32 +702,28 @@
     assert len(f.data) == 1
     assert isinstance(f.data[0], go.Surface)
     assert f.data[0]["name"] == "sqrt(x)"
     assert f.data[0]["showscale"] is True
     assert f.data[0]["colorbar"]["title"]["text"] == "Argument"
 
 
-def test_plot_list_is_filled_false():
+@pytest.mark.parametrize(
+    "is_filled", [True, False]
+)
+def test_plot_list_is_filled(is_filled):
     # verify that the backends produce the expected results when
     # `plot_list()` is called with `is_filled=False`
 
-    p = make_test_plot_list_is_filled_false(PB)
+    p = make_test_plot_list_is_filled(PB, is_filled)
     assert len(p.series) == 1
     f = p.fig
-    assert f.data[0]["marker"]["line"]["color"] is not None
-
-
-def test_plot_list_is_filled_true():
-    # verify that the backends produce the expected results when
-    # `plot_list()` is called with `is_filled=True`
-
-    p = make_test_plot_list_is_filled_true(PB)
-    assert len(p.series) == 1
-    f = p.fig
-    assert f.data[0]["marker"]["line"]["color"] is None
+    if not is_filled:
+        assert f.data[0]["marker"]["line"]["color"] is not None
+    else:
+        assert f.data[0]["marker"]["line"]["color"] is None
 
 
 def test_plot_list_color_func():
     # verify that the backends produce the expected results when
     # `plot_list()` is called with `color_func`
 
     p = make_test_plot_list_color_func(PB)
@@ -769,48 +805,39 @@
         p.save(os.path.join(tmpdir, filename))
 
         p = plot(sin(x), cos(x), **options)
         filename = "test_plotly_save_4.html"
         p.save(os.path.join(tmpdir, filename), include_plotlyjs="cdn")
 
 
-def test_vectors_3d_update_interactive():
-    # Some backends do not support streamlines with iplot. Test that the
-    # backends raise error.
-
-    p = make_test_vectors_3d_update_interactive(PB)
-    raises(
-        NotImplementedError,
-        lambda: p.backend.update_interactive({a: 2, b: 2, c: 2})
-    )
-
-
 def test_aspect_ratio_2d_issue_11764():
     # verify that the backends apply the provided aspect ratio.
     # NOTE: read the backend docs to understand which options are available.
 
     p = make_test_aspect_ratio_2d_issue_11764(PB)
     assert p.aspect == "auto"
     assert p.fig.layout.yaxis.scaleanchor is None
 
     p = make_test_aspect_ratio_2d_issue_11764(PB, "equal")
     assert p.aspect == "equal"
     assert p.fig.layout.yaxis.scaleanchor == "x"
 
 
-def test_aspect_ratio_3d():
+@pytest.mark.parametrize(
+    "aspect, expected", [
+        ("auto", "auto"),
+        ("cube", "cube"),
+    ]
+)
+def test_aspect_ratio_3d(aspect, expected):
     # verify that the backends apply the provided aspect ratio.
 
-    p = make_test_aspect_ratio_3d(PB)
-    assert p.aspect == "auto"
-    assert p.fig.layout.scene.aspectmode == "auto"
-
-    p = make_test_aspect_ratio_3d(PB, "cube")
-    assert p.aspect == "cube"
-    assert p.fig.layout.scene.aspectmode == "cube"
+    p = make_test_aspect_ratio_3d(PB, aspect)
+    assert p.aspect == aspect
+    assert p.fig.layout.scene.aspectmode == expected
 
 
 def test_plot_size():
     # verify that the keyword `size` is doing it's job
     # NOTE: K3DBackend doesn't support custom size
 
     p = make_test_plot_size(PB)
@@ -819,29 +846,29 @@
 
     p = make_test_plot_size(PB, (800, 400))
     assert p.fig.layout.width == 800
     assert p.fig.layout.height == 400
 
 
 @pytest.mark.filterwarnings("ignore::RuntimeWarning")
-def test_plot_scale_lin_log():
+@pytest.mark.parametrize(
+    "xscale, yscale", [
+        ("linear", "linear"),
+        ("log", "linear"),
+        ("linear", "log"),
+        ("log", "log"),
+    ]
+)
+def test_plot_scale_lin_log(xscale, yscale):
     # verify that backends are applying the correct scale to the axes
     # NOTE: none of the 3D libraries currently support log scale.
 
-    p = make_test_plot_scale_lin_log(PB, "linear", "linear")
-    assert p.fig.layout["xaxis"]["type"] == "linear"
-    assert p.fig.layout["yaxis"]["type"] == "linear"
-
-    p = make_test_plot_scale_lin_log(PB, "log", "linear")
-    assert p.fig.layout["xaxis"]["type"] == "log"
-    assert p.fig.layout["yaxis"]["type"] == "linear"
-
-    p = make_test_plot_scale_lin_log(PB, "linear", "log")
-    assert p.fig.layout["xaxis"]["type"] == "linear"
-    assert p.fig.layout["yaxis"]["type"] == "log"
+    p = make_test_plot_scale_lin_log(PB, xscale, yscale)
+    assert p.fig.layout["xaxis"]["type"] == xscale
+    assert p.fig.layout["yaxis"]["type"] == yscale
 
 
 def test_backend_latex_labels():
     # verify that backends are going to set axis latex-labels in the
     # 2D and 3D case
 
     p1 = make_test_backend_latex_labels_1(PB, True)
@@ -863,160 +890,14 @@
         == "$f\\left(x^{2}_{1}, x_{2}\\right)$"
     )
     assert p2.xlabel == p2.fig.layout.scene.xaxis.title.text == "x_1^2"
     assert p2.ylabel == p2.fig.layout.scene.yaxis.title.text == "x_2"
     assert p2.zlabel == p2.fig.layout.scene.zaxis.title.text == "f(x_1^2, x_2)"
 
 
-def test_plot_use_latex():
-    # verify that the backends produce the expected results when `plot()`
-    # is called and `rendering_kw` overrides the default line settings
-
-    p = make_test_plot_use_latex(PB)
-    f = p.fig
-    assert f.data[0]["name"] == "$\\sin{\\left(x \\right)}$"
-    assert f.data[1]["name"] == "$\\cos{\\left(x \\right)}$"
-    assert f.layout["showlegend"] is True
-
-
-def test_plot_parametric_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_parametric_use_latex(PB)
-    f = p.fig
-    assert f.data[0]["name"] == "$x$"
-    assert f.data[0]["marker"]["colorbar"]["title"]["text"] == "$x$"
-
-
-def test_plot_contour_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_contour_use_latex(PB)
-    f = p.fig
-    assert f.data[0]["colorbar"]["title"]["text"] == "$%s$" % latex(
-        cos(x**2 + y**2)
-    )
-
-
-def test_plot3d_parametric_line_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot3d_parametric_line_use_latex(PB)
-    f = p.fig
-    assert f.data[0]["name"] == "$x$"
-    assert f.data[0]["line"]["colorbar"]["title"]["text"] == "$x$"
-
-
-def test_plot3d_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot3d_use_latex(PB)
-    f = p.fig
-    assert f.data[0].colorbar.title.text == "$%s$" % latex(cos(x**2 + y**2))
-    assert f.data[1].colorbar.title.text == "$%s$" % latex(sin(x**2 + y**2))
-    assert f.data[0].name == "$%s$" % latex(cos(x**2 + y**2))
-    assert f.data[1].name == "$%s$" % latex(sin(x**2 + y**2))
-    assert f.data[0]["showscale"]
-    assert f.layout["showlegend"] is False
-
-
-def test_plot_vector_2d_quivers_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_quivers_use_latex(PB)
-    f = p.fig
-    assert f.data[0]["colorbar"]["title"]["text"] == "Magnitude"
-
-
-def test_plot_vector_2d_streamlines_custom_scalar_field_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_streamlines_custom_scalar_field_use_latex(PB)
-    f = p.fig
-    assert f.data[0]["colorbar"]["title"]["text"] == "$x + y$"
-
-
-def test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_streamlines_custom_scalar_field_custom_label_use_latex(
-        PB
-    )
-    f = p.fig
-    assert f.data[0]["colorbar"]["title"]["text"] == "test"
-
-
-def test_plot_vector_2d_use_latex_colorbar():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_2d_use_latex_colorbar(PB, True, False)
-    assert p.fig.data[0]["colorbar"]["title"]["text"] == "Magnitude"
-
-    p = make_test_plot_vector_2d_use_latex_colorbar(PB, True, True)
-    assert p.fig.data[0]["colorbar"]["title"]["text"] == "Magnitude"
-
-    p = make_test_plot_vector_2d_use_latex_colorbar(PB, False, False)
-    assert p.fig.data[0]["name"] == "$\\left( x, \\  y\\right)$"
-
-    p = make_test_plot_vector_2d_use_latex_colorbar(PB, False, True)
-    assert p.fig.data[0]["name"] == "$\\left( x, \\  y\\right)$"
-
-
-def test_plot_vector_3d_quivers_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_3d_quivers_use_latex(PB)
-    assert (
-        p.fig.data[0]["colorbar"]["title"]["text"]
-        == "$\\left( z, \\  y, \\  x\\right)$"
-    )
-
-
-def test_plot_vector_3d_streamlines_use_latex():
-    # verify that the colorbar uses latex label
-
-    p = make_test_plot_vector_3d_streamlines_use_latex(PB)
-    assert (
-        p.fig.data[0]["colorbar"]["title"]["text"]
-        == "$\\left( z, \\  y, \\  x\\right)$"
-    )
-
-
-@pytest.mark.filterwarnings("ignore::RuntimeWarning")
-def test_plot_complex_use_latex():
-    # complex plot function should return the same result (for axis labels)
-    # wheter use_latex is True or False
-
-    p = make_test_plot_complex_use_latex_1(PB)
-    assert p.fig.layout.xaxis.title.text == "Real"
-    assert p.fig.layout.yaxis.title.text == "Abs"
-    assert p.fig.data[0].name == "Arg(cos(x) + I*sinh(x))"
-    assert (
-        p.fig.data[0]["marker"]["colorbar"]["title"]["text"]
-        == "Arg(cos(x) + I*sinh(x))"
-    )
-
-    p = make_test_plot_complex_use_latex_2(PB)
-    assert p.fig.layout.xaxis.title.text == "Re"
-    assert p.fig.layout.yaxis.title.text == "Im"
-    assert p.fig.data[0].name == "$gamma(z)$"
-    assert p.fig.data[1]["marker"]["colorbar"]["title"]["text"] == "Argument"
-
-
-def test_plot_real_imag_use_latex():
-    # real/imag plot function should return the same result (for axis labels)
-    # wheter use_latex is True or False
-
-    p = make_test_plot_real_imag_use_latex(PB)
-    assert p.fig.layout.xaxis.title.text == "$x$"
-    assert p.fig.layout.yaxis.title.text == r"$f\left(x\right)$"
-    assert p.fig.data[0]["name"] == "Re(sqrt(x))"
-    assert p.fig.data[1]["name"] == "Im(sqrt(x))"
-
-
 def test_plot3d_use_cm():
     # verify that use_cm produces the expected results on plot3d
 
     p1 = make_test_plot3d_use_cm(PB, True)
     p2 = make_test_plot3d_use_cm(PB, False)
     assert len(p1.fig.data[0]["colorscale"]) > 2
     assert len(p2.fig.data[0]["colorscale"]) == 2
@@ -1059,67 +940,31 @@
 
 def test_surface_color_func():
     # After the addition of `color_func`, `SurfaceOver2DRangeSeries` and
     # `ParametricSurfaceSeries` returns different elements.
     # Verify that backends do not raise errors when plotting surfaces and that
     # the color function is applied.
 
-    p1 = make_test_surface_color_func_1(PB, lambda x, y, z: z)
-    p2 = make_test_surface_color_func_1(
-        PB, lambda x, y, z: np.sqrt(x**2 + y**2))
+    p = make_test_surface_color_func(PB)
     assert not np.allclose(
-        p1.fig.data[0]["surfacecolor"], p2.fig.data[0]["surfacecolor"]
-    )
-
-    p1 = make_test_surface_color_func_2(PB, lambda x, y, z, u, v: z)
-    p2 = make_test_surface_color_func_2(
-        PB, lambda x, y, z, u, v: np.sqrt(x**2 + y**2)
+        p.fig.data[0]["surfacecolor"], p.fig.data[1]["surfacecolor"]
     )
     assert not np.allclose(
-        p1.fig.data[0]["surfacecolor"], p2.fig.data[0]["surfacecolor"]
-    )
-
-
-def test_surface_interactive_color_func():
-    # After the addition of `color_func`, `SurfaceInteractiveSeries` and
-    # `ParametricSurfaceInteractiveSeries` returns different elements.
-    # Verify that backends do not raise errors when updating surfaces and a
-    # color function is applied.
-
-    p = make_test_surface_interactive_color_func(PB)
-    p.update_interactive({t: 2})
-    assert not np.allclose(
-        p.fig.data[0]["surfacecolor"],
-        p.fig.data[1]["surfacecolor"]
-    )
-    assert not np.allclose(
-        p.fig.data[2]["surfacecolor"],
-        p.fig.data[3]["surfacecolor"]
+        p.fig.data[2]["surfacecolor"], p.fig.data[3]["surfacecolor"]
     )
+    p.backend.update_interactive({t: 2})
 
 
 def test_line_color_func():
     # Verify that backends do not raise errors when plotting lines and that
     # the color function is applied.
 
-    p1 = make_test_line_color_func(PB, None)
-    p2 = make_test_line_color_func(PB, lambda x, y: np.cos(x))
-    assert p1.fig.data[0].marker.color is None
-    assert np.allclose(
-        p2.fig.data[0].marker.color,
-        np.cos(np.linspace(-3, 3, 5))
-    )
-
-
-def test_line_interactive_color_func():
-    # Verify that backends do not raise errors when updating lines and a
-    # color function is applied.
-
-    p = make_test_line_interactive_color_func(PB)
-    p.update_interactive({t: 2})
+    p = make_test_line_color_func(PB)
+    assert p.fig.data[0].marker.color is None
+    p.backend.update_interactive({t: 2})
     assert p.fig.data[0].marker.color is None
     assert np.allclose(
         p.fig.data[1].marker.color,
         np.cos(np.linspace(-3, 3, 5))
     )
 
 
@@ -1181,214 +1026,40 @@
 
 def test_update_interactive():
     # quick round down of tests to verify that _update_interactive doesn't
     # raise errors
 
     u, v, x, y, z = symbols("u, v, x:z")
 
-    def do_test(p, params, prop):
-        p.backend.draw()
-        d1 = p.backend[0].get_data()
-        v1 = np.array(p.fig.data[0][prop])
-        # quivers contain None, which is not comparable with np.allclose
-        v1[v1 == None] = np.nan
-        p.backend.update_interactive(params)
-        d2 = p.backend[0].get_data()
-        v2 = np.array(p.fig.data[0][prop])
-        v2[v2 == None] = np.nan
-        c1 = not all(np.allclose(s, t) for s, t in zip(d1, d2))
-        c2 = not np.allclose(
-            v1.astype(float), v2.astype(float), equal_nan=True
-        )
-        return c1 and c2
-
-    p = plot(
-        sin(u * x),
-        (x, -pi, pi),
-        adaptive=False,
-        n=5,
-        backend=PB,
-        show=False,
-        params={u: (1, 0, 2)},
-    )
-    assert do_test(p, {u: 2}, "y")
-
-    p = plot_polar(
-        1 + sin(10 * u * x) / 10,
-        (x, 0, 2 * pi),
-        adaptive=False,
-        n=5,
-        backend=PB,
-        show=False,
-        params={u: (1, 0, 2)},
-    )
-    assert do_test(p, {u: 1.5}, "y")
-
-    p = plot_parametric(
-        cos(u * x),
-        sin(u * x),
-        (x, 0, 2 * pi),
-        adaptive=False,
-        n=5,
-        backend=PB,
-        show=False,
-        params={u: (1, 0, 2)},
-    )
-    assert do_test(p, {u: 2}, "y")
-
-    # points
-    p = plot3d_parametric_line(
-        cos(u * x),
-        sin(x),
-        x,
-        (x, -pi, pi),
-        backend=PB,
-        is_point=True,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-    )
-    assert do_test(p, {u: 2}, "x")
-
-    # line
-    p = plot3d_parametric_line(
-        cos(u * x),
-        sin(x),
-        x,
-        (x, -pi, pi),
-        backend=PB,
-        is_point=False,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-        use_cm=False,
-    )
-    assert do_test(p, {u: 2}, "x")
-
-    p = plot3d_parametric_line(
-        cos(u * x),
-        sin(x),
-        x,
-        (x, -pi, pi),
-        backend=PB,
-        is_point=False,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-        use_cm=True,
-    )
-    assert do_test(p, {u: 2}, "x")
-
-    p = plot3d(
-        cos(u * x**2 + y**2),
-        (x, -2, 2),
-        (y, -2, 2),
-        backend=PB,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-    )
-    assert do_test(p, {u: 2}, "z")
-
-    p = plot_contour(
-        cos(u * x**2 + y**2),
-        (x, -2, 2),
-        (y, -2, 2),
-        backend=PB,
-        show=False,
-        adaptive=False,
-        n=5,
-        params={u: (1, 0, 2)},
-    )
-    assert do_test(p, {u: 2}, "z")
-
-    u, v = symbols("u, v")
-    fx = (1 + v / 2 * cos(u / 2)) * cos(x * u)
-    fy = (1 + v / 2 * cos(u / 2)) * sin(x * u)
-    fz = v / 2 * sin(u / 2)
-    p = plot3d_parametric_surface(
-        fx,
-        fy,
-        fz,
-        (u, 0, 2 * pi),
-        (v, -1, 1),
-        backend=PB,
-        use_cm=True,
-        n1=5,
-        n2=5,
-        show=False,
-        params={x: (1, 0, 2)},
-    )
-    assert do_test(p, {x: 2}, "x")
-
-    p = plot_vector(
-        Matrix([-u * y, x]),
-        (x, -5, 5),
-        (y, -4, 4),
-        backend=PB,
-        n=4,
-        show=False,
-        params={u: (1, 0, 2)},
-        scalar=False,
-    )
-    assert do_test(p, {u: 2}, "x")
-
-    p = plot_vector(
-        Matrix([u * z, y, x]),
-        (x, -5, 5),
-        (y, -4, 4),
-        (z, -3, 3),
-        backend=PB,
-        n=4,
-        show=False,
-        params={u: (1, 0, 2)},
-    )
-    assert do_test(p, {u: 2}, "u")
-
     p = plot_complex(
-        sqrt(u * x),
-        (x, -5 - 5 * I, 5 + 5 * I),
-        show=False,
-        backend=PB,
-        threed=True,
-        use_cm=True,
-        n=5,
+        sqrt(u * x), (x, -5 - 5 * I, 5 + 5 * I),
+        show=False, backend=PB, threed=True, use_cm=True, n=5,
         params={u: (1, 0, 2)},
     )
-    assert do_test(p, {u: 2}, "z")
+    p.backend.update_interactive({u: 2})
 
     from sympy.geometry import Line as SymPyLine
 
     p = plot_geometry(
         SymPyLine((u, 2), (5, 4)),
         Circle((0, 0), u),
         Polygon((2, u), 3, n=6),
-        backend=PB,
-        show=False,
-        is_filled=False,
-        use_latex=False,
+        backend=PB, show=False, is_filled=False, use_latex=False,
         params={u: (1, 0, 2)},
     )
-    assert do_test(p, {u: 2}, "x")
+    p.backend.update_interactive({u: 2})
 
     p = plot_geometry(
         SymPyLine((u, 2), (5, 4)),
         Circle((0, 0), u),
         Polygon((2, u), 3, n=6),
-        backend=PB,
-        show=False,
-        is_filled=True,
-        use_latex=False,
+        backend=PB, show=False, is_filled=True, use_latex=False,
         params={u: (1, 0, 2)},
     )
-    assert do_test(p, {u: 2}, "x")
+    p.backend.update_interactive({u: 2})
 
 
 def test_generic_data_series():
     # verify that backends do not raise errors when generic data series
     # are used
 
     x = symbols("x")
@@ -1453,78 +1124,75 @@
     f1, f2, f3, f4, f5, f6 = [t.fig for t in [p1, p2, p3, p4, p5, p6]]
     assert all(isinstance(t.data[0], go.Scatter) for t in [f1, f5])
     assert all(isinstance(t.data[0], go.Scattergl) for t in [f2, f6])
     assert isinstance(f3.data[0], go.Scatterpolar)
     assert isinstance(f4.data[0], go.Scatterpolargl)
 
 
-def test_plot3d_list_use_cm_False():
+def test_plot3d_list():
     # verify that plot3d_list produces the expected results when no color map
     # is required
 
-    # solid color line
-    p = make_test_plot3d_list_use_cm_False(PB, False, False)
-    assert p.fig.data[0].mode == "lines"
-    assert p.fig.data[0].line.color == "#636EFA"
-
-    # solid color markers with empty faces
-    p = make_test_plot3d_list_use_cm_False(PB, True, False)
-    assert p.fig.data[0].mode == "markers"
-    assert p.fig.data[0].marker.color == "#E5ECF6"
-    assert p.fig.data[0].marker.line.color == "#636EFA"
-
-    # solid color markers with filled faces
-    p = make_test_plot3d_list_use_cm_False(PB, True, True)
-    assert p.fig.data[0].marker.color == "#636EFA"
-
-
-def test_plot3d_list_use_cm_color_func():
-    # verify that use_cm=True and color_func do their job
-
-    # line with colormap
-    # if color_func is not provided, the same parameter will be used
-    # for all points
-    p1 = make_test_plot3d_list_use_cm_color_func(PB, False, False, None)
-    c1 = p1.fig.data[0].line.color
-    p2 = make_test_plot3d_list_use_cm_color_func(
-        PB, False, False, lambda x, y, z: x
-    )
-    c2 = p2.fig.data[0].line.color
-    assert not np.allclose(c1, c2)
-
-    # markers with empty faces
-    p1 = make_test_plot3d_list_use_cm_color_func(PB, False, False, None)
-    c1 = p1.fig.data[0].line.color
-    p2 = make_test_plot3d_list_use_cm_color_func(
-        PB, False, False, lambda x, y, z: x
-    )
-    c2 = p2.fig.data[0].line.color
-    assert not np.allclose(c1, c2)
+    # TODO: these tests dont't make any sense, colors are different from what
+    # I see on Jupyter Notebook. WTF???
+    p = make_test_plot3d_list(PB, False, None)
+    fig = p.fig
+    assert fig.data[2].mode == "lines"
+    assert fig.data[2].line.color == "#00CC96"
+    assert fig.data[1].mode == "markers"
+    assert fig.data[1].marker.color == "#E5ECF6"
+    assert fig.data[1].marker.line.color == "#EF553B"
+    assert fig.data[0].mode == "markers"
+    assert fig.data[0].marker.color == "#E5ECF6"
+    assert np.allclose(fig.data[0].marker.line.color, 1)
+    # assert np.allclose(fig.data[0].line.color, 0)
+    p.backend.update_interactive({t: 1})
 
+    p = make_test_plot3d_list(PB, True, None)
+    fig = p.fig
+    assert fig.data[2].mode == "lines"
+    assert fig.data[2].line.color == "#00CC96"
+    assert fig.data[1].mode == "markers"
+    assert fig.data[1].marker.color == "#EF553B"
+    assert fig.data[1].marker.line.color is None
+    assert fig.data[0].mode == "markers"
+    assert np.allclose(fig.data[0].marker.color, 1)
+    assert fig.data[0].line.color is None
+    p.backend.update_interactive({t: 1})
 
-def test_plot3d_list_interactive():
-    # verify that no errors are raises while updating a plot3d_list
+    p = make_test_plot3d_list(PB, False, lambda x, y, z: z)
+    fig = p.fig
+    assert fig.data[2].mode == "lines"
+    assert fig.data[2].line.color == "#00CC96"
+    assert fig.data[1].mode == "markers"
+    assert fig.data[1].marker.color == "#E5ECF6"
+    assert fig.data[1].marker.line.color == "#EF553B"
+    assert fig.data[0].mode == "markers"
+    assert not np.allclose(fig.data[0].marker.line.color, 1)
+    p.backend.update_interactive({t: 1})
 
-    p = make_test_plot3d_list_interactive(PB)
+    p = make_test_plot3d_list(PB, True, lambda x, y, z: z)
+    p.fig
+    assert fig.data[2].mode == "lines"
+    assert fig.data[2].line.color == "#00CC96"
+    assert fig.data[1].mode == "markers"
+    assert fig.data[1].marker.color == "#E5ECF6"
+    assert fig.data[1].marker.line.color == "#EF553B"
+    assert fig.data[0].mode == "markers"
+    assert not np.allclose(fig.data[0].marker.line.color, 1)
     p.backend.update_interactive({t: 1})
 
 
 def test_contour_show_clabels():
-    p = make_test_contour_show_clabels_1(PB, False)
-    assert not p.fig.data[0].contours.showlabels
-
-    p = make_test_contour_show_clabels_1(PB, True)
-    assert p.fig.data[0].contours.showlabels
-
-    p = make_test_contour_show_clabels_2(PB, False)
-    p.backend.update_interactive({Symbol("u"): 2})
+    p = make_test_contour_show_clabels(PB, False)
+    p.backend.update_interactive({a: 2})
     assert not p.fig.data[0].contours.showlabels
 
-    p = make_test_contour_show_clabels_2(PB, True)
-    p.backend.update_interactive({Symbol("u"): 2})
+    p = make_test_contour_show_clabels(PB, True)
+    p.backend.update_interactive({a: 2})
     assert p.fig.data[0].contours.showlabels
 
 
 def test_color_func_expr():
     # verify that passing an expression to color_func is supported
 
     with warns(
@@ -1860,25 +1528,27 @@
     assert p.fig.layout.title.text == wrapper % "a=1.5, a+b=3.500"
     assert p.fig.layout.scene.xaxis.title.text == "test a=1.50"
     assert p.fig.layout.scene.yaxis.title.text == "test b=2.00"
     assert p.fig.layout.scene.zaxis.title.text == "test a=1.50, b=2.00"
 
 
 def test_arrow_2d():
+    a, b = symbols("a, b")
     p = make_test_arrow_2d(PB, "test", {"arrowcolor": "red"}, True)
-    p.fig
-    assert len(p.fig.layout.annotations) == 1
-    assert p.fig.layout.annotations[0]["text"] == "test"
-    assert p.fig.layout.annotations[0]["arrowcolor"] == "red"
+    fig = p.fig
+    assert len(fig.layout.annotations) == 1
+    assert fig.layout.annotations[0]["text"] == "$test$"
+    assert fig.layout.annotations[0]["arrowcolor"] == "red"
+    p.backend.update_interactive({a: 4, b: 5})
 
     p = make_test_arrow_2d(PB, "test", {"arrowcolor": "red"}, False)
-    p.fig
-    assert len(p.fig.layout.annotations) == 1
-    assert p.fig.layout.annotations[0]["text"] == ""
-    assert p.fig.layout.annotations[0]["arrowcolor"] == "red"
+    fig = p.fig
+    assert len(fig.layout.annotations) == 1
+    assert fig.layout.annotations[0]["text"] == ""
+    assert fig.layout.annotations[0]["arrowcolor"] == "red"
 
 
 def test_existing_figure_lines():
     # verify that user can provide an existing figure containing lines
     # and plot over it
 
     fig = go.Figure()
@@ -1910,7 +1580,53 @@
     x, y = symbols("x, y")
     p = plot3d(x*y, (x, -3, 3), (y, -3, 3), n=10, backend=PB,
         fig=fig, use_cm=False, show=False)
     assert p.fig is fig
     assert len(fig.data) == 2
     assert fig.data[0].colorscale is None
     assert fig.data[1].colorscale[0][1] == "#EF553B"
+
+
+@pytest.mark.parametrize("update_event, fig_type", [
+    (False, go.Figure),
+    (True, go.FigureWidget)
+])
+def test_plotly_update_ranges(update_event, fig_type):
+    # verify that `update_event` doesn't raise errors
+
+    x, y = symbols("x, y")
+    p = plot(cos(x), (x, -pi, pi), n=10, backend=PB,
+        show=False, update_event=update_event)
+    assert isinstance(p.fig, fig_type)
+
+    if update_event:
+        assert len(p.fig.layout._change_callbacks) == 1
+        f = list(p.fig.layout._change_callbacks.values())[0][0]
+        f(None, (-5, 4), (-3, 2))
+    else:
+        assert len(p.fig.layout._change_callbacks) == 0
+
+    p = plot_contour(cos(x**2+y**2), (x, -pi, pi), (y, -pi, pi),
+        n=10, backend=PB, show=False, update_event=update_event)
+    assert isinstance(p.fig, fig_type)
+
+    if update_event:
+        assert len(p.fig.layout._change_callbacks) == 1
+        f = list(p.fig.layout._change_callbacks.values())[0][0]
+        f(None, (-5, 4), (-3, 2))
+    else:
+        assert len(p.fig.layout._change_callbacks) == 0
+
+
+def test_hvlines():
+    a, b = symbols("a, b")
+    p = make_test_hvlines(PB)
+    fig = p.backend.fig
+    assert len(fig.layout.shapes) == 2
+    l1, l2 = fig.layout.shapes
+    assert l1["xref"] == "x domain"
+    assert l2["yref"] == "y domain"
+    assert not np.allclose(
+        [l1.x0, l1.x1, l1.y0, l1.y1],
+        [l2.x0, l2.x1, l2.y0, l2.y1]
+    )
+    p.backend.update_interactive({a: 3, b: 4})
```

### Comparing `sympy_plot_backends-3.1.1/tests/graphics/test_complex_analysis.py` & `sympy_plot_backends-3.2.0/tests/graphics/test_complex_analysis.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/graphics/test_control.py` & `sympy_plot_backends-3.2.0/tests/graphics/test_control.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 scipy = pytest.importorskip("scipy")
 from spb import (
     control_axis, pole_zero, step_response, impulse_response, ramp_response,
     bode_magnitude, bode_phase, nyquist, nichols, sgrid, root_locus, zgrid,
     mcircles
 )
 from spb.series import (
-    LineOver1DRangeSeries, HVLineSeries, List2DSeries, NyquistLineSeries,
+    LineOver1DRangeSeries, HVLineSeries, PoleZeroWithSympySeries, NyquistLineSeries,
     NicholsLineSeries, SGridLineSeries, RootLocusSeries, ZGridLineSeries,
     SystemResponseSeries, PoleZeroSeries, NGridLineSeries, MCirclesSeries
 )
 from sympy.abc import a, b, c, d, e, s
 from sympy import exp
 from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix
 from sympy.external import import_module
@@ -109,15 +109,15 @@
     if pkw:
         kwargs["p_rendering_kw"] = pkw
     if zkw:
         kwargs["z_rendering_kw"] = zkw
 
     series = pole_zero(tf, label=label, control=use_control, **kwargs)
     assert len(series) == 2
-    test_series = List2DSeries if not use_control else PoleZeroSeries
+    test_series = PoleZeroWithSympySeries if not use_control else PoleZeroSeries
     assert all(isinstance(s, test_series) for s in series)
     assert "poles" in series[0].get_label(True)
     assert "zeros" in series[1].get_label(True)
     d1 = series[0].get_data()
     assert len(d1) == 2
     # use np.sort because sympy and numpy results of roots are
     # sorted differently
@@ -147,15 +147,15 @@
         (tf_siso_scipy, False),
         (tf_siso_scipy, True)
     ]
 )
 def test_pole_zero_control_scipy(tf, use_control):
     series = pole_zero(tf, control=use_control)
     assert len(series) == 2
-    test_series = List2DSeries if not use_control else PoleZeroSeries
+    test_series = PoleZeroWithSympySeries if not use_control else PoleZeroSeries
     assert all(isinstance(s, test_series) for s in series)
     assert "poles" in series[0].get_label(True)
     assert "zeros" in series[1].get_label(True)
     d0 = series[0].get_data()
     assert np.allclose(d0[0], [-0.5, -0.5])
     # use np.sort because sympy and numpy results of roots are
     # sorted differently
@@ -173,26 +173,26 @@
         (tf_mimo_control, True),
         (tf_mimo_control, False),
     ]
 )
 def test_pole_zero_mimo_1(tf, use_control):
     series = pole_zero(tf, control=use_control)
     assert len(series) == 12
-    test_series = List2DSeries if not use_control else PoleZeroSeries
+    test_series = PoleZeroWithSympySeries if not use_control else PoleZeroSeries
     assert all(isinstance(s, test_series) for s in series)
 
 
 @pytest.mark.parametrize(
     "use_control", [True, False]
 )
 def test_pole_zero_grids(use_control):
     # verify that grid line series works with pole_zero
 
     tf = TransferFunction(s**2 + 1, s**4 + 4*s**3 + 6*s**2 + 5*s + 2, s)
-    test_series = List2DSeries if not use_control else PoleZeroSeries
+    test_series = PoleZeroWithSympySeries if not use_control else PoleZeroSeries
 
     series = pole_zero(tf, sgrid=False, zgrid=False, control=use_control)
     assert len(series) == 2
     assert all(isinstance(t, test_series) for t in series)
 
     series = pole_zero(tf, sgrid=True, zgrid=False, control=use_control)
     assert len(series) == 3
```

### Comparing `sympy_plot_backends-3.1.1/tests/graphics/test_control_min_module.py` & `sympy_plot_backends-3.2.0/tests/graphics/test_control_min_module.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import pytest
 from pytest import warns, raises
-from spb.series import LineOver1DRangeSeries, List2DSeries
+from spb.series import LineOver1DRangeSeries, PoleZeroWithSympySeries
 from spb.graphics.control import (
     step_response, impulse_response, ramp_response, pole_zero,
     root_locus, nyquist
 )
 from sympy.abc import s
 from sympy.external import import_module
 ct = import_module("control")
@@ -16,15 +16,15 @@
 
 @pytest.mark.skipif(ct is not None, reason="control is installed")
 @pytest.mark.parametrize(
     "func, series_type", [
         (step_response, LineOver1DRangeSeries),
         (impulse_response, LineOver1DRangeSeries),
         (ramp_response, LineOver1DRangeSeries),
-        (pole_zero, List2DSeries)
+        (pole_zero, PoleZeroWithSympySeries)
     ]
 )
 def test_functions(func, series_type):
     # the plotting module informs the user that the evaluation will be done
     # with sympy (when ``control`` is not installed)
     G = (s + 1) / (s**2 + s + 1)
```

### Comparing `sympy_plot_backends-3.1.1/tests/graphics/test_functions_2d.py` & `sympy_plot_backends-3.2.0/tests/graphics/test_functions_2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/graphics/test_functions_3d.py` & `sympy_plot_backends-3.2.0/tests/graphics/test_functions_3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/graphics/test_graphics.py` & `sympy_plot_backends-3.2.0/tests/graphics/test_graphics.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/graphics/test_vectors.py` & `sympy_plot_backends-3.2.0/tests/graphics/test_vectors.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/plot_functions/test_complex.py` & `sympy_plot_backends-3.2.0/tests/plot_functions/test_complex.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/plot_functions/test_control.py` & `sympy_plot_backends-3.2.0/tests/plot_functions/test_control.py`

 * *Files 2% similar despite different names*

```diff
@@ -643,91 +643,14 @@
     assert nyquist_res_tester(tf5, 10, exp5)
     assert nyquist_res_tester(tf6, 10, exp6)
     assert nyquist_res_tester(tf7, 10, exp7)
     assert nyquist_res_tester(tf8, 10, exp8)
 
 
 @pytest.mark.skipif(ct is None, reason="control is not installed")
-def test_plot_nyquist_matplotlib():
-    # verify that plot_nyquist adds the necessary objects to the plot
-
-    # standard plot, no m-circles
-    p = plot_nyquist(tf1, show=False, n=10)
-    ax = p.ax
-    assert len(ax.lines) == 6
-    assert len(ax.patches) == 4
-    assert len(ax.texts) == 0
-
-    # standard plot, no m-circles, no mirror image
-    p = plot_nyquist(tf1, show=False, n=10, mirror_style=False)
-    ax = p.ax
-    assert len(ax.lines) == 4
-    assert len(ax.patches) == 2
-    assert len(ax.texts) == 0
-
-    # m-circles + custom number of arrows
-    p = plot_nyquist(tf1, show=False, n=10, arrows=3, m_circles=True)
-    ax = p.ax
-    assert len(ax.lines) == 17
-    assert len(ax.patches) == 6
-    assert len(ax.texts) > 0
-
-    # standard plot but no start marker, no m-circles
-    p = plot_nyquist(tf1, show=False, n=10, start_marker=False)
-    ax = p.ax
-    assert len(ax.lines) == 5
-    assert len(ax.patches) == 4
-    assert len(ax.texts) == 0
-
-
-@pytest.mark.skipif(ct is None, reason="control is not installed")
-def test_plot_nyquist_matplotlib_linestyles():
-
-    # standard plot, custom line styles. Verify that no errors are raised
-    p = plot_nyquist(tf1, show=False, n=10,
-        primary_style="-", mirror_style=":")
-    ax = p.ax
-
-    p = plot_nyquist(tf1, show=False, n=10,
-        primary_style=["-", "-."], mirror_style=["--", ":"])
-    ax = p.ax
-
-    p = plot_nyquist(tf1, show=False, n=10,
-        primary_style={"linestyle": "-"},
-        mirror_style={"linestyle": ":"})
-    ax = p.ax
-
-    p = plot_nyquist(tf1, show=False, n=10,
-        primary_style=[{"linestyle": "-"}, {"linestyle": ":"}],
-        mirror_style=[{"linestyle": "--"}, {"linestyle": "-."}])
-    ax = p.ax
-
-    # unrecognized line styles
-    p = plot_nyquist(tf1, show=False, n=10,
-        primary_style=2,
-        mirror_style=2)
-    raises(ValueError, lambda: p.ax)
-
-
-@pytest.mark.skipif(ct is None, reason="control is not installed")
-def test_plot_nyquist_matplotlib_interactive():
-    # verify that interactive update doesn't raise errors
-
-    tf = TransferFunction(1, s + a, s)
-    pl = plot_nyquist(
-        tf, xlim=(-2, 1), ylim=(-1, 1),
-        aspect="equal", m_circles=True,
-        params={a: (1, 0, 2)},
-        arrows=4, n=10, show=False
-    )
-    ax = pl.backend.ax # force first draw
-    pl.backend.update_interactive({a: 2}) # update with new value
-
-
-@pytest.mark.skipif(ct is None, reason="control is not installed")
 def test_plot_nyquist_omega_limits():
     # verify that `omega_limits` works as expected
 
     p1 = plot_nyquist(tf1, show=False)
     p2 = plot_nyquist(tf1, omega_limits=(1e-05, 1e-02), show=False)
     assert p2[0].ranges[0][1] == 1e-05
     assert p2[0].ranges[0][2] == 1e-02
@@ -736,67 +659,65 @@
 
 def test_plot_nichols():
     # verify that NicholsLineSeries produces correct results
 
     def nichols_res_tester(sys, omega_limits, num_points, expected_value):
         p = plot_nichols(sys, omega_limits=omega_limits,
             show=False, n=num_points)
-        x, y, param = p[0].get_data()
-        x_check = check_point_accuracy(x, expected_value[0])
-        y_check = check_point_accuracy(y, expected_value[1])
-        param_check = check_point_accuracy(param, expected_value[2])
-        return x_check and y_check and param_check
+        data = p[0].get_data()
+        assert len(data) == len(expected_value) == 5
+        results = []
+        for d, e in zip(data, expected_value):
+            results.append(check_point_accuracy(d, e))
+        return all(results)
 
     tf1 = TransferFunction(5 * (s - 1), s**2 * (s**2 + s + 4), s)
     exp1 = (
+        [ 0.1       ,  0.16681005,  0.27825594,  0.46415888,  0.77426368,
+         1.29154967,  2.15443469,  3.59381366,  5.9948425 , 10.        ],
         [  -7.14627703,  -11.87501843,  -19.6071407 ,  -31.89094174,
          -50.57631953,  -81.231069  , -171.68469677, -232.49622166,
         -249.89886567, -258.34254381],
         [ 42.0004288 ,  33.22148705,  24.63227702,  16.53494133,
           9.61324014,   5.28081374,   1.12439465, -16.46462887,
         -31.69352926, -45.66968097],
-        [ 0.1       ,  0.16681005,  0.27825594,  0.46415888,  0.77426368,
-         1.29154967,  2.15443469,  3.59381366,  5.9948425 , 10.        ]
+        [-5.61723149e-02, -2.51921979e-01, -1.06875703e+00, -3.99771428e+00,
+        -1.19190473e+01, -2.64204118e+01, -4.42001337e+01,  1.20030327e+02,
+         1.08688709e+02,  1.01365014e+02],
+        [ -0.06819096,  -0.18363121,  -0.46873569,  -1.0560048 ,
+         -1.84476495,  -1.65075335,  14.78653171, -15.70556577,
+        -31.61814275, -45.66065215]
     )
     assert nichols_res_tester(tf1, [1e-01, 1e01], 10, exp1)
 
     tf2 = TransferFunction(-4*s**4 + 48*s**3 - 18*s**2 + 250*s + 600, s**4 + 30*s**3 + 282*s**2 + 525*s + 60, s)
     exp2 = (
+        [1.00000000e-02, 2.27584593e-02, 5.17947468e-02, 1.17876863e-01,
+        2.68269580e-01, 6.10540230e-01, 1.38949549e+00, 3.16227766e+00,
+        7.19685673e+00, 1.63789371e+01, 3.72759372e+01, 8.48342898e+01,
+        1.93069773e+02, 4.39397056e+02, 1.00000000e+03],
         [  -4.7642299 ,  -10.74556702,  -23.41579813,  -44.99062736,
          -67.91516888,  -85.00078123, -107.10140914, -227.43935552,
         -331.72108713, -412.10280752, -477.24930481, -511.78850082,
         -527.54912472, -534.52446663, -537.59367177],
         [ 19.97103009,  19.85200215,  19.28289443,  17.14539872,
          12.36002147,   5.86393272,  -1.78976124, -10.51502076,
           2.44764247,   9.06567945,  11.41302756,  11.91973828,
          12.01777399,  12.0366782 ,  12.04032688],
-        [1.00000000e-02, 2.27584593e-02, 5.17947468e-02, 1.17876863e-01,
-        2.68269580e-01, 6.10540230e-01, 1.38949549e+00, 3.16227766e+00,
-        7.19685673e+00, 1.63789371e+01, 3.72759372e+01, 8.48342898e+01,
-        1.93069773e+02, 4.39397056e+02, 1.00000000e+03]
+         [ -0.43405484,  -0.98780295,  -2.24762925,  -5.10994215,
+        -11.57169533, -25.90211657, -61.4640825 , 117.18808478,
+         12.11997649, -12.86906586, -15.24033768,  -8.77282042,
+         -4.09330585,  -1.82028219,  -0.80169308],
+        [-0.82800363, -0.82863006, -0.8318701 , -0.84853088, -0.93173103,
+        -1.29661324, -2.52196107, -8.87617467, -4.62089205, -1.9217847 ,
+         0.82954185,  2.09388531,  2.4163407 ,  2.48268802,  2.4956624 ]
     )
     assert nichols_res_tester(tf2, [1e-02, 1e03], 15, exp2)
 
 
-def test_plot_nichols_matplotlib():
-    tf = TransferFunction(5 * (s - 1), s**2 * (s**2 + s + 4), s)
-
-    # with nichols grid lines
-    p = plot_nichols(tf, ngrid=True, show=False, n=10)
-    ax = p.ax
-    assert len(ax.lines) > 2
-    assert len(ax.texts) > 0
-
-    # no nichols grid lines
-    p = plot_nichols(tf, ngrid=False, show=False, n=10)
-    ax = p.ax
-    assert len(ax.lines) == 1
-    assert len(ax.texts) == 0
-
-
 @pytest.mark.parametrize(
     "func, params",
     [
         (plot_pole_zero, test_params),
         (plot_impulse_response, test_params),
         (plot_step_response, test_params),
         (plot_ramp_response, test_params),
```

### Comparing `sympy_plot_backends-3.1.1/tests/plot_functions/test_functions_2d.py` & `sympy_plot_backends-3.2.0/tests/plot_functions/test_functions_2d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/plot_functions/test_functions_3d.py` & `sympy_plot_backends-3.2.0/tests/plot_functions/test_functions_3d.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/plot_functions/test_vectors.py` & `sympy_plot_backends-3.2.0/tests/plot_functions/test_vectors.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/test_defaults.py` & `sympy_plot_backends-3.2.0/tests/test_defaults.py`

 * *Files 12% similar despite different names*

```diff
@@ -46,51 +46,56 @@
     for k in must_have_keys:
         assert k in cfg["adaptive"].keys()
     assert cfg["adaptive"]["used_by_default"] is False
     assert cfg["adaptive"]["goal"] == 0.01
 
 
 def test_cfg_matplotlib_keys():
-    matplotlib_keys = ["axis_center", "grid", "show_minor_grid", "use_latex"]
+    matplotlib_keys = [
+        "axis_center", "grid", "show_minor_grid", "use_latex", "update_event"]
     for k in matplotlib_keys:
         assert k in cfg["matplotlib"].keys()
     assert isinstance(cfg["matplotlib"]["grid"], bool)
     assert isinstance(cfg["matplotlib"]["show_minor_grid"], bool)
+    assert isinstance(cfg["matplotlib"]["update_event"], bool)
 
 
 def test_cfg_plotly_keys():
-    must_have_keys = ["theme", "grid", "use_latex"]
+    must_have_keys = ["theme", "grid", "use_latex", "update_event"]
     for k in must_have_keys:
         assert k in cfg["plotly"].keys()
     assert isinstance(cfg["plotly"]["theme"], str)
     assert isinstance(cfg["plotly"]["grid"], bool)
+    assert isinstance(cfg["plotly"]["update_event"], bool)
 
 
 def test_cfg_bokeh_keys():
     bokeh_keys = [
         "theme",
         "sizing_mode",
         "show_minor_grid",
         "width",
         "height",
         "minor_grid_line_alpha",
         "minor_grid_line_dash",
         "grid",
         "use_latex",
+        "update_event"
     ]
     for k in bokeh_keys:
         assert k in cfg["bokeh"].keys()
     assert isinstance(cfg["bokeh"]["sizing_mode"], str)
     assert isinstance(cfg["bokeh"]["width"], int)
     assert isinstance(cfg["bokeh"]["height"], int)
     assert isinstance(cfg["bokeh"]["sizing_mode"], str)
     assert isinstance(cfg["bokeh"]["grid"], bool)
     assert isinstance(cfg["bokeh"]["show_minor_grid"], bool)
     assert isinstance(cfg["bokeh"]["minor_grid_line_alpha"], (float, int))
     assert isinstance(cfg["bokeh"]["minor_grid_line_dash"], (list, tuple))
+    assert isinstance(cfg["bokeh"]["update_event"], bool)
 
 
 def test_cfg_k3d_keys():
     k3d_keys = [
         "bg_color",
         "grid_color",
         "label_color",
```

### Comparing `sympy_plot_backends-3.1.1/tests/test_deprecated_module.py` & `sympy_plot_backends-3.2.0/tests/test_deprecated_module.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/test_doc_utils.py` & `sympy_plot_backends-3.2.0/tests/test_doc_utils.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/test_plotgrid.py` & `sympy_plot_backends-3.2.0/tests/test_plotgrid.py`

 * *Files identical despite different names*

### Comparing `sympy_plot_backends-3.1.1/tests/test_series.py` & `sympy_plot_backends-3.2.0/tests/test_series.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,16 @@
     Vector2DSeries, Vector3DSeries, SliceVector3DSeries,
     ComplexSurfaceSeries, ComplexDomainColoringSeries,
     ComplexPointSeries, GeometrySeries,
     PlaneSeries, List2DSeries, List3DSeries, AbsArgLineSeries,
     _set_discretization_points, ColoredLineOver1DRangeSeries,
     HVLineSeries, Arrow2DSeries, Arrow3DSeries, RootLocusSeries,
     SGridLineSeries, ZGridLineSeries, PoleZeroSeries, SystemResponseSeries,
-    ColoredSystemResponseSeries, NyquistLineSeries, Ellipse
+    ColoredSystemResponseSeries, NyquistLineSeries, Ellipse,
+    NicholsLineSeries, NyquistLineSeries, SystemResponseSeries
 )
 from spb import plot3d_spherical
 from sympy.abc import j, k, l, d, s, x, y
 from sympy import (
     latex, exp, symbols, Tuple, I, pi, sin, cos, tan, log, sqrt,
     re, im, arg, frac, Plane, Circle, Point, Sum, S, Abs, lambdify,
     Function, dsolve, Eq, Ynm, floor, Ne, Piecewise, hyper, nsolve,
@@ -1890,14 +1891,73 @@
         x**2 + y**3 - z**2, (x, -2, 2), (y, -3, 3), (z, -4, 4))
     assert (
         str(s)
         == "implicit surface series: x**2 + y**3 - z**2 for x over (-2.0, 2.0) and y over (-3.0, 3.0) and z over (-4.0, 4.0)"
     )
 
 
+@pytest.mark.skipif(ct is None, reason="control is not installed")
+def test_str_control_system():
+
+    s, o = symbols("s, o")
+    tf = TransferFunction(50*s**2 - 20*s + 15, -10*s**2 + 40*s + 30, s)
+    G = tf.to_expr()
+    H = (G / (1 + G)).simplify().expand().together()
+    ser = NicholsLineSeries(tf, arg(G), Abs(G), arg(H), Abs(H), (o, 0.01, 100))
+    assert (
+        str(ser)
+        == "nichols line of TransferFunction(50*s**2 - 20*s + 15, -10*s**2 + 40*s + 30, s)"
+    )
+
+    a, b, c = symbols("a:c")
+    tf = TransferFunction(a*s**2 + b*s + c, s**3 + 10*s**2 + 5 * s + 1, s)
+    G = tf.to_expr()
+    H = (G / (1 + G)).simplify().expand().together()
+    ser = NicholsLineSeries(
+        tf, arg(G), Abs(G), arg(H), Abs(H), (o, 0.01, 100),
+        params={a: 1, b: 2, c: 3})
+    assert (
+        str(ser)
+        == "interactive nichols line of TransferFunction(a*s**2 + b*s + c, s**3 + 10*s**2 + 5*s + 1, s) and parameters (a, b, c)"
+    )
+
+    tf = TransferFunction(50*s**2 - 20*s + 15, -10*s**2 + 40*s + 30, s)
+    ser = NyquistLineSeries(tf, (o, 0.01, 100))
+    assert (
+        str(ser)
+        == "nyquist line of TransferFunction(50*s**2 - 20*s + 15, -10*s**2 + 40*s + 30, s)"
+    )
+
+    tf = TransferFunction(a*s**2 + b*s + c, s**3 + 10*s**2 + 5 * s + 1, s)
+    ser = NyquistLineSeries(tf, (o, 0.01, 100), params={a: 1, b: 2, c: 3})
+    assert (
+        str(ser)
+        == "interactive nyquist line of TransferFunction(a*s**2 + b*s + c, s**3 + 10*s**2 + 5*s + 1, s) and parameters (a, b, c)"
+    )
+
+    tf = TransferFunction(50*s**2 - 20*s + 15, -10*s**2 + 40*s + 30, s)
+    ser = SystemResponseSeries(tf, (o, 0.01, 100), response_type="step")
+    assert (
+        str(ser)
+        == "step response of TransferFunction(50*s**2 - 20*s + 15, -10*s**2 + 40*s + 30, s)"
+    )
+
+    ser = SystemResponseSeries(tf, (o, 0.01, 100), response_type="impulse")
+    assert (
+        str(ser)
+        == "impulse response of TransferFunction(50*s**2 - 20*s + 15, -10*s**2 + 40*s + 30, s)"
+    )
+
+    ser = SystemResponseSeries(tf, (o, 0.01, 100), response_type="ramp")
+    assert (
+        str(ser)
+        == "ramp response of TransferFunction(50*s**2 - 20*s + 15, -10*s**2 + 40*s + 30, s)"
+    )
+
+
 @pytest.mark.parametrize("use_cm", [True, False])
 def test_use_cm(use_cm):
     # verify that the `use_cm` attribute is implemented.
 
     u, x, y, z = symbols("u, x:z")
 
     s = List2DSeries([1, 2, 3, 4], [5, 6, 7, 8], use_cm=use_cm)
```

### Comparing `sympy_plot_backends-3.1.1/tests/test_utils.py` & `sympy_plot_backends-3.2.0/tests/test_utils.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,19 +4,20 @@
     plot, plot3d, plot_implicit, plot_vector,
     plot_complex, plot_complex_list, plot_geometry,
     MB,
 )
 from spb.utils import (
     _create_missing_ranges, _plot_sympify,
     _validate_kwargs, prange, extract_solution,
-    tf_to_control, tf_to_sympy, is_discrete_time, tf_find_time_delay
+    tf_to_control, tf_to_sympy, is_discrete_time, tf_find_time_delay,
+    is_number
 )
 from sympy import (
     symbols, Expr, Tuple, Integer, sin, cos, Matrix,
-    I, Polygon, solveset, FiniteSet, ImageSet, exp
+    I, Polygon, solveset, FiniteSet, ImageSet, exp, Rational, Float, pi
 )
 from sympy.external import import_module
 from sympy.physics.control import TransferFunction, TransferFunctionMatrix
 import numpy as np
 
 ct = import_module("control")
 scipy = import_module("scipy")
@@ -473,7 +474,26 @@
     assert tf_find_time_delay(G7) == []
     assert tf_find_time_delay(G8) == [exp(2*s)]
     assert tf_find_time_delay(G9) == [exp(2*s)]
     assert tf_find_time_delay(G10) == [exp(2*s)]
     delays = tf_find_time_delay(G11)
     assert (delays == [exp(2*s), exp(3*s)]) or (delays == [exp(3*s), exp(2*s)])
     assert tf_find_time_delay(G12, a) == [exp(a*s)]
+
+
+@pytest.mark.parametrize(
+    "num, expected",
+    [
+        (4, True),
+        (4.5, True),
+        (Integer(4), True),
+        (Float(4), True),
+        (Rational(5, 2), True),
+        (np.pi, True),
+        (pi, True),
+        (2 * pi, True),
+        (x, False),
+        (x + a, False),
+    ]
+)
+def test_is_number(num, expected):
+    assert is_number(num) is expected
```

